{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/Staticfile","path":"Staticfile","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/sogousiteverification.txt","path":"sogousiteverification.txt","modified":0,"renderable":0},{"_id":"themes/cactus-light/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"source/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1497013753000},{"_id":"source/robots.txt","hash":"dabd6699992a60e4142995a12cd48f7a3c19c7c5","modified":1497013753000},{"_id":"themes/cactus-light/LICENSE","hash":"2f1530f30fbec68407daa54391553c3d5ff71f6a","modified":1497013753000},{"_id":"source/sogousiteverification.txt","hash":"ac2b4638cb7bf220aa8f359e044ef61e5a304363","modified":1497013753000},{"_id":"themes/cactus-light/README.md","hash":"da60bf6d6f800de621ea3a2600f4a850ddaff7d2","modified":1497013753000},{"_id":"themes/cactus-light/_config.yml","hash":"7a3bf15cc7cd18343bc5f52656427a34d0867226","modified":1497013753000},{"_id":"themes/cactus-light/layout/index.ejs","hash":"c60cbe214fce2da24f1f4e57f54d35f47a59e867","modified":1497013753000},{"_id":"themes/cactus-light/layout/layout.ejs","hash":"56a555a41dfb9bb2e08bccfd806b647a0d4b8920","modified":1497013753000},{"_id":"themes/cactus-light/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1497013753000},{"_id":"themes/cactus-light/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1497013753000},{"_id":"themes/cactus-light/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1497013753000},{"_id":"themes/cactus-light/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1497013753000},{"_id":"themes/cactus-light/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1497013753000},{"_id":"source/_posts/Architecture/2017_03_19_扯扯单元测试.md","hash":"8568b7a7dca0916b0a8e4cacdc2cb59c8e0ea733","modified":1497013753000},{"_id":"source/_posts/Architecture/2017_03_04_谈谈ID.md","hash":"16f18726e2c860a1ea455cbab265b66cac564d0f","modified":1497013753000},{"_id":"source/_posts/Docker/2017_02_04_Docker网络——Flannel配置.md","hash":"138209aa48d59eb1b0cc1fd540408f6eb20fc38b","modified":1497013753000},{"_id":"source/_posts/MyCAT/2017_05_22_为什么阅读MyCAT源码？.md","hash":"ab8f1ab2ea796435faa1a10927299cb1ea43068b","modified":1497552719000},{"_id":"source/_posts/MyCAT/2017_05_23_MyCAT源码分析——调试环境搭建.md","hash":"5c1347d2907ad326f72a278a54270a68cf979031","modified":1497454360000},{"_id":"source/_posts/MyCAT/2017_07_12_MyCAT源码分析——跨库两表Join.md","hash":"df78ba694fb042ba38d82f1847bfac9f3e2ae4ee","modified":1499880601000},{"_id":"source/_posts/MyCAT/2017_05_29_MyCAT源码分析——【单库单表】插入.md","hash":"8ae86889970a31297d74bc06889a15f69fd0b5ce","modified":1499766351000},{"_id":"source/_posts/MyCAT/2017_05_30_MyCAT源码分析——【单库单表】查询.md","hash":"aab44b913bf2937a7a0f3e6bf330a3dba52b530b","modified":1499766359000},{"_id":"source/_posts/MyCAT/2017_06_13_MyCAT源码分析——分片结果合并.md","hash":"6f842f0245e26a6b32338f86e893d3ac5e20f6a0","modified":1497525637000},{"_id":"source/_posts/Nginx/2017_01_07_Nginx动态配置upstream.md","hash":"509f38efd1bd00593624d3cd5b947257c3a104aa","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_03_23_为什么阅读RocketMQ源码？.md","hash":"134ba52199137fbbbee7a48a886f3559efe4787e","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_04_05_RocketMQ之Namesrv小结.md","hash":"6ae111cbdc5ad84c99ef7107657da9c624b6843d","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_04_07_RocketMQ源码分析——Topic.md","hash":"3b162722fa1ee8f00d539ccd5a4876ec959d955e","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_04_08_RocketMQ源码分析——Message基础.md","hash":"06d2a199a0927bece31d4220eda23fdae636c1cd","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_04_18_RocketMQ源码分析——Message发送与接收.md","hash":"20ad7a79cbc0227f98c948a0e735c54991d27a1b","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_04_23_RocketMQ源码分析——Message存储.md","hash":"31fa919083f01a35bd57cfdd1905277c09348109","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_12_RocketMQ源码分析——Store初始化与关闭.md","hash":"0a34e6f9b94ef5920c8e01e636bd848ffa09aaef","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_13_RocketMQ源码分析——Message顺序发送与消费.md","hash":"9b1f20d4624f76ada5e3e1972487e6cc56b55e05","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_14_RocketMQ源码分析——高可用.md","hash":"7d016ddeb55431b230dc167c567bb68c275b2b0b","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_15_RocketMQ源码分析——定时消息与消息重试.md","hash":"41b69918dda4fbfdec2d36f97bb3f186789723df","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_17_RocketMQ源码分析——Filtersrv.md","hash":"3c9bf9e78aab92d76edd150dac39866fdd10ac7f","modified":1497013753000},{"_id":"themes/cactus-light/layout/_widget/lean-analytics.ejs","hash":"08233ac2027ec2aa76ca89435c2035a07904e34a","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/footer.ejs","hash":"eafacb50dd7585f1c4a217d113451e680de05784","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_21_RocketMQ源码分析——事务消息.md","hash":"4d845a0084508946fbf33e6603e32b10072a5ce7","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/head.ejs","hash":"b47c3a3699ff780bb9368360e7513bc897cc5a74","modified":1497013878000},{"_id":"themes/cactus-light/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/scripts.ejs","hash":"5e2c7f394d1fb009eaaffe849104680525749901","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/styles.ejs","hash":"e62b799d8ac369d1f1b36bd2649ecc34aec3384c","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_extend.styl","hash":"faca25132d55e8989d1c1d638e55d1e97de3c561","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_variables.styl","hash":"35d671e97f68b258aeb7f19d101a0850c6c20f62","modified":1497013753000},{"_id":"themes/cactus-light/source/css/style.styl","hash":"fd444326438df9d1fb26690943fd65459f0b20d3","modified":1497013753000},{"_id":"themes/cactus-light/source/images/favicon.ico","hash":"d7152fdb65d116c197d394d437b27e86db64590c","modified":1497013753000},{"_id":"themes/cactus-light/source/images/logo.png","hash":"86be6c333b7ddbb16a3fa14c0901b58be4d6ebd6","modified":1497013753000},{"_id":"themes/cactus-light/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1497013753000},{"_id":"source/_drafts/MyCAT/9999_99_99_MyCAT_UML.asta","hash":"9b41f540242fb30b4a90575429b05e7b61beefde","modified":1497013753000},{"_id":"source/_drafts/JVM/Java内存.xmind","hash":"2e452fb05a369ac1addb2a37c603578a5b9c6358","modified":1497552609000},{"_id":"source/_posts/RocketMQ/2017_05_04_RocketMQ源码分析——Message拉取与消费（上）.md","hash":"2935053714fdddc367d64752477966e4efef907c","modified":1497013753000},{"_id":"source/_posts/RocketMQ/2017_05_11_RocketMQ源码分析——Message拉取与消费（下）.md","hash":"ff2be626c63c0921aea8c815a9a4c1a9e68c4a90","modified":1497013753000},{"_id":"source/_drafts/RocketMQ/9999_99_99_RocketMQ_UML.asta","hash":"0d2f4155546075bc31f5dfcf18359d35fe4f13d0","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/actions_desktop.ejs","hash":"e454a4c3dd97ca0857431600b511e93217de353d","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/actions_mobile.ejs","hash":"e7638a83e5aaa4bf5b24440ca76fec8eb563bed7","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1497013753000},{"_id":"themes/cactus-light/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/monokai.styl","hash":"bd4b20bdbb3a62972f5c9e52f1f794090b8ff7f9","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/article.styl","hash":"b90c7eebe9b39110aac089d65155e937dc1836e9","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/footer.styl","hash":"e01bb6d5b745983148bd6b7eeccb7d4df2c55108","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/header.styl","hash":"63707d9103a283147ca222fd6f8ff9bffbffe427","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/index.styl","hash":"cf43702450ea1e5617541501886982a394cff8ec","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/pagination.styl","hash":"f483e0b4e8aefaa81f5e1e5e8ab7c54f70557f75","modified":1497013753000},{"_id":"themes/cactus-light/source/images/apple-touch-icon.png","hash":"33b0899283a91d7fd539f6b26d9f43fb3d8751ba","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1497013753000},{"_id":"themes/cactus-light/source/images/favicon-192x192.png","hash":"aaed0c6f5279d5765100ed5c16cc5450b57a72f0","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/post/actions_mobile.styl","hash":"dce6466e2ab708854c9e15173bfc19e5715d4303","modified":1497013753000},{"_id":"themes/cactus-light/source/css/_partial/post/actions_desktop.styl","hash":"1fc72bf23c1eb93324edfb5877b45c24ae85eb99","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1497013753000},{"_id":"themes/cactus-light/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1497013753000},{"_id":"public/baidu_urls.txt","hash":"9722e346e8ef7dff72e19b4a002f41f8f76887d9","modified":1499879592985},{"_id":"public/baidusitemap.xml","hash":"ed98647076637a68f7bd2e55205e1c0235d910b5","modified":1499880610917},{"_id":"public/sitemap.xml","hash":"ad0c75e499facea4ce7870bf1200ab3ecbf851c0","modified":1499880612395},{"_id":"public/atom.xml","hash":"53f0407c8ddde8dbed41b591f557be9c9f4717c7","modified":1499880610919},{"_id":"public/archives/2017/01/index.html","hash":"2261871a02ea83439f5cfd6a677f046b7fc27db0","modified":1499879594443},{"_id":"public/archives/2017/02/index.html","hash":"942b9180bc2569d2d08ee4f83ea0e5a167e92ef8","modified":1499879594443},{"_id":"public/archives/2017/03/index.html","hash":"cdd69062df051db591ee7e1727b9f6c12697f220","modified":1499879594481},{"_id":"public/archives/2017/04/index.html","hash":"21d25a55af279c7b7c4231803e1472e4fee0259c","modified":1499879594481},{"_id":"public/archives/2017/05/index.html","hash":"9bc7dd4e8380d064d9207f78624bf1945870edac","modified":1499879594482},{"_id":"public/archives/2017/06/index.html","hash":"cbb799db16a0eb1c28948799dd8f01ab60ecd1c5","modified":1499879594482},{"_id":"public/categories/技术杂文/index.html","hash":"5f22fbd1bc82a46e693d52e32c55c9f3bd5308e1","modified":1499879594482},{"_id":"public/categories/Docker/index.html","hash":"bc21878e2f11d3fc2a1f30c1b102f088ed34c384","modified":1499879594483},{"_id":"public/categories/MyCAT/index.html","hash":"fadce7c2a5283a0060d14d29eda0db65796e4182","modified":1499880612457},{"_id":"public/categories/Nginx/index.html","hash":"98246f9f9dc32645f45ea17db8b6cc397653678d","modified":1499879594483},{"_id":"public/categories/RocketMQ/index.html","hash":"87e569f1c5a0a8d8436e66e83fed0070a4419f3e","modified":1499879594483},{"_id":"public/MyCAT/sharding-result-merge-first/index.html","hash":"849de4f47cb11d5e4adc24404d622b967749fd4c","modified":1499879594483},{"_id":"public/MyCAT/single-db-single-table-select/index.html","hash":"b712c8045aaeea0b5cae9065016ad3cbaf5c220f","modified":1499879594483},{"_id":"public/MyCAT/single-db-single-table-insert/index.html","hash":"0b99563425780650cf21e735e46cef34eaad2050","modified":1499879594483},{"_id":"public/MyCAT/build-debugging-environment/index.html","hash":"87f9b1f02e7d15a8f90a639985b785cf8a94513f","modified":1499879594483},{"_id":"public/MyCAT/why-read-MyCAT-source-code/index.html","hash":"97621273dff40ae00d1b3a39ae5c21e04e03f26d","modified":1499879594483},{"_id":"public/RocketMQ/message-transaction/index.html","hash":"a4b4bd7b9944aae92d08ae3759ba2f54595a11a6","modified":1499879594483},{"_id":"public/RocketMQ/filtersrv/index.html","hash":"15ef9734de6e68c0bb62621521339ca19ff4beb5","modified":1499879594483},{"_id":"public/RocketMQ/message-schedule-and-retry/index.html","hash":"42b12d4c3275fabf25d0a917460d06bf19e75a5e","modified":1499879594484},{"_id":"public/RocketMQ/high-availability/index.html","hash":"d6f8465e959acd323028d94376137897d133e3d8","modified":1499879594484},{"_id":"public/RocketMQ/message-send-and-consume-orderly/index.html","hash":"c9be05051b548f47e4e05d72f22dbaff1f759f5a","modified":1499879594484},{"_id":"public/RocketMQ/store-init-and-shutdown/index.html","hash":"c4e517897a8027a399aceee35a85b81d7a4597f2","modified":1499879594484},{"_id":"public/RocketMQ/message-pull-and-consume-second/index.html","hash":"3a5730b2f853d78879220d1a1e14dd8633c41dac","modified":1499879594484},{"_id":"public/RocketMQ/message-pull-and-consume-first/index.html","hash":"6943636a10af36f59354118c6ade9e389531cf21","modified":1499879594484},{"_id":"public/RocketMQ/message-store/index.html","hash":"9eb7b0578d9b0ae80aa8708c3e4db1757809f4d5","modified":1499879594484},{"_id":"public/RocketMQ/message-send-and-receive/index.html","hash":"3962b3a0aff8473da2b5e9888214e39ce2cce643","modified":1499879594484},{"_id":"public/RocketMQ/message/index.html","hash":"aa569e7a7afe0e57ebf11656de75c1477d9a92f7","modified":1499879594484},{"_id":"public/RocketMQ/topic/index.html","hash":"7d3b011be5ef14ac196872e68a8e2f71acbcb582","modified":1499879594484},{"_id":"public/RocketMQ/namesrv-intro/index.html","hash":"56874c4bc0a3fc3e6c55cb9b791f62fd5ada70db","modified":1499879594485},{"_id":"public/RocketMQ/why-read-RocketMQ-source-code/index.html","hash":"071c525a442e2259c14a2426729530cff95a087d","modified":1499879594485},{"_id":"public/Architecture/talk-about-java-unit-test/index.html","hash":"0b4895d6cad2183ac2b5dd8164bf5af0706aee56","modified":1499879594485},{"_id":"public/Architecture/talk-about-global-id/index.html","hash":"b889c6106dc61958d427e6a1fa2b503636cb139e","modified":1499879594485},{"_id":"public/Docker/docker-network-flannel/index.html","hash":"fefee135f8e979f315679c8a7cb9a715bada48df","modified":1499879594485},{"_id":"public/Nginx/nginx-dynamic-upstream/index.html","hash":"fbe630d24932caaee20b8cc5819e3c72b890985e","modified":1499879594485},{"_id":"public/archives/index.html","hash":"e800dc3513c6725886fcec00a9cb6527f9388c87","modified":1499880612457},{"_id":"public/archives/2017/index.html","hash":"5b3819e411ef13a35716a09b28128fde4e857f29","modified":1499880612457},{"_id":"public/index.html","hash":"8e5e11f2657126d2f2eddea51d900016a05206de","modified":1499880612457},{"_id":"public/archives/2017/07/index.html","hash":"4cd22ea0469e05947595ceef31664a25d00ca3ca","modified":1499880612457},{"_id":"public/MyCAT/sharding-two-table-join/index.html","hash":"e65bb1f31de841c77278070e71babccfa627f86b","modified":1499880612457},{"_id":"public/Staticfile","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1499879594497},{"_id":"public/robots.txt","hash":"dabd6699992a60e4142995a12cd48f7a3c19c7c5","modified":1499879594506},{"_id":"public/sogousiteverification.txt","hash":"ac2b4638cb7bf220aa8f359e044ef61e5a304363","modified":1499879594506},{"_id":"public/images/logo.png","hash":"86be6c333b7ddbb16a3fa14c0901b58be4d6ebd6","modified":1499879594507},{"_id":"public/images/favicon.ico","hash":"d7152fdb65d116c197d394d437b27e86db64590c","modified":1499879594507},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1499879594946},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1499879594949},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1499879594953},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1499879594953},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1499879594953},{"_id":"public/css/style.css","hash":"1c312411b10beb69d3534d5e1976ab0ee308848c","modified":1499879594953},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1499879594953},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1499879594953},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1499879594953},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1499879594953},{"_id":"public/images/apple-touch-icon.png","hash":"33b0899283a91d7fd539f6b26d9f43fb3d8751ba","modified":1499879594953},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1499879594953},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1499879594957},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1499879594957},{"_id":"public/images/favicon-192x192.png","hash":"aaed0c6f5279d5765100ed5c16cc5450b57a72f0","modified":1499879594967},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1499879594993},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1499879595000},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1499879595000},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1499879595001},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1499879595002},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1499879595002},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1499879595002},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1499879595003},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1499879595004},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1499879595004},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1499879595005},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1499879595005},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1499879595006}],"Category":[{"name":"技术杂文","_id":"cj519kz9n0002ag5dotac7hr4"},{"name":"Docker","_id":"cj519kza1000aag5d09i3gxhq"},{"name":"MyCAT","_id":"cj519kza4000eag5d29ir0s7d"},{"name":"Nginx","_id":"cj519kzak0012ag5dazzo3rnj"},{"name":"RocketMQ","_id":"cj519kzal0015ag5dej9fbt12"}],"Data":[],"Page":[],"Post":[{"title":"谈谈单元测试","date":"2017-03-18T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/Architecture/talk-about-java-unit-test/](http://www.yunai.me/Architecture/talk-about-java-unit-test/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 为什么做单元测试](#)\n- [2. 选型](#)\n\t- [2.1 JUnit](#)\n\t- [2.2 Mockito](#)\n\t- [2.3 PowerMock](#)\n- [3. 实践](#)\n\t- [3.1 Service 层](#)\n\t- [3.2 Controller 层](#)\n\t- [3.3 Dao 层](#)\n- [4. 建议](#)\n\n**本文主要面向Java工程师，见谅**\n\n# 1. 为什么做单元测试\n\n* 提升重复测试效率\n* 提升代码质量\n* 提升部署可靠性\n\n# 2. 选型\n\n## 2.1 JUnit\n\n> 单元测试套件\n\n为什么不使用 TestNG ？在整合 TestNG + Mockito + PowerMock + Spring 时，Spring 容器初始化失败， `@Autowired` 的属性无法注入，查找资料，基本无解，只好退而求其次，选择 JUnit 。从功能强大程度，易用性上，个人较为推荐 TestNG 。\n\n## 2.2 Mockito\n\n> Mock 工具\n\n为什么不使用 JMock 、EasyMock ？因为 API 上更加轻量级，用起来爽爽的。\n\n## 2.3 PowerMock\n\n> 作为 Mockito 的补充，增加对 `private`、`static`、`final` 的支持。\n\n为什么 Mockito 不自己支持？[Mockito-And-Private-Methods](https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods) 作者有自己的考虑，不过对于使用者，增加了很多整合的痛苦。\n\n# 3. 实践\n\n## 3.1 Service 层\n\n> 方案一：\n\n* 依赖的 Dao 层代码，使用 mock 进行模拟\n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n> 方案二：\n\n* 依赖的 Dao 层代码，使用内嵌数据库，例如说 h2database \n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n**个人较为推荐方案二。从可靠性角度考虑，相对真实的模拟了 Dao 层，例如数据插入后，可以进行查询，判断Service是否正确设置值，是否有属性漏设置会设置错；当然，该方案在维护上会相对麻烦一些，各有利弊。**\n\n## 3.2 Controller 层\n\n> 方案一：\n\n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n> 方案二：\n\n* 依赖的 Service 层【**读**】类逻辑，执行真实逻辑。读取依赖的数据，使用内嵌数据库插入。\n* 依赖的 Service 层【**写**】类逻辑，使用 mock 进行模拟。和 Controller 类的逻辑或者返回有关系的数据，使用内嵌数据库插入。\n\n**个人较为推荐方案二。原因同 Service 层单元测试。**\n\n另外，大部门互联网公司 MVC 框架选用的是 SpringMVC ，可以使用 SpringMVC Test 框架。使用方式如下：\n\n```\nMockMvcBuilders.standaloneSetup(XXXController).build()\n```\n\n## 3.3 Dao 层\n\n使用内嵌的数据实现进行测试。\n\n* MySQL ：[h2database](https://github.com/h2database/h2database) \n* MongoDB ：[fongo](https://github.com/fakemongo/fongo)\n* Redis ：[embedded-redis](https://github.com/kstyrc/embedded-redis)\n\n# 4. 建议\n\n1. 加 QQ：**7685413**，进行互相交流。😜。\n2. 当使用 TestNG + Mockito + PowerMock ，测试类使用 IObjectFactory 而不要去继承 PowerMockTestCase 。Java 无法多继承，如果此时你有必须继承的类就十分棘手。\n\n```\n@ObjectFactory  \npublic IObjectFactory getObjectFactory() {  \n\treturn new PowerMockObjectFactory();  \n}   \n```\t\n\n3. 当使用 PowerMockTestCase 每个测试单元执行完后，会清理掉对方法的 mock。因此，如果有公用的 mock 方法，需要使用下 @BeforeMethod（TestNG）、@Before（JUnit）里在进行一次mock。\n4. 当使用 Mockito + PowerMock ，对测试类进行测试时，有需要对测试类的一些私有方法、或者静态方法进行 mock 时，不要使用 @Spy，而要使用PowerMokito.spy()进行 mock 。很酸爽。\n\n","source":"_posts/Architecture/2017_03_19_扯扯单元测试.md","raw":"title: 谈谈单元测试\ndate: 2017-03-19\ntags:\ncategories: 技术杂文\npermalink: Architecture/talk-about-java-unit-test\n\n-------\n\n>  原文地址：[http://www.yunai.me/Architecture/talk-about-java-unit-test/](http://www.yunai.me/Architecture/talk-about-java-unit-test/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 为什么做单元测试](#)\n- [2. 选型](#)\n\t- [2.1 JUnit](#)\n\t- [2.2 Mockito](#)\n\t- [2.3 PowerMock](#)\n- [3. 实践](#)\n\t- [3.1 Service 层](#)\n\t- [3.2 Controller 层](#)\n\t- [3.3 Dao 层](#)\n- [4. 建议](#)\n\n**本文主要面向Java工程师，见谅**\n\n# 1. 为什么做单元测试\n\n* 提升重复测试效率\n* 提升代码质量\n* 提升部署可靠性\n\n# 2. 选型\n\n## 2.1 JUnit\n\n> 单元测试套件\n\n为什么不使用 TestNG ？在整合 TestNG + Mockito + PowerMock + Spring 时，Spring 容器初始化失败， `@Autowired` 的属性无法注入，查找资料，基本无解，只好退而求其次，选择 JUnit 。从功能强大程度，易用性上，个人较为推荐 TestNG 。\n\n## 2.2 Mockito\n\n> Mock 工具\n\n为什么不使用 JMock 、EasyMock ？因为 API 上更加轻量级，用起来爽爽的。\n\n## 2.3 PowerMock\n\n> 作为 Mockito 的补充，增加对 `private`、`static`、`final` 的支持。\n\n为什么 Mockito 不自己支持？[Mockito-And-Private-Methods](https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods) 作者有自己的考虑，不过对于使用者，增加了很多整合的痛苦。\n\n# 3. 实践\n\n## 3.1 Service 层\n\n> 方案一：\n\n* 依赖的 Dao 层代码，使用 mock 进行模拟\n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n> 方案二：\n\n* 依赖的 Dao 层代码，使用内嵌数据库，例如说 h2database \n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n**个人较为推荐方案二。从可靠性角度考虑，相对真实的模拟了 Dao 层，例如数据插入后，可以进行查询，判断Service是否正确设置值，是否有属性漏设置会设置错；当然，该方案在维护上会相对麻烦一些，各有利弊。**\n\n## 3.2 Controller 层\n\n> 方案一：\n\n* 依赖的 Service 层代码，使用 mock 进行模拟\n\n> 方案二：\n\n* 依赖的 Service 层【**读**】类逻辑，执行真实逻辑。读取依赖的数据，使用内嵌数据库插入。\n* 依赖的 Service 层【**写**】类逻辑，使用 mock 进行模拟。和 Controller 类的逻辑或者返回有关系的数据，使用内嵌数据库插入。\n\n**个人较为推荐方案二。原因同 Service 层单元测试。**\n\n另外，大部门互联网公司 MVC 框架选用的是 SpringMVC ，可以使用 SpringMVC Test 框架。使用方式如下：\n\n```\nMockMvcBuilders.standaloneSetup(XXXController).build()\n```\n\n## 3.3 Dao 层\n\n使用内嵌的数据实现进行测试。\n\n* MySQL ：[h2database](https://github.com/h2database/h2database) \n* MongoDB ：[fongo](https://github.com/fakemongo/fongo)\n* Redis ：[embedded-redis](https://github.com/kstyrc/embedded-redis)\n\n# 4. 建议\n\n1. 加 QQ：**7685413**，进行互相交流。😜。\n2. 当使用 TestNG + Mockito + PowerMock ，测试类使用 IObjectFactory 而不要去继承 PowerMockTestCase 。Java 无法多继承，如果此时你有必须继承的类就十分棘手。\n\n```\n@ObjectFactory  \npublic IObjectFactory getObjectFactory() {  \n\treturn new PowerMockObjectFactory();  \n}   \n```\t\n\n3. 当使用 PowerMockTestCase 每个测试单元执行完后，会清理掉对方法的 mock。因此，如果有公用的 mock 方法，需要使用下 @BeforeMethod（TestNG）、@Before（JUnit）里在进行一次mock。\n4. 当使用 Mockito + PowerMock ，对测试类进行测试时，有需要对测试类的一些私有方法、或者静态方法进行 mock 时，不要使用 @Spy，而要使用PowerMokito.spy()进行 mock 。很酸爽。\n\n","slug":"Architecture/talk-about-java-unit-test","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9h0000ag5daz47obvg","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Architecture/talk-about-java-unit-test/\">http://www.yunai.me/Architecture/talk-about-java-unit-test/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 为什么做单元测试</a></li>\n<li><a href=\"#\">2. 选型</a><ul>\n<li><a href=\"#\">2.1 JUnit</a></li>\n<li><a href=\"#\">2.2 Mockito</a></li>\n<li><a href=\"#\">2.3 PowerMock</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 实践</a><ul>\n<li><a href=\"#\">3.1 Service 层</a></li>\n<li><a href=\"#\">3.2 Controller 层</a></li>\n<li><a href=\"#\">3.3 Dao 层</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 建议</a></li>\n</ul>\n<p><strong>本文主要面向Java工程师，见谅</strong></p>\n<h1 id=\"1-为什么做单元测试\"><a href=\"#1-为什么做单元测试\" class=\"headerlink\" title=\"1. 为什么做单元测试\"></a>1. 为什么做单元测试</h1><ul>\n<li>提升重复测试效率</li>\n<li>提升代码质量</li>\n<li>提升部署可靠性</li>\n</ul>\n<h1 id=\"2-选型\"><a href=\"#2-选型\" class=\"headerlink\" title=\"2. 选型\"></a>2. 选型</h1><h2 id=\"2-1-JUnit\"><a href=\"#2-1-JUnit\" class=\"headerlink\" title=\"2.1 JUnit\"></a>2.1 JUnit</h2><blockquote>\n<p>单元测试套件</p>\n</blockquote>\n<p>为什么不使用 TestNG ？在整合 TestNG + Mockito + PowerMock + Spring 时，Spring 容器初始化失败， <code>@Autowired</code> 的属性无法注入，查找资料，基本无解，只好退而求其次，选择 JUnit 。从功能强大程度，易用性上，个人较为推荐 TestNG 。</p>\n<h2 id=\"2-2-Mockito\"><a href=\"#2-2-Mockito\" class=\"headerlink\" title=\"2.2 Mockito\"></a>2.2 Mockito</h2><blockquote>\n<p>Mock 工具</p>\n</blockquote>\n<p>为什么不使用 JMock 、EasyMock ？因为 API 上更加轻量级，用起来爽爽的。</p>\n<h2 id=\"2-3-PowerMock\"><a href=\"#2-3-PowerMock\" class=\"headerlink\" title=\"2.3 PowerMock\"></a>2.3 PowerMock</h2><blockquote>\n<p>作为 Mockito 的补充，增加对 <code>private</code>、<code>static</code>、<code>final</code> 的支持。</p>\n</blockquote>\n<p>为什么 Mockito 不自己支持？<a href=\"https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods\" target=\"_blank\" rel=\"external\">Mockito-And-Private-Methods</a> 作者有自己的考虑，不过对于使用者，增加了很多整合的痛苦。</p>\n<h1 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3. 实践\"></a>3. 实践</h1><h2 id=\"3-1-Service-层\"><a href=\"#3-1-Service-层\" class=\"headerlink\" title=\"3.1 Service 层\"></a>3.1 Service 层</h2><blockquote>\n<p>方案一：</p>\n</blockquote>\n<ul>\n<li>依赖的 Dao 层代码，使用 mock 进行模拟</li>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<blockquote>\n<p>方案二：</p>\n</blockquote>\n<ul>\n<li>依赖的 Dao 层代码，使用内嵌数据库，例如说 h2database </li>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<p><strong>个人较为推荐方案二。从可靠性角度考虑，相对真实的模拟了 Dao 层，例如数据插入后，可以进行查询，判断Service是否正确设置值，是否有属性漏设置会设置错；当然，该方案在维护上会相对麻烦一些，各有利弊。</strong></p>\n<h2 id=\"3-2-Controller-层\"><a href=\"#3-2-Controller-层\" class=\"headerlink\" title=\"3.2 Controller 层\"></a>3.2 Controller 层</h2><blockquote>\n<p>方案一：</p>\n</blockquote>\n<ul>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<blockquote>\n<p>方案二：</p>\n</blockquote>\n<ul>\n<li>依赖的 Service 层【<strong>读</strong>】类逻辑，执行真实逻辑。读取依赖的数据，使用内嵌数据库插入。</li>\n<li>依赖的 Service 层【<strong>写</strong>】类逻辑，使用 mock 进行模拟。和 Controller 类的逻辑或者返回有关系的数据，使用内嵌数据库插入。</li>\n</ul>\n<p><strong>个人较为推荐方案二。原因同 Service 层单元测试。</strong></p>\n<p>另外，大部门互联网公司 MVC 框架选用的是 SpringMVC ，可以使用 SpringMVC Test 框架。使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">MockMvcBuilders.standaloneSetup(XXXController).build()</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-Dao-层\"><a href=\"#3-3-Dao-层\" class=\"headerlink\" title=\"3.3 Dao 层\"></a>3.3 Dao 层</h2><p>使用内嵌的数据实现进行测试。</p>\n<ul>\n<li>MySQL ：<a href=\"https://github.com/h2database/h2database\" target=\"_blank\" rel=\"external\">h2database</a> </li>\n<li>MongoDB ：<a href=\"https://github.com/fakemongo/fongo\" target=\"_blank\" rel=\"external\">fongo</a></li>\n<li>Redis ：<a href=\"https://github.com/kstyrc/embedded-redis\" target=\"_blank\" rel=\"external\">embedded-redis</a></li>\n</ul>\n<h1 id=\"4-建议\"><a href=\"#4-建议\" class=\"headerlink\" title=\"4. 建议\"></a>4. 建议</h1><ol>\n<li>加 QQ：<strong>7685413</strong>，进行互相交流。😜。</li>\n<li>当使用 TestNG + Mockito + PowerMock ，测试类使用 IObjectFactory 而不要去继承 PowerMockTestCase 。Java 无法多继承，如果此时你有必须继承的类就十分棘手。</li>\n</ol>\n<pre><code>@ObjectFactory  \npublic IObjectFactory getObjectFactory() {  \n    return new PowerMockObjectFactory();  \n}\n</code></pre><ol>\n<li>当使用 PowerMockTestCase 每个测试单元执行完后，会清理掉对方法的 mock。因此，如果有公用的 mock 方法，需要使用下 @BeforeMethod（TestNG）、@Before（JUnit）里在进行一次mock。</li>\n<li>当使用 Mockito + PowerMock ，对测试类进行测试时，有需要对测试类的一些私有方法、或者静态方法进行 mock 时，不要使用 @Spy，而要使用PowerMokito.spy()进行 mock 。很酸爽。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Architecture/talk-about-java-unit-test/\">http://www.yunai.me/Architecture/talk-about-java-unit-test/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 为什么做单元测试</a></li>\n<li><a href=\"#\">2. 选型</a><ul>\n<li><a href=\"#\">2.1 JUnit</a></li>\n<li><a href=\"#\">2.2 Mockito</a></li>\n<li><a href=\"#\">2.3 PowerMock</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 实践</a><ul>\n<li><a href=\"#\">3.1 Service 层</a></li>\n<li><a href=\"#\">3.2 Controller 层</a></li>\n<li><a href=\"#\">3.3 Dao 层</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 建议</a></li>\n</ul>\n<p><strong>本文主要面向Java工程师，见谅</strong></p>\n<h1 id=\"1-为什么做单元测试\"><a href=\"#1-为什么做单元测试\" class=\"headerlink\" title=\"1. 为什么做单元测试\"></a>1. 为什么做单元测试</h1><ul>\n<li>提升重复测试效率</li>\n<li>提升代码质量</li>\n<li>提升部署可靠性</li>\n</ul>\n<h1 id=\"2-选型\"><a href=\"#2-选型\" class=\"headerlink\" title=\"2. 选型\"></a>2. 选型</h1><h2 id=\"2-1-JUnit\"><a href=\"#2-1-JUnit\" class=\"headerlink\" title=\"2.1 JUnit\"></a>2.1 JUnit</h2><blockquote>\n<p>单元测试套件</p>\n</blockquote>\n<p>为什么不使用 TestNG ？在整合 TestNG + Mockito + PowerMock + Spring 时，Spring 容器初始化失败， <code>@Autowired</code> 的属性无法注入，查找资料，基本无解，只好退而求其次，选择 JUnit 。从功能强大程度，易用性上，个人较为推荐 TestNG 。</p>\n<h2 id=\"2-2-Mockito\"><a href=\"#2-2-Mockito\" class=\"headerlink\" title=\"2.2 Mockito\"></a>2.2 Mockito</h2><blockquote>\n<p>Mock 工具</p>\n</blockquote>\n<p>为什么不使用 JMock 、EasyMock ？因为 API 上更加轻量级，用起来爽爽的。</p>\n<h2 id=\"2-3-PowerMock\"><a href=\"#2-3-PowerMock\" class=\"headerlink\" title=\"2.3 PowerMock\"></a>2.3 PowerMock</h2><blockquote>\n<p>作为 Mockito 的补充，增加对 <code>private</code>、<code>static</code>、<code>final</code> 的支持。</p>\n</blockquote>\n<p>为什么 Mockito 不自己支持？<a href=\"https://github.com/mockito/mockito/wiki/Mockito-And-Private-Methods\" target=\"_blank\" rel=\"external\">Mockito-And-Private-Methods</a> 作者有自己的考虑，不过对于使用者，增加了很多整合的痛苦。</p>\n<h1 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3. 实践\"></a>3. 实践</h1><h2 id=\"3-1-Service-层\"><a href=\"#3-1-Service-层\" class=\"headerlink\" title=\"3.1 Service 层\"></a>3.1 Service 层</h2><blockquote>\n<p>方案一：</p>\n</blockquote>\n<ul>\n<li>依赖的 Dao 层代码，使用 mock 进行模拟</li>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<blockquote>\n<p>方案二：</p>\n</blockquote>\n<ul>\n<li>依赖的 Dao 层代码，使用内嵌数据库，例如说 h2database </li>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<p><strong>个人较为推荐方案二。从可靠性角度考虑，相对真实的模拟了 Dao 层，例如数据插入后，可以进行查询，判断Service是否正确设置值，是否有属性漏设置会设置错；当然，该方案在维护上会相对麻烦一些，各有利弊。</strong></p>\n<h2 id=\"3-2-Controller-层\"><a href=\"#3-2-Controller-层\" class=\"headerlink\" title=\"3.2 Controller 层\"></a>3.2 Controller 层</h2><blockquote>\n<p>方案一：</p>\n</blockquote>\n<ul>\n<li>依赖的 Service 层代码，使用 mock 进行模拟</li>\n</ul>\n<blockquote>\n<p>方案二：</p>\n</blockquote>\n<ul>\n<li>依赖的 Service 层【<strong>读</strong>】类逻辑，执行真实逻辑。读取依赖的数据，使用内嵌数据库插入。</li>\n<li>依赖的 Service 层【<strong>写</strong>】类逻辑，使用 mock 进行模拟。和 Controller 类的逻辑或者返回有关系的数据，使用内嵌数据库插入。</li>\n</ul>\n<p><strong>个人较为推荐方案二。原因同 Service 层单元测试。</strong></p>\n<p>另外，大部门互联网公司 MVC 框架选用的是 SpringMVC ，可以使用 SpringMVC Test 框架。使用方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">MockMvcBuilders.standaloneSetup(XXXController).build()</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-Dao-层\"><a href=\"#3-3-Dao-层\" class=\"headerlink\" title=\"3.3 Dao 层\"></a>3.3 Dao 层</h2><p>使用内嵌的数据实现进行测试。</p>\n<ul>\n<li>MySQL ：<a href=\"https://github.com/h2database/h2database\" target=\"_blank\" rel=\"external\">h2database</a> </li>\n<li>MongoDB ：<a href=\"https://github.com/fakemongo/fongo\" target=\"_blank\" rel=\"external\">fongo</a></li>\n<li>Redis ：<a href=\"https://github.com/kstyrc/embedded-redis\" target=\"_blank\" rel=\"external\">embedded-redis</a></li>\n</ul>\n<h1 id=\"4-建议\"><a href=\"#4-建议\" class=\"headerlink\" title=\"4. 建议\"></a>4. 建议</h1><ol>\n<li>加 QQ：<strong>7685413</strong>，进行互相交流。😜。</li>\n<li>当使用 TestNG + Mockito + PowerMock ，测试类使用 IObjectFactory 而不要去继承 PowerMockTestCase 。Java 无法多继承，如果此时你有必须继承的类就十分棘手。</li>\n</ol>\n<pre><code>@ObjectFactory  \npublic IObjectFactory getObjectFactory() {  \n    return new PowerMockObjectFactory();  \n}\n</code></pre><ol>\n<li>当使用 PowerMockTestCase 每个测试单元执行完后，会清理掉对方法的 mock。因此，如果有公用的 mock 方法，需要使用下 @BeforeMethod（TestNG）、@Before（JUnit）里在进行一次mock。</li>\n<li>当使用 Mockito + PowerMock ，对测试类进行测试时，有需要对测试类的一些私有方法、或者静态方法进行 mock 时，不要使用 @Spy，而要使用PowerMokito.spy()进行 mock 。很酸爽。</li>\n</ol>\n"},{"title":"谈谈 ID","date":"2017-03-03T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/Architecture/talk-about-global-id/](http://www.yunai.me/Architecture/talk-about-global-id/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 数据库自增](#)\n- [2. 类UUID算法](#)\n- [3. SnowFlake](#)\n\t- [3.1 Twitter-Snowflake](#)\n\t- [3.2 Instagram SnowFlake](#)\n\t- [3.3 Simpleflake](#)\n\t- [3.4 Boundary flake](#)\n\t- [3.5 自己的想法](#)\n- [4. 参考文章](#)\n- [草稿](#)\n\n\n在日常开发中，数据库的id是不可少的。在各个场景下会有不同的选择，本文对互联网上常见的ID算法进行归纳，希望对工程师们有一点点帮助。\n\n# 1. 数据库自增\n1. MySQL、Oracle、PGSQL等关系数据库的id主键自增\n2. Redis、Memcached等K/V数据库的incr操作自增\n    * 需要考虑持久化的问题\n3. MongoDB自己维护一个id自增集合\n    * MongoDB的Update操作支持incr操作，因此可以这么做。\n    * 该方式适用于支持该操作的其他数据库。\n\n# 2. 类UUID算法\n1. UUID\n2. MongoDB的ObjectId\n\n# 3. SnowFlake\n\n## 3.1 Twitter-Snowflake\n \n>  Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。\n\n64bits从左往右依次是\n\n* 1bit 保留\n* 41bits 时间戳\n    * 支持69.7年需要的id。2 ^41 /365/24/60/60/1000=69.7\n* 10bits work-id\n    * 支持1024个work\n* 12bits sequence-id\n    * 支持每work每毫秒4096个id\n    * 支持每work每秒4096000个id\n    * 若当前毫秒超过4096，则sleep1毫秒，获取下一毫秒的自增\n \n** snowflake的意义，不仅仅在于提供了解决方式，更多的是一种基于Long长度实现具有时间相关性的id自增序列。因此，很多公司基于它进行二次改造适应自己的场景 **\n\n## 3.2 Instagram SnowFlake\n\n去中性化，基于PGSQL实现\n\n64bits从左至右依次是\n\n* 41bits 时间戳\n* 13bits logic-shard-id\n* 10bits sequence-id\n\n实现方式\n\n* 根据`share-key`获取对应的PGSQL实例-库\n* id使用PGSQL的存储过程\n* 13bits = `share-key对应值%logic-share-id` \n* 10bits = `该Table的auto_increment_id%(2 ^10)`\n\n好处\n\n* 去中性化\n* 根据id可以获得对应PGSQL实例-库\n\n## 3.3 Simpleflake\n\n64bits\n\n * 去中性化\n * 将work-id的12bits给sequence-id。完全随机，每毫秒有1/(2^22 )出现冲突的情况。数据量大时需要注意。\n * 未来可以平滑迁移到Twitter SnowFlake\n\n## 3.4 Boundary flake\n\n去中性化，基于erlang实现\n128bits从左到右依次是\n\n* 64bits 时间戳\n    * 和毫秒时间戳等长\n* 48bits work-id\n    * 和mac地址等长，使用时要避免相同mac多个进程\n* 14bits sequence-id\n\n## 3.5 自己的想法\n\n***参考Instagram SnowFlake的做法***\n\n去中心化，基于redis实现\n64bits从左到右依次是\n\n* 1bit 保留\n* 41bits 时间戳\n* 12bits 基于logic-shard-id\n* 10bits 基于时间戳+logic-shard-id在redis里自增\n\n# 4. 参考文章\n\n1. [互联网分布式id生成方法|msup微课干货](http://mp.weixin.qq.com/s?__biz=MzAwNjE3ODQ4NQ==&mid=2650896366&idx=1&sn=5d5acdf323df2b6d581249b32031ccd7&scene=1&srcid=0618GuDjWjenr7TacVTFj6VU#rd)\n2. [服务化框架－分布式Unique ID的生成方法一览](http://calvin1978.blogcn.com/articles/uuid.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n3. [分布式系统中 Unique ID 的生成方法](https://www.google.co.jp/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&oq=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&aqs=chrome..69i57.291j0j1&sourceid=chrome&ie=UTF-8)\n\n\n# 草稿\n\n1. 2实例、4分表\n* a：0*2*4*6\n* b：1*3*5*7\n\n2. 4实例、4分表\n* a：0*4*8*12\n* b：1*5*9*13\n* c：2*6*10*14\n* d：3*7*11*15\n\n扩展方式：\n* a与c双主〈a c〉\n* b与d双主〈b d〉","source":"_posts/Architecture/2017_03_04_谈谈ID.md","raw":"title: 谈谈 ID\ndate: 2017-03-04\ntags:\ncategories: 技术杂文\npermalink: Architecture/talk-about-global-id\n\n-------\n\n>  原文地址：[http://www.yunai.me/Architecture/talk-about-global-id/](http://www.yunai.me/Architecture/talk-about-global-id/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 数据库自增](#)\n- [2. 类UUID算法](#)\n- [3. SnowFlake](#)\n\t- [3.1 Twitter-Snowflake](#)\n\t- [3.2 Instagram SnowFlake](#)\n\t- [3.3 Simpleflake](#)\n\t- [3.4 Boundary flake](#)\n\t- [3.5 自己的想法](#)\n- [4. 参考文章](#)\n- [草稿](#)\n\n\n在日常开发中，数据库的id是不可少的。在各个场景下会有不同的选择，本文对互联网上常见的ID算法进行归纳，希望对工程师们有一点点帮助。\n\n# 1. 数据库自增\n1. MySQL、Oracle、PGSQL等关系数据库的id主键自增\n2. Redis、Memcached等K/V数据库的incr操作自增\n    * 需要考虑持久化的问题\n3. MongoDB自己维护一个id自增集合\n    * MongoDB的Update操作支持incr操作，因此可以这么做。\n    * 该方式适用于支持该操作的其他数据库。\n\n# 2. 类UUID算法\n1. UUID\n2. MongoDB的ObjectId\n\n# 3. SnowFlake\n\n## 3.1 Twitter-Snowflake\n \n>  Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。\n\n64bits从左往右依次是\n\n* 1bit 保留\n* 41bits 时间戳\n    * 支持69.7年需要的id。2 ^41 /365/24/60/60/1000=69.7\n* 10bits work-id\n    * 支持1024个work\n* 12bits sequence-id\n    * 支持每work每毫秒4096个id\n    * 支持每work每秒4096000个id\n    * 若当前毫秒超过4096，则sleep1毫秒，获取下一毫秒的自增\n \n** snowflake的意义，不仅仅在于提供了解决方式，更多的是一种基于Long长度实现具有时间相关性的id自增序列。因此，很多公司基于它进行二次改造适应自己的场景 **\n\n## 3.2 Instagram SnowFlake\n\n去中性化，基于PGSQL实现\n\n64bits从左至右依次是\n\n* 41bits 时间戳\n* 13bits logic-shard-id\n* 10bits sequence-id\n\n实现方式\n\n* 根据`share-key`获取对应的PGSQL实例-库\n* id使用PGSQL的存储过程\n* 13bits = `share-key对应值%logic-share-id` \n* 10bits = `该Table的auto_increment_id%(2 ^10)`\n\n好处\n\n* 去中性化\n* 根据id可以获得对应PGSQL实例-库\n\n## 3.3 Simpleflake\n\n64bits\n\n * 去中性化\n * 将work-id的12bits给sequence-id。完全随机，每毫秒有1/(2^22 )出现冲突的情况。数据量大时需要注意。\n * 未来可以平滑迁移到Twitter SnowFlake\n\n## 3.4 Boundary flake\n\n去中性化，基于erlang实现\n128bits从左到右依次是\n\n* 64bits 时间戳\n    * 和毫秒时间戳等长\n* 48bits work-id\n    * 和mac地址等长，使用时要避免相同mac多个进程\n* 14bits sequence-id\n\n## 3.5 自己的想法\n\n***参考Instagram SnowFlake的做法***\n\n去中心化，基于redis实现\n64bits从左到右依次是\n\n* 1bit 保留\n* 41bits 时间戳\n* 12bits 基于logic-shard-id\n* 10bits 基于时间戳+logic-shard-id在redis里自增\n\n# 4. 参考文章\n\n1. [互联网分布式id生成方法|msup微课干货](http://mp.weixin.qq.com/s?__biz=MzAwNjE3ODQ4NQ==&mid=2650896366&idx=1&sn=5d5acdf323df2b6d581249b32031ccd7&scene=1&srcid=0618GuDjWjenr7TacVTFj6VU#rd)\n2. [服务化框架－分布式Unique ID的生成方法一览](http://calvin1978.blogcn.com/articles/uuid.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n3. [分布式系统中 Unique ID 的生成方法](https://www.google.co.jp/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&oq=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&aqs=chrome..69i57.291j0j1&sourceid=chrome&ie=UTF-8)\n\n\n# 草稿\n\n1. 2实例、4分表\n* a：0*2*4*6\n* b：1*3*5*7\n\n2. 4实例、4分表\n* a：0*4*8*12\n* b：1*5*9*13\n* c：2*6*10*14\n* d：3*7*11*15\n\n扩展方式：\n* a与c双主〈a c〉\n* b与d双主〈b d〉","slug":"Architecture/talk-about-global-id","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9l0001ag5drp5hfcuo","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Architecture/talk-about-global-id/\">http://www.yunai.me/Architecture/talk-about-global-id/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 数据库自增</a></li>\n<li><a href=\"#\">2. 类UUID算法</a></li>\n<li><a href=\"#\">3. SnowFlake</a><ul>\n<li><a href=\"#\">3.1 Twitter-Snowflake</a></li>\n<li><a href=\"#\">3.2 Instagram SnowFlake</a></li>\n<li><a href=\"#\">3.3 Simpleflake</a></li>\n<li><a href=\"#\">3.4 Boundary flake</a></li>\n<li><a href=\"#\">3.5 自己的想法</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 参考文章</a></li>\n<li><a href=\"#\">草稿</a></li>\n</ul>\n<p>在日常开发中，数据库的id是不可少的。在各个场景下会有不同的选择，本文对互联网上常见的ID算法进行归纳，希望对工程师们有一点点帮助。</p>\n<h1 id=\"1-数据库自增\"><a href=\"#1-数据库自增\" class=\"headerlink\" title=\"1. 数据库自增\"></a>1. 数据库自增</h1><ol>\n<li>MySQL、Oracle、PGSQL等关系数据库的id主键自增</li>\n<li>Redis、Memcached等K/V数据库的incr操作自增<ul>\n<li>需要考虑持久化的问题</li>\n</ul>\n</li>\n<li>MongoDB自己维护一个id自增集合<ul>\n<li>MongoDB的Update操作支持incr操作，因此可以这么做。</li>\n<li>该方式适用于支持该操作的其他数据库。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"2-类UUID算法\"><a href=\"#2-类UUID算法\" class=\"headerlink\" title=\"2. 类UUID算法\"></a>2. 类UUID算法</h1><ol>\n<li>UUID</li>\n<li>MongoDB的ObjectId</li>\n</ol>\n<h1 id=\"3-SnowFlake\"><a href=\"#3-SnowFlake\" class=\"headerlink\" title=\"3. SnowFlake\"></a>3. SnowFlake</h1><h2 id=\"3-1-Twitter-Snowflake\"><a href=\"#3-1-Twitter-Snowflake\" class=\"headerlink\" title=\"3.1 Twitter-Snowflake\"></a>3.1 Twitter-Snowflake</h2><blockquote>\n<p> Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。</p>\n</blockquote>\n<p>64bits从左往右依次是</p>\n<ul>\n<li>1bit 保留</li>\n<li>41bits 时间戳<ul>\n<li>支持69.7年需要的id。2 ^41 /365/24/60/60/1000=69.7</li>\n</ul>\n</li>\n<li>10bits work-id<ul>\n<li>支持1024个work</li>\n</ul>\n</li>\n<li>12bits sequence-id<ul>\n<li>支持每work每毫秒4096个id</li>\n<li>支持每work每秒4096000个id</li>\n<li>若当前毫秒超过4096，则sleep1毫秒，获取下一毫秒的自增</li>\n</ul>\n</li>\n</ul>\n<p><strong> snowflake的意义，不仅仅在于提供了解决方式，更多的是一种基于Long长度实现具有时间相关性的id自增序列。因此，很多公司基于它进行二次改造适应自己的场景 </strong></p>\n<h2 id=\"3-2-Instagram-SnowFlake\"><a href=\"#3-2-Instagram-SnowFlake\" class=\"headerlink\" title=\"3.2 Instagram SnowFlake\"></a>3.2 Instagram SnowFlake</h2><p>去中性化，基于PGSQL实现</p>\n<p>64bits从左至右依次是</p>\n<ul>\n<li>41bits 时间戳</li>\n<li>13bits logic-shard-id</li>\n<li>10bits sequence-id</li>\n</ul>\n<p>实现方式</p>\n<ul>\n<li>根据<code>share-key</code>获取对应的PGSQL实例-库</li>\n<li>id使用PGSQL的存储过程</li>\n<li>13bits = <code>share-key对应值%logic-share-id</code> </li>\n<li>10bits = <code>该Table的auto_increment_id%(2 ^10)</code></li>\n</ul>\n<p>好处</p>\n<ul>\n<li>去中性化</li>\n<li>根据id可以获得对应PGSQL实例-库</li>\n</ul>\n<h2 id=\"3-3-Simpleflake\"><a href=\"#3-3-Simpleflake\" class=\"headerlink\" title=\"3.3 Simpleflake\"></a>3.3 Simpleflake</h2><p>64bits</p>\n<ul>\n<li>去中性化</li>\n<li>将work-id的12bits给sequence-id。完全随机，每毫秒有1/(2^22 )出现冲突的情况。数据量大时需要注意。</li>\n<li>未来可以平滑迁移到Twitter SnowFlake</li>\n</ul>\n<h2 id=\"3-4-Boundary-flake\"><a href=\"#3-4-Boundary-flake\" class=\"headerlink\" title=\"3.4 Boundary flake\"></a>3.4 Boundary flake</h2><p>去中性化，基于erlang实现<br>128bits从左到右依次是</p>\n<ul>\n<li>64bits 时间戳<ul>\n<li>和毫秒时间戳等长</li>\n</ul>\n</li>\n<li>48bits work-id<ul>\n<li>和mac地址等长，使用时要避免相同mac多个进程</li>\n</ul>\n</li>\n<li>14bits sequence-id</li>\n</ul>\n<h2 id=\"3-5-自己的想法\"><a href=\"#3-5-自己的想法\" class=\"headerlink\" title=\"3.5 自己的想法\"></a>3.5 自己的想法</h2><p><strong><em>参考Instagram SnowFlake的做法</em></strong></p>\n<p>去中心化，基于redis实现<br>64bits从左到右依次是</p>\n<ul>\n<li>1bit 保留</li>\n<li>41bits 时间戳</li>\n<li>12bits 基于logic-shard-id</li>\n<li>10bits 基于时间戳+logic-shard-id在redis里自增</li>\n</ul>\n<h1 id=\"4-参考文章\"><a href=\"#4-参考文章\" class=\"headerlink\" title=\"4. 参考文章\"></a>4. 参考文章</h1><ol>\n<li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNjE3ODQ4NQ==&amp;mid=2650896366&amp;idx=1&amp;sn=5d5acdf323df2b6d581249b32031ccd7&amp;scene=1&amp;srcid=0618GuDjWjenr7TacVTFj6VU#rd\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">互联网分布式id生成方法|msup微课干货</a></li>\n<li><a href=\"http://calvin1978.blogcn.com/articles/uuid.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">服务化框架－分布式Unique ID的生成方法一览</a></li>\n<li><a href=\"https://www.google.co.jp/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&amp;oq=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&amp;aqs=chrome..69i57.291j0j1&amp;sourceid=chrome&amp;ie=UTF-8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">分布式系统中 Unique ID 的生成方法</a></li>\n</ol>\n<h1 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h1><ol>\n<li>2实例、4分表</li>\n</ol>\n<ul>\n<li>a：0<em>2</em>4*6</li>\n<li>b：1<em>3</em>5*7</li>\n</ul>\n<ol>\n<li>4实例、4分表</li>\n</ol>\n<ul>\n<li>a：0<em>4</em>8*12</li>\n<li>b：1<em>5</em>9*13</li>\n<li>c：2<em>6</em>10*14</li>\n<li>d：3<em>7</em>11*15</li>\n</ul>\n<p>扩展方式：</p>\n<ul>\n<li>a与c双主〈a c〉</li>\n<li>b与d双主〈b d〉</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Architecture/talk-about-global-id/\">http://www.yunai.me/Architecture/talk-about-global-id/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 数据库自增</a></li>\n<li><a href=\"#\">2. 类UUID算法</a></li>\n<li><a href=\"#\">3. SnowFlake</a><ul>\n<li><a href=\"#\">3.1 Twitter-Snowflake</a></li>\n<li><a href=\"#\">3.2 Instagram SnowFlake</a></li>\n<li><a href=\"#\">3.3 Simpleflake</a></li>\n<li><a href=\"#\">3.4 Boundary flake</a></li>\n<li><a href=\"#\">3.5 自己的想法</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 参考文章</a></li>\n<li><a href=\"#\">草稿</a></li>\n</ul>\n<p>在日常开发中，数据库的id是不可少的。在各个场景下会有不同的选择，本文对互联网上常见的ID算法进行归纳，希望对工程师们有一点点帮助。</p>\n<h1 id=\"1-数据库自增\"><a href=\"#1-数据库自增\" class=\"headerlink\" title=\"1. 数据库自增\"></a>1. 数据库自增</h1><ol>\n<li>MySQL、Oracle、PGSQL等关系数据库的id主键自增</li>\n<li>Redis、Memcached等K/V数据库的incr操作自增<ul>\n<li>需要考虑持久化的问题</li>\n</ul>\n</li>\n<li>MongoDB自己维护一个id自增集合<ul>\n<li>MongoDB的Update操作支持incr操作，因此可以这么做。</li>\n<li>该方式适用于支持该操作的其他数据库。</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"2-类UUID算法\"><a href=\"#2-类UUID算法\" class=\"headerlink\" title=\"2. 类UUID算法\"></a>2. 类UUID算法</h1><ol>\n<li>UUID</li>\n<li>MongoDB的ObjectId</li>\n</ol>\n<h1 id=\"3-SnowFlake\"><a href=\"#3-SnowFlake\" class=\"headerlink\" title=\"3. SnowFlake\"></a>3. SnowFlake</h1><h2 id=\"3-1-Twitter-Snowflake\"><a href=\"#3-1-Twitter-Snowflake\" class=\"headerlink\" title=\"3.1 Twitter-Snowflake\"></a>3.1 Twitter-Snowflake</h2><blockquote>\n<p> Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。</p>\n</blockquote>\n<p>64bits从左往右依次是</p>\n<ul>\n<li>1bit 保留</li>\n<li>41bits 时间戳<ul>\n<li>支持69.7年需要的id。2 ^41 /365/24/60/60/1000=69.7</li>\n</ul>\n</li>\n<li>10bits work-id<ul>\n<li>支持1024个work</li>\n</ul>\n</li>\n<li>12bits sequence-id<ul>\n<li>支持每work每毫秒4096个id</li>\n<li>支持每work每秒4096000个id</li>\n<li>若当前毫秒超过4096，则sleep1毫秒，获取下一毫秒的自增</li>\n</ul>\n</li>\n</ul>\n<p><strong> snowflake的意义，不仅仅在于提供了解决方式，更多的是一种基于Long长度实现具有时间相关性的id自增序列。因此，很多公司基于它进行二次改造适应自己的场景 </strong></p>\n<h2 id=\"3-2-Instagram-SnowFlake\"><a href=\"#3-2-Instagram-SnowFlake\" class=\"headerlink\" title=\"3.2 Instagram SnowFlake\"></a>3.2 Instagram SnowFlake</h2><p>去中性化，基于PGSQL实现</p>\n<p>64bits从左至右依次是</p>\n<ul>\n<li>41bits 时间戳</li>\n<li>13bits logic-shard-id</li>\n<li>10bits sequence-id</li>\n</ul>\n<p>实现方式</p>\n<ul>\n<li>根据<code>share-key</code>获取对应的PGSQL实例-库</li>\n<li>id使用PGSQL的存储过程</li>\n<li>13bits = <code>share-key对应值%logic-share-id</code> </li>\n<li>10bits = <code>该Table的auto_increment_id%(2 ^10)</code></li>\n</ul>\n<p>好处</p>\n<ul>\n<li>去中性化</li>\n<li>根据id可以获得对应PGSQL实例-库</li>\n</ul>\n<h2 id=\"3-3-Simpleflake\"><a href=\"#3-3-Simpleflake\" class=\"headerlink\" title=\"3.3 Simpleflake\"></a>3.3 Simpleflake</h2><p>64bits</p>\n<ul>\n<li>去中性化</li>\n<li>将work-id的12bits给sequence-id。完全随机，每毫秒有1/(2^22 )出现冲突的情况。数据量大时需要注意。</li>\n<li>未来可以平滑迁移到Twitter SnowFlake</li>\n</ul>\n<h2 id=\"3-4-Boundary-flake\"><a href=\"#3-4-Boundary-flake\" class=\"headerlink\" title=\"3.4 Boundary flake\"></a>3.4 Boundary flake</h2><p>去中性化，基于erlang实现<br>128bits从左到右依次是</p>\n<ul>\n<li>64bits 时间戳<ul>\n<li>和毫秒时间戳等长</li>\n</ul>\n</li>\n<li>48bits work-id<ul>\n<li>和mac地址等长，使用时要避免相同mac多个进程</li>\n</ul>\n</li>\n<li>14bits sequence-id</li>\n</ul>\n<h2 id=\"3-5-自己的想法\"><a href=\"#3-5-自己的想法\" class=\"headerlink\" title=\"3.5 自己的想法\"></a>3.5 自己的想法</h2><p><strong><em>参考Instagram SnowFlake的做法</em></strong></p>\n<p>去中心化，基于redis实现<br>64bits从左到右依次是</p>\n<ul>\n<li>1bit 保留</li>\n<li>41bits 时间戳</li>\n<li>12bits 基于logic-shard-id</li>\n<li>10bits 基于时间戳+logic-shard-id在redis里自增</li>\n</ul>\n<h1 id=\"4-参考文章\"><a href=\"#4-参考文章\" class=\"headerlink\" title=\"4. 参考文章\"></a>4. 参考文章</h1><ol>\n<li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNjE3ODQ4NQ==&amp;mid=2650896366&amp;idx=1&amp;sn=5d5acdf323df2b6d581249b32031ccd7&amp;scene=1&amp;srcid=0618GuDjWjenr7TacVTFj6VU#rd\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">互联网分布式id生成方法|msup微课干货</a></li>\n<li><a href=\"http://calvin1978.blogcn.com/articles/uuid.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">服务化框架－分布式Unique ID的生成方法一览</a></li>\n<li><a href=\"https://www.google.co.jp/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&amp;oq=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD+Unique+ID+%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&amp;aqs=chrome..69i57.291j0j1&amp;sourceid=chrome&amp;ie=UTF-8\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">分布式系统中 Unique ID 的生成方法</a></li>\n</ol>\n<h1 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h1><ol>\n<li>2实例、4分表</li>\n</ol>\n<ul>\n<li>a：0<em>2</em>4*6</li>\n<li>b：1<em>3</em>5*7</li>\n</ul>\n<ol>\n<li>4实例、4分表</li>\n</ol>\n<ul>\n<li>a：0<em>4</em>8*12</li>\n<li>b：1<em>5</em>9*13</li>\n<li>c：2<em>6</em>10*14</li>\n<li>d：3<em>7</em>11*15</li>\n</ul>\n<p>扩展方式：</p>\n<ul>\n<li>a与c双主〈a c〉</li>\n<li>b与d双主〈b d〉</li>\n</ul>\n"},{"title":"Docker 网络 —— Flannel 配置","date":"2017-02-03T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/Docker/docker-network-flannel//](http://www.yunai.me/Docker/docker-network-flannel//)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\ntodo flannel简介\n\n## A. 安装Etcd\n\n😉网络上一大抄，我相信你能找到。\n\n##B. 安装Flannel\n\n基于CentOS 7.2\n\n### 1. 下载Flannel\n\n\n```\n$ mkdir /root/work/flannel -p\n$ cd /root/work/flannel\n$ wget https://github.com/coreos/flannel/releases/download/v0.7.0/flannel-v0.7.0-linux-amd64.tar.gz\n$ tar -zxvf flannel-v0.7.0-linux-amd64.tar.gz\n$ ls -ls\n```\n    \n结果：![](http://www.yunai.me/images/Docker/2017_02_04/00AD067C-53F7-43EF-A8CA-F77CD72471BA.png)    \n    \n### 2. 启动Flannel\n\n\n```\n$ nohup ./flanneld -etcd-endpoints=http://10.29.76.96:2379 &  \n# 说明：http://10.29.76.96:2379 为etcd请求地址，需要改成你自己的噢\n$ cat /run/flannel/subnet.env\n```\n\n结果：![](http://www.yunai.me/images/Docker/2017_02_04/D7087C8C-E6D7-408E-A088-3517E454A592.png)    \n\nps：重要！重要！重要！目前该方式仅仅用于测试，如果正式使用，请将Flannel配置到Systemd。\n\n### 3. 配置Docker\n\n* Docker版本：Docker version 1.12.5, build 047e51b/1.12.5\n* Docker安装方式：yum\n\n**该步骤可能Docker安装方式不同，配置方式不同。目的是修改Docker的bip、mtu。**\n\n```\n$ vi /etc/sysconfig/docker-network \n# 说明：DOCKER_NETWORK_OPTIONS=' --bip=10.1.77.1/24 --mtu=1472 ' \n# 说明：bip为subnet.env里的FLANNEL_SUBNET，mtu为subnet.env里的FLANNEL_MTU\n$ systemctl daemon-reload\n$ systemctl restart docker\n$ ifconfig docker0\n$ ifconfig flannel0\n```\n\n结果：![](http://www.yunai.me/images/Docker/2017_02_04/3B5B0FEC-E65D-4D02-87FD-70C443952845.png)\n\n### 4. 验证网络是否通畅 \n\n* 节点1：ip=10.1.97.1/24\n* 节点2：ip=10.1.77.1/24\n\n节点1：\n\n```\n$ docker run -it --rm ubuntu\n# 假设ip为10.1.97.2\n```\n\n节点2:\n\n```\n$ docker run -it --rm ubuntu\n# 假设ip为10.1.77.2\n$ apt-get update\n$ apt-get install iputils-ping\n$ ping 10.1.97.2\n# ping通即配置成功！\n```\n\n## C. 原理\n\n1. [浅析flannel与docker结合的机制和原理](https://xuxinkun.github.io/2016/07/18/flannel-docker/)\n2. [DockOne技术分享（十八）：一篇文章带你了解Flannel](http://dockone.io/article/618)\n\n## D. 性能\n\n* ![](http://www.yunai.me/images/Docker/2017_02_04/F7429465-2334-48C6-B84E-4C7FC735F5F9.png)\n（来自文章[干货|你想要的百分点大规模Kubernetes集群的应用实践来了](http://mp.weixin.qq.com/s?__biz=MjM5MzI5NjY2MA==&mid=2653782073&idx=1&sn=6db70559acabae67e35e13af7883e1d5&chksm=bd4018428a37915415ffda36c4f9f5e31088063ef3ad83e325d3e4ecd4eccf8d202709ac9629&mpshare=1&scene=1&srcid=0203g7cy4y9XpVhqA9fr5PGp#rd)）\n\n* ![](http://www.yunai.me/images/Docker/2017_02_04/0BF283C9-C26C-46C1-9BDA-604EAD67B2E2.png)\n（来自文章[Weave is kinda slow](http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）\n\n* [Docker或Kubernets的网络模型](http://www.do1618.com/archives/869)\n\n* [Kubernets,Flannel,Docker网络性能深度测试](http://pangxiekr.com/kubernetsflannel-wang-luo-xing-neng-ce-shi-ji-diao-you/)\n\n总结的话：host-gw > vxlan > udp。\nkubernetes在阿里云已经有host-gw + vpc的支持。\n\n## E. 碰到的问题\n1. Flannel刚安装好，配置完Docker后，启动的Container无法被ping通，而Docker0的IP可以被ping通。\n    TODO: 已解决，但是原因未知。目前猜测Kubernetes可能对Flannel第一次初始化有些影响。\n    * 新开一台服务器，重新安装并进行配置(yum安装docker1.12版本），未重现该情况。出问题的机子都安装过Kubernetes。\n    * 在出问题的机子上使用`tcpdump -i flannel0`，命令行输出了`01:57:55.680586 IP 10.1.77.0 > 10.1.11.2: ICMP echo request, id 12091, seq 514, length 64`。可以得出网络本身应该是通的，但是未进行响应。进入Container，`tcpdump -i eth0`，未输出任何东西。得出结论：`flannel0`未将ping转到Container。\n    * 关闭有问题机子的Kubernetes相关的服务。重启启动Container，结果可以ping通了。此时重启服务器，结果这个时候，即使Kubernetes启动着，依然可以ping通。好怪T T。\n    \n\n\n## F. 参考文章列表\n\n1. [Dokcer 使用 Flannel 跨主机通讯](https://mritd.me/2016/09/03/Dokcer-%E4%BD%BF%E7%94%A8-Flannel-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E8%AE%AF/)\n2. [kubernetes入门1：kubernetes+flannel+etcd环境搭建(通用安装)](http://zdevops.blog.51cto.com/2579684/1735492)\n3. [用 Flannel 配置 Kubernetes 网络](http://dockone.io/article/1186)\n\n\n","source":"_posts/Docker/2017_02_04_Docker网络——Flannel配置.md","raw":"title: Docker 网络 —— Flannel 配置\ndate: 2017-02-04\ntags:\ncategories: Docker\npermalink: Docker/docker-network-flannel\n\n-------\n\n>  原文地址：[http://www.yunai.me/Docker/docker-network-flannel//](http://www.yunai.me/Docker/docker-network-flannel//)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\ntodo flannel简介\n\n## A. 安装Etcd\n\n😉网络上一大抄，我相信你能找到。\n\n##B. 安装Flannel\n\n基于CentOS 7.2\n\n### 1. 下载Flannel\n\n\n```\n$ mkdir /root/work/flannel -p\n$ cd /root/work/flannel\n$ wget https://github.com/coreos/flannel/releases/download/v0.7.0/flannel-v0.7.0-linux-amd64.tar.gz\n$ tar -zxvf flannel-v0.7.0-linux-amd64.tar.gz\n$ ls -ls\n```\n    \n结果：![](http://www.yunai.me/images/Docker/2017_02_04/00AD067C-53F7-43EF-A8CA-F77CD72471BA.png)    \n    \n### 2. 启动Flannel\n\n\n```\n$ nohup ./flanneld -etcd-endpoints=http://10.29.76.96:2379 &  \n# 说明：http://10.29.76.96:2379 为etcd请求地址，需要改成你自己的噢\n$ cat /run/flannel/subnet.env\n```\n\n结果：![](http://www.yunai.me/images/Docker/2017_02_04/D7087C8C-E6D7-408E-A088-3517E454A592.png)    \n\nps：重要！重要！重要！目前该方式仅仅用于测试，如果正式使用，请将Flannel配置到Systemd。\n\n### 3. 配置Docker\n\n* Docker版本：Docker version 1.12.5, build 047e51b/1.12.5\n* Docker安装方式：yum\n\n**该步骤可能Docker安装方式不同，配置方式不同。目的是修改Docker的bip、mtu。**\n\n```\n$ vi /etc/sysconfig/docker-network \n# 说明：DOCKER_NETWORK_OPTIONS=' --bip=10.1.77.1/24 --mtu=1472 ' \n# 说明：bip为subnet.env里的FLANNEL_SUBNET，mtu为subnet.env里的FLANNEL_MTU\n$ systemctl daemon-reload\n$ systemctl restart docker\n$ ifconfig docker0\n$ ifconfig flannel0\n```\n\n结果：![](http://www.yunai.me/images/Docker/2017_02_04/3B5B0FEC-E65D-4D02-87FD-70C443952845.png)\n\n### 4. 验证网络是否通畅 \n\n* 节点1：ip=10.1.97.1/24\n* 节点2：ip=10.1.77.1/24\n\n节点1：\n\n```\n$ docker run -it --rm ubuntu\n# 假设ip为10.1.97.2\n```\n\n节点2:\n\n```\n$ docker run -it --rm ubuntu\n# 假设ip为10.1.77.2\n$ apt-get update\n$ apt-get install iputils-ping\n$ ping 10.1.97.2\n# ping通即配置成功！\n```\n\n## C. 原理\n\n1. [浅析flannel与docker结合的机制和原理](https://xuxinkun.github.io/2016/07/18/flannel-docker/)\n2. [DockOne技术分享（十八）：一篇文章带你了解Flannel](http://dockone.io/article/618)\n\n## D. 性能\n\n* ![](http://www.yunai.me/images/Docker/2017_02_04/F7429465-2334-48C6-B84E-4C7FC735F5F9.png)\n（来自文章[干货|你想要的百分点大规模Kubernetes集群的应用实践来了](http://mp.weixin.qq.com/s?__biz=MjM5MzI5NjY2MA==&mid=2653782073&idx=1&sn=6db70559acabae67e35e13af7883e1d5&chksm=bd4018428a37915415ffda36c4f9f5e31088063ef3ad83e325d3e4ecd4eccf8d202709ac9629&mpshare=1&scene=1&srcid=0203g7cy4y9XpVhqA9fr5PGp#rd)）\n\n* ![](http://www.yunai.me/images/Docker/2017_02_04/0BF283C9-C26C-46C1-9BDA-604EAD67B2E2.png)\n（来自文章[Weave is kinda slow](http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）\n\n* [Docker或Kubernets的网络模型](http://www.do1618.com/archives/869)\n\n* [Kubernets,Flannel,Docker网络性能深度测试](http://pangxiekr.com/kubernetsflannel-wang-luo-xing-neng-ce-shi-ji-diao-you/)\n\n总结的话：host-gw > vxlan > udp。\nkubernetes在阿里云已经有host-gw + vpc的支持。\n\n## E. 碰到的问题\n1. Flannel刚安装好，配置完Docker后，启动的Container无法被ping通，而Docker0的IP可以被ping通。\n    TODO: 已解决，但是原因未知。目前猜测Kubernetes可能对Flannel第一次初始化有些影响。\n    * 新开一台服务器，重新安装并进行配置(yum安装docker1.12版本），未重现该情况。出问题的机子都安装过Kubernetes。\n    * 在出问题的机子上使用`tcpdump -i flannel0`，命令行输出了`01:57:55.680586 IP 10.1.77.0 > 10.1.11.2: ICMP echo request, id 12091, seq 514, length 64`。可以得出网络本身应该是通的，但是未进行响应。进入Container，`tcpdump -i eth0`，未输出任何东西。得出结论：`flannel0`未将ping转到Container。\n    * 关闭有问题机子的Kubernetes相关的服务。重启启动Container，结果可以ping通了。此时重启服务器，结果这个时候，即使Kubernetes启动着，依然可以ping通。好怪T T。\n    \n\n\n## F. 参考文章列表\n\n1. [Dokcer 使用 Flannel 跨主机通讯](https://mritd.me/2016/09/03/Dokcer-%E4%BD%BF%E7%94%A8-Flannel-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E8%AE%AF/)\n2. [kubernetes入门1：kubernetes+flannel+etcd环境搭建(通用安装)](http://zdevops.blog.51cto.com/2579684/1735492)\n3. [用 Flannel 配置 Kubernetes 网络](http://dockone.io/article/1186)\n\n\n","slug":"Docker/docker-network-flannel","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9p0003ag5duhiuiqhu","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Docker/docker-network-flannel//\">http://www.yunai.me/Docker/docker-network-flannel//</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<p>todo flannel简介</p>\n<h2 id=\"A-安装Etcd\"><a href=\"#A-安装Etcd\" class=\"headerlink\" title=\"A. 安装Etcd\"></a>A. 安装Etcd</h2><p>😉网络上一大抄，我相信你能找到。</p>\n<p>##B. 安装Flannel</p>\n<p>基于CentOS 7.2</p>\n<h3 id=\"1-下载Flannel\"><a href=\"#1-下载Flannel\" class=\"headerlink\" title=\"1. 下载Flannel\"></a>1. 下载Flannel</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ mkdir /root/work/flannel -p</div><div class=\"line\">$ cd /root/work/flannel</div><div class=\"line\">$ wget https://github.com/coreos/flannel/releases/download/v0.7.0/flannel-v0.7.0-linux-amd64.tar.gz</div><div class=\"line\">$ tar -zxvf flannel-v0.7.0-linux-amd64.tar.gz</div><div class=\"line\">$ ls -ls</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/00AD067C-53F7-43EF-A8CA-F77CD72471BA.png\" alt=\"\">    </p>\n<h3 id=\"2-启动Flannel\"><a href=\"#2-启动Flannel\" class=\"headerlink\" title=\"2. 启动Flannel\"></a>2. 启动Flannel</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nohup ./flanneld -etcd-endpoints=http://10.29.76.96:2379 &amp;  </div><div class=\"line\"># 说明：http://10.29.76.96:2379 为etcd请求地址，需要改成你自己的噢</div><div class=\"line\">$ cat /run/flannel/subnet.env</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/D7087C8C-E6D7-408E-A088-3517E454A592.png\" alt=\"\">    </p>\n<p>ps：重要！重要！重要！目前该方式仅仅用于测试，如果正式使用，请将Flannel配置到Systemd。</p>\n<h3 id=\"3-配置Docker\"><a href=\"#3-配置Docker\" class=\"headerlink\" title=\"3. 配置Docker\"></a>3. 配置Docker</h3><ul>\n<li>Docker版本：Docker version 1.12.5, build 047e51b/1.12.5</li>\n<li>Docker安装方式：yum</li>\n</ul>\n<p><strong>该步骤可能Docker安装方式不同，配置方式不同。目的是修改Docker的bip、mtu。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vi /etc/sysconfig/docker-network </div><div class=\"line\"># 说明：DOCKER_NETWORK_OPTIONS=&apos; --bip=10.1.77.1/24 --mtu=1472 &apos; </div><div class=\"line\"># 说明：bip为subnet.env里的FLANNEL_SUBNET，mtu为subnet.env里的FLANNEL_MTU</div><div class=\"line\">$ systemctl daemon-reload</div><div class=\"line\">$ systemctl restart docker</div><div class=\"line\">$ ifconfig docker0</div><div class=\"line\">$ ifconfig flannel0</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/3B5B0FEC-E65D-4D02-87FD-70C443952845.png\" alt=\"\"></p>\n<h3 id=\"4-验证网络是否通畅\"><a href=\"#4-验证网络是否通畅\" class=\"headerlink\" title=\"4. 验证网络是否通畅\"></a>4. 验证网络是否通畅</h3><ul>\n<li>节点1：ip=10.1.97.1/24</li>\n<li>节点2：ip=10.1.77.1/24</li>\n</ul>\n<p>节点1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ docker run -it --rm ubuntu</div><div class=\"line\"># 假设ip为10.1.97.2</div></pre></td></tr></table></figure>\n<p>节点2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ docker run -it --rm ubuntu</div><div class=\"line\"># 假设ip为10.1.77.2</div><div class=\"line\">$ apt-get update</div><div class=\"line\">$ apt-get install iputils-ping</div><div class=\"line\">$ ping 10.1.97.2</div><div class=\"line\"># ping通即配置成功！</div></pre></td></tr></table></figure>\n<h2 id=\"C-原理\"><a href=\"#C-原理\" class=\"headerlink\" title=\"C. 原理\"></a>C. 原理</h2><ol>\n<li><a href=\"https://xuxinkun.github.io/2016/07/18/flannel-docker/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">浅析flannel与docker结合的机制和原理</a></li>\n<li><a href=\"http://dockone.io/article/618\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DockOne技术分享（十八）：一篇文章带你了解Flannel</a></li>\n</ol>\n<h2 id=\"D-性能\"><a href=\"#D-性能\" class=\"headerlink\" title=\"D. 性能\"></a>D. 性能</h2><ul>\n<li><p><img src=\"http://www.yunai.me/images/Docker/2017_02_04/F7429465-2334-48C6-B84E-4C7FC735F5F9.png\" alt=\"\"><br>（来自文章<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MzI5NjY2MA==&amp;mid=2653782073&amp;idx=1&amp;sn=6db70559acabae67e35e13af7883e1d5&amp;chksm=bd4018428a37915415ffda36c4f9f5e31088063ef3ad83e325d3e4ecd4eccf8d202709ac9629&amp;mpshare=1&amp;scene=1&amp;srcid=0203g7cy4y9XpVhqA9fr5PGp#rd\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">干货|你想要的百分点大规模Kubernetes集群的应用实践来了</a>）</p>\n</li>\n<li><p><img src=\"http://www.yunai.me/images/Docker/2017_02_04/0BF283C9-C26C-46C1-9BDA-604EAD67B2E2.png\" alt=\"\"><br>（来自文章[Weave is kinda slow](<a href=\"http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）</a></p>\n</li>\n<li><p><a href=\"http://www.do1618.com/archives/869\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Docker或Kubernets的网络模型</a></p>\n</li>\n<li><p><a href=\"http://pangxiekr.com/kubernetsflannel-wang-luo-xing-neng-ce-shi-ji-diao-you/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Kubernets,Flannel,Docker网络性能深度测试</a></p>\n</li>\n</ul>\n<p>总结的话：host-gw &gt; vxlan &gt; udp。<br>kubernetes在阿里云已经有host-gw + vpc的支持。</p>\n<h2 id=\"E-碰到的问题\"><a href=\"#E-碰到的问题\" class=\"headerlink\" title=\"E. 碰到的问题\"></a>E. 碰到的问题</h2><ol>\n<li>Flannel刚安装好，配置完Docker后，启动的Container无法被ping通，而Docker0的IP可以被ping通。<br> TODO: 已解决，但是原因未知。目前猜测Kubernetes可能对Flannel第一次初始化有些影响。<ul>\n<li>新开一台服务器，重新安装并进行配置(yum安装docker1.12版本），未重现该情况。出问题的机子都安装过Kubernetes。</li>\n<li>在出问题的机子上使用<code>tcpdump -i flannel0</code>，命令行输出了<code>01:57:55.680586 IP 10.1.77.0 &gt; 10.1.11.2: ICMP echo request, id 12091, seq 514, length 64</code>。可以得出网络本身应该是通的，但是未进行响应。进入Container，<code>tcpdump -i eth0</code>，未输出任何东西。得出结论：<code>flannel0</code>未将ping转到Container。</li>\n<li>关闭有问题机子的Kubernetes相关的服务。重启启动Container，结果可以ping通了。此时重启服务器，结果这个时候，即使Kubernetes启动着，依然可以ping通。好怪T T。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"F-参考文章列表\"><a href=\"#F-参考文章列表\" class=\"headerlink\" title=\"F. 参考文章列表\"></a>F. 参考文章列表</h2><ol>\n<li><a href=\"https://mritd.me/2016/09/03/Dokcer-%E4%BD%BF%E7%94%A8-Flannel-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E8%AE%AF/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Dokcer 使用 Flannel 跨主机通讯</a></li>\n<li><a href=\"http://zdevops.blog.51cto.com/2579684/1735492\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">kubernetes入门1：kubernetes+flannel+etcd环境搭建(通用安装)</a></li>\n<li><a href=\"http://dockone.io/article/1186\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">用 Flannel 配置 Kubernetes 网络</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Docker/docker-network-flannel//\">http://www.yunai.me/Docker/docker-network-flannel//</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<p>todo flannel简介</p>\n<h2 id=\"A-安装Etcd\"><a href=\"#A-安装Etcd\" class=\"headerlink\" title=\"A. 安装Etcd\"></a>A. 安装Etcd</h2><p>😉网络上一大抄，我相信你能找到。</p>\n<p>##B. 安装Flannel</p>\n<p>基于CentOS 7.2</p>\n<h3 id=\"1-下载Flannel\"><a href=\"#1-下载Flannel\" class=\"headerlink\" title=\"1. 下载Flannel\"></a>1. 下载Flannel</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ mkdir /root/work/flannel -p</div><div class=\"line\">$ cd /root/work/flannel</div><div class=\"line\">$ wget https://github.com/coreos/flannel/releases/download/v0.7.0/flannel-v0.7.0-linux-amd64.tar.gz</div><div class=\"line\">$ tar -zxvf flannel-v0.7.0-linux-amd64.tar.gz</div><div class=\"line\">$ ls -ls</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/00AD067C-53F7-43EF-A8CA-F77CD72471BA.png\" alt=\"\">    </p>\n<h3 id=\"2-启动Flannel\"><a href=\"#2-启动Flannel\" class=\"headerlink\" title=\"2. 启动Flannel\"></a>2. 启动Flannel</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ nohup ./flanneld -etcd-endpoints=http://10.29.76.96:2379 &amp;  </div><div class=\"line\"># 说明：http://10.29.76.96:2379 为etcd请求地址，需要改成你自己的噢</div><div class=\"line\">$ cat /run/flannel/subnet.env</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/D7087C8C-E6D7-408E-A088-3517E454A592.png\" alt=\"\">    </p>\n<p>ps：重要！重要！重要！目前该方式仅仅用于测试，如果正式使用，请将Flannel配置到Systemd。</p>\n<h3 id=\"3-配置Docker\"><a href=\"#3-配置Docker\" class=\"headerlink\" title=\"3. 配置Docker\"></a>3. 配置Docker</h3><ul>\n<li>Docker版本：Docker version 1.12.5, build 047e51b/1.12.5</li>\n<li>Docker安装方式：yum</li>\n</ul>\n<p><strong>该步骤可能Docker安装方式不同，配置方式不同。目的是修改Docker的bip、mtu。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vi /etc/sysconfig/docker-network </div><div class=\"line\"># 说明：DOCKER_NETWORK_OPTIONS=&apos; --bip=10.1.77.1/24 --mtu=1472 &apos; </div><div class=\"line\"># 说明：bip为subnet.env里的FLANNEL_SUBNET，mtu为subnet.env里的FLANNEL_MTU</div><div class=\"line\">$ systemctl daemon-reload</div><div class=\"line\">$ systemctl restart docker</div><div class=\"line\">$ ifconfig docker0</div><div class=\"line\">$ ifconfig flannel0</div></pre></td></tr></table></figure>\n<p>结果：<img src=\"http://www.yunai.me/images/Docker/2017_02_04/3B5B0FEC-E65D-4D02-87FD-70C443952845.png\" alt=\"\"></p>\n<h3 id=\"4-验证网络是否通畅\"><a href=\"#4-验证网络是否通畅\" class=\"headerlink\" title=\"4. 验证网络是否通畅\"></a>4. 验证网络是否通畅</h3><ul>\n<li>节点1：ip=10.1.97.1/24</li>\n<li>节点2：ip=10.1.77.1/24</li>\n</ul>\n<p>节点1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ docker run -it --rm ubuntu</div><div class=\"line\"># 假设ip为10.1.97.2</div></pre></td></tr></table></figure>\n<p>节点2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ docker run -it --rm ubuntu</div><div class=\"line\"># 假设ip为10.1.77.2</div><div class=\"line\">$ apt-get update</div><div class=\"line\">$ apt-get install iputils-ping</div><div class=\"line\">$ ping 10.1.97.2</div><div class=\"line\"># ping通即配置成功！</div></pre></td></tr></table></figure>\n<h2 id=\"C-原理\"><a href=\"#C-原理\" class=\"headerlink\" title=\"C. 原理\"></a>C. 原理</h2><ol>\n<li><a href=\"https://xuxinkun.github.io/2016/07/18/flannel-docker/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">浅析flannel与docker结合的机制和原理</a></li>\n<li><a href=\"http://dockone.io/article/618\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DockOne技术分享（十八）：一篇文章带你了解Flannel</a></li>\n</ol>\n<h2 id=\"D-性能\"><a href=\"#D-性能\" class=\"headerlink\" title=\"D. 性能\"></a>D. 性能</h2><ul>\n<li><p><img src=\"http://www.yunai.me/images/Docker/2017_02_04/F7429465-2334-48C6-B84E-4C7FC735F5F9.png\" alt=\"\"><br>（来自文章<a href=\"http://mp.weixin.qq.com/s?__biz=MjM5MzI5NjY2MA==&amp;mid=2653782073&amp;idx=1&amp;sn=6db70559acabae67e35e13af7883e1d5&amp;chksm=bd4018428a37915415ffda36c4f9f5e31088063ef3ad83e325d3e4ecd4eccf8d202709ac9629&amp;mpshare=1&amp;scene=1&amp;srcid=0203g7cy4y9XpVhqA9fr5PGp#rd\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">干货|你想要的百分点大规模Kubernetes集群的应用实践来了</a>）</p>\n</li>\n<li><p><img src=\"http://www.yunai.me/images/Docker/2017_02_04/0BF283C9-C26C-46C1-9BDA-604EAD67B2E2.png\" alt=\"\"><br>（来自文章[Weave is kinda slow](<a href=\"http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://www.generictestdomain.net/docker/weave/networking/stupidity/2015/04/05/weave-is-kinda-slow/）</a></p>\n</li>\n<li><p><a href=\"http://www.do1618.com/archives/869\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Docker或Kubernets的网络模型</a></p>\n</li>\n<li><p><a href=\"http://pangxiekr.com/kubernetsflannel-wang-luo-xing-neng-ce-shi-ji-diao-you/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Kubernets,Flannel,Docker网络性能深度测试</a></p>\n</li>\n</ul>\n<p>总结的话：host-gw &gt; vxlan &gt; udp。<br>kubernetes在阿里云已经有host-gw + vpc的支持。</p>\n<h2 id=\"E-碰到的问题\"><a href=\"#E-碰到的问题\" class=\"headerlink\" title=\"E. 碰到的问题\"></a>E. 碰到的问题</h2><ol>\n<li>Flannel刚安装好，配置完Docker后，启动的Container无法被ping通，而Docker0的IP可以被ping通。<br> TODO: 已解决，但是原因未知。目前猜测Kubernetes可能对Flannel第一次初始化有些影响。<ul>\n<li>新开一台服务器，重新安装并进行配置(yum安装docker1.12版本），未重现该情况。出问题的机子都安装过Kubernetes。</li>\n<li>在出问题的机子上使用<code>tcpdump -i flannel0</code>，命令行输出了<code>01:57:55.680586 IP 10.1.77.0 &gt; 10.1.11.2: ICMP echo request, id 12091, seq 514, length 64</code>。可以得出网络本身应该是通的，但是未进行响应。进入Container，<code>tcpdump -i eth0</code>，未输出任何东西。得出结论：<code>flannel0</code>未将ping转到Container。</li>\n<li>关闭有问题机子的Kubernetes相关的服务。重启启动Container，结果可以ping通了。此时重启服务器，结果这个时候，即使Kubernetes启动着，依然可以ping通。好怪T T。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"F-参考文章列表\"><a href=\"#F-参考文章列表\" class=\"headerlink\" title=\"F. 参考文章列表\"></a>F. 参考文章列表</h2><ol>\n<li><a href=\"https://mritd.me/2016/09/03/Dokcer-%E4%BD%BF%E7%94%A8-Flannel-%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E8%AE%AF/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Dokcer 使用 Flannel 跨主机通讯</a></li>\n<li><a href=\"http://zdevops.blog.51cto.com/2579684/1735492\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">kubernetes入门1：kubernetes+flannel+etcd环境搭建(通用安装)</a></li>\n<li><a href=\"http://dockone.io/article/1186\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">用 Flannel 配置 Kubernetes 网络</a></li>\n</ol>\n"},{"title":"为什么阅读 MyCAT 源码？","date":"2017-05-21T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/](http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## 为什么阅读 MyCAT 源码？\n\n* 深入了解**数据库中间件** ，知其然知其所以然。\n* NIO 的实现 与 Netty 有什么特殊的地方？\n* 分布式事务如何实现的？\n* 内存管理\n* SQL 解析\n* 等等\n\n## 步骤\n\n* [ ] NIO\n* [ ] 分布式事务\n* [ ] 分表\n* [ ] 分库 50%\n* [ ] 自增序列 30%\n* [ ] 单库任意 Join Doing\n* [ ] 跨库2表 Join Doing\n* [ ] 跨库多表 Join\n* [ ] SQL 解析\n* [ ] 读写分离\n* [ ] MySQL 主从\n* [ ] 自动故障切换\n* [ ] Galera Cluster 集群\n* [ ] MHA 集群\n* [ ] Percona 集群\n* [ ] 服务降级\n* [ ] 多租户\n* [ ] 路由\n* [ ] MyCAT 集群\n* [ ] 注解\n* [ ] 内存管理 20%\n* [ ] 缓存\n* [ ] 监控\n* [ ] Mongodb\n* [ ] 数据聚合 30% \n* [ ] 数据排序 25%\n* [ ] PreparedStatement","source":"_posts/MyCAT/2017_05_22_为什么阅读MyCAT源码？.md","raw":"title: 为什么阅读 MyCAT 源码？\ndate: 2017-05-22\ntags:\ncategories: MyCAT\npermalink: MyCAT/why-read-MyCAT-source-code\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/](http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## 为什么阅读 MyCAT 源码？\n\n* 深入了解**数据库中间件** ，知其然知其所以然。\n* NIO 的实现 与 Netty 有什么特殊的地方？\n* 分布式事务如何实现的？\n* 内存管理\n* SQL 解析\n* 等等\n\n## 步骤\n\n* [ ] NIO\n* [ ] 分布式事务\n* [ ] 分表\n* [ ] 分库 50%\n* [ ] 自增序列 30%\n* [ ] 单库任意 Join Doing\n* [ ] 跨库2表 Join Doing\n* [ ] 跨库多表 Join\n* [ ] SQL 解析\n* [ ] 读写分离\n* [ ] MySQL 主从\n* [ ] 自动故障切换\n* [ ] Galera Cluster 集群\n* [ ] MHA 集群\n* [ ] Percona 集群\n* [ ] 服务降级\n* [ ] 多租户\n* [ ] 路由\n* [ ] MyCAT 集群\n* [ ] 注解\n* [ ] 内存管理 20%\n* [ ] 缓存\n* [ ] 监控\n* [ ] Mongodb\n* [ ] 数据聚合 30% \n* [ ] 数据排序 25%\n* [ ] PreparedStatement","slug":"MyCAT/why-read-MyCAT-source-code","published":1,"updated":"2017-06-15T18:51:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9r0004ag5daq7uhkcu","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/\">http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"为什么阅读-MyCAT-源码？\"><a href=\"#为什么阅读-MyCAT-源码？\" class=\"headerlink\" title=\"为什么阅读 MyCAT 源码？\"></a>为什么阅读 MyCAT 源码？</h2><ul>\n<li>深入了解<strong>数据库中间件</strong> ，知其然知其所以然。</li>\n<li>NIO 的实现 与 Netty 有什么特殊的地方？</li>\n<li>分布式事务如何实现的？</li>\n<li>内存管理</li>\n<li>SQL 解析</li>\n<li>等等</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>[ ] NIO</li>\n<li>[ ] 分布式事务</li>\n<li>[ ] 分表</li>\n<li>[ ] 分库 50%</li>\n<li>[ ] 自增序列 30%</li>\n<li>[ ] 单库任意 Join Doing</li>\n<li>[ ] 跨库2表 Join Doing</li>\n<li>[ ] 跨库多表 Join</li>\n<li>[ ] SQL 解析</li>\n<li>[ ] 读写分离</li>\n<li>[ ] MySQL 主从</li>\n<li>[ ] 自动故障切换</li>\n<li>[ ] Galera Cluster 集群</li>\n<li>[ ] MHA 集群</li>\n<li>[ ] Percona 集群</li>\n<li>[ ] 服务降级</li>\n<li>[ ] 多租户</li>\n<li>[ ] 路由</li>\n<li>[ ] MyCAT 集群</li>\n<li>[ ] 注解</li>\n<li>[ ] 内存管理 20%</li>\n<li>[ ] 缓存</li>\n<li>[ ] 监控</li>\n<li>[ ] Mongodb</li>\n<li>[ ] 数据聚合 30% </li>\n<li>[ ] 数据排序 25%</li>\n<li>[ ] PreparedStatement</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/\">http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"为什么阅读-MyCAT-源码？\"><a href=\"#为什么阅读-MyCAT-源码？\" class=\"headerlink\" title=\"为什么阅读 MyCAT 源码？\"></a>为什么阅读 MyCAT 源码？</h2><ul>\n<li>深入了解<strong>数据库中间件</strong> ，知其然知其所以然。</li>\n<li>NIO 的实现 与 Netty 有什么特殊的地方？</li>\n<li>分布式事务如何实现的？</li>\n<li>内存管理</li>\n<li>SQL 解析</li>\n<li>等等</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>[ ] NIO</li>\n<li>[ ] 分布式事务</li>\n<li>[ ] 分表</li>\n<li>[ ] 分库 50%</li>\n<li>[ ] 自增序列 30%</li>\n<li>[ ] 单库任意 Join Doing</li>\n<li>[ ] 跨库2表 Join Doing</li>\n<li>[ ] 跨库多表 Join</li>\n<li>[ ] SQL 解析</li>\n<li>[ ] 读写分离</li>\n<li>[ ] MySQL 主从</li>\n<li>[ ] 自动故障切换</li>\n<li>[ ] Galera Cluster 集群</li>\n<li>[ ] MHA 集群</li>\n<li>[ ] Percona 集群</li>\n<li>[ ] 服务降级</li>\n<li>[ ] 多租户</li>\n<li>[ ] 路由</li>\n<li>[ ] MyCAT 集群</li>\n<li>[ ] 注解</li>\n<li>[ ] 内存管理 20%</li>\n<li>[ ] 缓存</li>\n<li>[ ] 监控</li>\n<li>[ ] Mongodb</li>\n<li>[ ] 数据聚合 30% </li>\n<li>[ ] 数据排序 25%</li>\n<li>[ ] PreparedStatement</li>\n</ul>\n"},{"title":"MyCAT 源码分析 —— 调试环境搭建","date":"2017-05-22T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/build-debugging-environment/](http://www.yunai.me/MyCAT/build-debugging-environment/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 依赖工具](#)\n- [2. 源码拉取](#)\n- [3. 数据库配置](#)\n- [4. MyCat 配置](#)\n- [5. MyCAT 启动](#)\n- [6. MyCAT 测试](#)\n- [7. 交流](#)\n\n# 1. 依赖工具\n\n* Maven\n* Git\n* JDK\n* MySQL\n* IntelliJ IDEA\n\n# 2. 源码拉取\n\n从官方仓库 [https://github.com/MyCATApache/Mycat-Server](https://github.com/MyCATApache/Mycat-Server) `Fork` 出属于自己的仓库。为什么要 `Fork` ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈\n\n使用 `IntelliJ IDEA` 从 `Fork` 出来的仓库拉取代码。拉取完成后，`Maven` 会下载依赖包，可能会花费一些时间，耐心等待下。\n\n# 3. 数据库配置\n\n我们要搭建的是**非分片表**的调试环境，需要创建一个数据库和表：\n\n1. 创建数据库：`db01` 。\n2. 创建数据库表：`travelrecord` 。\n\n```SQL\nCREATE TABLE `travelrecord` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET latin1 DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COLLATE=utf8_bin\n```\n\n# 4. MyCAT 配置\n\n为了避免对实现源码产生影响，我们选择对 `test` 目录做变更。\n\n1、在 `resources` 目录下新建文件夹 `backups` ，将原 `resources` 下的所有文件移到 `backups` 下，这样我们的环境就干干净了。  \n2、在 `resources` 目录下新建 `schema.xml` 文件，配置 `MyCAT` 的逻辑库、表、数据节点、数据源。\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE mycat:schema SYSTEM \"schema.dtd\">\n<mycat:schema xmlns:mycat=\"http://io.mycat/\">\n\n    <schema name=\"dbtest\" checkSQLschema=\"true\" sqlMaxLimit=\"100\">\n        <table name=\"travelrecord\" dataNode=\"dn1\" autoIncrement=\"true\" primaryKey=\"id\" />\n    </schema>\n\n\t<dataNode name=\"dn1\" dataHost=\"localhost1\" database=\"db1\" />\n\n\t<dataHost name=\"localhost1\" maxCon=\"1000\" minCon=\"10\" balance=\"0\"\n\t\t\t  writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\" slaveThreshold=\"100\">\n\t\t<heartbeat>select user()</heartbeat>\n\t\t<writeHost host=\"hostM1\" url=\"127.0.0.1:33061\" user=\"root\" password=\"123456\"> <!-- ‼️‼️‼️ url、user、password 设置成你的数据库 -->\n\t\t</writeHost>\n\t</dataHost>\n\n</mycat:schema>\n```\n\n3、在 `resources` 目录下新建 `server.xml` 文件，配置 `MyCAT` 系统配置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mycat:server SYSTEM \"server.dtd\">\n<mycat:server xmlns:mycat=\"http://io.mycat/\">\n\t<system>\n        <property name=\"nonePasswordLogin\">0</property> <!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户-->\n        <property name=\"useHandshakeV10\">1</property>\n        <property name=\"useSqlStat\">0</property>  <!-- 1为开启实时统计、0为关闭 -->\n        <property name=\"useGlobleTableCheck\">0</property>  <!-- 1为开启全加班一致性检测、0为关闭 -->\n\t\t<property name=\"sequnceHandlerType\">2</property>\n\t\t<property name=\"processorBufferPoolType\">0</property>\n\t\t<property name=\"handleDistributedTransactions\">0</property>\n\t\t<property name=\"useOffHeapForMerge\">1</property>\n        <property name=\"memoryPageSize\">64k</property>\n\t\t<property name=\"spillsFileBufferSize\">1k</property>\n\t\t<property name=\"useStreamOutput\">0</property>\n\t\t<property name=\"systemReserveMemorySize\">384m</property>\n\t\t<property name=\"useZKSwitch\">false</property>\n\t</system>\n\n\t<user name=\"root\" defaultAccount=\"true\">\n\t\t<property name=\"password\">123456</property>\n\t\t<property name=\"schemas\">dbtest</property>\n\t</user>\n\n</mycat:server>\n```\n\n# 5. MyCAT 启动\n\n1、在 `java` 目录下新建 `debugger` 包，和原先已存在的包做区分。  \n2、在 `debbuger` 包下新建 `MycatStartupTest.java` ：\n\n```Java\npackage debugger;\n\nimport io.mycat.MycatStartup;\n\n/**\n * {@link io.mycat.MycatStartup}测试\n *\n * Created by yunai on 2017/5/22.\n */\npublic class MycatStartupTest {\n\n    public static void main(String[] args) {\n        MycatStartup.main(args);\n    }\n\n}\n```\n\n3、运行 `MycatStartupTest.java` ，当看到输出日志 `MyCAT Server startup successfully. see logs in logs/mycat.log` 即为启动成功。\n\n截止目前，`test` 目录如下：\n\n![test目录.png](http://www.yunai.me/images/MyCAT/2017_05_23/01.png)\n\n# 6. MyCAT 测试\n\n调试环境已经搭建完成，我们看看是否正确。\n\n使用 `MySQL` 客户端连接 `MyCAT` ：\n\n* HOST ：127.0.0.1\n* PORT ：8066\n* USERNAME ：root\n* PASSWORD ：123456\n\n```SQL\nmysql> insert into travelrecord(name) values ('haha');\nQuery OK, 1 rows affected (0.01 sec)\n\nmysql> select * from travelrecord;\n+--------------------+------+\n| id                 | name |\n+--------------------+------+\n| 866707181398003712 | haha |\n+--------------------+------+\n1 rows in set (0.05 sec)\n```\n\n成功。😈😈😈\n\n# 7. 交流\n\n感谢阅读、收藏、关注。  \n**知其然知其所以然。学习 MyCAT 会是一段很愉快的旅程。如果有你的交流，相信会更加愉快。欢迎添加微信：`wangwenbin-server` 进行探讨。**\n\n\n","source":"_posts/MyCAT/2017_05_23_MyCAT源码分析——调试环境搭建.md","raw":"title: MyCAT 源码分析 —— 调试环境搭建\ndate: 2017-05-23\ntags:\ncategories: MyCAT\npermalink: MyCAT/build-debugging-environment\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/build-debugging-environment/](http://www.yunai.me/MyCAT/build-debugging-environment/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 依赖工具](#)\n- [2. 源码拉取](#)\n- [3. 数据库配置](#)\n- [4. MyCat 配置](#)\n- [5. MyCAT 启动](#)\n- [6. MyCAT 测试](#)\n- [7. 交流](#)\n\n# 1. 依赖工具\n\n* Maven\n* Git\n* JDK\n* MySQL\n* IntelliJ IDEA\n\n# 2. 源码拉取\n\n从官方仓库 [https://github.com/MyCATApache/Mycat-Server](https://github.com/MyCATApache/Mycat-Server) `Fork` 出属于自己的仓库。为什么要 `Fork` ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈\n\n使用 `IntelliJ IDEA` 从 `Fork` 出来的仓库拉取代码。拉取完成后，`Maven` 会下载依赖包，可能会花费一些时间，耐心等待下。\n\n# 3. 数据库配置\n\n我们要搭建的是**非分片表**的调试环境，需要创建一个数据库和表：\n\n1. 创建数据库：`db01` 。\n2. 创建数据库表：`travelrecord` 。\n\n```SQL\nCREATE TABLE `travelrecord` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET latin1 DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COLLATE=utf8_bin\n```\n\n# 4. MyCAT 配置\n\n为了避免对实现源码产生影响，我们选择对 `test` 目录做变更。\n\n1、在 `resources` 目录下新建文件夹 `backups` ，将原 `resources` 下的所有文件移到 `backups` 下，这样我们的环境就干干净了。  \n2、在 `resources` 目录下新建 `schema.xml` 文件，配置 `MyCAT` 的逻辑库、表、数据节点、数据源。\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE mycat:schema SYSTEM \"schema.dtd\">\n<mycat:schema xmlns:mycat=\"http://io.mycat/\">\n\n    <schema name=\"dbtest\" checkSQLschema=\"true\" sqlMaxLimit=\"100\">\n        <table name=\"travelrecord\" dataNode=\"dn1\" autoIncrement=\"true\" primaryKey=\"id\" />\n    </schema>\n\n\t<dataNode name=\"dn1\" dataHost=\"localhost1\" database=\"db1\" />\n\n\t<dataHost name=\"localhost1\" maxCon=\"1000\" minCon=\"10\" balance=\"0\"\n\t\t\t  writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\" slaveThreshold=\"100\">\n\t\t<heartbeat>select user()</heartbeat>\n\t\t<writeHost host=\"hostM1\" url=\"127.0.0.1:33061\" user=\"root\" password=\"123456\"> <!-- ‼️‼️‼️ url、user、password 设置成你的数据库 -->\n\t\t</writeHost>\n\t</dataHost>\n\n</mycat:schema>\n```\n\n3、在 `resources` 目录下新建 `server.xml` 文件，配置 `MyCAT` 系统配置。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mycat:server SYSTEM \"server.dtd\">\n<mycat:server xmlns:mycat=\"http://io.mycat/\">\n\t<system>\n        <property name=\"nonePasswordLogin\">0</property> <!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户-->\n        <property name=\"useHandshakeV10\">1</property>\n        <property name=\"useSqlStat\">0</property>  <!-- 1为开启实时统计、0为关闭 -->\n        <property name=\"useGlobleTableCheck\">0</property>  <!-- 1为开启全加班一致性检测、0为关闭 -->\n\t\t<property name=\"sequnceHandlerType\">2</property>\n\t\t<property name=\"processorBufferPoolType\">0</property>\n\t\t<property name=\"handleDistributedTransactions\">0</property>\n\t\t<property name=\"useOffHeapForMerge\">1</property>\n        <property name=\"memoryPageSize\">64k</property>\n\t\t<property name=\"spillsFileBufferSize\">1k</property>\n\t\t<property name=\"useStreamOutput\">0</property>\n\t\t<property name=\"systemReserveMemorySize\">384m</property>\n\t\t<property name=\"useZKSwitch\">false</property>\n\t</system>\n\n\t<user name=\"root\" defaultAccount=\"true\">\n\t\t<property name=\"password\">123456</property>\n\t\t<property name=\"schemas\">dbtest</property>\n\t</user>\n\n</mycat:server>\n```\n\n# 5. MyCAT 启动\n\n1、在 `java` 目录下新建 `debugger` 包，和原先已存在的包做区分。  \n2、在 `debbuger` 包下新建 `MycatStartupTest.java` ：\n\n```Java\npackage debugger;\n\nimport io.mycat.MycatStartup;\n\n/**\n * {@link io.mycat.MycatStartup}测试\n *\n * Created by yunai on 2017/5/22.\n */\npublic class MycatStartupTest {\n\n    public static void main(String[] args) {\n        MycatStartup.main(args);\n    }\n\n}\n```\n\n3、运行 `MycatStartupTest.java` ，当看到输出日志 `MyCAT Server startup successfully. see logs in logs/mycat.log` 即为启动成功。\n\n截止目前，`test` 目录如下：\n\n![test目录.png](http://www.yunai.me/images/MyCAT/2017_05_23/01.png)\n\n# 6. MyCAT 测试\n\n调试环境已经搭建完成，我们看看是否正确。\n\n使用 `MySQL` 客户端连接 `MyCAT` ：\n\n* HOST ：127.0.0.1\n* PORT ：8066\n* USERNAME ：root\n* PASSWORD ：123456\n\n```SQL\nmysql> insert into travelrecord(name) values ('haha');\nQuery OK, 1 rows affected (0.01 sec)\n\nmysql> select * from travelrecord;\n+--------------------+------+\n| id                 | name |\n+--------------------+------+\n| 866707181398003712 | haha |\n+--------------------+------+\n1 rows in set (0.05 sec)\n```\n\n成功。😈😈😈\n\n# 7. 交流\n\n感谢阅读、收藏、关注。  \n**知其然知其所以然。学习 MyCAT 会是一段很愉快的旅程。如果有你的交流，相信会更加愉快。欢迎添加微信：`wangwenbin-server` 进行探讨。**\n\n\n","slug":"MyCAT/build-debugging-environment","published":1,"updated":"2017-06-14T15:32:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9w0005ag5d7sh61b7t","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/build-debugging-environment/\">http://www.yunai.me/MyCAT/build-debugging-environment/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 依赖工具</a></li>\n<li><a href=\"#\">2. 源码拉取</a></li>\n<li><a href=\"#\">3. 数据库配置</a></li>\n<li><a href=\"#\">4. MyCat 配置</a></li>\n<li><a href=\"#\">5. MyCAT 启动</a></li>\n<li><a href=\"#\">6. MyCAT 测试</a></li>\n<li><a href=\"#\">7. 交流</a></li>\n</ul>\n<h1 id=\"1-依赖工具\"><a href=\"#1-依赖工具\" class=\"headerlink\" title=\"1. 依赖工具\"></a>1. 依赖工具</h1><ul>\n<li>Maven</li>\n<li>Git</li>\n<li>JDK</li>\n<li>MySQL</li>\n<li>IntelliJ IDEA</li>\n</ul>\n<h1 id=\"2-源码拉取\"><a href=\"#2-源码拉取\" class=\"headerlink\" title=\"2. 源码拉取\"></a>2. 源码拉取</h1><p>从官方仓库 <a href=\"https://github.com/MyCATApache/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/MyCATApache/Mycat-Server</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p>\n<p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p>\n<h1 id=\"3-数据库配置\"><a href=\"#3-数据库配置\" class=\"headerlink\" title=\"3. 数据库配置\"></a>3. 数据库配置</h1><p>我们要搭建的是<strong>非分片表</strong>的调试环境，需要创建一个数据库和表：</p>\n<ol>\n<li>创建数据库：<code>db01</code> 。</li>\n<li>创建数据库表：<code>travelrecord</code> 。</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`travelrecord`</span> (</div><div class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</div><div class=\"line\">  <span class=\"string\">`name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"built_in\">CHARACTER</span> <span class=\"keyword\">SET</span> latin1 <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</div><div class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</div><div class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8 <span class=\"keyword\">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure>\n<h1 id=\"4-MyCAT-配置\"><a href=\"#4-MyCAT-配置\" class=\"headerlink\" title=\"4. MyCAT 配置\"></a>4. MyCAT 配置</h1><p>为了避免对实现源码产生影响，我们选择对 <code>test</code> 目录做变更。</p>\n<p>1、在 <code>resources</code> 目录下新建文件夹 <code>backups</code> ，将原 <code>resources</code> 下的所有文件移到 <code>backups</code> 下，这样我们的环境就干干净了。<br>2、在 <code>resources</code> 目录下新建 <code>schema.xml</code> 文件，配置 <code>MyCAT</code> 的逻辑库、表、数据节点、数据源。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mycat:schema SYSTEM \"schema.dtd\"&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mycat:schema</span> <span class=\"attr\">xmlns:mycat</span>=<span class=\"string\">\"http://io.mycat/\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">schema</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dbtest\"</span> <span class=\"attr\">checkSQLschema</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">sqlMaxLimit</span>=<span class=\"string\">\"100\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">name</span>=<span class=\"string\">\"travelrecord\"</span> <span class=\"attr\">dataNode</span>=<span class=\"string\">\"dn1\"</span> <span class=\"attr\">autoIncrement</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">primaryKey</span>=<span class=\"string\">\"id\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">schema</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dataNode</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dn1\"</span> <span class=\"attr\">dataHost</span>=<span class=\"string\">\"localhost1\"</span> <span class=\"attr\">database</span>=<span class=\"string\">\"db1\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dataHost</span> <span class=\"attr\">name</span>=<span class=\"string\">\"localhost1\"</span> <span class=\"attr\">maxCon</span>=<span class=\"string\">\"1000\"</span> <span class=\"attr\">minCon</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">balance</span>=<span class=\"string\">\"0\"</span></span></div><div class=\"line\">\t\t\t  <span class=\"attr\">writeType</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">dbType</span>=<span class=\"string\">\"mysql\"</span> <span class=\"attr\">dbDriver</span>=<span class=\"string\">\"native\"</span> <span class=\"attr\">switchType</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">slaveThreshold</span>=<span class=\"string\">\"100\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">heartbeat</span>&gt;</span>select user()<span class=\"tag\">&lt;/<span class=\"name\">heartbeat</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">writeHost</span> <span class=\"attr\">host</span>=<span class=\"string\">\"hostM1\"</span> <span class=\"attr\">url</span>=<span class=\"string\">\"127.0.0.1:33061\"</span> <span class=\"attr\">user</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"123456\"</span>&gt;</span> <span class=\"comment\">&lt;!-- ‼️‼️‼️ url、user、password 设置成你的数据库 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">writeHost</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dataHost</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mycat:schema</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3、在 <code>resources</code> 目录下新建 <code>server.xml</code> 文件，配置 <code>MyCAT</code> 系统配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mycat:server SYSTEM \"server.dtd\"&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mycat:server</span> <span class=\"attr\">xmlns:mycat</span>=<span class=\"string\">\"http://io.mycat/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">system</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"nonePasswordLogin\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> <span class=\"comment\">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useHandshakeV10\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useSqlStat\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  <span class=\"comment\">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useGlobleTableCheck\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  <span class=\"comment\">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sequnceHandlerType\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"processorBufferPoolType\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"handleDistributedTransactions\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useOffHeapForMerge\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"memoryPageSize\"</span>&gt;</span>64k<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"spillsFileBufferSize\"</span>&gt;</span>1k<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useStreamOutput\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"systemReserveMemorySize\"</span>&gt;</span>384m<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useZKSwitch\"</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">system</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">user</span> <span class=\"attr\">name</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">defaultAccount</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span>123456<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"schemas\"</span>&gt;</span>dbtest<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">user</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mycat:server</span>&gt;</span></div></pre></td></tr></table></figure>\n<h1 id=\"5-MyCAT-启动\"><a href=\"#5-MyCAT-启动\" class=\"headerlink\" title=\"5. MyCAT 启动\"></a>5. MyCAT 启动</h1><p>1、在 <code>java</code> 目录下新建 <code>debugger</code> 包，和原先已存在的包做区分。<br>2、在 <code>debbuger</code> 包下新建 <code>MycatStartupTest.java</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> debugger;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> io.mycat.MycatStartup;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> io.mycat.MycatStartup&#125;测试</div><div class=\"line\"> *</div><div class=\"line\"> * Created by yunai on 2017/5/22.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MycatStartupTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        MycatStartup.main(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、运行 <code>MycatStartupTest.java</code> ，当看到输出日志 <code>MyCAT Server startup successfully. see logs in logs/mycat.log</code> 即为启动成功。</p>\n<p>截止目前，<code>test</code> 目录如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_23/01.png\" alt=\"test目录.png\"></p>\n<h1 id=\"6-MyCAT-测试\"><a href=\"#6-MyCAT-测试\" class=\"headerlink\" title=\"6. MyCAT 测试\"></a>6. MyCAT 测试</h1><p>调试环境已经搭建完成，我们看看是否正确。</p>\n<p>使用 <code>MySQL</code> 客户端连接 <code>MyCAT</code> ：</p>\n<ul>\n<li>HOST ：127.0.0.1</li>\n<li>PORT ：8066</li>\n<li>USERNAME ：root</li>\n<li>PASSWORD ：123456</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">mysql&gt; insert into travelrecord(name) values ('haha');</div><div class=\"line\">Query OK, 1 rows affected (0.01 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; select * from travelrecord;</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">| id                 | name |</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">| 866707181398003712 | haha |</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">1 rows in set (0.05 sec)</div></pre></td></tr></table></figure>\n<p>成功。😈😈😈</p>\n<h1 id=\"7-交流\"><a href=\"#7-交流\" class=\"headerlink\" title=\"7. 交流\"></a>7. 交流</h1><p>感谢阅读、收藏、关注。<br><strong>知其然知其所以然。学习 MyCAT 会是一段很愉快的旅程。如果有你的交流，相信会更加愉快。欢迎添加微信：<code>wangwenbin-server</code> 进行探讨。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/build-debugging-environment/\">http://www.yunai.me/MyCAT/build-debugging-environment/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 依赖工具</a></li>\n<li><a href=\"#\">2. 源码拉取</a></li>\n<li><a href=\"#\">3. 数据库配置</a></li>\n<li><a href=\"#\">4. MyCat 配置</a></li>\n<li><a href=\"#\">5. MyCAT 启动</a></li>\n<li><a href=\"#\">6. MyCAT 测试</a></li>\n<li><a href=\"#\">7. 交流</a></li>\n</ul>\n<h1 id=\"1-依赖工具\"><a href=\"#1-依赖工具\" class=\"headerlink\" title=\"1. 依赖工具\"></a>1. 依赖工具</h1><ul>\n<li>Maven</li>\n<li>Git</li>\n<li>JDK</li>\n<li>MySQL</li>\n<li>IntelliJ IDEA</li>\n</ul>\n<h1 id=\"2-源码拉取\"><a href=\"#2-源码拉取\" class=\"headerlink\" title=\"2. 源码拉取\"></a>2. 源码拉取</h1><p>从官方仓库 <a href=\"https://github.com/MyCATApache/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/MyCATApache/Mycat-Server</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p>\n<p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p>\n<h1 id=\"3-数据库配置\"><a href=\"#3-数据库配置\" class=\"headerlink\" title=\"3. 数据库配置\"></a>3. 数据库配置</h1><p>我们要搭建的是<strong>非分片表</strong>的调试环境，需要创建一个数据库和表：</p>\n<ol>\n<li>创建数据库：<code>db01</code> 。</li>\n<li>创建数据库表：<code>travelrecord</code> 。</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`travelrecord`</span> (</div><div class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</div><div class=\"line\">  <span class=\"string\">`name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"built_in\">CHARACTER</span> <span class=\"keyword\">SET</span> latin1 <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</div><div class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</div><div class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8 <span class=\"keyword\">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure>\n<h1 id=\"4-MyCAT-配置\"><a href=\"#4-MyCAT-配置\" class=\"headerlink\" title=\"4. MyCAT 配置\"></a>4. MyCAT 配置</h1><p>为了避免对实现源码产生影响，我们选择对 <code>test</code> 目录做变更。</p>\n<p>1、在 <code>resources</code> 目录下新建文件夹 <code>backups</code> ，将原 <code>resources</code> 下的所有文件移到 <code>backups</code> 下，这样我们的环境就干干净了。<br>2、在 <code>resources</code> 目录下新建 <code>schema.xml</code> 文件，配置 <code>MyCAT</code> 的逻辑库、表、数据节点、数据源。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mycat:schema SYSTEM \"schema.dtd\"&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mycat:schema</span> <span class=\"attr\">xmlns:mycat</span>=<span class=\"string\">\"http://io.mycat/\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">schema</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dbtest\"</span> <span class=\"attr\">checkSQLschema</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">sqlMaxLimit</span>=<span class=\"string\">\"100\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">name</span>=<span class=\"string\">\"travelrecord\"</span> <span class=\"attr\">dataNode</span>=<span class=\"string\">\"dn1\"</span> <span class=\"attr\">autoIncrement</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">primaryKey</span>=<span class=\"string\">\"id\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">schema</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dataNode</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dn1\"</span> <span class=\"attr\">dataHost</span>=<span class=\"string\">\"localhost1\"</span> <span class=\"attr\">database</span>=<span class=\"string\">\"db1\"</span> /&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dataHost</span> <span class=\"attr\">name</span>=<span class=\"string\">\"localhost1\"</span> <span class=\"attr\">maxCon</span>=<span class=\"string\">\"1000\"</span> <span class=\"attr\">minCon</span>=<span class=\"string\">\"10\"</span> <span class=\"attr\">balance</span>=<span class=\"string\">\"0\"</span></span></div><div class=\"line\">\t\t\t  <span class=\"attr\">writeType</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">dbType</span>=<span class=\"string\">\"mysql\"</span> <span class=\"attr\">dbDriver</span>=<span class=\"string\">\"native\"</span> <span class=\"attr\">switchType</span>=<span class=\"string\">\"1\"</span> <span class=\"attr\">slaveThreshold</span>=<span class=\"string\">\"100\"</span>&gt;</div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">heartbeat</span>&gt;</span>select user()<span class=\"tag\">&lt;/<span class=\"name\">heartbeat</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">writeHost</span> <span class=\"attr\">host</span>=<span class=\"string\">\"hostM1\"</span> <span class=\"attr\">url</span>=<span class=\"string\">\"127.0.0.1:33061\"</span> <span class=\"attr\">user</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">password</span>=<span class=\"string\">\"123456\"</span>&gt;</span> <span class=\"comment\">&lt;!-- ‼️‼️‼️ url、user、password 设置成你的数据库 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">writeHost</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dataHost</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mycat:schema</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>3、在 <code>resources</code> 目录下新建 <code>server.xml</code> 文件，配置 <code>MyCAT</code> 系统配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mycat:server SYSTEM \"server.dtd\"&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mycat:server</span> <span class=\"attr\">xmlns:mycat</span>=<span class=\"string\">\"http://io.mycat/\"</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">system</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"nonePasswordLogin\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span> <span class=\"comment\">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useHandshakeV10\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useSqlStat\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  <span class=\"comment\">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useGlobleTableCheck\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span>  <span class=\"comment\">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sequnceHandlerType\"</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"processorBufferPoolType\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"handleDistributedTransactions\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useOffHeapForMerge\"</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"memoryPageSize\"</span>&gt;</span>64k<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"spillsFileBufferSize\"</span>&gt;</span>1k<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useStreamOutput\"</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"systemReserveMemorySize\"</span>&gt;</span>384m<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"useZKSwitch\"</span>&gt;</span>false<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">system</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">user</span> <span class=\"attr\">name</span>=<span class=\"string\">\"root\"</span> <span class=\"attr\">defaultAccount</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span>123456<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"schemas\"</span>&gt;</span>dbtest<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></div><div class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">user</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mycat:server</span>&gt;</span></div></pre></td></tr></table></figure>\n<h1 id=\"5-MyCAT-启动\"><a href=\"#5-MyCAT-启动\" class=\"headerlink\" title=\"5. MyCAT 启动\"></a>5. MyCAT 启动</h1><p>1、在 <code>java</code> 目录下新建 <code>debugger</code> 包，和原先已存在的包做区分。<br>2、在 <code>debbuger</code> 包下新建 <code>MycatStartupTest.java</code> ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> debugger;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> io.mycat.MycatStartup;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * &#123;<span class=\"doctag\">@link</span> io.mycat.MycatStartup&#125;测试</div><div class=\"line\"> *</div><div class=\"line\"> * Created by yunai on 2017/5/22.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MycatStartupTest</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        MycatStartup.main(args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>3、运行 <code>MycatStartupTest.java</code> ，当看到输出日志 <code>MyCAT Server startup successfully. see logs in logs/mycat.log</code> 即为启动成功。</p>\n<p>截止目前，<code>test</code> 目录如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_23/01.png\" alt=\"test目录.png\"></p>\n<h1 id=\"6-MyCAT-测试\"><a href=\"#6-MyCAT-测试\" class=\"headerlink\" title=\"6. MyCAT 测试\"></a>6. MyCAT 测试</h1><p>调试环境已经搭建完成，我们看看是否正确。</p>\n<p>使用 <code>MySQL</code> 客户端连接 <code>MyCAT</code> ：</p>\n<ul>\n<li>HOST ：127.0.0.1</li>\n<li>PORT ：8066</li>\n<li>USERNAME ：root</li>\n<li>PASSWORD ：123456</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">mysql&gt; insert into travelrecord(name) values ('haha');</div><div class=\"line\">Query OK, 1 rows affected (0.01 sec)</div><div class=\"line\"></div><div class=\"line\">mysql&gt; select * from travelrecord;</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">| id                 | name |</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">| 866707181398003712 | haha |</div><div class=\"line\">+--------------------+------+</div><div class=\"line\">1 rows in set (0.05 sec)</div></pre></td></tr></table></figure>\n<p>成功。😈😈😈</p>\n<h1 id=\"7-交流\"><a href=\"#7-交流\" class=\"headerlink\" title=\"7. 交流\"></a>7. 交流</h1><p>感谢阅读、收藏、关注。<br><strong>知其然知其所以然。学习 MyCAT 会是一段很愉快的旅程。如果有你的交流，相信会更加愉快。欢迎添加微信：<code>wangwenbin-server</code> 进行探讨。</strong></p>\n"},{"title":"MyCAT源码分析——跨库两表Join","date":"2017-07-11T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/sharding-result-merge-first/](http://www.yunai.me/MyCAT/sharding-two-table-join/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n> QQ ：7685413\n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 主流程](#)\n- [3. ShareJoin](#)\n\t- [3.1 JoinParser](#)\n\t- [3.2 ShareJoin.processSQL(...)](#)\n\t- [3.3 BatchSQLJob](#)\n\t- [3.4 ShareDBJoinHandler](#)\n\t- [3.5 ShareRowOutPutDataHandler](#)\n- [4. 彩蛋](#)\n\n-------\n\n# 1. 概述\n\nMyCAT 支持跨库表 Join，目前版本仅支持跨库**两**表 Join。虽然如此，已经能够满足我们大部分的业务场景。况且，Join 过多的表可能带来的性能问题也是很麻烦的。\n\n本文主要分享：\n\n1. 整体流程、调用顺序图\n2. 核心代码的分析\n\n前置阅读：[《MyCAT 源码分析 —— 【单库单表】查询》](http://www.yunai.me/MyCAT/single-db-single-table-select/?yunai)。\n\nOK，Let's Go。\n\n# 2. 主流程\n\n当执行跨库两表 Join SQL 时，经历的大体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/01.png)\n\nSQL 上，需要添加注解 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ ${SQL}` 。`RouteService#route(...)` 解析注解 `mycat:catlet` 后，路由给 `HintCatletHandler` 作进一步处理。\n\n`HintCatletHandler` 获取注解对应的 `Catlet` 实现类，`io.mycat.catlets.ShareJoin` 就是其中一种实现（目前也只有这一种实现），提供了跨库两表 Join 的功能。从类命名上看，`ShareJoin` 很大可能性后续会提供**完整**的跨库多表的 Join 功能。\n\n核心代码如下：\n\n``` Java\n// HintCatletHandler.java\npublic RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,\n                           int sqlType, String realSQL, String charset, ServerConnection sc,\n                           LayerCachePool cachePool, String hintSQLValue, int hintSqlType, Map hintMap)\n       throws SQLNonTransientException {\n   String cateletClass = hintSQLValue;\n   if (LOGGER.isDebugEnabled()) {\n       LOGGER.debug(\"load catelet class:\" + hintSQLValue + \" to run sql \" + realSQL);\n   }\n   try {\n       Catlet catlet = (Catlet) MycatServer.getInstance().getCatletClassLoader().getInstanceofClass(cateletClass);\n       catlet.route(sysConfig, schema, sqlType, realSQL, charset, sc, cachePool);\n       catlet.processSQL(realSQL, new EngineCtx(sc.getSession2()));\n   } catch (Exception e) {\n       LOGGER.warn(\"catlet error \" + e);\n       throw new SQLNonTransientException(e);\n   }\n   return null;\n}\n```\n\n# 3. ShareJoin\n\n目前支持跨库**两**表 Join。`ShareJoin` 将 SQL 拆分成左表 SQL 和 右表 SQL，发送给各数据节点执行，汇总数据结果进行合后返回。\n\n伪代码如下：\n\n```Java\n// SELECT u.id, o.id FROM t_order o \n// INNER JOIN t_user u ON o.uid = u.id\n// 【顺序】查询左表\nString leftSQL = \"SELECT o.id, u.id FROM t_order o\";\nList leftList = dn[0].select(leftSQL) + dn[1].select(leftSQL) + ... + dn[n].select(leftsql);\n// 【并行】查询右表\nString rightSQL = \"SELECT u.id FROM t_user u WHERE u.id IN (${leftList.uid})\";\nfor (dn : dns) { // 此处是并行执行，使用回调逻辑\n    for (rightRecord : dn.select(rightSQL)) { // 查询右表\n        // 合并结果\n        for (leftRecord : leftList) {\n            if (leftRecord.uid == rightRecord.id) {\n                write(leftRecord + leftRecord.uid 拼接结果);\n            }\n        }\n    }\n} \n```\n\n实际情况会更加复杂，我们接下来一点点往下看。\n\n## 3.1 JoinParser\n\n`JoinParser` 负责对 SQL 进行解析。整体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/02.png)\n \n举个例子，`/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 解析后，`TableFilter` 结果如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/03.png)\n\n* tName ：表名\n* tAlia ：表自定义命名\n* where ：过滤条件\n* order ：排序条件\n* parenTable ：左连接的 Join 的表名。`t_user`表 在 `join`属性 的 `parenTable` 为 \"o\"，即 `t_order`。\n* joinParentkey ：左连接的 Join 字段\n* joinKey ：join 字段。`t_user`表 在 `join`属性 为 `id`。\n* join ：子 tableFilter。即，该表连接的右边的表。\n* parent ：和 `join`属性 相对。\n\n看到此处，大家可能有疑问，为什么要把 SQL 解析成 `TableFilter`。`JoinParser` 根据 `TableFilter` 生成数据节点执行 SQL。代码如下：\n\n```Java\n// TableFilter.java\npublic String getSQL() {\n   String sql = \"\";\n   // fields\n   for (Entry<String, String> entry : fieldAliasMap.entrySet()) {\n       String key = entry.getKey();\n       String val = entry.getValue();\n       if (val == null) {\n           sql = unionsql(sql, getFieldfrom(key), \",\");\n       } else {\n           sql = unionsql(sql, getFieldfrom(key) + \" as \" + val, \",\");\n       }\n   }\n   // where\n   if (parent == null) {    // on/where 等于号左边的表\n       String parentJoinKey = getJoinKey(true);\n       // fix sharejoin bug：\n       // (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:\n       // 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误\n       if (sql != null && parentJoinKey != null &&\n               !sql.toUpperCase().contains(parentJoinKey.trim().toUpperCase())) {\n           sql += \", \" + parentJoinKey;\n       }\n       sql = \"select \" + sql + \" from \" + tName;\n       if (!(where.trim().equals(\"\"))) {\n           sql += \" where \" + where.trim();\n       }\n   } else {    // on/where 等于号右边边的表\n       if (allField) {\n           sql = \"select \" + sql + \" from \" + tName;\n       } else {\n           sql = unionField(\"select \" + joinKey, sql, \",\");\n           sql = sql + \" from \" + tName;\n           //sql=\"select \"+joinKey+\",\"+sql+\" from \"+tName;\n       }\n       if (!(where.trim().equals(\"\"))) {\n           sql += \" where \" + where.trim() + \" and (\" + joinKey + \" in %s )\";\n       } else {\n           sql += \" where \" + joinKey + \" in %s \";\n       }\n   }\n   // order\n   if (!(order.trim().equals(\"\"))) {\n       sql += \" order by \" + order.trim();\n   }\n   // limit\n   if (parent == null) {\n       if ((rowCount > 0) && (offset > 0)) {\n           sql += \" limit\" + offset + \",\" + rowCount;\n       } else {\n           if (rowCount > 0) {\n               sql += \" limit \" + rowCount;\n           }\n       }\n   }\n   return sql;\n}\n```\n\n* 当 `parent` 为空时，即**on/where 等于号左边的表**。例如：`select id, uid from t_order`。\n* 当 `parent`  不为空时，即**on/where 等于号右边的表**。例如：`select id, username from t_user where id in (1, 2, 3) `。\n\n## 3.2 ShareJoin.processSQL(...)\n\n当 SQL 解析完后，生成**左边的表**执行的 SQL，发送给对应的数据节点查询数据。大体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/04.png)\n\n当 SQL 为 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 时，\n`sql = getSql()` 的返回结果为 `select id, uid from t_order`。\n\n生成**左边的表**执行的 SQL 后，**顺序顺序顺序**发送给对应的数据节点查询数据。具体顺序查询是怎么实现的，我们来看下章 **BatchSQLJob**。\n\n## 3.3 BatchSQLJob\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/05.png)\n\n`EngineCtx` 对 `BatchSQLJob` 封装，提供上层两个方法：\n\n1. executeNativeSQLSequnceJob ：顺序（非并发）在每个数据节点执行SQL任务\n2. executeNativeSQLParallJob ：并发在每个数据节点执行SQL任务\n\n核心代码如下：\n\n```Java\n// EngineCtx.java\npublic void executeNativeSQLSequnceJob(String[] dataNodes, String sql,\n\t\tSQLJobHandler jobHandler) {\n\tfor (String dataNode : dataNodes) {\n\t\tSQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,\n\t\t\t\tjobHandler, this);\n\t\tbachJob.addJob(job, false);\n\t}\n}\n\npublic void executeNativeSQLParallJob(String[] dataNodes, String sql,\n\t\tSQLJobHandler jobHandler) {\n\tfor (String dataNode : dataNodes) {\n\t\tSQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,\n\t\t\t\tjobHandler, this);\n\t\tbachJob.addJob(job, true);\n\t}\n}\t\n```\n\n-------\n\n`BatchSQLJob` 通过**执行中任务列表**、**待执行任务列表**来实现**顺序/并发**执行任务。核心代码如下：\n\n```Java\n// BatchSQLJob.java\n/**\n* 执行中任务列表\n*/\nprivate ConcurrentHashMap<Integer, SQLJob> runningJobs = new ConcurrentHashMap<Integer, SQLJob>();\n/**\n* 待执行任务列表\n*/\nprivate ConcurrentLinkedQueue<SQLJob> waitingJobs = new ConcurrentLinkedQueue<SQLJob>();\n\npublic void addJob(SQLJob newJob, boolean parallExecute) {\n   if (parallExecute) {\n       runJob(newJob);\n   } else {\n       waitingJobs.offer(newJob);\n       if (runningJobs.isEmpty()) { // 若无正在执行中的任务，则从等待队列里获取任务进行执行。\n           SQLJob job = waitingJobs.poll();\n           if (job != null) {\n               runJob(job);\n           }\n       }\n   }\n}\n\npublic boolean jobFinished(SQLJob sqlJob) {\n\trunningJobs.remove(sqlJob.getId());\n\tSQLJob job = waitingJobs.poll();\n\tif (job != null) {\n\t\trunJob(job);\n\t\treturn false;\n\t} else {\n\t\tif (noMoreJobInput) {\n\t\t\treturn runningJobs.isEmpty() && waitingJobs.isEmpty();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n```\n\n* **顺序**执行时，当 `runningJobs` 存在执行中的任务时，`#addJob(...)` 时，不立即执行，添加到 `waitingJobs`。当 `SQLJob` 完成时，顺序调用下一个任务。\n* **并发**执行时，`#addJob(...)` 时，立即执行。\n\n-------\n\n`SQLJob` SQL 异步执行任务。其 `jobHandler(SQLJobHandler)` 属性，在 SQL 执行有返回结果时，会进行回调，从而实现异步执行。\n\n在 `ShareJoin` 里，`SQLJobHandler` 有两个实现：`ShareDBJoinHandler`、`ShareRowOutPutDataHandler`。前者，**左边的表**执行的 SQL 回调；后者，**右边的表**执行的 SQL 回调。\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/06.png)\n\n## 3.4 ShareDBJoinHandler\n\n`ShareDBJoinHandler`，**左边的表**执行的 SQL 回调。流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/07.png)\n\n* `#fieldEofResponse(...)` ：接收数据节点返回的 fields，放入内存。\n* `#rowResponse(...)` ：接收数据节点返回的 row，放入内存。\n* `#rowEofResponse(...)` ：接收完一个数据节点返回所有的 row。当所有数据节点都完成 SQL 执行时，提交**右边的表**执行的 SQL 任务，**并行**执行，即图中**#createQryJob(...)**。\n\n当 SQL 为 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 时，\n`sql = getChildSQL()` 的返回结果为 `select id, username from t_user where id in (1, 2, 3) `。\n\n核心代码如下：\n\n```Java\n// ShareJoin.java\nprivate void createQryJob(int batchSize) {\n   int count = 0;\n   Map<String, byte[]> batchRows = new ConcurrentHashMap<String, byte[]>();\n   String theId = null;\n   StringBuilder sb = new StringBuilder().append('(');\n   String svalue = \"\";\n   for (Map.Entry<String, String> e : ids.entrySet()) {\n       theId = e.getKey();\n       byte[] rowbyte = rows.remove(theId);\n       if (rowbyte != null) {\n           batchRows.put(theId, rowbyte);\n       }\n       if (!svalue.equals(e.getValue())) {\n           if (joinKeyType == Fields.FIELD_TYPE_VAR_STRING\n                   || joinKeyType == Fields.FIELD_TYPE_STRING) { // joinkey 为varchar\n               sb.append(\"'\").append(e.getValue()).append(\"'\").append(','); // ('digdeep','yuanfang')\n           } else { // 默认joinkey为int/long\n               sb.append(e.getValue()).append(','); // (1,2,3)\n           }\n       }\n       svalue = e.getValue();\n       if (count++ > batchSize) {\n           break;\n       }\n   }\n   if (count == 0) {\n       return;\n   }\n   jointTableIsData = true;\n   sb.deleteCharAt(sb.length() - 1).append(')');\n   String sql = String.format(joinParser.getChildSQL(), sb);\n   getRoute(sql);\n   ctx.executeNativeSQLParallJob(getDataNodes(), sql, new ShareRowOutPutDataHandler(this, fields, joinindex, joinParser.getJoinRkey(), batchRows, ctx.getSession()));\n}\n```\n\n## 3.5 ShareRowOutPutDataHandler\n\n`ShareRowOutPutDataHandler`，**右边的表**执行的 SQL 回调。流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/08.png)\n\n* `#fieldEofResponse(...)` ：接收数据节点返回的 fields，返回 header 给 MySQL Client。\n* `#rowResponse(...)` ：接收数据节点返回的 row，匹配左表的记录，返回合并后返回的 row 给 MySQL Client。\n* `#rowEofResponse(...)` ：当所有 row 都返回完后，返回 eof 给 MySQL Client。\n\n核心代码如下：\n\n```Java\n// ShareRowOutPutDataHandler.java\npublic boolean onRowData(String dataNode, byte[] rowData) {\n   RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);\n   //拷贝一份batchRows\n   Map<String, byte[]> batchRowsCopy = new ConcurrentHashMap<String, byte[]>();\n   batchRowsCopy.putAll(arows);\n   // 获取Id字段，\n   String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));\n   // 查找ID对应的A表的记录\n   byte[] arow = getRow(batchRowsCopy, id, joinL);\n   while (arow != null) {\n       RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow, afields);//ctx.getAllFields());\n       for (int i = 1; i < rowDataPkgold.fieldCount; i++) {\n           // 设置b.name 字段\n           byte[] bname = rowDataPkgold.fieldValues.get(i);\n           rowDataPkg.add(bname);\n           rowDataPkg.addFieldCount(1);\n       }\n       // huangyiming add\n       MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();\n       if (null == middlerResultHandler) {\n           ctx.writeRow(rowDataPkg);\n       } else {\n           if (middlerResultHandler instanceof MiddlerQueryResultHandler) {\n               byte[] columnData = rowDataPkg.fieldValues.get(0);\n               if (columnData != null && columnData.length > 0) {\n                   String rowValue = new String(columnData);\n                   middlerResultHandler.add(rowValue);\n               }\n               //}\n           }\n\n       }\n       arow = getRow(batchRowsCopy, id, joinL);\n   }\n   return false;\n}\n```\n\n# 4. 彩蛋\n\n如下是本文涉及到的核心类，有兴趣的同学可以翻一翻。\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/09.png)\n\n`ShareJoin` 另外不支持的功能：\n\n1. 只支持 inner join，不支持 left join、right join 等等连接。\n2. 不支持 order by。\n3. 不支持 group by 以及 相关聚合函数。\n4. 即使 join 左表的字段未声明为返回 fields 也会返回。\n\n恩，**MyCAT 弱XA** 源码继续走起！\n\n","source":"_posts/MyCAT/2017_07_12_MyCAT源码分析——跨库两表Join.md","raw":"title: MyCAT源码分析——跨库两表Join\ndate: 2017-07-12\ntags:\ncategories: MyCAT\npermalink: MyCAT/sharding-two-table-join\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/sharding-result-merge-first/](http://www.yunai.me/MyCAT/sharding-two-table-join/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n> QQ ：7685413\n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 主流程](#)\n- [3. ShareJoin](#)\n\t- [3.1 JoinParser](#)\n\t- [3.2 ShareJoin.processSQL(...)](#)\n\t- [3.3 BatchSQLJob](#)\n\t- [3.4 ShareDBJoinHandler](#)\n\t- [3.5 ShareRowOutPutDataHandler](#)\n- [4. 彩蛋](#)\n\n-------\n\n# 1. 概述\n\nMyCAT 支持跨库表 Join，目前版本仅支持跨库**两**表 Join。虽然如此，已经能够满足我们大部分的业务场景。况且，Join 过多的表可能带来的性能问题也是很麻烦的。\n\n本文主要分享：\n\n1. 整体流程、调用顺序图\n2. 核心代码的分析\n\n前置阅读：[《MyCAT 源码分析 —— 【单库单表】查询》](http://www.yunai.me/MyCAT/single-db-single-table-select/?yunai)。\n\nOK，Let's Go。\n\n# 2. 主流程\n\n当执行跨库两表 Join SQL 时，经历的大体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/01.png)\n\nSQL 上，需要添加注解 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ ${SQL}` 。`RouteService#route(...)` 解析注解 `mycat:catlet` 后，路由给 `HintCatletHandler` 作进一步处理。\n\n`HintCatletHandler` 获取注解对应的 `Catlet` 实现类，`io.mycat.catlets.ShareJoin` 就是其中一种实现（目前也只有这一种实现），提供了跨库两表 Join 的功能。从类命名上看，`ShareJoin` 很大可能性后续会提供**完整**的跨库多表的 Join 功能。\n\n核心代码如下：\n\n``` Java\n// HintCatletHandler.java\npublic RouteResultset route(SystemConfig sysConfig, SchemaConfig schema,\n                           int sqlType, String realSQL, String charset, ServerConnection sc,\n                           LayerCachePool cachePool, String hintSQLValue, int hintSqlType, Map hintMap)\n       throws SQLNonTransientException {\n   String cateletClass = hintSQLValue;\n   if (LOGGER.isDebugEnabled()) {\n       LOGGER.debug(\"load catelet class:\" + hintSQLValue + \" to run sql \" + realSQL);\n   }\n   try {\n       Catlet catlet = (Catlet) MycatServer.getInstance().getCatletClassLoader().getInstanceofClass(cateletClass);\n       catlet.route(sysConfig, schema, sqlType, realSQL, charset, sc, cachePool);\n       catlet.processSQL(realSQL, new EngineCtx(sc.getSession2()));\n   } catch (Exception e) {\n       LOGGER.warn(\"catlet error \" + e);\n       throw new SQLNonTransientException(e);\n   }\n   return null;\n}\n```\n\n# 3. ShareJoin\n\n目前支持跨库**两**表 Join。`ShareJoin` 将 SQL 拆分成左表 SQL 和 右表 SQL，发送给各数据节点执行，汇总数据结果进行合后返回。\n\n伪代码如下：\n\n```Java\n// SELECT u.id, o.id FROM t_order o \n// INNER JOIN t_user u ON o.uid = u.id\n// 【顺序】查询左表\nString leftSQL = \"SELECT o.id, u.id FROM t_order o\";\nList leftList = dn[0].select(leftSQL) + dn[1].select(leftSQL) + ... + dn[n].select(leftsql);\n// 【并行】查询右表\nString rightSQL = \"SELECT u.id FROM t_user u WHERE u.id IN (${leftList.uid})\";\nfor (dn : dns) { // 此处是并行执行，使用回调逻辑\n    for (rightRecord : dn.select(rightSQL)) { // 查询右表\n        // 合并结果\n        for (leftRecord : leftList) {\n            if (leftRecord.uid == rightRecord.id) {\n                write(leftRecord + leftRecord.uid 拼接结果);\n            }\n        }\n    }\n} \n```\n\n实际情况会更加复杂，我们接下来一点点往下看。\n\n## 3.1 JoinParser\n\n`JoinParser` 负责对 SQL 进行解析。整体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/02.png)\n \n举个例子，`/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 解析后，`TableFilter` 结果如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/03.png)\n\n* tName ：表名\n* tAlia ：表自定义命名\n* where ：过滤条件\n* order ：排序条件\n* parenTable ：左连接的 Join 的表名。`t_user`表 在 `join`属性 的 `parenTable` 为 \"o\"，即 `t_order`。\n* joinParentkey ：左连接的 Join 字段\n* joinKey ：join 字段。`t_user`表 在 `join`属性 为 `id`。\n* join ：子 tableFilter。即，该表连接的右边的表。\n* parent ：和 `join`属性 相对。\n\n看到此处，大家可能有疑问，为什么要把 SQL 解析成 `TableFilter`。`JoinParser` 根据 `TableFilter` 生成数据节点执行 SQL。代码如下：\n\n```Java\n// TableFilter.java\npublic String getSQL() {\n   String sql = \"\";\n   // fields\n   for (Entry<String, String> entry : fieldAliasMap.entrySet()) {\n       String key = entry.getKey();\n       String val = entry.getValue();\n       if (val == null) {\n           sql = unionsql(sql, getFieldfrom(key), \",\");\n       } else {\n           sql = unionsql(sql, getFieldfrom(key) + \" as \" + val, \",\");\n       }\n   }\n   // where\n   if (parent == null) {    // on/where 等于号左边的表\n       String parentJoinKey = getJoinKey(true);\n       // fix sharejoin bug：\n       // (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:\n       // 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误\n       if (sql != null && parentJoinKey != null &&\n               !sql.toUpperCase().contains(parentJoinKey.trim().toUpperCase())) {\n           sql += \", \" + parentJoinKey;\n       }\n       sql = \"select \" + sql + \" from \" + tName;\n       if (!(where.trim().equals(\"\"))) {\n           sql += \" where \" + where.trim();\n       }\n   } else {    // on/where 等于号右边边的表\n       if (allField) {\n           sql = \"select \" + sql + \" from \" + tName;\n       } else {\n           sql = unionField(\"select \" + joinKey, sql, \",\");\n           sql = sql + \" from \" + tName;\n           //sql=\"select \"+joinKey+\",\"+sql+\" from \"+tName;\n       }\n       if (!(where.trim().equals(\"\"))) {\n           sql += \" where \" + where.trim() + \" and (\" + joinKey + \" in %s )\";\n       } else {\n           sql += \" where \" + joinKey + \" in %s \";\n       }\n   }\n   // order\n   if (!(order.trim().equals(\"\"))) {\n       sql += \" order by \" + order.trim();\n   }\n   // limit\n   if (parent == null) {\n       if ((rowCount > 0) && (offset > 0)) {\n           sql += \" limit\" + offset + \",\" + rowCount;\n       } else {\n           if (rowCount > 0) {\n               sql += \" limit \" + rowCount;\n           }\n       }\n   }\n   return sql;\n}\n```\n\n* 当 `parent` 为空时，即**on/where 等于号左边的表**。例如：`select id, uid from t_order`。\n* 当 `parent`  不为空时，即**on/where 等于号右边的表**。例如：`select id, username from t_user where id in (1, 2, 3) `。\n\n## 3.2 ShareJoin.processSQL(...)\n\n当 SQL 解析完后，生成**左边的表**执行的 SQL，发送给对应的数据节点查询数据。大体流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/04.png)\n\n当 SQL 为 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 时，\n`sql = getSql()` 的返回结果为 `select id, uid from t_order`。\n\n生成**左边的表**执行的 SQL 后，**顺序顺序顺序**发送给对应的数据节点查询数据。具体顺序查询是怎么实现的，我们来看下章 **BatchSQLJob**。\n\n## 3.3 BatchSQLJob\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/05.png)\n\n`EngineCtx` 对 `BatchSQLJob` 封装，提供上层两个方法：\n\n1. executeNativeSQLSequnceJob ：顺序（非并发）在每个数据节点执行SQL任务\n2. executeNativeSQLParallJob ：并发在每个数据节点执行SQL任务\n\n核心代码如下：\n\n```Java\n// EngineCtx.java\npublic void executeNativeSQLSequnceJob(String[] dataNodes, String sql,\n\t\tSQLJobHandler jobHandler) {\n\tfor (String dataNode : dataNodes) {\n\t\tSQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,\n\t\t\t\tjobHandler, this);\n\t\tbachJob.addJob(job, false);\n\t}\n}\n\npublic void executeNativeSQLParallJob(String[] dataNodes, String sql,\n\t\tSQLJobHandler jobHandler) {\n\tfor (String dataNode : dataNodes) {\n\t\tSQLJob job = new SQLJob(jobId.incrementAndGet(), sql, dataNode,\n\t\t\t\tjobHandler, this);\n\t\tbachJob.addJob(job, true);\n\t}\n}\t\n```\n\n-------\n\n`BatchSQLJob` 通过**执行中任务列表**、**待执行任务列表**来实现**顺序/并发**执行任务。核心代码如下：\n\n```Java\n// BatchSQLJob.java\n/**\n* 执行中任务列表\n*/\nprivate ConcurrentHashMap<Integer, SQLJob> runningJobs = new ConcurrentHashMap<Integer, SQLJob>();\n/**\n* 待执行任务列表\n*/\nprivate ConcurrentLinkedQueue<SQLJob> waitingJobs = new ConcurrentLinkedQueue<SQLJob>();\n\npublic void addJob(SQLJob newJob, boolean parallExecute) {\n   if (parallExecute) {\n       runJob(newJob);\n   } else {\n       waitingJobs.offer(newJob);\n       if (runningJobs.isEmpty()) { // 若无正在执行中的任务，则从等待队列里获取任务进行执行。\n           SQLJob job = waitingJobs.poll();\n           if (job != null) {\n               runJob(job);\n           }\n       }\n   }\n}\n\npublic boolean jobFinished(SQLJob sqlJob) {\n\trunningJobs.remove(sqlJob.getId());\n\tSQLJob job = waitingJobs.poll();\n\tif (job != null) {\n\t\trunJob(job);\n\t\treturn false;\n\t} else {\n\t\tif (noMoreJobInput) {\n\t\t\treturn runningJobs.isEmpty() && waitingJobs.isEmpty();\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n```\n\n* **顺序**执行时，当 `runningJobs` 存在执行中的任务时，`#addJob(...)` 时，不立即执行，添加到 `waitingJobs`。当 `SQLJob` 完成时，顺序调用下一个任务。\n* **并发**执行时，`#addJob(...)` 时，立即执行。\n\n-------\n\n`SQLJob` SQL 异步执行任务。其 `jobHandler(SQLJobHandler)` 属性，在 SQL 执行有返回结果时，会进行回调，从而实现异步执行。\n\n在 `ShareJoin` 里，`SQLJobHandler` 有两个实现：`ShareDBJoinHandler`、`ShareRowOutPutDataHandler`。前者，**左边的表**执行的 SQL 回调；后者，**右边的表**执行的 SQL 回调。\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/06.png)\n\n## 3.4 ShareDBJoinHandler\n\n`ShareDBJoinHandler`，**左边的表**执行的 SQL 回调。流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/07.png)\n\n* `#fieldEofResponse(...)` ：接收数据节点返回的 fields，放入内存。\n* `#rowResponse(...)` ：接收数据节点返回的 row，放入内存。\n* `#rowEofResponse(...)` ：接收完一个数据节点返回所有的 row。当所有数据节点都完成 SQL 执行时，提交**右边的表**执行的 SQL 任务，**并行**执行，即图中**#createQryJob(...)**。\n\n当 SQL 为 `/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;` 时，\n`sql = getChildSQL()` 的返回结果为 `select id, username from t_user where id in (1, 2, 3) `。\n\n核心代码如下：\n\n```Java\n// ShareJoin.java\nprivate void createQryJob(int batchSize) {\n   int count = 0;\n   Map<String, byte[]> batchRows = new ConcurrentHashMap<String, byte[]>();\n   String theId = null;\n   StringBuilder sb = new StringBuilder().append('(');\n   String svalue = \"\";\n   for (Map.Entry<String, String> e : ids.entrySet()) {\n       theId = e.getKey();\n       byte[] rowbyte = rows.remove(theId);\n       if (rowbyte != null) {\n           batchRows.put(theId, rowbyte);\n       }\n       if (!svalue.equals(e.getValue())) {\n           if (joinKeyType == Fields.FIELD_TYPE_VAR_STRING\n                   || joinKeyType == Fields.FIELD_TYPE_STRING) { // joinkey 为varchar\n               sb.append(\"'\").append(e.getValue()).append(\"'\").append(','); // ('digdeep','yuanfang')\n           } else { // 默认joinkey为int/long\n               sb.append(e.getValue()).append(','); // (1,2,3)\n           }\n       }\n       svalue = e.getValue();\n       if (count++ > batchSize) {\n           break;\n       }\n   }\n   if (count == 0) {\n       return;\n   }\n   jointTableIsData = true;\n   sb.deleteCharAt(sb.length() - 1).append(')');\n   String sql = String.format(joinParser.getChildSQL(), sb);\n   getRoute(sql);\n   ctx.executeNativeSQLParallJob(getDataNodes(), sql, new ShareRowOutPutDataHandler(this, fields, joinindex, joinParser.getJoinRkey(), batchRows, ctx.getSession()));\n}\n```\n\n## 3.5 ShareRowOutPutDataHandler\n\n`ShareRowOutPutDataHandler`，**右边的表**执行的 SQL 回调。流程如下：\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/08.png)\n\n* `#fieldEofResponse(...)` ：接收数据节点返回的 fields，返回 header 给 MySQL Client。\n* `#rowResponse(...)` ：接收数据节点返回的 row，匹配左表的记录，返回合并后返回的 row 给 MySQL Client。\n* `#rowEofResponse(...)` ：当所有 row 都返回完后，返回 eof 给 MySQL Client。\n\n核心代码如下：\n\n```Java\n// ShareRowOutPutDataHandler.java\npublic boolean onRowData(String dataNode, byte[] rowData) {\n   RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);\n   //拷贝一份batchRows\n   Map<String, byte[]> batchRowsCopy = new ConcurrentHashMap<String, byte[]>();\n   batchRowsCopy.putAll(arows);\n   // 获取Id字段，\n   String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));\n   // 查找ID对应的A表的记录\n   byte[] arow = getRow(batchRowsCopy, id, joinL);\n   while (arow != null) {\n       RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow, afields);//ctx.getAllFields());\n       for (int i = 1; i < rowDataPkgold.fieldCount; i++) {\n           // 设置b.name 字段\n           byte[] bname = rowDataPkgold.fieldValues.get(i);\n           rowDataPkg.add(bname);\n           rowDataPkg.addFieldCount(1);\n       }\n       // huangyiming add\n       MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();\n       if (null == middlerResultHandler) {\n           ctx.writeRow(rowDataPkg);\n       } else {\n           if (middlerResultHandler instanceof MiddlerQueryResultHandler) {\n               byte[] columnData = rowDataPkg.fieldValues.get(0);\n               if (columnData != null && columnData.length > 0) {\n                   String rowValue = new String(columnData);\n                   middlerResultHandler.add(rowValue);\n               }\n               //}\n           }\n\n       }\n       arow = getRow(batchRowsCopy, id, joinL);\n   }\n   return false;\n}\n```\n\n# 4. 彩蛋\n\n如下是本文涉及到的核心类，有兴趣的同学可以翻一翻。\n\n![](http://www.yunai.me/images/MyCAT/2017_07_12/09.png)\n\n`ShareJoin` 另外不支持的功能：\n\n1. 只支持 inner join，不支持 left join、right join 等等连接。\n2. 不支持 order by。\n3. 不支持 group by 以及 相关聚合函数。\n4. 即使 join 左表的字段未声明为返回 fields 也会返回。\n\n恩，**MyCAT 弱XA** 源码继续走起！\n\n","slug":"MyCAT/sharding-two-table-join","published":1,"updated":"2017-07-12T17:30:01.000Z","_id":"cj519kz9y0007ag5dv6sgh5qe","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/sharding-two-table-join/\">http://www.yunai.me/MyCAT/sharding-result-merge-first/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong><br>QQ ：7685413</p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 主流程</a></li>\n<li><a href=\"#\">3. ShareJoin</a><ul>\n<li><a href=\"#\">3.1 JoinParser</a></li>\n<li><a href=\"#\">3.2 ShareJoin.processSQL(…)</a></li>\n<li><a href=\"#\">3.3 BatchSQLJob</a></li>\n<li><a href=\"#\">3.4 ShareDBJoinHandler</a></li>\n<li><a href=\"#\">3.5 ShareRowOutPutDataHandler</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 彩蛋</a></li>\n</ul>\n<hr>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>MyCAT 支持跨库表 Join，目前版本仅支持跨库<strong>两</strong>表 Join。虽然如此，已经能够满足我们大部分的业务场景。况且，Join 过多的表可能带来的性能问题也是很麻烦的。</p>\n<p>本文主要分享：</p>\n<ol>\n<li>整体流程、调用顺序图</li>\n<li>核心代码的分析</li>\n</ol>\n<p>前置阅读：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-select/?yunai\">《MyCAT 源码分析 —— 【单库单表】查询》</a>。</p>\n<p>OK，Let’s Go。</p>\n<h1 id=\"2-主流程\"><a href=\"#2-主流程\" class=\"headerlink\" title=\"2. 主流程\"></a>2. 主流程</h1><p>当执行跨库两表 Join SQL 时，经历的大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/01.png\" alt=\"\"></p>\n<p>SQL 上，需要添加注解 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ ${SQL}</code> 。<code>RouteService#route(...)</code> 解析注解 <code>mycat:catlet</code> 后，路由给 <code>HintCatletHandler</code> 作进一步处理。</p>\n<p><code>HintCatletHandler</code> 获取注解对应的 <code>Catlet</code> 实现类，<code>io.mycat.catlets.ShareJoin</code> 就是其中一种实现（目前也只有这一种实现），提供了跨库两表 Join 的功能。从类命名上看，<code>ShareJoin</code> 很大可能性后续会提供<strong>完整</strong>的跨库多表的 Join 功能。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HintCatletHandler.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema,</span></span></div><div class=\"line\">                           <span class=\"keyword\">int</span> sqlType, String realSQL, String charset, ServerConnection sc,</div><div class=\"line\">                           LayerCachePool cachePool, String hintSQLValue, <span class=\"keyword\">int</span> hintSqlType, Map hintMap)</div><div class=\"line\">       <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\">   String cateletClass = hintSQLValue;</div><div class=\"line\">   <span class=\"keyword\">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class=\"line\">       LOGGER.debug(<span class=\"string\">\"load catelet class:\"</span> + hintSQLValue + <span class=\"string\">\" to run sql \"</span> + realSQL);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">       Catlet catlet = (Catlet) MycatServer.getInstance().getCatletClassLoader().getInstanceofClass(cateletClass);</div><div class=\"line\">       catlet.route(sysConfig, schema, sqlType, realSQL, charset, sc, cachePool);</div><div class=\"line\">       catlet.processSQL(realSQL, <span class=\"keyword\">new</span> EngineCtx(sc.getSession2()));</div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">       LOGGER.warn(<span class=\"string\">\"catlet error \"</span> + e);</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLNonTransientException(e);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-ShareJoin\"><a href=\"#3-ShareJoin\" class=\"headerlink\" title=\"3. ShareJoin\"></a>3. ShareJoin</h1><p>目前支持跨库<strong>两</strong>表 Join。<code>ShareJoin</code> 将 SQL 拆分成左表 SQL 和 右表 SQL，发送给各数据节点执行，汇总数据结果进行合后返回。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SELECT u.id, o.id FROM t_order o </span></div><div class=\"line\"><span class=\"comment\">// INNER JOIN t_user u ON o.uid = u.id</span></div><div class=\"line\"><span class=\"comment\">// 【顺序】查询左表</span></div><div class=\"line\">String leftSQL = <span class=\"string\">\"SELECT o.id, u.id FROM t_order o\"</span>;</div><div class=\"line\">List leftList = dn[<span class=\"number\">0</span>].select(leftSQL) + dn[<span class=\"number\">1</span>].select(leftSQL) + ... + dn[n].select(leftsql);</div><div class=\"line\"><span class=\"comment\">// 【并行】查询右表</span></div><div class=\"line\">String rightSQL = <span class=\"string\">\"SELECT u.id FROM t_user u WHERE u.id IN ($&#123;leftList.uid&#125;)\"</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (dn : dns) &#123; <span class=\"comment\">// 此处是并行执行，使用回调逻辑</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (rightRecord : dn.select(rightSQL)) &#123; <span class=\"comment\">// 查询右表</span></div><div class=\"line\">        <span class=\"comment\">// 合并结果</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (leftRecord : leftList) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (leftRecord.uid == rightRecord.id) &#123;</div><div class=\"line\">                write(leftRecord + leftRecord.uid 拼接结果);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际情况会更加复杂，我们接下来一点点往下看。</p>\n<h2 id=\"3-1-JoinParser\"><a href=\"#3-1-JoinParser\" class=\"headerlink\" title=\"3.1 JoinParser\"></a>3.1 JoinParser</h2><p><code>JoinParser</code> 负责对 SQL 进行解析。整体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/02.png\" alt=\"\"></p>\n<p>举个例子，<code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 解析后，<code>TableFilter</code> 结果如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/03.png\" alt=\"\"></p>\n<ul>\n<li>tName ：表名</li>\n<li>tAlia ：表自定义命名</li>\n<li>where ：过滤条件</li>\n<li>order ：排序条件</li>\n<li>parenTable ：左连接的 Join 的表名。<code>t_user</code>表 在 <code>join</code>属性 的 <code>parenTable</code> 为 “o”，即 <code>t_order</code>。</li>\n<li>joinParentkey ：左连接的 Join 字段</li>\n<li>joinKey ：join 字段。<code>t_user</code>表 在 <code>join</code>属性 为 <code>id</code>。</li>\n<li>join ：子 tableFilter。即，该表连接的右边的表。</li>\n<li>parent ：和 <code>join</code>属性 相对。</li>\n</ul>\n<p>看到此处，大家可能有疑问，为什么要把 SQL 解析成 <code>TableFilter</code>。<code>JoinParser</code> 根据 <code>TableFilter</code> 生成数据节点执行 SQL。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// TableFilter.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSQL</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   String sql = <span class=\"string\">\"\"</span>;</div><div class=\"line\">   <span class=\"comment\">// fields</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, String&gt; entry : fieldAliasMap.entrySet()) &#123;</div><div class=\"line\">       String key = entry.getKey();</div><div class=\"line\">       String val = entry.getValue();</div><div class=\"line\">       <span class=\"keyword\">if</span> (val == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           sql = unionsql(sql, getFieldfrom(key), <span class=\"string\">\",\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql = unionsql(sql, getFieldfrom(key) + <span class=\"string\">\" as \"</span> + val, <span class=\"string\">\",\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// where</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// on/where 等于号左边的表</span></div><div class=\"line\">       String parentJoinKey = getJoinKey(<span class=\"keyword\">true</span>);</div><div class=\"line\">       <span class=\"comment\">// fix sharejoin bug：</span></div><div class=\"line\">       <span class=\"comment\">// (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:</span></div><div class=\"line\">       <span class=\"comment\">// 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (sql != <span class=\"keyword\">null</span> &amp;&amp; parentJoinKey != <span class=\"keyword\">null</span> &amp;&amp;</div><div class=\"line\">               !sql.toUpperCase().contains(parentJoinKey.trim().toUpperCase())) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\", \"</span> + parentJoinKey;</div><div class=\"line\">       &#125;</div><div class=\"line\">       sql = <span class=\"string\">\"select \"</span> + sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!(where.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + where.trim();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// on/where 等于号右边边的表</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (allField) &#123;</div><div class=\"line\">           sql = <span class=\"string\">\"select \"</span> + sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql = unionField(<span class=\"string\">\"select \"</span> + joinKey, sql, <span class=\"string\">\",\"</span>);</div><div class=\"line\">           sql = sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">           <span class=\"comment\">//sql=\"select \"+joinKey+\",\"+sql+\" from \"+tName;</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!(where.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + where.trim() + <span class=\"string\">\" and (\"</span> + joinKey + <span class=\"string\">\" in %s )\"</span>;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + joinKey + <span class=\"string\">\" in %s \"</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// order</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!(order.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">       sql += <span class=\"string\">\" order by \"</span> + order.trim();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// limit</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> ((rowCount &gt; <span class=\"number\">0</span>) &amp;&amp; (offset &gt; <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" limit\"</span> + offset + <span class=\"string\">\",\"</span> + rowCount;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (rowCount &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               sql += <span class=\"string\">\" limit \"</span> + rowCount;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> sql;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>当 <code>parent</code> 为空时，即<strong>on/where 等于号左边的表</strong>。例如：<code>select id, uid from t_order</code>。</li>\n<li>当 <code>parent</code>  不为空时，即<strong>on/where 等于号右边的表</strong>。例如：<code>select id, username from t_user where id in (1, 2, 3)</code>。</li>\n</ul>\n<h2 id=\"3-2-ShareJoin-processSQL-…\"><a href=\"#3-2-ShareJoin-processSQL-…\" class=\"headerlink\" title=\"3.2 ShareJoin.processSQL(…)\"></a>3.2 ShareJoin.processSQL(…)</h2><p>当 SQL 解析完后，生成<strong>左边的表</strong>执行的 SQL，发送给对应的数据节点查询数据。大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/04.png\" alt=\"\"></p>\n<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getSql()</code> 的返回结果为 <code>select id, uid from t_order</code>。</p>\n<p>生成<strong>左边的表</strong>执行的 SQL 后，<strong>顺序顺序顺序</strong>发送给对应的数据节点查询数据。具体顺序查询是怎么实现的，我们来看下章 <strong>BatchSQLJob</strong>。</p>\n<h2 id=\"3-3-BatchSQLJob\"><a href=\"#3-3-BatchSQLJob\" class=\"headerlink\" title=\"3.3 BatchSQLJob\"></a>3.3 BatchSQLJob</h2><p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/05.png\" alt=\"\"></p>\n<p><code>EngineCtx</code> 对 <code>BatchSQLJob</code> 封装，提供上层两个方法：</p>\n<ol>\n<li>executeNativeSQLSequnceJob ：顺序（非并发）在每个数据节点执行SQL任务</li>\n<li>executeNativeSQLParallJob ：并发在每个数据节点执行SQL任务</li>\n</ol>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EngineCtx.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeNativeSQLSequnceJob</span><span class=\"params\">(String[] dataNodes, String sql,</span></span></div><div class=\"line\">\t\tSQLJobHandler jobHandler) &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String dataNode : dataNodes) &#123;</div><div class=\"line\">\t\tSQLJob job = <span class=\"keyword\">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class=\"line\">\t\t\t\tjobHandler, <span class=\"keyword\">this</span>);</div><div class=\"line\">\t\tbachJob.addJob(job, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeNativeSQLParallJob</span><span class=\"params\">(String[] dataNodes, String sql,</span></span></div><div class=\"line\">\t\tSQLJobHandler jobHandler) &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String dataNode : dataNodes) &#123;</div><div class=\"line\">\t\tSQLJob job = <span class=\"keyword\">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class=\"line\">\t\t\t\tjobHandler, <span class=\"keyword\">this</span>);</div><div class=\"line\">\t\tbachJob.addJob(job, <span class=\"keyword\">true</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p><code>BatchSQLJob</code> 通过<strong>执行中任务列表</strong>、<strong>待执行任务列表</strong>来实现<strong>顺序/并发</strong>执行任务。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// BatchSQLJob.java</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* 执行中任务列表</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">private</span> ConcurrentHashMap&lt;Integer, SQLJob&gt; runningJobs = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Integer, SQLJob&gt;();</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* 待执行任务列表</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">private</span> ConcurrentLinkedQueue&lt;SQLJob&gt; waitingJobs = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;SQLJob&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addJob</span><span class=\"params\">(SQLJob newJob, <span class=\"keyword\">boolean</span> parallExecute)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (parallExecute) &#123;</div><div class=\"line\">       runJob(newJob);</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       waitingJobs.offer(newJob);</div><div class=\"line\">       <span class=\"keyword\">if</span> (runningJobs.isEmpty()) &#123; <span class=\"comment\">// 若无正在执行中的任务，则从等待队列里获取任务进行执行。</span></div><div class=\"line\">           SQLJob job = waitingJobs.poll();</div><div class=\"line\">           <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               runJob(job);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">jobFinished</span><span class=\"params\">(SQLJob sqlJob)</span> </span>&#123;</div><div class=\"line\">\trunningJobs.remove(sqlJob.getId());</div><div class=\"line\">\tSQLJob job = waitingJobs.poll();</div><div class=\"line\">\t<span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\trunJob(job);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (noMoreJobInput) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> runningJobs.isEmpty() &amp;&amp; waitingJobs.isEmpty();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>顺序</strong>执行时，当 <code>runningJobs</code> 存在执行中的任务时，<code>#addJob(...)</code> 时，不立即执行，添加到 <code>waitingJobs</code>。当 <code>SQLJob</code> 完成时，顺序调用下一个任务。</li>\n<li><strong>并发</strong>执行时，<code>#addJob(...)</code> 时，立即执行。</li>\n</ul>\n<hr>\n<p><code>SQLJob</code> SQL 异步执行任务。其 <code>jobHandler(SQLJobHandler)</code> 属性，在 SQL 执行有返回结果时，会进行回调，从而实现异步执行。</p>\n<p>在 <code>ShareJoin</code> 里，<code>SQLJobHandler</code> 有两个实现：<code>ShareDBJoinHandler</code>、<code>ShareRowOutPutDataHandler</code>。前者，<strong>左边的表</strong>执行的 SQL 回调；后者，<strong>右边的表</strong>执行的 SQL 回调。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/06.png\" alt=\"\"></p>\n<h2 id=\"3-4-ShareDBJoinHandler\"><a href=\"#3-4-ShareDBJoinHandler\" class=\"headerlink\" title=\"3.4 ShareDBJoinHandler\"></a>3.4 ShareDBJoinHandler</h2><p><code>ShareDBJoinHandler</code>，<strong>左边的表</strong>执行的 SQL 回调。流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/07.png\" alt=\"\"></p>\n<ul>\n<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，放入内存。</li>\n<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，放入内存。</li>\n<li><code>#rowEofResponse(...)</code> ：接收完一个数据节点返回所有的 row。当所有数据节点都完成 SQL 执行时，提交<strong>右边的表</strong>执行的 SQL 任务，<strong>并行</strong>执行，即图中<strong>#createQryJob(…)</strong>。</li>\n</ul>\n<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getChildSQL()</code> 的返回结果为 <code>select id, username from t_user where id in (1, 2, 3)</code>。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ShareJoin.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createQryJob</span><span class=\"params\">(<span class=\"keyword\">int</span> batchSize)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">   Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; batchRows = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, <span class=\"keyword\">byte</span>[]&gt;();</div><div class=\"line\">   String theId = <span class=\"keyword\">null</span>;</div><div class=\"line\">   StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">'('</span>);</div><div class=\"line\">   String svalue = <span class=\"string\">\"\"</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; e : ids.entrySet()) &#123;</div><div class=\"line\">       theId = e.getKey();</div><div class=\"line\">       <span class=\"keyword\">byte</span>[] rowbyte = rows.remove(theId);</div><div class=\"line\">       <span class=\"keyword\">if</span> (rowbyte != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           batchRows.put(theId, rowbyte);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!svalue.equals(e.getValue())) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (joinKeyType == Fields.FIELD_TYPE_VAR_STRING</div><div class=\"line\">                   || joinKeyType == Fields.FIELD_TYPE_STRING) &#123; <span class=\"comment\">// joinkey 为varchar</span></div><div class=\"line\">               sb.append(<span class=\"string\">\"'\"</span>).append(e.getValue()).append(<span class=\"string\">\"'\"</span>).append(<span class=\"string\">','</span>); <span class=\"comment\">// ('digdeep','yuanfang')</span></div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 默认joinkey为int/long</span></div><div class=\"line\">               sb.append(e.getValue()).append(<span class=\"string\">','</span>); <span class=\"comment\">// (1,2,3)</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       svalue = e.getValue();</div><div class=\"line\">       <span class=\"keyword\">if</span> (count++ &gt; batchSize) &#123;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   jointTableIsData = <span class=\"keyword\">true</span>;</div><div class=\"line\">   sb.deleteCharAt(sb.length() - <span class=\"number\">1</span>).append(<span class=\"string\">')'</span>);</div><div class=\"line\">   String sql = String.format(joinParser.getChildSQL(), sb);</div><div class=\"line\">   getRoute(sql);</div><div class=\"line\">   ctx.executeNativeSQLParallJob(getDataNodes(), sql, <span class=\"keyword\">new</span> ShareRowOutPutDataHandler(<span class=\"keyword\">this</span>, fields, joinindex, joinParser.getJoinRkey(), batchRows, ctx.getSession()));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-5-ShareRowOutPutDataHandler\"><a href=\"#3-5-ShareRowOutPutDataHandler\" class=\"headerlink\" title=\"3.5 ShareRowOutPutDataHandler\"></a>3.5 ShareRowOutPutDataHandler</h2><p><code>ShareRowOutPutDataHandler</code>，<strong>右边的表</strong>执行的 SQL 回调。流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/08.png\" alt=\"\"></p>\n<ul>\n<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，返回 header 给 MySQL Client。</li>\n<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，匹配左表的记录，返回合并后返回的 row 给 MySQL Client。</li>\n<li><code>#rowEofResponse(...)</code> ：当所有 row 都返回完后，返回 eof 给 MySQL Client。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ShareRowOutPutDataHandler.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onRowData</span><span class=\"params\">(String dataNode, <span class=\"keyword\">byte</span>[] rowData)</span> </span>&#123;</div><div class=\"line\">   RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);</div><div class=\"line\">   <span class=\"comment\">//拷贝一份batchRows</span></div><div class=\"line\">   Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; batchRowsCopy = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, <span class=\"keyword\">byte</span>[]&gt;();</div><div class=\"line\">   batchRowsCopy.putAll(arows);</div><div class=\"line\">   <span class=\"comment\">// 获取Id字段，</span></div><div class=\"line\">   String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));</div><div class=\"line\">   <span class=\"comment\">// 查找ID对应的A表的记录</span></div><div class=\"line\">   <span class=\"keyword\">byte</span>[] arow = getRow(batchRowsCopy, id, joinL);</div><div class=\"line\">   <span class=\"keyword\">while</span> (arow != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow, afields);<span class=\"comment\">//ctx.getAllFields());</span></div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; rowDataPkgold.fieldCount; i++) &#123;</div><div class=\"line\">           <span class=\"comment\">// 设置b.name 字段</span></div><div class=\"line\">           <span class=\"keyword\">byte</span>[] bname = rowDataPkgold.fieldValues.get(i);</div><div class=\"line\">           rowDataPkg.add(bname);</div><div class=\"line\">           rowDataPkg.addFieldCount(<span class=\"number\">1</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// huangyiming add</span></div><div class=\"line\">       MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();</div><div class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == middlerResultHandler) &#123;</div><div class=\"line\">           ctx.writeRow(rowDataPkg);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (middlerResultHandler <span class=\"keyword\">instanceof</span> MiddlerQueryResultHandler) &#123;</div><div class=\"line\">               <span class=\"keyword\">byte</span>[] columnData = rowDataPkg.fieldValues.get(<span class=\"number\">0</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (columnData != <span class=\"keyword\">null</span> &amp;&amp; columnData.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                   String rowValue = <span class=\"keyword\">new</span> String(columnData);</div><div class=\"line\">                   middlerResultHandler.add(rowValue);</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"comment\">//&#125;</span></div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       arow = getRow(batchRowsCopy, id, joinL);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"4-彩蛋\"><a href=\"#4-彩蛋\" class=\"headerlink\" title=\"4. 彩蛋\"></a>4. 彩蛋</h1><p>如下是本文涉及到的核心类，有兴趣的同学可以翻一翻。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/09.png\" alt=\"\"></p>\n<p><code>ShareJoin</code> 另外不支持的功能：</p>\n<ol>\n<li>只支持 inner join，不支持 left join、right join 等等连接。</li>\n<li>不支持 order by。</li>\n<li>不支持 group by 以及 相关聚合函数。</li>\n<li>即使 join 左表的字段未声明为返回 fields 也会返回。</li>\n</ol>\n<p>恩，<strong>MyCAT 弱XA</strong> 源码继续走起！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/sharding-two-table-join/\">http://www.yunai.me/MyCAT/sharding-result-merge-first/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong><br>QQ ：7685413</p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 主流程</a></li>\n<li><a href=\"#\">3. ShareJoin</a><ul>\n<li><a href=\"#\">3.1 JoinParser</a></li>\n<li><a href=\"#\">3.2 ShareJoin.processSQL(…)</a></li>\n<li><a href=\"#\">3.3 BatchSQLJob</a></li>\n<li><a href=\"#\">3.4 ShareDBJoinHandler</a></li>\n<li><a href=\"#\">3.5 ShareRowOutPutDataHandler</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 彩蛋</a></li>\n</ul>\n<hr>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>MyCAT 支持跨库表 Join，目前版本仅支持跨库<strong>两</strong>表 Join。虽然如此，已经能够满足我们大部分的业务场景。况且，Join 过多的表可能带来的性能问题也是很麻烦的。</p>\n<p>本文主要分享：</p>\n<ol>\n<li>整体流程、调用顺序图</li>\n<li>核心代码的分析</li>\n</ol>\n<p>前置阅读：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-select/?yunai\">《MyCAT 源码分析 —— 【单库单表】查询》</a>。</p>\n<p>OK，Let’s Go。</p>\n<h1 id=\"2-主流程\"><a href=\"#2-主流程\" class=\"headerlink\" title=\"2. 主流程\"></a>2. 主流程</h1><p>当执行跨库两表 Join SQL 时，经历的大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/01.png\" alt=\"\"></p>\n<p>SQL 上，需要添加注解 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ ${SQL}</code> 。<code>RouteService#route(...)</code> 解析注解 <code>mycat:catlet</code> 后，路由给 <code>HintCatletHandler</code> 作进一步处理。</p>\n<p><code>HintCatletHandler</code> 获取注解对应的 <code>Catlet</code> 实现类，<code>io.mycat.catlets.ShareJoin</code> 就是其中一种实现（目前也只有这一种实现），提供了跨库两表 Join 的功能。从类命名上看，<code>ShareJoin</code> 很大可能性后续会提供<strong>完整</strong>的跨库多表的 Join 功能。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// HintCatletHandler.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema,</span></span></div><div class=\"line\">                           <span class=\"keyword\">int</span> sqlType, String realSQL, String charset, ServerConnection sc,</div><div class=\"line\">                           LayerCachePool cachePool, String hintSQLValue, <span class=\"keyword\">int</span> hintSqlType, Map hintMap)</div><div class=\"line\">       <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\">   String cateletClass = hintSQLValue;</div><div class=\"line\">   <span class=\"keyword\">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class=\"line\">       LOGGER.debug(<span class=\"string\">\"load catelet class:\"</span> + hintSQLValue + <span class=\"string\">\" to run sql \"</span> + realSQL);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">       Catlet catlet = (Catlet) MycatServer.getInstance().getCatletClassLoader().getInstanceofClass(cateletClass);</div><div class=\"line\">       catlet.route(sysConfig, schema, sqlType, realSQL, charset, sc, cachePool);</div><div class=\"line\">       catlet.processSQL(realSQL, <span class=\"keyword\">new</span> EngineCtx(sc.getSession2()));</div><div class=\"line\">   &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\">       LOGGER.warn(<span class=\"string\">\"catlet error \"</span> + e);</div><div class=\"line\">       <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SQLNonTransientException(e);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-ShareJoin\"><a href=\"#3-ShareJoin\" class=\"headerlink\" title=\"3. ShareJoin\"></a>3. ShareJoin</h1><p>目前支持跨库<strong>两</strong>表 Join。<code>ShareJoin</code> 将 SQL 拆分成左表 SQL 和 右表 SQL，发送给各数据节点执行，汇总数据结果进行合后返回。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// SELECT u.id, o.id FROM t_order o </span></div><div class=\"line\"><span class=\"comment\">// INNER JOIN t_user u ON o.uid = u.id</span></div><div class=\"line\"><span class=\"comment\">// 【顺序】查询左表</span></div><div class=\"line\">String leftSQL = <span class=\"string\">\"SELECT o.id, u.id FROM t_order o\"</span>;</div><div class=\"line\">List leftList = dn[<span class=\"number\">0</span>].select(leftSQL) + dn[<span class=\"number\">1</span>].select(leftSQL) + ... + dn[n].select(leftsql);</div><div class=\"line\"><span class=\"comment\">// 【并行】查询右表</span></div><div class=\"line\">String rightSQL = <span class=\"string\">\"SELECT u.id FROM t_user u WHERE u.id IN ($&#123;leftList.uid&#125;)\"</span>;</div><div class=\"line\"><span class=\"keyword\">for</span> (dn : dns) &#123; <span class=\"comment\">// 此处是并行执行，使用回调逻辑</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (rightRecord : dn.select(rightSQL)) &#123; <span class=\"comment\">// 查询右表</span></div><div class=\"line\">        <span class=\"comment\">// 合并结果</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (leftRecord : leftList) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (leftRecord.uid == rightRecord.id) &#123;</div><div class=\"line\">                write(leftRecord + leftRecord.uid 拼接结果);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际情况会更加复杂，我们接下来一点点往下看。</p>\n<h2 id=\"3-1-JoinParser\"><a href=\"#3-1-JoinParser\" class=\"headerlink\" title=\"3.1 JoinParser\"></a>3.1 JoinParser</h2><p><code>JoinParser</code> 负责对 SQL 进行解析。整体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/02.png\" alt=\"\"></p>\n<p>举个例子，<code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 解析后，<code>TableFilter</code> 结果如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/03.png\" alt=\"\"></p>\n<ul>\n<li>tName ：表名</li>\n<li>tAlia ：表自定义命名</li>\n<li>where ：过滤条件</li>\n<li>order ：排序条件</li>\n<li>parenTable ：左连接的 Join 的表名。<code>t_user</code>表 在 <code>join</code>属性 的 <code>parenTable</code> 为 “o”，即 <code>t_order</code>。</li>\n<li>joinParentkey ：左连接的 Join 字段</li>\n<li>joinKey ：join 字段。<code>t_user</code>表 在 <code>join</code>属性 为 <code>id</code>。</li>\n<li>join ：子 tableFilter。即，该表连接的右边的表。</li>\n<li>parent ：和 <code>join</code>属性 相对。</li>\n</ul>\n<p>看到此处，大家可能有疑问，为什么要把 SQL 解析成 <code>TableFilter</code>。<code>JoinParser</code> 根据 <code>TableFilter</code> 生成数据节点执行 SQL。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// TableFilter.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSQL</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">   String sql = <span class=\"string\">\"\"</span>;</div><div class=\"line\">   <span class=\"comment\">// fields</span></div><div class=\"line\">   <span class=\"keyword\">for</span> (Entry&lt;String, String&gt; entry : fieldAliasMap.entrySet()) &#123;</div><div class=\"line\">       String key = entry.getKey();</div><div class=\"line\">       String val = entry.getValue();</div><div class=\"line\">       <span class=\"keyword\">if</span> (val == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           sql = unionsql(sql, getFieldfrom(key), <span class=\"string\">\",\"</span>);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql = unionsql(sql, getFieldfrom(key) + <span class=\"string\">\" as \"</span> + val, <span class=\"string\">\",\"</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// where</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// on/where 等于号左边的表</span></div><div class=\"line\">       String parentJoinKey = getJoinKey(<span class=\"keyword\">true</span>);</div><div class=\"line\">       <span class=\"comment\">// fix sharejoin bug：</span></div><div class=\"line\">       <span class=\"comment\">// (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:</span></div><div class=\"line\">       <span class=\"comment\">// 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (sql != <span class=\"keyword\">null</span> &amp;&amp; parentJoinKey != <span class=\"keyword\">null</span> &amp;&amp;</div><div class=\"line\">               !sql.toUpperCase().contains(parentJoinKey.trim().toUpperCase())) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\", \"</span> + parentJoinKey;</div><div class=\"line\">       &#125;</div><div class=\"line\">       sql = <span class=\"string\">\"select \"</span> + sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!(where.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + where.trim();</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// on/where 等于号右边边的表</span></div><div class=\"line\">       <span class=\"keyword\">if</span> (allField) &#123;</div><div class=\"line\">           sql = <span class=\"string\">\"select \"</span> + sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql = unionField(<span class=\"string\">\"select \"</span> + joinKey, sql, <span class=\"string\">\",\"</span>);</div><div class=\"line\">           sql = sql + <span class=\"string\">\" from \"</span> + tName;</div><div class=\"line\">           <span class=\"comment\">//sql=\"select \"+joinKey+\",\"+sql+\" from \"+tName;</span></div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!(where.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + where.trim() + <span class=\"string\">\" and (\"</span> + joinKey + <span class=\"string\">\" in %s )\"</span>;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" where \"</span> + joinKey + <span class=\"string\">\" in %s \"</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// order</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (!(order.trim().equals(<span class=\"string\">\"\"</span>))) &#123;</div><div class=\"line\">       sql += <span class=\"string\">\" order by \"</span> + order.trim();</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"comment\">// limit</span></div><div class=\"line\">   <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> ((rowCount &gt; <span class=\"number\">0</span>) &amp;&amp; (offset &gt; <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">           sql += <span class=\"string\">\" limit\"</span> + offset + <span class=\"string\">\",\"</span> + rowCount;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (rowCount &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">               sql += <span class=\"string\">\" limit \"</span> + rowCount;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> sql;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>当 <code>parent</code> 为空时，即<strong>on/where 等于号左边的表</strong>。例如：<code>select id, uid from t_order</code>。</li>\n<li>当 <code>parent</code>  不为空时，即<strong>on/where 等于号右边的表</strong>。例如：<code>select id, username from t_user where id in (1, 2, 3)</code>。</li>\n</ul>\n<h2 id=\"3-2-ShareJoin-processSQL-…\"><a href=\"#3-2-ShareJoin-processSQL-…\" class=\"headerlink\" title=\"3.2 ShareJoin.processSQL(…)\"></a>3.2 ShareJoin.processSQL(…)</h2><p>当 SQL 解析完后，生成<strong>左边的表</strong>执行的 SQL，发送给对应的数据节点查询数据。大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/04.png\" alt=\"\"></p>\n<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getSql()</code> 的返回结果为 <code>select id, uid from t_order</code>。</p>\n<p>生成<strong>左边的表</strong>执行的 SQL 后，<strong>顺序顺序顺序</strong>发送给对应的数据节点查询数据。具体顺序查询是怎么实现的，我们来看下章 <strong>BatchSQLJob</strong>。</p>\n<h2 id=\"3-3-BatchSQLJob\"><a href=\"#3-3-BatchSQLJob\" class=\"headerlink\" title=\"3.3 BatchSQLJob\"></a>3.3 BatchSQLJob</h2><p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/05.png\" alt=\"\"></p>\n<p><code>EngineCtx</code> 对 <code>BatchSQLJob</code> 封装，提供上层两个方法：</p>\n<ol>\n<li>executeNativeSQLSequnceJob ：顺序（非并发）在每个数据节点执行SQL任务</li>\n<li>executeNativeSQLParallJob ：并发在每个数据节点执行SQL任务</li>\n</ol>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// EngineCtx.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeNativeSQLSequnceJob</span><span class=\"params\">(String[] dataNodes, String sql,</span></span></div><div class=\"line\">\t\tSQLJobHandler jobHandler) &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String dataNode : dataNodes) &#123;</div><div class=\"line\">\t\tSQLJob job = <span class=\"keyword\">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class=\"line\">\t\t\t\tjobHandler, <span class=\"keyword\">this</span>);</div><div class=\"line\">\t\tbachJob.addJob(job, <span class=\"keyword\">false</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeNativeSQLParallJob</span><span class=\"params\">(String[] dataNodes, String sql,</span></span></div><div class=\"line\">\t\tSQLJobHandler jobHandler) &#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (String dataNode : dataNodes) &#123;</div><div class=\"line\">\t\tSQLJob job = <span class=\"keyword\">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class=\"line\">\t\t\t\tjobHandler, <span class=\"keyword\">this</span>);</div><div class=\"line\">\t\tbachJob.addJob(job, <span class=\"keyword\">true</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<hr>\n<p><code>BatchSQLJob</code> 通过<strong>执行中任务列表</strong>、<strong>待执行任务列表</strong>来实现<strong>顺序/并发</strong>执行任务。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// BatchSQLJob.java</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* 执行中任务列表</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">private</span> ConcurrentHashMap&lt;Integer, SQLJob&gt; runningJobs = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Integer, SQLJob&gt;();</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* 待执行任务列表</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"keyword\">private</span> ConcurrentLinkedQueue&lt;SQLJob&gt; waitingJobs = <span class=\"keyword\">new</span> ConcurrentLinkedQueue&lt;SQLJob&gt;();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addJob</span><span class=\"params\">(SQLJob newJob, <span class=\"keyword\">boolean</span> parallExecute)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">if</span> (parallExecute) &#123;</div><div class=\"line\">       runJob(newJob);</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       waitingJobs.offer(newJob);</div><div class=\"line\">       <span class=\"keyword\">if</span> (runningJobs.isEmpty()) &#123; <span class=\"comment\">// 若无正在执行中的任务，则从等待队列里获取任务进行执行。</span></div><div class=\"line\">           SQLJob job = waitingJobs.poll();</div><div class=\"line\">           <span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">               runJob(job);</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">jobFinished</span><span class=\"params\">(SQLJob sqlJob)</span> </span>&#123;</div><div class=\"line\">\trunningJobs.remove(sqlJob.getId());</div><div class=\"line\">\tSQLJob job = waitingJobs.poll();</div><div class=\"line\">\t<span class=\"keyword\">if</span> (job != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">\t\trunJob(job);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> (noMoreJobInput) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> runningJobs.isEmpty() &amp;&amp; waitingJobs.isEmpty();</div><div class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>顺序</strong>执行时，当 <code>runningJobs</code> 存在执行中的任务时，<code>#addJob(...)</code> 时，不立即执行，添加到 <code>waitingJobs</code>。当 <code>SQLJob</code> 完成时，顺序调用下一个任务。</li>\n<li><strong>并发</strong>执行时，<code>#addJob(...)</code> 时，立即执行。</li>\n</ul>\n<hr>\n<p><code>SQLJob</code> SQL 异步执行任务。其 <code>jobHandler(SQLJobHandler)</code> 属性，在 SQL 执行有返回结果时，会进行回调，从而实现异步执行。</p>\n<p>在 <code>ShareJoin</code> 里，<code>SQLJobHandler</code> 有两个实现：<code>ShareDBJoinHandler</code>、<code>ShareRowOutPutDataHandler</code>。前者，<strong>左边的表</strong>执行的 SQL 回调；后者，<strong>右边的表</strong>执行的 SQL 回调。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/06.png\" alt=\"\"></p>\n<h2 id=\"3-4-ShareDBJoinHandler\"><a href=\"#3-4-ShareDBJoinHandler\" class=\"headerlink\" title=\"3.4 ShareDBJoinHandler\"></a>3.4 ShareDBJoinHandler</h2><p><code>ShareDBJoinHandler</code>，<strong>左边的表</strong>执行的 SQL 回调。流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/07.png\" alt=\"\"></p>\n<ul>\n<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，放入内存。</li>\n<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，放入内存。</li>\n<li><code>#rowEofResponse(...)</code> ：接收完一个数据节点返回所有的 row。当所有数据节点都完成 SQL 执行时，提交<strong>右边的表</strong>执行的 SQL 任务，<strong>并行</strong>执行，即图中<strong>#createQryJob(…)</strong>。</li>\n</ul>\n<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getChildSQL()</code> 的返回结果为 <code>select id, username from t_user where id in (1, 2, 3)</code>。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ShareJoin.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createQryJob</span><span class=\"params\">(<span class=\"keyword\">int</span> batchSize)</span> </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</div><div class=\"line\">   Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; batchRows = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, <span class=\"keyword\">byte</span>[]&gt;();</div><div class=\"line\">   String theId = <span class=\"keyword\">null</span>;</div><div class=\"line\">   StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">'('</span>);</div><div class=\"line\">   String svalue = <span class=\"string\">\"\"</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span> (Map.Entry&lt;String, String&gt; e : ids.entrySet()) &#123;</div><div class=\"line\">       theId = e.getKey();</div><div class=\"line\">       <span class=\"keyword\">byte</span>[] rowbyte = rows.remove(theId);</div><div class=\"line\">       <span class=\"keyword\">if</span> (rowbyte != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">           batchRows.put(theId, rowbyte);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"keyword\">if</span> (!svalue.equals(e.getValue())) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (joinKeyType == Fields.FIELD_TYPE_VAR_STRING</div><div class=\"line\">                   || joinKeyType == Fields.FIELD_TYPE_STRING) &#123; <span class=\"comment\">// joinkey 为varchar</span></div><div class=\"line\">               sb.append(<span class=\"string\">\"'\"</span>).append(e.getValue()).append(<span class=\"string\">\"'\"</span>).append(<span class=\"string\">','</span>); <span class=\"comment\">// ('digdeep','yuanfang')</span></div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 默认joinkey为int/long</span></div><div class=\"line\">               sb.append(e.getValue()).append(<span class=\"string\">','</span>); <span class=\"comment\">// (1,2,3)</span></div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       svalue = e.getValue();</div><div class=\"line\">       <span class=\"keyword\">if</span> (count++ &gt; batchSize) &#123;</div><div class=\"line\">           <span class=\"keyword\">break</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">       <span class=\"keyword\">return</span>;</div><div class=\"line\">   &#125;</div><div class=\"line\">   jointTableIsData = <span class=\"keyword\">true</span>;</div><div class=\"line\">   sb.deleteCharAt(sb.length() - <span class=\"number\">1</span>).append(<span class=\"string\">')'</span>);</div><div class=\"line\">   String sql = String.format(joinParser.getChildSQL(), sb);</div><div class=\"line\">   getRoute(sql);</div><div class=\"line\">   ctx.executeNativeSQLParallJob(getDataNodes(), sql, <span class=\"keyword\">new</span> ShareRowOutPutDataHandler(<span class=\"keyword\">this</span>, fields, joinindex, joinParser.getJoinRkey(), batchRows, ctx.getSession()));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-5-ShareRowOutPutDataHandler\"><a href=\"#3-5-ShareRowOutPutDataHandler\" class=\"headerlink\" title=\"3.5 ShareRowOutPutDataHandler\"></a>3.5 ShareRowOutPutDataHandler</h2><p><code>ShareRowOutPutDataHandler</code>，<strong>右边的表</strong>执行的 SQL 回调。流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/08.png\" alt=\"\"></p>\n<ul>\n<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，返回 header 给 MySQL Client。</li>\n<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，匹配左表的记录，返回合并后返回的 row 给 MySQL Client。</li>\n<li><code>#rowEofResponse(...)</code> ：当所有 row 都返回完后，返回 eof 给 MySQL Client。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ShareRowOutPutDataHandler.java</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onRowData</span><span class=\"params\">(String dataNode, <span class=\"keyword\">byte</span>[] rowData)</span> </span>&#123;</div><div class=\"line\">   RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);</div><div class=\"line\">   <span class=\"comment\">//拷贝一份batchRows</span></div><div class=\"line\">   Map&lt;String, <span class=\"keyword\">byte</span>[]&gt; batchRowsCopy = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, <span class=\"keyword\">byte</span>[]&gt;();</div><div class=\"line\">   batchRowsCopy.putAll(arows);</div><div class=\"line\">   <span class=\"comment\">// 获取Id字段，</span></div><div class=\"line\">   String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));</div><div class=\"line\">   <span class=\"comment\">// 查找ID对应的A表的记录</span></div><div class=\"line\">   <span class=\"keyword\">byte</span>[] arow = getRow(batchRowsCopy, id, joinL);</div><div class=\"line\">   <span class=\"keyword\">while</span> (arow != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">       RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow, afields);<span class=\"comment\">//ctx.getAllFields());</span></div><div class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; rowDataPkgold.fieldCount; i++) &#123;</div><div class=\"line\">           <span class=\"comment\">// 设置b.name 字段</span></div><div class=\"line\">           <span class=\"keyword\">byte</span>[] bname = rowDataPkgold.fieldValues.get(i);</div><div class=\"line\">           rowDataPkg.add(bname);</div><div class=\"line\">           rowDataPkg.addFieldCount(<span class=\"number\">1</span>);</div><div class=\"line\">       &#125;</div><div class=\"line\">       <span class=\"comment\">// huangyiming add</span></div><div class=\"line\">       MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();</div><div class=\"line\">       <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == middlerResultHandler) &#123;</div><div class=\"line\">           ctx.writeRow(rowDataPkg);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (middlerResultHandler <span class=\"keyword\">instanceof</span> MiddlerQueryResultHandler) &#123;</div><div class=\"line\">               <span class=\"keyword\">byte</span>[] columnData = rowDataPkg.fieldValues.get(<span class=\"number\">0</span>);</div><div class=\"line\">               <span class=\"keyword\">if</span> (columnData != <span class=\"keyword\">null</span> &amp;&amp; columnData.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                   String rowValue = <span class=\"keyword\">new</span> String(columnData);</div><div class=\"line\">                   middlerResultHandler.add(rowValue);</div><div class=\"line\">               &#125;</div><div class=\"line\">               <span class=\"comment\">//&#125;</span></div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">       &#125;</div><div class=\"line\">       arow = getRow(batchRowsCopy, id, joinL);</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"4-彩蛋\"><a href=\"#4-彩蛋\" class=\"headerlink\" title=\"4. 彩蛋\"></a>4. 彩蛋</h1><p>如下是本文涉及到的核心类，有兴趣的同学可以翻一翻。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_07_12/09.png\" alt=\"\"></p>\n<p><code>ShareJoin</code> 另外不支持的功能：</p>\n<ol>\n<li>只支持 inner join，不支持 left join、right join 等等连接。</li>\n<li>不支持 order by。</li>\n<li>不支持 group by 以及 相关聚合函数。</li>\n<li>即使 join 左表的字段未声明为返回 fields 也会返回。</li>\n</ol>\n<p>恩，<strong>MyCAT 弱XA</strong> 源码继续走起！</p>\n"},{"title":"MyCAT 源码分析 —— 【单库单表】插入","date":"2017-05-28T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/single-db-single-table-insert/](http://www.yunai.me/MyCAT/single-db-single-table-insert/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 接收请求，解析 SQL](#)\n- [3. 获得路由结果](#)\n- [4. 获得 MySQL 连接，执行 SQL](#)\n- [5. 响应执行 SQL 结果](#)\n\n# 1. 概述\n\n> 内容形态以 顺序图 + 核心代码 为主。  \n> 如果有地方表述不错误或者不清晰，欢迎留言。  \n> 对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。  \n> 微信号：wangwenbin-server。\n\n本文讲解 【单库单表】插入 所涉及到的代码。交互如下图：\n\n![单库单表插入简图](http://www.yunai.me/images/MyCAT/2017_05_29/05.png)\n\n整个过程，MyCAT Server 流程如下：\n\n1. 接收 MySQL Client 请求，解析 SQL。\n2. 获得路由结果，进行路由。\n3. 获得 MySQL 连接，执行 SQL。\n4. 响应执行结果，发送结果给 MySQL Client。\n\n我们逐个步骤分析，一起来看看源码。\n\n# 2. 接收请求，解析 SQL\n\n![【单库单表】插入（01主流程）](http://www.yunai.me/images/MyCAT/2017_05_29/01.png)\n\n## 【 1 - 2 】\n\n接收**一条** MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。\n\n## 【 3 】\n\n不同 MySQL 命令，分发到不同的方法执行。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendCommandHandler.java】\n  2: public class FrontendCommandHandler implements NIOHandler {\n  3: \n  4:     @Override\n  5:     public void handle(byte[] data) {\n  6:     \n  7:         // .... 省略部分代码\n  8:         switch (data[4]) // \n  9:         {\n 10:             case MySQLPacket.COM_INIT_DB:\n 11:                 commands.doInitDB();\n 12:                 source.initDB(data);\n 13:                 break;\n 14:             case MySQLPacket.COM_QUERY: // 查询命令\n 15:                 // 计数查询命令\n 16:                 commands.doQuery();\n 17:                 // 执行查询命令\n 18:                 source.query(data);\n 19:                 break;\n 20:             case MySQLPacket.COM_PING:\n 21:                 commands.doPing();\n 22:                 source.ping();\n 23:                 break;\n 24:             // .... 省略部分case\n 25:         }\n 26:     }\n 27: \n 28: }\n```\n\n`INSERT`/`SELECT`/`UPDATE`/`DELETE` 等 SQL 归属于 `MySQLPacket.COM_QUERY`，详细可见：[《MySQL协议分析#4.2 客户端命令请求报文（客户端 -> 服务器）》](http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-)。\n\n##【 4 】\n\n将 二进制数组 解析成 SQL。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendConnection.java】\n  2: public void query(byte[] data) {\n  3: \t// 取得语句\n  4: \tString sql = null;\t\t\n  5: \ttry {\n  6: \t\tMySQLMessage mm = new MySQLMessage(data);\n  7: \t\tmm.position(5);\n  8: \t\tsql = mm.readString(charset);\n  9: \t} catch (UnsupportedEncodingException e) {\n 10: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown charset '\" + charset + \"'\");\n 11: \t\treturn;\n 12: \t}\t\t\n 13: \t// 执行语句\n 14: \tthis.query( sql );\n 15: }\n```\n\n##【 5 】\n\n解析 SQL 类型。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerQueryHandler.java】\n  2: @Override\n  3: public void query(String sql) {\n  4: \t// 解析 SQL 类型\n  5: \tint rs = ServerParse.parse(sql);\n  6: \tint sqlType = rs & 0xff;\n  7: \t\n  8: \tswitch (sqlType) {\n  9: \t//explain sql\n 10: \tcase ServerParse.EXPLAIN:\n 11: \t\tExplainHandler.handle(sql, c, rs >>> 8);\n 12: \t\tbreak;\n 13: \t// .... 省略部分case\n 14: \t\tbreak;\n 15: \tcase ServerParse.SELECT:\n 16: \t\tSelectHandler.handle(sql, c, rs >>> 8);\n 17: \t\tbreak;\n 18: \t// .... 省略部分case\n 19: \tdefault:\n 20: \t\tif(readOnly){\n 21: \t\t\tLOGGER.warn(new StringBuilder().append(\"User readonly:\").append(sql).toString());\n 22: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, \"User readonly\");\n 23: \t\t\tbreak;\n 24: \t\t}\n 25: \t\tc.execute(sql, rs & 0xff);\n 26: \t}\n 27: }\n 28: \n 29:\n 30: // ⬇️⬇️⬇️【ServerParse.java】\n 31: public static int parse(String stmt) {\n 32: \tint length = stmt.length();\n 33: \t//FIX BUG FOR SQL SUCH AS /XXXX/SQL\n 34: \tint rt = -1;\n 35: \tfor (int i = 0; i < length; ++i) {\n 36: \t\tswitch (stmt.charAt(i)) {\n 37: \t\t// .... 省略部分case\t\t\tcase 'I':\n 38: \t\tcase 'i':\n 39: \t\t\trt = insertCheck(stmt, i);\n 40: \t\t\tif (rt != OTHER) {\n 41: \t\t\t\treturn rt;\n 42: \t\t\t}\n 43: \t\t\tcontinue;\n 44: \t\t\t// .... 省略部分case\n 45: \t\tcase 'S':\n 46: \t\tcase 's':\n 47: \t\t\trt = sCheck(stmt, i);\n 48: \t\t\tif (rt != OTHER) {\n 49: \t\t\t\treturn rt;\n 50: \t\t\t}\n 51: \t\t\tcontinue;\n 52: \t\t\t// .... 省略部分case\n 53: \t\tdefault:\n 54: \t\t\tcontinue;\n 55: \t\t}\n 56: \t}\n 57: \treturn OTHER;\n 58: }\n```\n\n##【 6 】\n\n执行 SQL，详细解析见下文，核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerConnection.java】\n  2: public class ServerConnection extends FrontendConnection {\n  3: \tpublic void execute(String sql, int type) {\n  4: \t\t// .... 省略代码\n  5: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);\n  6: \t\tif (schema == null) {\n  7: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,\n  8: \t\t\t\t\t\"Unknown MyCAT Database '\" + db + \"'\");\n  9: \t\t\treturn;\n 10: \t\t}\n 11: \n 12: \t\t// .... 省略代码\n 13: \n 14: \t\t// 路由到后端数据库，执行 SQL\n 15: \t\trouteEndExecuteSQL(sql, type, schema);\n 16: \t}\n 17: \t\n 18:     public void routeEndExecuteSQL(String sql, final int type, final SchemaConfig schema) {\n 19: \t\t// 路由计算\n 20: \t\tRouteResultset rrs = null;\n 21: \t\ttry {\n 22: \t\t\trrs = MycatServer\n 23: \t\t\t\t\t.getInstance()\n 24: \t\t\t\t\t.getRouterservice()\n 25: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),\n 26: \t\t\t\t\t\t\tschema, type, sql, this.charset, this);\n 27: \n 28: \t\t} catch (Exception e) {\n 29: \t\t\tStringBuilder s = new StringBuilder();\n 30: \t\t\tLOGGER.warn(s.append(this).append(sql).toString() + \" err:\" + e.toString(),e);\n 31: \t\t\tString msg = e.getMessage();\n 32: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);\n 33: \t\t\treturn;\n 34: \t\t}\n 35: \n 36: \t\t// 执行 SQL\n 37: \t\tif (rrs != null) {\n 38: \t\t\t// session执行\n 39: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);\n 40: \t\t}\n 41: \t\t\n 42:  \t}\n 43: \n 44: }\n```\n\n# 3. 获得路由结果\n\n![【单库单表】插入（02获取路由）](http://www.yunai.me/images/MyCAT/2017_05_29/02.png)\n\n## 【 1 - 2 】【 12 】\n\n获得路由主流程。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RouteService.java】\n  2: public RouteResultset route(SystemConfig sysconf, SchemaConfig schema,\n  3: \t\tint sqlType, String stmt, String charset, ServerConnection sc)\n  4: \t\tthrows SQLNonTransientException {\n  5: \tRouteResultset rrs = null;\n  6: \t// .... 省略代码\n  7: \tint hintLength = RouteService.isHintSql(stmt);\n  8: \tif(hintLength != -1){ // TODO 待读：hint\n  9: \t\t// .... 省略代码\n 10: \t\t}\n 11: \t} else {\n 12: \t\tstmt = stmt.trim();\n 13: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,\n 14: \t\t\t\tcharset, sc, tableId2DataNodeCache);\n 15: \t}\n 16: \n 17: \t// .... 省略代码\t\treturn rrs;\n 18: }\n 19: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n 20: @Override\n 21: public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String origSQL,\n 22: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) throws SQLNonTransientException {\n 23: \n 24: \t// .... 省略代码\n 25: \n 26: \t// 处理一些路由之前的逻辑;全局序列号，父子表插入\n 27: \tif (beforeRouteProcess(schema, sqlType, origSQL, sc) ) {\n 28: \t\treturn null;\n 29: \t}\n 30: \n 31: \t// .... 省略代码\n 32: \n 33: \t// 检查是否有分片\n 34: \tif (schema.isNoSharding() && ServerParse.SHOW != sqlType) {\n 35: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);\n 36: \t} else {\n 37: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);\n 38: \t\tif (returnedSet == null) {\n 39: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);\n 40: \t\t}\n 41: \t}\n 42: \n 43: \treturn rrs;\n 44: }\n```\n\n_**路由** 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。_\n\n## 【 3 - 6 】\n\n路由**前置**处理。当符合如下三种情况下，进行处理：  \n\n{ 1 } 使用**全局序列号**：\n\n```SQL\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n```\n \n{ 2 } ER 子表插入  \n{ 3 } 主键使用自增 ID 插入：\n\n```SQL\ninsert into table (name) values ('name')\n===>\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n```  \n\n情况 { 1 } { 3 } 情况类似，使用全局序列号。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n  2: private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)\n  3: \t\tthrows SQLNonTransientException {\n  4: \treturn  // 处理 id 使用 全局序列号\n  5:             RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)\n  6:             // 处理 ER 子表\n  7: \t\t\t|| (sqlType == ServerParse.INSERT && RouterUtil.processERChildTable(schema, origSQL, sc))\n  8:             // 处理 id 自增长\n  9: \t\t\t|| (sqlType == ServerParse.INSERT && RouterUtil.processInsert(schema, sqlType, origSQL, sc));\n 10: }\n```\n\n`RouterUtil.java` 处理 SQL 考虑性能，实现会比较 C-style，代码咱就不贴了，传送门：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。 （😈该仓库从官方 Fork，逐步完善中文注释，欢迎 Star）\n\n## 【 7 - 11 】\n\n当**前置**路由处理**全局序列号**时，添加到全局序列处理器（`MyCATSequnceProcessor`）。该处理器会异步生成 ID，替换 SQL 内的 `NEXT VALUE FOR MYCATSEQ_` 正则。例如：\n\n```SQL\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n===>\ninsert into table (id, name) values (868348974560579584, 'name')\n```\n\n异步处理完后，调用 `ServerConnection#routeEndExecuteSQL(sql, type, schema)` 方法重新执行 SQL。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RouterUtil.java】\n  2: public static void processSQL(ServerConnection sc,SchemaConfig schema,String sql,int sqlType){\n  3: \tSessionSQLPair sessionSQLPair = new SessionSQLPair(sc.getSession2(), schema, sql, sqlType);\n  4: \tMycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);\n  5: }\n  6: // ⬇️⬇️⬇️【MyCATSequnceProcessor.java】\n  7: public class MyCATSequnceProcessor {\n  8: \tprivate LinkedBlockingQueue<SessionSQLPair> seqSQLQueue = new LinkedBlockingQueue<SessionSQLPair>();\n  9: \tprivate volatile boolean running=true;\n 10: \t\n 11: \tpublic void addNewSql(SessionSQLPair pair) {\n 12: \t\tseqSQLQueue.add(pair);\n 13: \t}\n 14: \n 15: \tprivate void executeSeq(SessionSQLPair pair) {\n 16: \t\ttry {\n 17: \t\t\t\n 18: \t\t\t// 使用Druid解析器实现sequence处理  @兵临城下\n 19: \t\t\tDruidSequenceHandler sequenceHandler = new DruidSequenceHandler(MycatServer\n 20: \t\t\t\t\t.getInstance().getConfig().getSystem().getSequnceHandlerType());\n 21: \n 22: \t\t\t// 生成可执行 SQL ：目前主要是生成 id\n 23: \t\t\tString charset = pair.session.getSource().getCharset();\n 24: \t\t\tString executeSql = sequenceHandler.getExecuteSql(pair.sql,charset == null ? \"utf-8\":charset);\n 25: \n 26: \t\t\t// 执行 SQL\n 27: \t\t\tpair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);\n 28: \t\t} catch (Exception e) {\n 29: \t\t\tLOGGER.error(\"MyCATSequenceProcessor.executeSeq(SesionSQLPair)\",e);\n 30: \t\t\tpair.session.getSource().writeErrMessage(ErrorCode.ER_YES,\"mycat sequnce err.\" + e);\n 31: \t\t\treturn;\n 32: \t\t}\n 33: \t}\n 34: \t\n 35: \tclass ExecuteThread extends Thread {\n 36: \t\t\n 37: \t\tpublic ExecuteThread() {\n 38: \t\t\tsetDaemon(true); // 设置为后台线程,防止throw RuntimeExecption进程仍然存在的问题\n 39: \t\t}\n 40: \t\t\n 41: \t\tpublic void run() {\n 42: \t\t\twhile (running) {\n 43: \t\t\t\ttry {\n 44: \t\t\t\t\tSessionSQLPair pair=seqSQLQueue.poll(100,TimeUnit.MILLISECONDS);\n 45: \t\t\t\t\tif(pair!=null){\n 46:                         executeSeq(pair);\n 47: \t\t\t\t\t}\n 48: \t\t\t\t} catch (Exception e) {\n 49: \t\t\t\t\tLOGGER.warn(\"MyCATSequenceProcessor$ExecutorThread\",e);\n 50: \t\t\t\t}\n 51: \t\t\t}\n 52: \t\t}\n 53: \t}\n 54: }\n```\n\n❓此处有个疑问：`MyCATSequnceProcessor` 是单线程，会不会插入性能有一定的影响？后续咱做下性能测试。\n\n# 4. 获得 MySQL 连接，执行 SQL\n\n![【单库单表】插入（03执行 SQL）](http://www.yunai.me/images/MyCAT/2017_05_29/03.png)\n\n## 【 1 - 8 】\n\n获得 MySQL 连接。\n\n* PhysicalDBNode ：物理数据库节点。\n* PhysicalDatasource ：物理数据库数据源。\n\n## 【 9 - 13 】\n\n发送 SQL 到 MySQL Server，执行 SQL。\n\n# 5. 响应执行 SQL 结果\n\n![【单库单表】插入（04执行响应）](http://www.yunai.me/images/MyCAT/2017_05_29/04.png)\n\n## 【 1 - 4 】\n\n处理 MySQL Server 响应数据包。\n\n## 【 5 - 8 】\n\n发送插入成功结果给 MySQL Client。\n\n\n","source":"_posts/MyCAT/2017_05_29_MyCAT源码分析——【单库单表】插入.md","raw":"title: MyCAT 源码分析 —— 【单库单表】插入\ndate: 2017-05-29\ntags:\ncategories: MyCAT\npermalink: MyCAT/single-db-single-table-insert\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/single-db-single-table-insert/](http://www.yunai.me/MyCAT/single-db-single-table-insert/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 接收请求，解析 SQL](#)\n- [3. 获得路由结果](#)\n- [4. 获得 MySQL 连接，执行 SQL](#)\n- [5. 响应执行 SQL 结果](#)\n\n# 1. 概述\n\n> 内容形态以 顺序图 + 核心代码 为主。  \n> 如果有地方表述不错误或者不清晰，欢迎留言。  \n> 对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。  \n> 微信号：wangwenbin-server。\n\n本文讲解 【单库单表】插入 所涉及到的代码。交互如下图：\n\n![单库单表插入简图](http://www.yunai.me/images/MyCAT/2017_05_29/05.png)\n\n整个过程，MyCAT Server 流程如下：\n\n1. 接收 MySQL Client 请求，解析 SQL。\n2. 获得路由结果，进行路由。\n3. 获得 MySQL 连接，执行 SQL。\n4. 响应执行结果，发送结果给 MySQL Client。\n\n我们逐个步骤分析，一起来看看源码。\n\n# 2. 接收请求，解析 SQL\n\n![【单库单表】插入（01主流程）](http://www.yunai.me/images/MyCAT/2017_05_29/01.png)\n\n## 【 1 - 2 】\n\n接收**一条** MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。\n\n## 【 3 】\n\n不同 MySQL 命令，分发到不同的方法执行。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendCommandHandler.java】\n  2: public class FrontendCommandHandler implements NIOHandler {\n  3: \n  4:     @Override\n  5:     public void handle(byte[] data) {\n  6:     \n  7:         // .... 省略部分代码\n  8:         switch (data[4]) // \n  9:         {\n 10:             case MySQLPacket.COM_INIT_DB:\n 11:                 commands.doInitDB();\n 12:                 source.initDB(data);\n 13:                 break;\n 14:             case MySQLPacket.COM_QUERY: // 查询命令\n 15:                 // 计数查询命令\n 16:                 commands.doQuery();\n 17:                 // 执行查询命令\n 18:                 source.query(data);\n 19:                 break;\n 20:             case MySQLPacket.COM_PING:\n 21:                 commands.doPing();\n 22:                 source.ping();\n 23:                 break;\n 24:             // .... 省略部分case\n 25:         }\n 26:     }\n 27: \n 28: }\n```\n\n`INSERT`/`SELECT`/`UPDATE`/`DELETE` 等 SQL 归属于 `MySQLPacket.COM_QUERY`，详细可见：[《MySQL协议分析#4.2 客户端命令请求报文（客户端 -> 服务器）》](http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-)。\n\n##【 4 】\n\n将 二进制数组 解析成 SQL。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendConnection.java】\n  2: public void query(byte[] data) {\n  3: \t// 取得语句\n  4: \tString sql = null;\t\t\n  5: \ttry {\n  6: \t\tMySQLMessage mm = new MySQLMessage(data);\n  7: \t\tmm.position(5);\n  8: \t\tsql = mm.readString(charset);\n  9: \t} catch (UnsupportedEncodingException e) {\n 10: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown charset '\" + charset + \"'\");\n 11: \t\treturn;\n 12: \t}\t\t\n 13: \t// 执行语句\n 14: \tthis.query( sql );\n 15: }\n```\n\n##【 5 】\n\n解析 SQL 类型。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerQueryHandler.java】\n  2: @Override\n  3: public void query(String sql) {\n  4: \t// 解析 SQL 类型\n  5: \tint rs = ServerParse.parse(sql);\n  6: \tint sqlType = rs & 0xff;\n  7: \t\n  8: \tswitch (sqlType) {\n  9: \t//explain sql\n 10: \tcase ServerParse.EXPLAIN:\n 11: \t\tExplainHandler.handle(sql, c, rs >>> 8);\n 12: \t\tbreak;\n 13: \t// .... 省略部分case\n 14: \t\tbreak;\n 15: \tcase ServerParse.SELECT:\n 16: \t\tSelectHandler.handle(sql, c, rs >>> 8);\n 17: \t\tbreak;\n 18: \t// .... 省略部分case\n 19: \tdefault:\n 20: \t\tif(readOnly){\n 21: \t\t\tLOGGER.warn(new StringBuilder().append(\"User readonly:\").append(sql).toString());\n 22: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, \"User readonly\");\n 23: \t\t\tbreak;\n 24: \t\t}\n 25: \t\tc.execute(sql, rs & 0xff);\n 26: \t}\n 27: }\n 28: \n 29:\n 30: // ⬇️⬇️⬇️【ServerParse.java】\n 31: public static int parse(String stmt) {\n 32: \tint length = stmt.length();\n 33: \t//FIX BUG FOR SQL SUCH AS /XXXX/SQL\n 34: \tint rt = -1;\n 35: \tfor (int i = 0; i < length; ++i) {\n 36: \t\tswitch (stmt.charAt(i)) {\n 37: \t\t// .... 省略部分case\t\t\tcase 'I':\n 38: \t\tcase 'i':\n 39: \t\t\trt = insertCheck(stmt, i);\n 40: \t\t\tif (rt != OTHER) {\n 41: \t\t\t\treturn rt;\n 42: \t\t\t}\n 43: \t\t\tcontinue;\n 44: \t\t\t// .... 省略部分case\n 45: \t\tcase 'S':\n 46: \t\tcase 's':\n 47: \t\t\trt = sCheck(stmt, i);\n 48: \t\t\tif (rt != OTHER) {\n 49: \t\t\t\treturn rt;\n 50: \t\t\t}\n 51: \t\t\tcontinue;\n 52: \t\t\t// .... 省略部分case\n 53: \t\tdefault:\n 54: \t\t\tcontinue;\n 55: \t\t}\n 56: \t}\n 57: \treturn OTHER;\n 58: }\n```\n\n##【 6 】\n\n执行 SQL，详细解析见下文，核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerConnection.java】\n  2: public class ServerConnection extends FrontendConnection {\n  3: \tpublic void execute(String sql, int type) {\n  4: \t\t// .... 省略代码\n  5: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);\n  6: \t\tif (schema == null) {\n  7: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,\n  8: \t\t\t\t\t\"Unknown MyCAT Database '\" + db + \"'\");\n  9: \t\t\treturn;\n 10: \t\t}\n 11: \n 12: \t\t// .... 省略代码\n 13: \n 14: \t\t// 路由到后端数据库，执行 SQL\n 15: \t\trouteEndExecuteSQL(sql, type, schema);\n 16: \t}\n 17: \t\n 18:     public void routeEndExecuteSQL(String sql, final int type, final SchemaConfig schema) {\n 19: \t\t// 路由计算\n 20: \t\tRouteResultset rrs = null;\n 21: \t\ttry {\n 22: \t\t\trrs = MycatServer\n 23: \t\t\t\t\t.getInstance()\n 24: \t\t\t\t\t.getRouterservice()\n 25: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),\n 26: \t\t\t\t\t\t\tschema, type, sql, this.charset, this);\n 27: \n 28: \t\t} catch (Exception e) {\n 29: \t\t\tStringBuilder s = new StringBuilder();\n 30: \t\t\tLOGGER.warn(s.append(this).append(sql).toString() + \" err:\" + e.toString(),e);\n 31: \t\t\tString msg = e.getMessage();\n 32: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);\n 33: \t\t\treturn;\n 34: \t\t}\n 35: \n 36: \t\t// 执行 SQL\n 37: \t\tif (rrs != null) {\n 38: \t\t\t// session执行\n 39: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);\n 40: \t\t}\n 41: \t\t\n 42:  \t}\n 43: \n 44: }\n```\n\n# 3. 获得路由结果\n\n![【单库单表】插入（02获取路由）](http://www.yunai.me/images/MyCAT/2017_05_29/02.png)\n\n## 【 1 - 2 】【 12 】\n\n获得路由主流程。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RouteService.java】\n  2: public RouteResultset route(SystemConfig sysconf, SchemaConfig schema,\n  3: \t\tint sqlType, String stmt, String charset, ServerConnection sc)\n  4: \t\tthrows SQLNonTransientException {\n  5: \tRouteResultset rrs = null;\n  6: \t// .... 省略代码\n  7: \tint hintLength = RouteService.isHintSql(stmt);\n  8: \tif(hintLength != -1){ // TODO 待读：hint\n  9: \t\t// .... 省略代码\n 10: \t\t}\n 11: \t} else {\n 12: \t\tstmt = stmt.trim();\n 13: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,\n 14: \t\t\t\tcharset, sc, tableId2DataNodeCache);\n 15: \t}\n 16: \n 17: \t// .... 省略代码\t\treturn rrs;\n 18: }\n 19: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n 20: @Override\n 21: public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String origSQL,\n 22: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) throws SQLNonTransientException {\n 23: \n 24: \t// .... 省略代码\n 25: \n 26: \t// 处理一些路由之前的逻辑;全局序列号，父子表插入\n 27: \tif (beforeRouteProcess(schema, sqlType, origSQL, sc) ) {\n 28: \t\treturn null;\n 29: \t}\n 30: \n 31: \t// .... 省略代码\n 32: \n 33: \t// 检查是否有分片\n 34: \tif (schema.isNoSharding() && ServerParse.SHOW != sqlType) {\n 35: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);\n 36: \t} else {\n 37: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);\n 38: \t\tif (returnedSet == null) {\n 39: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);\n 40: \t\t}\n 41: \t}\n 42: \n 43: \treturn rrs;\n 44: }\n```\n\n_**路由** 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。_\n\n## 【 3 - 6 】\n\n路由**前置**处理。当符合如下三种情况下，进行处理：  \n\n{ 1 } 使用**全局序列号**：\n\n```SQL\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n```\n \n{ 2 } ER 子表插入  \n{ 3 } 主键使用自增 ID 插入：\n\n```SQL\ninsert into table (name) values ('name')\n===>\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n```  \n\n情况 { 1 } { 3 } 情况类似，使用全局序列号。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n  2: private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)\n  3: \t\tthrows SQLNonTransientException {\n  4: \treturn  // 处理 id 使用 全局序列号\n  5:             RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)\n  6:             // 处理 ER 子表\n  7: \t\t\t|| (sqlType == ServerParse.INSERT && RouterUtil.processERChildTable(schema, origSQL, sc))\n  8:             // 处理 id 自增长\n  9: \t\t\t|| (sqlType == ServerParse.INSERT && RouterUtil.processInsert(schema, sqlType, origSQL, sc));\n 10: }\n```\n\n`RouterUtil.java` 处理 SQL 考虑性能，实现会比较 C-style，代码咱就不贴了，传送门：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。 （😈该仓库从官方 Fork，逐步完善中文注释，欢迎 Star）\n\n## 【 7 - 11 】\n\n当**前置**路由处理**全局序列号**时，添加到全局序列处理器（`MyCATSequnceProcessor`）。该处理器会异步生成 ID，替换 SQL 内的 `NEXT VALUE FOR MYCATSEQ_` 正则。例如：\n\n```SQL\ninsert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')\n===>\ninsert into table (id, name) values (868348974560579584, 'name')\n```\n\n异步处理完后，调用 `ServerConnection#routeEndExecuteSQL(sql, type, schema)` 方法重新执行 SQL。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RouterUtil.java】\n  2: public static void processSQL(ServerConnection sc,SchemaConfig schema,String sql,int sqlType){\n  3: \tSessionSQLPair sessionSQLPair = new SessionSQLPair(sc.getSession2(), schema, sql, sqlType);\n  4: \tMycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);\n  5: }\n  6: // ⬇️⬇️⬇️【MyCATSequnceProcessor.java】\n  7: public class MyCATSequnceProcessor {\n  8: \tprivate LinkedBlockingQueue<SessionSQLPair> seqSQLQueue = new LinkedBlockingQueue<SessionSQLPair>();\n  9: \tprivate volatile boolean running=true;\n 10: \t\n 11: \tpublic void addNewSql(SessionSQLPair pair) {\n 12: \t\tseqSQLQueue.add(pair);\n 13: \t}\n 14: \n 15: \tprivate void executeSeq(SessionSQLPair pair) {\n 16: \t\ttry {\n 17: \t\t\t\n 18: \t\t\t// 使用Druid解析器实现sequence处理  @兵临城下\n 19: \t\t\tDruidSequenceHandler sequenceHandler = new DruidSequenceHandler(MycatServer\n 20: \t\t\t\t\t.getInstance().getConfig().getSystem().getSequnceHandlerType());\n 21: \n 22: \t\t\t// 生成可执行 SQL ：目前主要是生成 id\n 23: \t\t\tString charset = pair.session.getSource().getCharset();\n 24: \t\t\tString executeSql = sequenceHandler.getExecuteSql(pair.sql,charset == null ? \"utf-8\":charset);\n 25: \n 26: \t\t\t// 执行 SQL\n 27: \t\t\tpair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);\n 28: \t\t} catch (Exception e) {\n 29: \t\t\tLOGGER.error(\"MyCATSequenceProcessor.executeSeq(SesionSQLPair)\",e);\n 30: \t\t\tpair.session.getSource().writeErrMessage(ErrorCode.ER_YES,\"mycat sequnce err.\" + e);\n 31: \t\t\treturn;\n 32: \t\t}\n 33: \t}\n 34: \t\n 35: \tclass ExecuteThread extends Thread {\n 36: \t\t\n 37: \t\tpublic ExecuteThread() {\n 38: \t\t\tsetDaemon(true); // 设置为后台线程,防止throw RuntimeExecption进程仍然存在的问题\n 39: \t\t}\n 40: \t\t\n 41: \t\tpublic void run() {\n 42: \t\t\twhile (running) {\n 43: \t\t\t\ttry {\n 44: \t\t\t\t\tSessionSQLPair pair=seqSQLQueue.poll(100,TimeUnit.MILLISECONDS);\n 45: \t\t\t\t\tif(pair!=null){\n 46:                         executeSeq(pair);\n 47: \t\t\t\t\t}\n 48: \t\t\t\t} catch (Exception e) {\n 49: \t\t\t\t\tLOGGER.warn(\"MyCATSequenceProcessor$ExecutorThread\",e);\n 50: \t\t\t\t}\n 51: \t\t\t}\n 52: \t\t}\n 53: \t}\n 54: }\n```\n\n❓此处有个疑问：`MyCATSequnceProcessor` 是单线程，会不会插入性能有一定的影响？后续咱做下性能测试。\n\n# 4. 获得 MySQL 连接，执行 SQL\n\n![【单库单表】插入（03执行 SQL）](http://www.yunai.me/images/MyCAT/2017_05_29/03.png)\n\n## 【 1 - 8 】\n\n获得 MySQL 连接。\n\n* PhysicalDBNode ：物理数据库节点。\n* PhysicalDatasource ：物理数据库数据源。\n\n## 【 9 - 13 】\n\n发送 SQL 到 MySQL Server，执行 SQL。\n\n# 5. 响应执行 SQL 结果\n\n![【单库单表】插入（04执行响应）](http://www.yunai.me/images/MyCAT/2017_05_29/04.png)\n\n## 【 1 - 4 】\n\n处理 MySQL Server 响应数据包。\n\n## 【 5 - 8 】\n\n发送插入成功结果给 MySQL Client。\n\n\n","slug":"MyCAT/single-db-single-table-insert","published":1,"updated":"2017-07-11T09:45:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kz9z0009ag5dm4tfb0fv","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-insert/\">http://www.yunai.me/MyCAT/single-db-single-table-insert/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 接收请求，解析 SQL</a></li>\n<li><a href=\"#\">3. 获得路由结果</a></li>\n<li><a href=\"#\">4. 获得 MySQL 连接，执行 SQL</a></li>\n<li><a href=\"#\">5. 响应执行 SQL 结果</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><blockquote>\n<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>\n</blockquote>\n<p>本文讲解 【单库单表】插入 所涉及到的代码。交互如下图：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/05.png\" alt=\"单库单表插入简图\"></p>\n<p>整个过程，MyCAT Server 流程如下：</p>\n<ol>\n<li>接收 MySQL Client 请求，解析 SQL。</li>\n<li>获得路由结果，进行路由。</li>\n<li>获得 MySQL 连接，执行 SQL。</li>\n<li>响应执行结果，发送结果给 MySQL Client。</li>\n</ol>\n<p>我们逐个步骤分析，一起来看看源码。</p>\n<h1 id=\"2-接收请求，解析-SQL\"><a href=\"#2-接收请求，解析-SQL\" class=\"headerlink\" title=\"2. 接收请求，解析 SQL\"></a>2. 接收请求，解析 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/01.png\" alt=\"【单库单表】插入（01主流程）\"></p>\n<h2 id=\"【-1-2-】\"><a href=\"#【-1-2-】\" class=\"headerlink\" title=\"【 1 - 2 】\"></a>【 1 - 2 】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>\n<h2 id=\"【-3-】\"><a href=\"#【-3-】\" class=\"headerlink\" title=\"【 3 】\"></a>【 3 】</h2><p>不同 MySQL 命令，分发到不同的方法执行。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontendCommandHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">NIOHandler</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     </div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// .... 省略部分代码</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) <span class=\"comment\">// </span></div><div class=\"line\"> <span class=\"number\">9</span>:         &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_INIT_DB:</div><div class=\"line\"><span class=\"number\">11</span>:                 commands.doInitDB();</div><div class=\"line\"><span class=\"number\">12</span>:                 source.initDB(data);</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_QUERY: <span class=\"comment\">// 查询命令</span></div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 计数查询命令</span></div><div class=\"line\"><span class=\"number\">16</span>:                 commands.doQuery();</div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 执行查询命令</span></div><div class=\"line\"><span class=\"number\">18</span>:                 source.query(data);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_PING:</div><div class=\"line\"><span class=\"number\">21</span>:                 commands.doPing();</div><div class=\"line\"><span class=\"number\">22</span>:                 source.ping();</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div></pre></td></tr></table></figure>\n<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href=\"http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>\n<p>##【 4 】</p>\n<p>将 二进制数组 解析成 SQL。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"comment\">// 取得语句</span></div><div class=\"line\"> <span class=\"number\">4</span>: \tString sql = <span class=\"keyword\">null</span>;\t\t</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>: \t\tMySQLMessage mm = <span class=\"keyword\">new</span> MySQLMessage(data);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\tmm.position(<span class=\"number\">5</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: \t\tsql = mm.readString(charset);</div><div class=\"line\"> <span class=\"number\">9</span>: \t&#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</div><div class=\"line\"><span class=\"number\">10</span>: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class=\"string\">\"Unknown charset '\"</span> + charset + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">12</span>: \t&#125;\t\t</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// 执行语句</span></div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">this</span>.query( sql );</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<p>##【 5 】</p>\n<p>解析 SQL 类型。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(String sql)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"comment\">// 解析 SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">int</span> rs = ServerParse.parse(sql);</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"keyword\">int</span> sqlType = rs &amp; <span class=\"number\">0xff</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: \t</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">switch</span> (sqlType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"comment\">//explain sql</span></div><div class=\"line\"><span class=\"number\">10</span>: \t<span class=\"keyword\">case</span> ServerParse.EXPLAIN:</div><div class=\"line\"><span class=\"number\">11</span>: \t\tExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"keyword\">case</span> ServerParse.SELECT:</div><div class=\"line\"><span class=\"number\">16</span>: \t\tSelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">17</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">20</span>: \t\t<span class=\"keyword\">if</span>(readOnly)&#123;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t\tLOGGER.warn(<span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">\"User readonly:\"</span>).append(sql).toString());</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class=\"string\">\"User readonly\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">25</span>: \t\tc.execute(sql, rs &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\"><span class=\"number\">26</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:</div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">32</span>: \t<span class=\"keyword\">int</span> length = stmt.length();</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">int</span> rt = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"comment\">// .... 省略部分case\t\t\tcase 'I':</span></div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'i'</span>:</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trt = insertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">45</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'S'</span>:</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\trt = sCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">56</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">58</span>: &#125;</div></pre></td></tr></table></figure>\n<p>##【 6 】</p>\n<p>执行 SQL，详细解析见下文，核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrontendConnection</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(String sql, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\t\t\t<span class=\"string\">\"Unknown MyCAT Database '\"</span> + db + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"comment\">// 路由到后端数据库，执行 SQL</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\trouteEndExecuteSQL(sql, type, schema);</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: \t</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">routeEndExecuteSQL</span><span class=\"params\">(String sql, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"comment\">// 路由计算</span></div><div class=\"line\"><span class=\"number\">20</span>: \t\tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\trrs = MycatServer</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t\t\t.getInstance()</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\t\t\t.getRouterservice()</div><div class=\"line\"><span class=\"number\">25</span>: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\t\t\t\tschema, type, sql, <span class=\"keyword\">this</span>.charset, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tStringBuilder s = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tLOGGER.warn(s.append(<span class=\"keyword\">this</span>).append(sql).toString() + <span class=\"string\">\" err:\"</span> + e.toString(),e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\tString msg = e.getMessage();</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class=\"keyword\">null</span> ? e.getClass().getSimpleName() : msg);</div><div class=\"line\"><span class=\"number\">33</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">34</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\t<span class=\"comment\">// session执行</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t</div><div class=\"line\"><span class=\"number\">42</span>:  \t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: </div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-获得路由结果\"><a href=\"#3-获得路由结果\" class=\"headerlink\" title=\"3. 获得路由结果\"></a>3. 获得路由结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/02.png\" alt=\"【单库单表】插入（02获取路由）\"></p>\n<h2 id=\"【-1-2-】【-12-】\"><a href=\"#【-1-2-】【-12-】\" class=\"headerlink\" title=\"【 1 - 2 】【 12 】\"></a>【 1 - 2 】【 12 】</h2><p>获得路由主流程。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RouteService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class=\"line\"> <span class=\"number\">3</span>: \t\t<span class=\"keyword\">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class=\"line\"> 4: \t\t<span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">7</span>: \t<span class=\"keyword\">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">if</span>(hintLength != -<span class=\"number\">1</span>)&#123; <span class=\"comment\">// TODO 待读：hint</span></div><div class=\"line\"> <span class=\"number\">9</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\tstmt = stmt.trim();</div><div class=\"line\"><span class=\"number\">13</span>: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\t\tcharset, sc, tableId2DataNodeCache);</div><div class=\"line\"><span class=\"number\">15</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>: \t<span class=\"comment\">// .... 省略代码\t\treturn rrs;</span></div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div><div class=\"line\"><span class=\"number\">19</span>: <span class=\"comment\">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class=\"line\"><span class=\"number\">20</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema, <span class=\"keyword\">int</span> sqlType, String origSQL,</span></span></div><div class=\"line\"><span class=\"number\">22</span>: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>: \t<span class=\"comment\">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class=\"line\"><span class=\"number\">27</span>: \t<span class=\"keyword\">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class=\"line\"><span class=\"number\">28</span>: \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">29</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">// 检查是否有分片</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class=\"line\"><span class=\"number\">35</span>: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class=\"line\"><span class=\"number\">36</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">if</span> (returnedSet == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>: \t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>\n<h2 id=\"【-3-6-】\"><a href=\"#【-3-6-】\" class=\"headerlink\" title=\"【 3 - 6 】\"></a>【 3 - 6 】</h2><p>路由<strong>前置</strong>处理。当符合如下三种情况下，进行处理：  </p>\n<p>{ 1 } 使用<strong>全局序列号</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"keyword\">NEXT</span> <span class=\"keyword\">VALUE</span> <span class=\"keyword\">FOR</span> MYCATSEQ_ID, <span class=\"string\">'name'</span>)</div></pre></td></tr></table></figure>\n<p>{ 2 } ER 子表插入<br>{ 3 } 主键使用自增 ID 插入：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">insert into table (name) values ('name')</div><div class=\"line\">===&gt;</div><div class=\"line\">insert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">情况 &#123; 1 &#125; &#123; 3 &#125; 情况类似，使用全局序列号。</div><div class=\"line\"></div><div class=\"line\">核心代码如下：</div><div class=\"line\"></div><div class=\"line\">```Java</div><div class=\"line\">  1: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】</div><div class=\"line\">  2: private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)</div><div class=\"line\">  3: \t\tthrows SQLNonTransientException &#123;</div><div class=\"line\">  4: \treturn  // 处理 id 使用 全局序列号</div><div class=\"line\">  5:             RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)</div><div class=\"line\">  6:             // 处理 ER 子表</div><div class=\"line\">  7: \t\t\t|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processERChildTable(schema, origSQL, sc))</div><div class=\"line\">  8:             // 处理 id 自增长</div><div class=\"line\">  9: \t\t\t|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processInsert(schema, sqlType, origSQL, sc));</div><div class=\"line\"> 10: &#125;</div></pre></td></tr></table></figure>\n<p><code>RouterUtil.java</code> 处理 SQL 考虑性能，实现会比较 C-style，代码咱就不贴了，传送门：<a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。</a> （😈该仓库从官方 Fork，逐步完善中文注释，欢迎 Star）</p>\n<h2 id=\"【-7-11-】\"><a href=\"#【-7-11-】\" class=\"headerlink\" title=\"【 7 - 11 】\"></a>【 7 - 11 】</h2><p>当<strong>前置</strong>路由处理<strong>全局序列号</strong>时，添加到全局序列处理器（<code>MyCATSequnceProcessor</code>）。该处理器会异步生成 ID，替换 SQL 内的 <code>NEXT VALUE FOR MYCATSEQ_</code> 正则。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"keyword\">NEXT</span> <span class=\"keyword\">VALUE</span> <span class=\"keyword\">FOR</span> MYCATSEQ_ID, <span class=\"string\">'name'</span>)</div><div class=\"line\">===&gt;</div><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"number\">868348974560579584</span>, <span class=\"string\">'name'</span>)</div></pre></td></tr></table></figure>\n<p>异步处理完后，调用 <code>ServerConnection#routeEndExecuteSQL(sql, type, schema)</code> 方法重新执行 SQL。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RouterUtil.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">processSQL</span><span class=\"params\">(ServerConnection sc,SchemaConfig schema,String sql,<span class=\"keyword\">int</span> sqlType)</span></span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \tSessionSQLPair sessionSQLPair = <span class=\"keyword\">new</span> SessionSQLPair(sc.getSession2(), schema, sql, sqlType);</div><div class=\"line\"> <span class=\"number\">4</span>: \tMycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);</div><div class=\"line\"> <span class=\"number\">5</span>: &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MyCATSequnceProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCATSequnceProcessor</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">private</span> LinkedBlockingQueue&lt;SessionSQLPair&gt; seqSQLQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;SessionSQLPair&gt;();</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running=<span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t</div><div class=\"line\"><span class=\"number\">11</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNewSql</span><span class=\"params\">(SessionSQLPair pair)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\tseqSQLQueue.add(pair);</div><div class=\"line\"><span class=\"number\">13</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeSeq</span><span class=\"params\">(SessionSQLPair pair)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>: \t\t\t</div><div class=\"line\"><span class=\"number\">18</span>: \t\t\t<span class=\"comment\">// 使用Druid解析器实现sequence处理  @兵临城下</span></div><div class=\"line\"><span class=\"number\">19</span>: \t\t\tDruidSequenceHandler sequenceHandler = <span class=\"keyword\">new</span> DruidSequenceHandler(MycatServer</div><div class=\"line\"><span class=\"number\">20</span>: \t\t\t\t\t.getInstance().getConfig().getSystem().getSequnceHandlerType());</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>: \t\t\t<span class=\"comment\">// 生成可执行 SQL ：目前主要是生成 id</span></div><div class=\"line\"><span class=\"number\">23</span>: \t\t\tString charset = pair.session.getSource().getCharset();</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\tString executeSql = sequenceHandler.getExecuteSql(pair.sql,charset == <span class=\"keyword\">null</span> ? <span class=\"string\">\"utf-8\"</span>:charset);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">27</span>: \t\t\tpair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);</div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tLOGGER.error(<span class=\"string\">\"MyCATSequenceProcessor.executeSeq(SesionSQLPair)\"</span>,e);</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tpair.session.getSource().writeErrMessage(ErrorCode.ER_YES,<span class=\"string\">\"mycat sequnce err.\"</span> + e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">32</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">33</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">34</span>: \t</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecuteThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecuteThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\tsetDaemon(<span class=\"keyword\">true</span>); <span class=\"comment\">// 设置为后台线程,防止throw RuntimeExecption进程仍然存在的问题</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">40</span>: \t\t</div><div class=\"line\"><span class=\"number\">41</span>: \t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t<span class=\"keyword\">while</span> (running) &#123;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t\t\tSessionSQLPair pair=seqSQLQueue.poll(<span class=\"number\">100</span>,TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\t\t\t<span class=\"keyword\">if</span>(pair!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\"><span class=\"number\">46</span>:                         executeSeq(pair);</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\t\t\t&#125;</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t\tLOGGER.warn(<span class=\"string\">\"MyCATSequenceProcessor$ExecutorThread\"</span>,e);</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">53</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div></pre></td></tr></table></figure>\n<p>❓此处有个疑问：<code>MyCATSequnceProcessor</code> 是单线程，会不会插入性能有一定的影响？后续咱做下性能测试。</p>\n<h1 id=\"4-获得-MySQL-连接，执行-SQL\"><a href=\"#4-获得-MySQL-连接，执行-SQL\" class=\"headerlink\" title=\"4. 获得 MySQL 连接，执行 SQL\"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/03.png\" alt=\"【单库单表】插入（03执行 SQL）\"></p>\n<h2 id=\"【-1-8-】\"><a href=\"#【-1-8-】\" class=\"headerlink\" title=\"【 1 - 8 】\"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>\n<ul>\n<li>PhysicalDBNode ：物理数据库节点。</li>\n<li>PhysicalDatasource ：物理数据库数据源。</li>\n</ul>\n<h2 id=\"【-9-13-】\"><a href=\"#【-9-13-】\" class=\"headerlink\" title=\"【 9 - 13 】\"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>\n<h1 id=\"5-响应执行-SQL-结果\"><a href=\"#5-响应执行-SQL-结果\" class=\"headerlink\" title=\"5. 响应执行 SQL 结果\"></a>5. 响应执行 SQL 结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/04.png\" alt=\"【单库单表】插入（04执行响应）\"></p>\n<h2 id=\"【-1-4-】\"><a href=\"#【-1-4-】\" class=\"headerlink\" title=\"【 1 - 4 】\"></a>【 1 - 4 】</h2><p>处理 MySQL Server 响应数据包。</p>\n<h2 id=\"【-5-8-】\"><a href=\"#【-5-8-】\" class=\"headerlink\" title=\"【 5 - 8 】\"></a>【 5 - 8 】</h2><p>发送插入成功结果给 MySQL Client。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-insert/\">http://www.yunai.me/MyCAT/single-db-single-table-insert/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 接收请求，解析 SQL</a></li>\n<li><a href=\"#\">3. 获得路由结果</a></li>\n<li><a href=\"#\">4. 获得 MySQL 连接，执行 SQL</a></li>\n<li><a href=\"#\">5. 响应执行 SQL 结果</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><blockquote>\n<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>\n</blockquote>\n<p>本文讲解 【单库单表】插入 所涉及到的代码。交互如下图：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/05.png\" alt=\"单库单表插入简图\"></p>\n<p>整个过程，MyCAT Server 流程如下：</p>\n<ol>\n<li>接收 MySQL Client 请求，解析 SQL。</li>\n<li>获得路由结果，进行路由。</li>\n<li>获得 MySQL 连接，执行 SQL。</li>\n<li>响应执行结果，发送结果给 MySQL Client。</li>\n</ol>\n<p>我们逐个步骤分析，一起来看看源码。</p>\n<h1 id=\"2-接收请求，解析-SQL\"><a href=\"#2-接收请求，解析-SQL\" class=\"headerlink\" title=\"2. 接收请求，解析 SQL\"></a>2. 接收请求，解析 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/01.png\" alt=\"【单库单表】插入（01主流程）\"></p>\n<h2 id=\"【-1-2-】\"><a href=\"#【-1-2-】\" class=\"headerlink\" title=\"【 1 - 2 】\"></a>【 1 - 2 】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>\n<h2 id=\"【-3-】\"><a href=\"#【-3-】\" class=\"headerlink\" title=\"【 3 】\"></a>【 3 】</h2><p>不同 MySQL 命令，分发到不同的方法执行。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontendCommandHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">NIOHandler</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     </div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// .... 省略部分代码</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) <span class=\"comment\">// </span></div><div class=\"line\"> <span class=\"number\">9</span>:         &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_INIT_DB:</div><div class=\"line\"><span class=\"number\">11</span>:                 commands.doInitDB();</div><div class=\"line\"><span class=\"number\">12</span>:                 source.initDB(data);</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_QUERY: <span class=\"comment\">// 查询命令</span></div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 计数查询命令</span></div><div class=\"line\"><span class=\"number\">16</span>:                 commands.doQuery();</div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 执行查询命令</span></div><div class=\"line\"><span class=\"number\">18</span>:                 source.query(data);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_PING:</div><div class=\"line\"><span class=\"number\">21</span>:                 commands.doPing();</div><div class=\"line\"><span class=\"number\">22</span>:                 source.ping();</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div></pre></td></tr></table></figure>\n<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href=\"http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>\n<p>##【 4 】</p>\n<p>将 二进制数组 解析成 SQL。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"comment\">// 取得语句</span></div><div class=\"line\"> <span class=\"number\">4</span>: \tString sql = <span class=\"keyword\">null</span>;\t\t</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>: \t\tMySQLMessage mm = <span class=\"keyword\">new</span> MySQLMessage(data);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\tmm.position(<span class=\"number\">5</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: \t\tsql = mm.readString(charset);</div><div class=\"line\"> <span class=\"number\">9</span>: \t&#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</div><div class=\"line\"><span class=\"number\">10</span>: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class=\"string\">\"Unknown charset '\"</span> + charset + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">12</span>: \t&#125;\t\t</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// 执行语句</span></div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">this</span>.query( sql );</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<p>##【 5 】</p>\n<p>解析 SQL 类型。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(String sql)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"comment\">// 解析 SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">int</span> rs = ServerParse.parse(sql);</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"keyword\">int</span> sqlType = rs &amp; <span class=\"number\">0xff</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: \t</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">switch</span> (sqlType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"comment\">//explain sql</span></div><div class=\"line\"><span class=\"number\">10</span>: \t<span class=\"keyword\">case</span> ServerParse.EXPLAIN:</div><div class=\"line\"><span class=\"number\">11</span>: \t\tExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"keyword\">case</span> ServerParse.SELECT:</div><div class=\"line\"><span class=\"number\">16</span>: \t\tSelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">17</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">20</span>: \t\t<span class=\"keyword\">if</span>(readOnly)&#123;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t\tLOGGER.warn(<span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">\"User readonly:\"</span>).append(sql).toString());</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class=\"string\">\"User readonly\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">25</span>: \t\tc.execute(sql, rs &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\"><span class=\"number\">26</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:</div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">32</span>: \t<span class=\"keyword\">int</span> length = stmt.length();</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">int</span> rt = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"comment\">// .... 省略部分case\t\t\tcase 'I':</span></div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'i'</span>:</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trt = insertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">45</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'S'</span>:</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\trt = sCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">56</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">58</span>: &#125;</div></pre></td></tr></table></figure>\n<p>##【 6 】</p>\n<p>执行 SQL，详细解析见下文，核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrontendConnection</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(String sql, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\t\t\t<span class=\"string\">\"Unknown MyCAT Database '\"</span> + db + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"comment\">// 路由到后端数据库，执行 SQL</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\trouteEndExecuteSQL(sql, type, schema);</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: \t</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">routeEndExecuteSQL</span><span class=\"params\">(String sql, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"comment\">// 路由计算</span></div><div class=\"line\"><span class=\"number\">20</span>: \t\tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\trrs = MycatServer</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t\t\t.getInstance()</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\t\t\t.getRouterservice()</div><div class=\"line\"><span class=\"number\">25</span>: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\t\t\t\tschema, type, sql, <span class=\"keyword\">this</span>.charset, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tStringBuilder s = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tLOGGER.warn(s.append(<span class=\"keyword\">this</span>).append(sql).toString() + <span class=\"string\">\" err:\"</span> + e.toString(),e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\tString msg = e.getMessage();</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class=\"keyword\">null</span> ? e.getClass().getSimpleName() : msg);</div><div class=\"line\"><span class=\"number\">33</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">34</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\t<span class=\"comment\">// session执行</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t</div><div class=\"line\"><span class=\"number\">42</span>:  \t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: </div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-获得路由结果\"><a href=\"#3-获得路由结果\" class=\"headerlink\" title=\"3. 获得路由结果\"></a>3. 获得路由结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/02.png\" alt=\"【单库单表】插入（02获取路由）\"></p>\n<h2 id=\"【-1-2-】【-12-】\"><a href=\"#【-1-2-】【-12-】\" class=\"headerlink\" title=\"【 1 - 2 】【 12 】\"></a>【 1 - 2 】【 12 】</h2><p>获得路由主流程。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RouteService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class=\"line\"> <span class=\"number\">3</span>: \t\t<span class=\"keyword\">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class=\"line\"> 4: \t\t<span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">7</span>: \t<span class=\"keyword\">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">if</span>(hintLength != -<span class=\"number\">1</span>)&#123; <span class=\"comment\">// TODO 待读：hint</span></div><div class=\"line\"> <span class=\"number\">9</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\tstmt = stmt.trim();</div><div class=\"line\"><span class=\"number\">13</span>: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\t\tcharset, sc, tableId2DataNodeCache);</div><div class=\"line\"><span class=\"number\">15</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>: \t<span class=\"comment\">// .... 省略代码\t\treturn rrs;</span></div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div><div class=\"line\"><span class=\"number\">19</span>: <span class=\"comment\">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class=\"line\"><span class=\"number\">20</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema, <span class=\"keyword\">int</span> sqlType, String origSQL,</span></span></div><div class=\"line\"><span class=\"number\">22</span>: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>: \t<span class=\"comment\">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class=\"line\"><span class=\"number\">27</span>: \t<span class=\"keyword\">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class=\"line\"><span class=\"number\">28</span>: \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">29</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">// 检查是否有分片</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class=\"line\"><span class=\"number\">35</span>: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class=\"line\"><span class=\"number\">36</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">if</span> (returnedSet == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>: \t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>\n<h2 id=\"【-3-6-】\"><a href=\"#【-3-6-】\" class=\"headerlink\" title=\"【 3 - 6 】\"></a>【 3 - 6 】</h2><p>路由<strong>前置</strong>处理。当符合如下三种情况下，进行处理：  </p>\n<p>{ 1 } 使用<strong>全局序列号</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"keyword\">NEXT</span> <span class=\"keyword\">VALUE</span> <span class=\"keyword\">FOR</span> MYCATSEQ_ID, <span class=\"string\">'name'</span>)</div></pre></td></tr></table></figure>\n<p>{ 2 } ER 子表插入<br>{ 3 } 主键使用自增 ID 插入：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">insert into table (name) values ('name')</div><div class=\"line\">===&gt;</div><div class=\"line\">insert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')</div><div class=\"line\">```  </div><div class=\"line\"></div><div class=\"line\">情况 &#123; 1 &#125; &#123; 3 &#125; 情况类似，使用全局序列号。</div><div class=\"line\"></div><div class=\"line\">核心代码如下：</div><div class=\"line\"></div><div class=\"line\">```Java</div><div class=\"line\">  1: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】</div><div class=\"line\">  2: private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)</div><div class=\"line\">  3: \t\tthrows SQLNonTransientException &#123;</div><div class=\"line\">  4: \treturn  // 处理 id 使用 全局序列号</div><div class=\"line\">  5:             RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)</div><div class=\"line\">  6:             // 处理 ER 子表</div><div class=\"line\">  7: \t\t\t|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processERChildTable(schema, origSQL, sc))</div><div class=\"line\">  8:             // 处理 id 自增长</div><div class=\"line\">  9: \t\t\t|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processInsert(schema, sqlType, origSQL, sc));</div><div class=\"line\"> 10: &#125;</div></pre></td></tr></table></figure>\n<p><code>RouterUtil.java</code> 处理 SQL 考虑性能，实现会比较 C-style，代码咱就不贴了，传送门：<a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。</a> （😈该仓库从官方 Fork，逐步完善中文注释，欢迎 Star）</p>\n<h2 id=\"【-7-11-】\"><a href=\"#【-7-11-】\" class=\"headerlink\" title=\"【 7 - 11 】\"></a>【 7 - 11 】</h2><p>当<strong>前置</strong>路由处理<strong>全局序列号</strong>时，添加到全局序列处理器（<code>MyCATSequnceProcessor</code>）。该处理器会异步生成 ID，替换 SQL 内的 <code>NEXT VALUE FOR MYCATSEQ_</code> 正则。例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"keyword\">NEXT</span> <span class=\"keyword\">VALUE</span> <span class=\"keyword\">FOR</span> MYCATSEQ_ID, <span class=\"string\">'name'</span>)</div><div class=\"line\">===&gt;</div><div class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> (<span class=\"keyword\">id</span>, <span class=\"keyword\">name</span>) <span class=\"keyword\">values</span> (<span class=\"number\">868348974560579584</span>, <span class=\"string\">'name'</span>)</div></pre></td></tr></table></figure>\n<p>异步处理完后，调用 <code>ServerConnection#routeEndExecuteSQL(sql, type, schema)</code> 方法重新执行 SQL。</p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RouterUtil.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">processSQL</span><span class=\"params\">(ServerConnection sc,SchemaConfig schema,String sql,<span class=\"keyword\">int</span> sqlType)</span></span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \tSessionSQLPair sessionSQLPair = <span class=\"keyword\">new</span> SessionSQLPair(sc.getSession2(), schema, sql, sqlType);</div><div class=\"line\"> <span class=\"number\">4</span>: \tMycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);</div><div class=\"line\"> <span class=\"number\">5</span>: &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MyCATSequnceProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCATSequnceProcessor</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">private</span> LinkedBlockingQueue&lt;SessionSQLPair&gt; seqSQLQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;SessionSQLPair&gt;();</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> running=<span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t</div><div class=\"line\"><span class=\"number\">11</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addNewSql</span><span class=\"params\">(SessionSQLPair pair)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\tseqSQLQueue.add(pair);</div><div class=\"line\"><span class=\"number\">13</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeSeq</span><span class=\"params\">(SessionSQLPair pair)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>: \t\t\t</div><div class=\"line\"><span class=\"number\">18</span>: \t\t\t<span class=\"comment\">// 使用Druid解析器实现sequence处理  @兵临城下</span></div><div class=\"line\"><span class=\"number\">19</span>: \t\t\tDruidSequenceHandler sequenceHandler = <span class=\"keyword\">new</span> DruidSequenceHandler(MycatServer</div><div class=\"line\"><span class=\"number\">20</span>: \t\t\t\t\t.getInstance().getConfig().getSystem().getSequnceHandlerType());</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>: \t\t\t<span class=\"comment\">// 生成可执行 SQL ：目前主要是生成 id</span></div><div class=\"line\"><span class=\"number\">23</span>: \t\t\tString charset = pair.session.getSource().getCharset();</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\tString executeSql = sequenceHandler.getExecuteSql(pair.sql,charset == <span class=\"keyword\">null</span> ? <span class=\"string\">\"utf-8\"</span>:charset);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">27</span>: \t\t\tpair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);</div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tLOGGER.error(<span class=\"string\">\"MyCATSequenceProcessor.executeSeq(SesionSQLPair)\"</span>,e);</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tpair.session.getSource().writeErrMessage(ErrorCode.ER_YES,<span class=\"string\">\"mycat sequnce err.\"</span> + e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">32</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">33</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">34</span>: \t</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecuteThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecuteThread</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\tsetDaemon(<span class=\"keyword\">true</span>); <span class=\"comment\">// 设置为后台线程,防止throw RuntimeExecption进程仍然存在的问题</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">40</span>: \t\t</div><div class=\"line\"><span class=\"number\">41</span>: \t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t<span class=\"keyword\">while</span> (running) &#123;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t\t\tSessionSQLPair pair=seqSQLQueue.poll(<span class=\"number\">100</span>,TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\t\t\t<span class=\"keyword\">if</span>(pair!=<span class=\"keyword\">null</span>)&#123;</div><div class=\"line\"><span class=\"number\">46</span>:                         executeSeq(pair);</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\t\t\t&#125;</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t\tLOGGER.warn(<span class=\"string\">\"MyCATSequenceProcessor$ExecutorThread\"</span>,e);</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">53</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div></pre></td></tr></table></figure>\n<p>❓此处有个疑问：<code>MyCATSequnceProcessor</code> 是单线程，会不会插入性能有一定的影响？后续咱做下性能测试。</p>\n<h1 id=\"4-获得-MySQL-连接，执行-SQL\"><a href=\"#4-获得-MySQL-连接，执行-SQL\" class=\"headerlink\" title=\"4. 获得 MySQL 连接，执行 SQL\"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/03.png\" alt=\"【单库单表】插入（03执行 SQL）\"></p>\n<h2 id=\"【-1-8-】\"><a href=\"#【-1-8-】\" class=\"headerlink\" title=\"【 1 - 8 】\"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>\n<ul>\n<li>PhysicalDBNode ：物理数据库节点。</li>\n<li>PhysicalDatasource ：物理数据库数据源。</li>\n</ul>\n<h2 id=\"【-9-13-】\"><a href=\"#【-9-13-】\" class=\"headerlink\" title=\"【 9 - 13 】\"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>\n<h1 id=\"5-响应执行-SQL-结果\"><a href=\"#5-响应执行-SQL-结果\" class=\"headerlink\" title=\"5. 响应执行 SQL 结果\"></a>5. 响应执行 SQL 结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/04.png\" alt=\"【单库单表】插入（04执行响应）\"></p>\n<h2 id=\"【-1-4-】\"><a href=\"#【-1-4-】\" class=\"headerlink\" title=\"【 1 - 4 】\"></a>【 1 - 4 】</h2><p>处理 MySQL Server 响应数据包。</p>\n<h2 id=\"【-5-8-】\"><a href=\"#【-5-8-】\" class=\"headerlink\" title=\"【 5 - 8 】\"></a>【 5 - 8 】</h2><p>发送插入成功结果给 MySQL Client。</p>\n"},{"title":"MyCAT 源码分析 —— 【单库单表】查询","date":"2017-05-29T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/single-db-single-table-select/](http://www.yunai.me/MyCAT/single-db-single-table-select/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 接收请求，解析 SQL](#)\n- [3. 获得路由结果](#)\n- [4. 获得 MySQL 连接，执行 SQL](#)\n- [5. 响应执行 SQL 结果](#)\n- [6. 其他 ：更新 / 删除](#)\n\n# 1. 概述\n\n> 内容形态以 顺序图 + 核心代码 为主。  \n> 如果有地方表述不错误或者不清晰，欢迎留言。  \n> 对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。  \n> 微信号：wangwenbin-server。\n\n本文讲解 【单库单表】查询 所涉及到的代码。\n  \n😂内容和 [《MyCAT 源码分析 —— 【单库单表】插入》](http://www.yunai.me/Mycat/single-db-single-table-insert/) 超级相似，一方面本身流程基本相同，另外一方面文章结构没拆分好。我们使用 🚀 标记差异的逻辑。\n\n交互如下图：\n\n![单库单表查询简图](http://www.yunai.me/images/MyCAT/2017_05_30/01.png)\n\n整个过程，MyCAT Server 流程如下：\n\n1. 接收 MySQL Client 请求，解析 SQL。\n2. 获得路由结果，进行路由。\n3. 获得 MySQL 连接，执行 SQL。\n4. 响应执行结果，发送结果给 MySQL Client。\n\n我们逐个步骤分析，一起来看看源码。\n\n# 2. 接收请求，解析 SQL\n\n![【单库单表】查询（01主流程）](http://www.yunai.me/images/MyCAT/2017_05_30/02.png)\n\n## 【1 - 2】\n\n接收**一条** MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。\n\n## 【3】\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendCommandHandler.java】\n  2: public class FrontendCommandHandler implements NIOHandler {\n  3: \n  4:     @Override\n  5:     public void handle(byte[] data) {\n  6:     \n  7:         // .... 省略部分代码\n  8:         switch (data[4]) // \n  9:         {\n 10:             case MySQLPacket.COM_INIT_DB:\n 11:                 commands.doInitDB();\n 12:                 source.initDB(data);\n 13:                 break;\n 14:             case MySQLPacket.COM_QUERY: // 查询命令\n 15:                 // 计数查询命令\n 16:                 commands.doQuery();\n 17:                 // 执行查询命令\n 18:                 source.query(data);\n 19:                 break;\n 20:             case MySQLPacket.COM_PING:\n 21:                 commands.doPing();\n 22:                 source.ping();\n 23:                 break;\n 24:             // .... 省略部分case\n 25:         }\n 26:     }\n 27: \n 28: }\n```\n\n`INSERT`/`SELECT`/`UPDATE`/`DELETE` 等 SQL 归属于 `MySQLPacket.COM_QUERY`，详细可见：[《MySQL协议分析#4.2 客户端命令请求报文（客户端 -> 服务器）》](http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-)。\n\n## 【4】\n\n将 二进制数组 解析成 SQL。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendConnection.java】\n  2: public void query(byte[] data) {\n  3: \t// 取得语句\n  4: \tString sql = null;\t\t\n  5: \ttry {\n  6: \t\tMySQLMessage mm = new MySQLMessage(data);\n  7: \t\tmm.position(5);\n  8: \t\tsql = mm.readString(charset);\n  9: \t} catch (UnsupportedEncodingException e) {\n 10: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown charset '\" + charset + \"'\");\n 11: \t\treturn;\n 12: \t}\t\t\n 13: \t// 执行语句\n 14: \tthis.query( sql );\n 15: }\n```\n\n## 【5】\n\n解析 SQL 类型。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerQueryHandler.java】\n  2: @Override\n  3: public void query(String sql) {\n  4: \t// 解析 SQL 类型\n  5: \tint rs = ServerParse.parse(sql);\n  6: \tint sqlType = rs & 0xff;\n  7: \t\n  8: \tswitch (sqlType) {\n  9: \t//explain sql\n 10: \tcase ServerParse.EXPLAIN:\n 11: \t\tExplainHandler.handle(sql, c, rs >>> 8);\n 12: \t\tbreak;\n 13: \t// .... 省略部分case\n 14: \t\tbreak;\n 15: \tcase ServerParse.SELECT:\n 16: \t\tSelectHandler.handle(sql, c, rs >>> 8);\n 17: \t\tbreak;\n 18: \t// .... 省略部分case\n 19: \tdefault:\n 20: \t\tif(readOnly){\n 21: \t\t\tLOGGER.warn(new StringBuilder().append(\"User readonly:\").append(sql).toString());\n 22: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, \"User readonly\");\n 23: \t\t\tbreak;\n 24: \t\t}\n 25: \t\tc.execute(sql, rs & 0xff);\n 26: \t}\n 27: }\n 28: \n 29:\n 30: // ⬇️⬇️⬇️【ServerParse.java】\n 31: public static int parse(String stmt) {\n 32: \tint length = stmt.length();\n 33: \t//FIX BUG FOR SQL SUCH AS /XXXX/SQL\n 34: \tint rt = -1;\n 35: \tfor (int i = 0; i < length; ++i) {\n 36: \t\tswitch (stmt.charAt(i)) {\n 37: \t\t// .... 省略部分case\t\t\tcase 'I':\n 38: \t\tcase 'i':\n 39: \t\t\trt = insertCheck(stmt, i);\n 40: \t\t\tif (rt != OTHER) {\n 41: \t\t\t\treturn rt;\n 42: \t\t\t}\n 43: \t\t\tcontinue;\n 44: \t\t\t// .... 省略部分case\n 45: \t\tcase 'S':\n 46: \t\tcase 's':\n 47: \t\t\trt = sCheck(stmt, i);\n 48: \t\t\tif (rt != OTHER) {\n 49: \t\t\t\treturn rt;\n 50: \t\t\t}\n 51: \t\t\tcontinue;\n 52: \t\t\t// .... 省略部分case\n 53: \t\tdefault:\n 54: \t\t\tcontinue;\n 55: \t\t}\n 56: \t}\n 57: \treturn OTHER;\n 58: }\n```\n\n## 🚀【6】【7】\n\n解析 Select SQL 类型，分发到对应的逻辑。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SelectHandler.java】\n  2: public static void handle(String stmt, ServerConnection c, int offs) {\n  3: \tint offset = offs;\n  4: \tswitch (ServerParseSelect.parse(stmt, offs)) { // 解析 Select SQL 类型\n  5: \tcase ServerParseSelect.VERSION_COMMENT: // select @@VERSION_COMMENT;\n  6: \t\tSelectVersionComment.response(c);\n  7: \t\tbreak;\n  8: \tcase ServerParseSelect.DATABASE: // select DATABASE();\n  9: \t\tSelectDatabase.response(c);\n 10: \t\tbreak;\n 11: \tcase ServerParseSelect.USER: // select CURRENT_USER();\n 12:         SelectUser.response(c);\n 13: \t\tbreak;\n 14: \tcase ServerParseSelect.VERSION: // select VERSION();\n 15: \t\tSelectVersion.response(c);\n 16: \t\tbreak;\n 17: \tcase ServerParseSelect.SESSION_INCREMENT: // select @@session.auto_increment_increment;\n 18: \t\tSessionIncrement.response(c);\n 19: \t\tbreak;\n 20: \tcase ServerParseSelect.SESSION_ISOLATION: // select @@session.tx_isolation;\n 21: \t\tSessionIsolation.response(c);\n 22: \t\tbreak;\n 23: \tcase ServerParseSelect.LAST_INSERT_ID: // select LAST_INSERT_ID();\n 24: \t\t// ....省略代码\n 25: \t\tbreak;\n 26: \tcase ServerParseSelect.IDENTITY: // select @@identity\n 27: \t\t// ....省略代码\n 28: \t\tbreak;\n 29:     case ServerParseSelect.SELECT_VAR_ALL: //\n 30:         SelectVariables.execute(c,stmt);\n 31:             break;\n 32:     case ServerParseSelect.SESSION_TX_READ_ONLY: //\n 33:         SelectTxReadOnly.response(c);\n 34: \t\t\tbreak;\n 35: \tdefault: // 其他，例如 select * from table\n 36: \t\tc.execute(stmt, ServerParse.SELECT);\n 37: \t}\n 38: }\n 39: // ⬇️⬇️⬇️【ServerParseSelect.java】\n 40: public static int parse(String stmt, int offset) {\n 41: \tint i = offset;\n 42: \tfor (; i < stmt.length(); ++i) {\n 43: \t\tswitch (stmt.charAt(i)) {\n 44: \t\tcase ' ':\n 45: \t\t\tcontinue;\n 46: \t\tcase '/':\n 47: \t\tcase '#':\n 48: \t\t\ti = ParseUtil.comment(stmt, i);\n 49: \t\t\tcontinue;\n 50: \t\tcase '@':\n 51: \t\t\treturn select2Check(stmt, i);\n 52: \t\tcase 'D':\n 53: \t\tcase 'd':\n 54: \t\t\treturn databaseCheck(stmt, i);\n 55: \t\tcase 'L':\n 56: \t\tcase 'l':\n 57: \t\t\treturn lastInsertCheck(stmt, i);\n 58: \t\tcase 'U':\n 59: \t\tcase 'u':\n 60: \t\t\treturn userCheck(stmt, i);\n 61: \t\tcase 'C':\n 62: \t\tcase 'c':\n 63: \t\t\treturn currentUserCheck(stmt, i);\n 64: \t\tcase 'V':\n 65: \t\tcase 'v':\n 66: \t\t\treturn versionCheck(stmt, i);\n 67: \t\tdefault:\n 68: \t\t\treturn OTHER;\n 69: \t\t}\n 70: \t}\n 71: \treturn OTHER;\n 72: }\n```\n\n## 【8】\n\n执行 SQL，详细解析见下文，核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerConnection.java】\n  2: public class ServerConnection extends FrontendConnection {\n  3: \tpublic void execute(String sql, int type) {\n  4: \t\t// .... 省略代码\n  5: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);\n  6: \t\tif (schema == null) {\n  7: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,\n  8: \t\t\t\t\t\"Unknown MyCAT Database '\" + db + \"'\");\n  9: \t\t\treturn;\n 10: \t\t}\n 11: \n 12: \t\t// .... 省略代码\n 13: \n 14: \t\t// 路由到后端数据库，执行 SQL\n 15: \t\trouteEndExecuteSQL(sql, type, schema);\n 16: \t}\n 17: \t\n 18:     public void routeEndExecuteSQL(String sql, final int type, final SchemaConfig schema) {\n 19: \t\t// 路由计算\n 20: \t\tRouteResultset rrs = null;\n 21: \t\ttry {\n 22: \t\t\trrs = MycatServer\n 23: \t\t\t\t\t.getInstance()\n 24: \t\t\t\t\t.getRouterservice()\n 25: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),\n 26: \t\t\t\t\t\t\tschema, type, sql, this.charset, this);\n 27: \n 28: \t\t} catch (Exception e) {\n 29: \t\t\tStringBuilder s = new StringBuilder();\n 30: \t\t\tLOGGER.warn(s.append(this).append(sql).toString() + \" err:\" + e.toString(),e);\n 31: \t\t\tString msg = e.getMessage();\n 32: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);\n 33: \t\t\treturn;\n 34: \t\t}\n 35: \n 36: \t\t// 执行 SQL\n 37: \t\tif (rrs != null) {\n 38: \t\t\t// session执行\n 39: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);\n 40: \t\t}\n 41: \t\t\n 42:  \t}\n 43: \n 44: }\n```\n\n# 3. 获得路由结果\n\n![【单库单表】插入（02获取路由）](http://www.yunai.me/images/MyCAT/2017_05_30/03.png)\n\n## 【 1 -  5 】\n\n获得路由主流程。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SelectHandler.java】\n  2: public RouteResultset route(SystemConfig sysconf, SchemaConfig schema,\n  3: \t\tint sqlType, String stmt, String charset, ServerConnection sc)\n  4: \t\tthrows SQLNonTransientException {\n  5: \tRouteResultset rrs = null;\n  6: \n  7: \t// SELECT 类型的SQL, 检测缓存是否存在\n  8: \tif (sqlType == ServerParse.SELECT) {\n  9: \t\tcacheKey = schema.getName() + stmt;\t\t\t\n 10: \t\trrs = (RouteResultset) sqlRouteCache.get(cacheKey);\n 11: \t\tif (rrs != null) {\n 12: \t\t\tcheckMigrateRule(schema.getName(),rrs,sqlType);\n 13: \t\t\treturn rrs;\n 14: \t\t\t}\n 15: \t\t}\n 16: \t}\n 17: \n 18: \t// .... 省略代码\n 19: \tint hintLength = RouteService.isHintSql(stmt);\n 20: \tif(hintLength != -1){ // TODO 待读：hint\n 21: \t\t// .... 省略代码\n 22: \t\t}\n 23: \t} else {\n 24: \t\tstmt = stmt.trim();\n 25: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,\n 26: \t\t\t\tcharset, sc, tableId2DataNodeCache);\n 27: \t}\n 28: \n 29: \t// 记录查询命令路由结果缓存\n 30: \tif (rrs != null && sqlType == ServerParse.SELECT && rrs.isCacheAble()) {\n 31: \t\tsqlRouteCache.putIfAbsent(cacheKey, rrs);\n 32: \t}\n 33: \t// .... 省略代码\t\treturn rrs;\n 34: }\n 35: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n 36: @Override\n 37: public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String origSQL,\n 38: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) throws SQLNonTransientException {\n 39: \n 40: \t// .... 省略代码\n 41: \n 42: \t// 处理一些路由之前的逻辑;全局序列号，父子表插入\n 43: \tif (beforeRouteProcess(schema, sqlType, origSQL, sc) ) {\n 44: \t\treturn null;\n 45: \t}\n 46: \n 47: \t// .... 省略代码\n 48: \n 49: \t// 检查是否有分片\n 50: \tif (schema.isNoSharding() && ServerParse.SHOW != sqlType) {\n 51: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);\n 52: \t} else {\n 53: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);\n 54: \t\tif (returnedSet == null) {\n 55: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);\n 56: \t\t}\n 57: \t}\n 58: \n 59: \treturn rrs;\n 60: }\n```\n\n🚀【3】第 7 至 16 行 ：当 Select SQL 存在路由结果缓存时，直接返回缓存。\n🚀【6】第 29 至 32 行 ：记录 Select SQL 路由结果到缓存。\n\n_**路由** 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。_\n\n# 4. 获得 MySQL 连接，执行 SQL\n\n![【单库单表】查询（03执行 SQL）](http://www.yunai.me/images/MyCAT/2017_05_29/03.png)\n\n## 【 1 - 8 】\n\n获得 MySQL 连接。\n\n* PhysicalDBNode ：物理数据库节点。\n* PhysicalDatasource ：物理数据库数据源。\n\n## 【 9 - 13 】\n\n发送 SQL 到 MySQL Server，执行 SQL。\n\n# 🚀 5. 响应执行 SQL 结果\n\n![【单库单表】查询（04执行响应）](http://www.yunai.me/images/MyCAT/2017_05_30/04.png)\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【MySQLConnectionHandler.java】\n  2: @Override\n  3: protected void handleData(byte[] data) {\n  4: \tswitch (resultStatus) {\n  5: \tcase RESULT_STATUS_INIT:\n  6: \t\tswitch (data[4]) {\n  7: \t\tcase OkPacket.FIELD_COUNT:\n  8: \t\t\thandleOkPacket(data);\n  9: \t\t\tbreak;\n 10: \t\tcase ErrorPacket.FIELD_COUNT:\n 11: \t\t\thandleErrorPacket(data);\n 12: \t\t\tbreak;\n 13: \t\tcase RequestFilePacket.FIELD_COUNT:\n 14: \t\t\thandleRequestPacket(data);\n 15: \t\t\tbreak;\n 16: \t\tdefault: // 初始化 header fields\n 17: \t\t\tresultStatus = RESULT_STATUS_HEADER;\n 18: \t\t\theader = data;\n 19: \t\t\tfields = new ArrayList<byte[]>((int) ByteUtil.readLength(data,\n 20: \t\t\t\t\t4));\n 21: \t\t}\n 22: \t\tbreak;\n 23: \tcase RESULT_STATUS_HEADER:\n 24: \t\tswitch (data[4]) {\n 25: \t\tcase ErrorPacket.FIELD_COUNT:\n 26: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 27: \t\t\thandleErrorPacket(data);\n 28: \t\t\tbreak;\n 29: \t\tcase EOFPacket.FIELD_COUNT: // 解析 fields 结束\n 30: \t\t\tresultStatus = RESULT_STATUS_FIELD_EOF;\n 31: \t\t\thandleFieldEofPacket(data);\n 32: \t\t\tbreak;\n 33: \t\tdefault: // 解析 fields\n 34: \t\t\tfields.add(data);\n 35: \t\t}\n 36: \t\tbreak;\n 37: \tcase RESULT_STATUS_FIELD_EOF:\n 38: \t\tswitch (data[4]) {\n 39: \t\tcase ErrorPacket.FIELD_COUNT:\n 40: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 41: \t\t\thandleErrorPacket(data);\n 42: \t\t\tbreak;\n 43: \t\tcase EOFPacket.FIELD_COUNT: // 解析 每行记录 结束\n 44: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 45: \t\t\thandleRowEofPacket(data);\n 46: \t\t\tbreak;\n 47: \t\tdefault: // 每行记录\n 48: \t\t\thandleRowPacket(data);\n 49: \t\t}\n 50: \t\tbreak;\n 51: \tdefault:\n 52: \t\tthrow new RuntimeException(\"unknown status!\");\n 53: \t}\n 54: }\n```\n\n# 6. 其他 ：更新 / 删除\n\n流程基本和 [《MyCAT源码分析：【单库单表】插入》](http://www.yunai.me/Mycat/single-db-single-table-insert/) 相同。我们就不另外文章解析。\n\n\n","source":"_posts/MyCAT/2017_05_30_MyCAT源码分析——【单库单表】查询.md","raw":"title: MyCAT 源码分析 —— 【单库单表】查询\ndate: 2017-05-30\ntags:\ncategories: MyCAT\npermalink: MyCAT/single-db-single-table-select\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/single-db-single-table-select/](http://www.yunai.me/MyCAT/single-db-single-table-select/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 接收请求，解析 SQL](#)\n- [3. 获得路由结果](#)\n- [4. 获得 MySQL 连接，执行 SQL](#)\n- [5. 响应执行 SQL 结果](#)\n- [6. 其他 ：更新 / 删除](#)\n\n# 1. 概述\n\n> 内容形态以 顺序图 + 核心代码 为主。  \n> 如果有地方表述不错误或者不清晰，欢迎留言。  \n> 对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。  \n> 微信号：wangwenbin-server。\n\n本文讲解 【单库单表】查询 所涉及到的代码。\n  \n😂内容和 [《MyCAT 源码分析 —— 【单库单表】插入》](http://www.yunai.me/Mycat/single-db-single-table-insert/) 超级相似，一方面本身流程基本相同，另外一方面文章结构没拆分好。我们使用 🚀 标记差异的逻辑。\n\n交互如下图：\n\n![单库单表查询简图](http://www.yunai.me/images/MyCAT/2017_05_30/01.png)\n\n整个过程，MyCAT Server 流程如下：\n\n1. 接收 MySQL Client 请求，解析 SQL。\n2. 获得路由结果，进行路由。\n3. 获得 MySQL 连接，执行 SQL。\n4. 响应执行结果，发送结果给 MySQL Client。\n\n我们逐个步骤分析，一起来看看源码。\n\n# 2. 接收请求，解析 SQL\n\n![【单库单表】查询（01主流程）](http://www.yunai.me/images/MyCAT/2017_05_30/02.png)\n\n## 【1 - 2】\n\n接收**一条** MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。\n\n## 【3】\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendCommandHandler.java】\n  2: public class FrontendCommandHandler implements NIOHandler {\n  3: \n  4:     @Override\n  5:     public void handle(byte[] data) {\n  6:     \n  7:         // .... 省略部分代码\n  8:         switch (data[4]) // \n  9:         {\n 10:             case MySQLPacket.COM_INIT_DB:\n 11:                 commands.doInitDB();\n 12:                 source.initDB(data);\n 13:                 break;\n 14:             case MySQLPacket.COM_QUERY: // 查询命令\n 15:                 // 计数查询命令\n 16:                 commands.doQuery();\n 17:                 // 执行查询命令\n 18:                 source.query(data);\n 19:                 break;\n 20:             case MySQLPacket.COM_PING:\n 21:                 commands.doPing();\n 22:                 source.ping();\n 23:                 break;\n 24:             // .... 省略部分case\n 25:         }\n 26:     }\n 27: \n 28: }\n```\n\n`INSERT`/`SELECT`/`UPDATE`/`DELETE` 等 SQL 归属于 `MySQLPacket.COM_QUERY`，详细可见：[《MySQL协议分析#4.2 客户端命令请求报文（客户端 -> 服务器）》](http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-)。\n\n## 【4】\n\n将 二进制数组 解析成 SQL。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FrontendConnection.java】\n  2: public void query(byte[] data) {\n  3: \t// 取得语句\n  4: \tString sql = null;\t\t\n  5: \ttry {\n  6: \t\tMySQLMessage mm = new MySQLMessage(data);\n  7: \t\tmm.position(5);\n  8: \t\tsql = mm.readString(charset);\n  9: \t} catch (UnsupportedEncodingException e) {\n 10: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, \"Unknown charset '\" + charset + \"'\");\n 11: \t\treturn;\n 12: \t}\t\t\n 13: \t// 执行语句\n 14: \tthis.query( sql );\n 15: }\n```\n\n## 【5】\n\n解析 SQL 类型。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerQueryHandler.java】\n  2: @Override\n  3: public void query(String sql) {\n  4: \t// 解析 SQL 类型\n  5: \tint rs = ServerParse.parse(sql);\n  6: \tint sqlType = rs & 0xff;\n  7: \t\n  8: \tswitch (sqlType) {\n  9: \t//explain sql\n 10: \tcase ServerParse.EXPLAIN:\n 11: \t\tExplainHandler.handle(sql, c, rs >>> 8);\n 12: \t\tbreak;\n 13: \t// .... 省略部分case\n 14: \t\tbreak;\n 15: \tcase ServerParse.SELECT:\n 16: \t\tSelectHandler.handle(sql, c, rs >>> 8);\n 17: \t\tbreak;\n 18: \t// .... 省略部分case\n 19: \tdefault:\n 20: \t\tif(readOnly){\n 21: \t\t\tLOGGER.warn(new StringBuilder().append(\"User readonly:\").append(sql).toString());\n 22: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, \"User readonly\");\n 23: \t\t\tbreak;\n 24: \t\t}\n 25: \t\tc.execute(sql, rs & 0xff);\n 26: \t}\n 27: }\n 28: \n 29:\n 30: // ⬇️⬇️⬇️【ServerParse.java】\n 31: public static int parse(String stmt) {\n 32: \tint length = stmt.length();\n 33: \t//FIX BUG FOR SQL SUCH AS /XXXX/SQL\n 34: \tint rt = -1;\n 35: \tfor (int i = 0; i < length; ++i) {\n 36: \t\tswitch (stmt.charAt(i)) {\n 37: \t\t// .... 省略部分case\t\t\tcase 'I':\n 38: \t\tcase 'i':\n 39: \t\t\trt = insertCheck(stmt, i);\n 40: \t\t\tif (rt != OTHER) {\n 41: \t\t\t\treturn rt;\n 42: \t\t\t}\n 43: \t\t\tcontinue;\n 44: \t\t\t// .... 省略部分case\n 45: \t\tcase 'S':\n 46: \t\tcase 's':\n 47: \t\t\trt = sCheck(stmt, i);\n 48: \t\t\tif (rt != OTHER) {\n 49: \t\t\t\treturn rt;\n 50: \t\t\t}\n 51: \t\t\tcontinue;\n 52: \t\t\t// .... 省略部分case\n 53: \t\tdefault:\n 54: \t\t\tcontinue;\n 55: \t\t}\n 56: \t}\n 57: \treturn OTHER;\n 58: }\n```\n\n## 🚀【6】【7】\n\n解析 Select SQL 类型，分发到对应的逻辑。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SelectHandler.java】\n  2: public static void handle(String stmt, ServerConnection c, int offs) {\n  3: \tint offset = offs;\n  4: \tswitch (ServerParseSelect.parse(stmt, offs)) { // 解析 Select SQL 类型\n  5: \tcase ServerParseSelect.VERSION_COMMENT: // select @@VERSION_COMMENT;\n  6: \t\tSelectVersionComment.response(c);\n  7: \t\tbreak;\n  8: \tcase ServerParseSelect.DATABASE: // select DATABASE();\n  9: \t\tSelectDatabase.response(c);\n 10: \t\tbreak;\n 11: \tcase ServerParseSelect.USER: // select CURRENT_USER();\n 12:         SelectUser.response(c);\n 13: \t\tbreak;\n 14: \tcase ServerParseSelect.VERSION: // select VERSION();\n 15: \t\tSelectVersion.response(c);\n 16: \t\tbreak;\n 17: \tcase ServerParseSelect.SESSION_INCREMENT: // select @@session.auto_increment_increment;\n 18: \t\tSessionIncrement.response(c);\n 19: \t\tbreak;\n 20: \tcase ServerParseSelect.SESSION_ISOLATION: // select @@session.tx_isolation;\n 21: \t\tSessionIsolation.response(c);\n 22: \t\tbreak;\n 23: \tcase ServerParseSelect.LAST_INSERT_ID: // select LAST_INSERT_ID();\n 24: \t\t// ....省略代码\n 25: \t\tbreak;\n 26: \tcase ServerParseSelect.IDENTITY: // select @@identity\n 27: \t\t// ....省略代码\n 28: \t\tbreak;\n 29:     case ServerParseSelect.SELECT_VAR_ALL: //\n 30:         SelectVariables.execute(c,stmt);\n 31:             break;\n 32:     case ServerParseSelect.SESSION_TX_READ_ONLY: //\n 33:         SelectTxReadOnly.response(c);\n 34: \t\t\tbreak;\n 35: \tdefault: // 其他，例如 select * from table\n 36: \t\tc.execute(stmt, ServerParse.SELECT);\n 37: \t}\n 38: }\n 39: // ⬇️⬇️⬇️【ServerParseSelect.java】\n 40: public static int parse(String stmt, int offset) {\n 41: \tint i = offset;\n 42: \tfor (; i < stmt.length(); ++i) {\n 43: \t\tswitch (stmt.charAt(i)) {\n 44: \t\tcase ' ':\n 45: \t\t\tcontinue;\n 46: \t\tcase '/':\n 47: \t\tcase '#':\n 48: \t\t\ti = ParseUtil.comment(stmt, i);\n 49: \t\t\tcontinue;\n 50: \t\tcase '@':\n 51: \t\t\treturn select2Check(stmt, i);\n 52: \t\tcase 'D':\n 53: \t\tcase 'd':\n 54: \t\t\treturn databaseCheck(stmt, i);\n 55: \t\tcase 'L':\n 56: \t\tcase 'l':\n 57: \t\t\treturn lastInsertCheck(stmt, i);\n 58: \t\tcase 'U':\n 59: \t\tcase 'u':\n 60: \t\t\treturn userCheck(stmt, i);\n 61: \t\tcase 'C':\n 62: \t\tcase 'c':\n 63: \t\t\treturn currentUserCheck(stmt, i);\n 64: \t\tcase 'V':\n 65: \t\tcase 'v':\n 66: \t\t\treturn versionCheck(stmt, i);\n 67: \t\tdefault:\n 68: \t\t\treturn OTHER;\n 69: \t\t}\n 70: \t}\n 71: \treturn OTHER;\n 72: }\n```\n\n## 【8】\n\n执行 SQL，详细解析见下文，核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ServerConnection.java】\n  2: public class ServerConnection extends FrontendConnection {\n  3: \tpublic void execute(String sql, int type) {\n  4: \t\t// .... 省略代码\n  5: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);\n  6: \t\tif (schema == null) {\n  7: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,\n  8: \t\t\t\t\t\"Unknown MyCAT Database '\" + db + \"'\");\n  9: \t\t\treturn;\n 10: \t\t}\n 11: \n 12: \t\t// .... 省略代码\n 13: \n 14: \t\t// 路由到后端数据库，执行 SQL\n 15: \t\trouteEndExecuteSQL(sql, type, schema);\n 16: \t}\n 17: \t\n 18:     public void routeEndExecuteSQL(String sql, final int type, final SchemaConfig schema) {\n 19: \t\t// 路由计算\n 20: \t\tRouteResultset rrs = null;\n 21: \t\ttry {\n 22: \t\t\trrs = MycatServer\n 23: \t\t\t\t\t.getInstance()\n 24: \t\t\t\t\t.getRouterservice()\n 25: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),\n 26: \t\t\t\t\t\t\tschema, type, sql, this.charset, this);\n 27: \n 28: \t\t} catch (Exception e) {\n 29: \t\t\tStringBuilder s = new StringBuilder();\n 30: \t\t\tLOGGER.warn(s.append(this).append(sql).toString() + \" err:\" + e.toString(),e);\n 31: \t\t\tString msg = e.getMessage();\n 32: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == null ? e.getClass().getSimpleName() : msg);\n 33: \t\t\treturn;\n 34: \t\t}\n 35: \n 36: \t\t// 执行 SQL\n 37: \t\tif (rrs != null) {\n 38: \t\t\t// session执行\n 39: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);\n 40: \t\t}\n 41: \t\t\n 42:  \t}\n 43: \n 44: }\n```\n\n# 3. 获得路由结果\n\n![【单库单表】插入（02获取路由）](http://www.yunai.me/images/MyCAT/2017_05_30/03.png)\n\n## 【 1 -  5 】\n\n获得路由主流程。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SelectHandler.java】\n  2: public RouteResultset route(SystemConfig sysconf, SchemaConfig schema,\n  3: \t\tint sqlType, String stmt, String charset, ServerConnection sc)\n  4: \t\tthrows SQLNonTransientException {\n  5: \tRouteResultset rrs = null;\n  6: \n  7: \t// SELECT 类型的SQL, 检测缓存是否存在\n  8: \tif (sqlType == ServerParse.SELECT) {\n  9: \t\tcacheKey = schema.getName() + stmt;\t\t\t\n 10: \t\trrs = (RouteResultset) sqlRouteCache.get(cacheKey);\n 11: \t\tif (rrs != null) {\n 12: \t\t\tcheckMigrateRule(schema.getName(),rrs,sqlType);\n 13: \t\t\treturn rrs;\n 14: \t\t\t}\n 15: \t\t}\n 16: \t}\n 17: \n 18: \t// .... 省略代码\n 19: \tint hintLength = RouteService.isHintSql(stmt);\n 20: \tif(hintLength != -1){ // TODO 待读：hint\n 21: \t\t// .... 省略代码\n 22: \t\t}\n 23: \t} else {\n 24: \t\tstmt = stmt.trim();\n 25: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,\n 26: \t\t\t\tcharset, sc, tableId2DataNodeCache);\n 27: \t}\n 28: \n 29: \t// 记录查询命令路由结果缓存\n 30: \tif (rrs != null && sqlType == ServerParse.SELECT && rrs.isCacheAble()) {\n 31: \t\tsqlRouteCache.putIfAbsent(cacheKey, rrs);\n 32: \t}\n 33: \t// .... 省略代码\t\treturn rrs;\n 34: }\n 35: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】\n 36: @Override\n 37: public RouteResultset route(SystemConfig sysConfig, SchemaConfig schema, int sqlType, String origSQL,\n 38: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) throws SQLNonTransientException {\n 39: \n 40: \t// .... 省略代码\n 41: \n 42: \t// 处理一些路由之前的逻辑;全局序列号，父子表插入\n 43: \tif (beforeRouteProcess(schema, sqlType, origSQL, sc) ) {\n 44: \t\treturn null;\n 45: \t}\n 46: \n 47: \t// .... 省略代码\n 48: \n 49: \t// 检查是否有分片\n 50: \tif (schema.isNoSharding() && ServerParse.SHOW != sqlType) {\n 51: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);\n 52: \t} else {\n 53: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);\n 54: \t\tif (returnedSet == null) {\n 55: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);\n 56: \t\t}\n 57: \t}\n 58: \n 59: \treturn rrs;\n 60: }\n```\n\n🚀【3】第 7 至 16 行 ：当 Select SQL 存在路由结果缓存时，直接返回缓存。\n🚀【6】第 29 至 32 行 ：记录 Select SQL 路由结果到缓存。\n\n_**路由** 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。_\n\n# 4. 获得 MySQL 连接，执行 SQL\n\n![【单库单表】查询（03执行 SQL）](http://www.yunai.me/images/MyCAT/2017_05_29/03.png)\n\n## 【 1 - 8 】\n\n获得 MySQL 连接。\n\n* PhysicalDBNode ：物理数据库节点。\n* PhysicalDatasource ：物理数据库数据源。\n\n## 【 9 - 13 】\n\n发送 SQL 到 MySQL Server，执行 SQL。\n\n# 🚀 5. 响应执行 SQL 结果\n\n![【单库单表】查询（04执行响应）](http://www.yunai.me/images/MyCAT/2017_05_30/04.png)\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【MySQLConnectionHandler.java】\n  2: @Override\n  3: protected void handleData(byte[] data) {\n  4: \tswitch (resultStatus) {\n  5: \tcase RESULT_STATUS_INIT:\n  6: \t\tswitch (data[4]) {\n  7: \t\tcase OkPacket.FIELD_COUNT:\n  8: \t\t\thandleOkPacket(data);\n  9: \t\t\tbreak;\n 10: \t\tcase ErrorPacket.FIELD_COUNT:\n 11: \t\t\thandleErrorPacket(data);\n 12: \t\t\tbreak;\n 13: \t\tcase RequestFilePacket.FIELD_COUNT:\n 14: \t\t\thandleRequestPacket(data);\n 15: \t\t\tbreak;\n 16: \t\tdefault: // 初始化 header fields\n 17: \t\t\tresultStatus = RESULT_STATUS_HEADER;\n 18: \t\t\theader = data;\n 19: \t\t\tfields = new ArrayList<byte[]>((int) ByteUtil.readLength(data,\n 20: \t\t\t\t\t4));\n 21: \t\t}\n 22: \t\tbreak;\n 23: \tcase RESULT_STATUS_HEADER:\n 24: \t\tswitch (data[4]) {\n 25: \t\tcase ErrorPacket.FIELD_COUNT:\n 26: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 27: \t\t\thandleErrorPacket(data);\n 28: \t\t\tbreak;\n 29: \t\tcase EOFPacket.FIELD_COUNT: // 解析 fields 结束\n 30: \t\t\tresultStatus = RESULT_STATUS_FIELD_EOF;\n 31: \t\t\thandleFieldEofPacket(data);\n 32: \t\t\tbreak;\n 33: \t\tdefault: // 解析 fields\n 34: \t\t\tfields.add(data);\n 35: \t\t}\n 36: \t\tbreak;\n 37: \tcase RESULT_STATUS_FIELD_EOF:\n 38: \t\tswitch (data[4]) {\n 39: \t\tcase ErrorPacket.FIELD_COUNT:\n 40: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 41: \t\t\thandleErrorPacket(data);\n 42: \t\t\tbreak;\n 43: \t\tcase EOFPacket.FIELD_COUNT: // 解析 每行记录 结束\n 44: \t\t\tresultStatus = RESULT_STATUS_INIT;\n 45: \t\t\thandleRowEofPacket(data);\n 46: \t\t\tbreak;\n 47: \t\tdefault: // 每行记录\n 48: \t\t\thandleRowPacket(data);\n 49: \t\t}\n 50: \t\tbreak;\n 51: \tdefault:\n 52: \t\tthrow new RuntimeException(\"unknown status!\");\n 53: \t}\n 54: }\n```\n\n# 6. 其他 ：更新 / 删除\n\n流程基本和 [《MyCAT源码分析：【单库单表】插入》](http://www.yunai.me/Mycat/single-db-single-table-insert/) 相同。我们就不另外文章解析。\n\n\n","slug":"MyCAT/single-db-single-table-select","published":1,"updated":"2017-07-11T09:45:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza2000bag5d3qpnx2u3","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-select/\">http://www.yunai.me/MyCAT/single-db-single-table-select/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 接收请求，解析 SQL</a></li>\n<li><a href=\"#\">3. 获得路由结果</a></li>\n<li><a href=\"#\">4. 获得 MySQL 连接，执行 SQL</a></li>\n<li><a href=\"#\">5. 响应执行 SQL 结果</a></li>\n<li><a href=\"#\">6. 其他 ：更新 / 删除</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><blockquote>\n<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>\n</blockquote>\n<p>本文讲解 【单库单表】查询 所涉及到的代码。</p>\n<p>😂内容和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-insert/\">《MyCAT 源码分析 —— 【单库单表】插入》</a> 超级相似，一方面本身流程基本相同，另外一方面文章结构没拆分好。我们使用 🚀 标记差异的逻辑。</p>\n<p>交互如下图：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/01.png\" alt=\"单库单表查询简图\"></p>\n<p>整个过程，MyCAT Server 流程如下：</p>\n<ol>\n<li>接收 MySQL Client 请求，解析 SQL。</li>\n<li>获得路由结果，进行路由。</li>\n<li>获得 MySQL 连接，执行 SQL。</li>\n<li>响应执行结果，发送结果给 MySQL Client。</li>\n</ol>\n<p>我们逐个步骤分析，一起来看看源码。</p>\n<h1 id=\"2-接收请求，解析-SQL\"><a href=\"#2-接收请求，解析-SQL\" class=\"headerlink\" title=\"2. 接收请求，解析 SQL\"></a>2. 接收请求，解析 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/02.png\" alt=\"【单库单表】查询（01主流程）\"></p>\n<h2 id=\"【1-2】\"><a href=\"#【1-2】\" class=\"headerlink\" title=\"【1 - 2】\"></a>【1 - 2】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>\n<h2 id=\"【3】\"><a href=\"#【3】\" class=\"headerlink\" title=\"【3】\"></a>【3】</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontendCommandHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">NIOHandler</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     </div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// .... 省略部分代码</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) <span class=\"comment\">// </span></div><div class=\"line\"> <span class=\"number\">9</span>:         &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_INIT_DB:</div><div class=\"line\"><span class=\"number\">11</span>:                 commands.doInitDB();</div><div class=\"line\"><span class=\"number\">12</span>:                 source.initDB(data);</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_QUERY: <span class=\"comment\">// 查询命令</span></div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 计数查询命令</span></div><div class=\"line\"><span class=\"number\">16</span>:                 commands.doQuery();</div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 执行查询命令</span></div><div class=\"line\"><span class=\"number\">18</span>:                 source.query(data);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_PING:</div><div class=\"line\"><span class=\"number\">21</span>:                 commands.doPing();</div><div class=\"line\"><span class=\"number\">22</span>:                 source.ping();</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div></pre></td></tr></table></figure>\n<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href=\"http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>\n<h2 id=\"【4】\"><a href=\"#【4】\" class=\"headerlink\" title=\"【4】\"></a>【4】</h2><p>将 二进制数组 解析成 SQL。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"comment\">// 取得语句</span></div><div class=\"line\"> <span class=\"number\">4</span>: \tString sql = <span class=\"keyword\">null</span>;\t\t</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>: \t\tMySQLMessage mm = <span class=\"keyword\">new</span> MySQLMessage(data);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\tmm.position(<span class=\"number\">5</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: \t\tsql = mm.readString(charset);</div><div class=\"line\"> <span class=\"number\">9</span>: \t&#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</div><div class=\"line\"><span class=\"number\">10</span>: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class=\"string\">\"Unknown charset '\"</span> + charset + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">12</span>: \t&#125;\t\t</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// 执行语句</span></div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">this</span>.query( sql );</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"【5】\"><a href=\"#【5】\" class=\"headerlink\" title=\"【5】\"></a>【5】</h2><p>解析 SQL 类型。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(String sql)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"comment\">// 解析 SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">int</span> rs = ServerParse.parse(sql);</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"keyword\">int</span> sqlType = rs &amp; <span class=\"number\">0xff</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: \t</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">switch</span> (sqlType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"comment\">//explain sql</span></div><div class=\"line\"><span class=\"number\">10</span>: \t<span class=\"keyword\">case</span> ServerParse.EXPLAIN:</div><div class=\"line\"><span class=\"number\">11</span>: \t\tExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"keyword\">case</span> ServerParse.SELECT:</div><div class=\"line\"><span class=\"number\">16</span>: \t\tSelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">17</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">20</span>: \t\t<span class=\"keyword\">if</span>(readOnly)&#123;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t\tLOGGER.warn(<span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">\"User readonly:\"</span>).append(sql).toString());</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class=\"string\">\"User readonly\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">25</span>: \t\tc.execute(sql, rs &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\"><span class=\"number\">26</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:</div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">32</span>: \t<span class=\"keyword\">int</span> length = stmt.length();</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">int</span> rt = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"comment\">// .... 省略部分case\t\t\tcase 'I':</span></div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'i'</span>:</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trt = insertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">45</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'S'</span>:</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\trt = sCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">56</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">58</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"🚀【6】【7】\"><a href=\"#🚀【6】【7】\" class=\"headerlink\" title=\"🚀【6】【7】\"></a>🚀【6】【7】</h2><p>解析 Select SQL 类型，分发到对应的逻辑。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(String stmt, ServerConnection c, <span class=\"keyword\">int</span> offs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"keyword\">int</span> offset = offs;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"keyword\">switch</span> (ServerParseSelect.parse(stmt, offs)) &#123; <span class=\"comment\">// 解析 Select SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.VERSION_COMMENT: <span class=\"comment\">// select @@VERSION_COMMENT;</span></div><div class=\"line\"> <span class=\"number\">6</span>: \t\tSelectVersionComment.response(c);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.DATABASE: <span class=\"comment\">// select DATABASE();</span></div><div class=\"line\"> <span class=\"number\">9</span>: \t\tSelectDatabase.response(c);</div><div class=\"line\"><span class=\"number\">10</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">11</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.USER: <span class=\"comment\">// select CURRENT_USER();</span></div><div class=\"line\"><span class=\"number\">12</span>:         SelectUser.response(c);</div><div class=\"line\"><span class=\"number\">13</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.VERSION: <span class=\"comment\">// select VERSION();</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\tSelectVersion.response(c);</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">17</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.SESSION_INCREMENT: <span class=\"comment\">// select @@session.auto_increment_increment;</span></div><div class=\"line\"><span class=\"number\">18</span>: \t\tSessionIncrement.response(c);</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.SESSION_ISOLATION: <span class=\"comment\">// select @@session.tx_isolation;</span></div><div class=\"line\"><span class=\"number\">21</span>: \t\tSessionIsolation.response(c);</div><div class=\"line\"><span class=\"number\">22</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">23</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.LAST_INSERT_ID: <span class=\"comment\">// select LAST_INSERT_ID();</span></div><div class=\"line\"><span class=\"number\">24</span>: \t\t<span class=\"comment\">// ....省略代码</span></div><div class=\"line\"><span class=\"number\">25</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">26</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.IDENTITY: <span class=\"comment\">// select @@identity</span></div><div class=\"line\"><span class=\"number\">27</span>: \t\t<span class=\"comment\">// ....省略代码</span></div><div class=\"line\"><span class=\"number\">28</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">case</span> ServerParseSelect.SELECT_VAR_ALL: <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">30</span>:         SelectVariables.execute(c,stmt);</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">case</span> ServerParseSelect.SESSION_TX_READ_ONLY: <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">33</span>:         SelectTxReadOnly.response(c);</div><div class=\"line\"><span class=\"number\">34</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">default</span>: <span class=\"comment\">// 其他，例如 select * from table</span></div><div class=\"line\"><span class=\"number\">36</span>: \t\tc.execute(stmt, ServerParse.SELECT);</div><div class=\"line\"><span class=\"number\">37</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParseSelect.java】</span></div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t<span class=\"keyword\">int</span> i = offset;</div><div class=\"line\"><span class=\"number\">42</span>: \t<span class=\"keyword\">for</span> (; i &lt; stmt.length(); ++i) &#123;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'#'</span>:</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\ti = ParseUtil.comment(stmt, i);</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'@'</span>:</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">return</span> select2Check(stmt, i);</div><div class=\"line\"><span class=\"number\">52</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'d'</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">return</span> databaseCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">55</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</div><div class=\"line\"><span class=\"number\">56</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'l'</span>:</div><div class=\"line\"><span class=\"number\">57</span>: \t\t\t<span class=\"keyword\">return</span> lastInsertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">58</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'U'</span>:</div><div class=\"line\"><span class=\"number\">59</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'u'</span>:</div><div class=\"line\"><span class=\"number\">60</span>: \t\t\t<span class=\"keyword\">return</span> userCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">61</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</div><div class=\"line\"><span class=\"number\">62</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'c'</span>:</div><div class=\"line\"><span class=\"number\">63</span>: \t\t\t<span class=\"keyword\">return</span> currentUserCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">64</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</div><div class=\"line\"><span class=\"number\">65</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'v'</span>:</div><div class=\"line\"><span class=\"number\">66</span>: \t\t\t<span class=\"keyword\">return</span> versionCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">67</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">68</span>: \t\t\t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">69</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">70</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">71</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">72</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"【8】\"><a href=\"#【8】\" class=\"headerlink\" title=\"【8】\"></a>【8】</h2><p>执行 SQL，详细解析见下文，核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrontendConnection</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(String sql, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\t\t\t<span class=\"string\">\"Unknown MyCAT Database '\"</span> + db + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"comment\">// 路由到后端数据库，执行 SQL</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\trouteEndExecuteSQL(sql, type, schema);</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: \t</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">routeEndExecuteSQL</span><span class=\"params\">(String sql, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"comment\">// 路由计算</span></div><div class=\"line\"><span class=\"number\">20</span>: \t\tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\trrs = MycatServer</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t\t\t.getInstance()</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\t\t\t.getRouterservice()</div><div class=\"line\"><span class=\"number\">25</span>: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\t\t\t\tschema, type, sql, <span class=\"keyword\">this</span>.charset, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tStringBuilder s = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tLOGGER.warn(s.append(<span class=\"keyword\">this</span>).append(sql).toString() + <span class=\"string\">\" err:\"</span> + e.toString(),e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\tString msg = e.getMessage();</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class=\"keyword\">null</span> ? e.getClass().getSimpleName() : msg);</div><div class=\"line\"><span class=\"number\">33</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">34</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\t<span class=\"comment\">// session执行</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t</div><div class=\"line\"><span class=\"number\">42</span>:  \t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: </div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-获得路由结果\"><a href=\"#3-获得路由结果\" class=\"headerlink\" title=\"3. 获得路由结果\"></a>3. 获得路由结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/03.png\" alt=\"【单库单表】插入（02获取路由）\"></p>\n<h2 id=\"【-1-5-】\"><a href=\"#【-1-5-】\" class=\"headerlink\" title=\"【 1 -  5 】\"></a>【 1 -  5 】</h2><p>获得路由主流程。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class=\"line\"> <span class=\"number\">3</span>: \t\t<span class=\"keyword\">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class=\"line\"> 4: \t\t<span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: \t<span class=\"comment\">// SELECT 类型的SQL, 检测缓存是否存在</span></div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">if</span> (sqlType == ServerParse.SELECT) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t\tcacheKey = schema.getName() + stmt;\t\t\t</div><div class=\"line\"><span class=\"number\">10</span>: \t\trrs = (RouteResultset) sqlRouteCache.get(cacheKey);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\t\tcheckMigrateRule(schema.getName(),rrs,sqlType);</div><div class=\"line\"><span class=\"number\">13</span>: \t\t\t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">15</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class=\"line\"><span class=\"number\">20</span>: \t<span class=\"keyword\">if</span>(hintLength != -<span class=\"number\">1</span>)&#123; <span class=\"comment\">// TODO 待读：hint</span></div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">22</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">23</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>: \t\tstmt = stmt.trim();</div><div class=\"line\"><span class=\"number\">25</span>: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\tcharset, sc, tableId2DataNodeCache);</div><div class=\"line\"><span class=\"number\">27</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>: \t<span class=\"comment\">// 记录查询命令路由结果缓存</span></div><div class=\"line\"><span class=\"number\">30</span>: \t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span> &amp;&amp; sqlType == ServerParse.SELECT &amp;&amp; rrs.isCacheAble()) &#123;</div><div class=\"line\"><span class=\"number\">31</span>: \t\tsqlRouteCache.putIfAbsent(cacheKey, rrs);</div><div class=\"line\"><span class=\"number\">32</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">// .... 省略代码\t\treturn rrs;</span></div><div class=\"line\"><span class=\"number\">34</span>: &#125;</div><div class=\"line\"><span class=\"number\">35</span>: <span class=\"comment\">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class=\"line\"><span class=\"number\">36</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">37</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema, <span class=\"keyword\">int</span> sqlType, String origSQL,</span></span></div><div class=\"line\"><span class=\"number\">38</span>: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>: \t<span class=\"comment\">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class=\"line\"><span class=\"number\">43</span>: \t<span class=\"keyword\">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">45</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>: \t<span class=\"comment\">// 检查是否有分片</span></div><div class=\"line\"><span class=\"number\">50</span>: \t<span class=\"keyword\">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class=\"line\"><span class=\"number\">51</span>: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class=\"line\"><span class=\"number\">52</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class=\"line\"><span class=\"number\">54</span>: \t\t<span class=\"keyword\">if</span> (returnedSet == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class=\"line\"><span class=\"number\">56</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: \t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">60</span>: &#125;</div></pre></td></tr></table></figure>\n<p>🚀【3】第 7 至 16 行 ：当 Select SQL 存在路由结果缓存时，直接返回缓存。<br>🚀【6】第 29 至 32 行 ：记录 Select SQL 路由结果到缓存。</p>\n<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>\n<h1 id=\"4-获得-MySQL-连接，执行-SQL\"><a href=\"#4-获得-MySQL-连接，执行-SQL\" class=\"headerlink\" title=\"4. 获得 MySQL 连接，执行 SQL\"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/03.png\" alt=\"【单库单表】查询（03执行 SQL）\"></p>\n<h2 id=\"【-1-8-】\"><a href=\"#【-1-8-】\" class=\"headerlink\" title=\"【 1 - 8 】\"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>\n<ul>\n<li>PhysicalDBNode ：物理数据库节点。</li>\n<li>PhysicalDatasource ：物理数据库数据源。</li>\n</ul>\n<h2 id=\"【-9-13-】\"><a href=\"#【-9-13-】\" class=\"headerlink\" title=\"【 9 - 13 】\"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>\n<h1 id=\"🚀-5-响应执行-SQL-结果\"><a href=\"#🚀-5-响应执行-SQL-结果\" class=\"headerlink\" title=\"🚀 5. 响应执行 SQL 结果\"></a>🚀 5. 响应执行 SQL 结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/04.png\" alt=\"【单库单表】查询（04执行响应）\"></p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MySQLConnectionHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleData</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"keyword\">switch</span> (resultStatus) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_INIT:</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t<span class=\"keyword\">case</span> OkPacket.FIELD_COUNT:</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\thandleOkPacket(data);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">11</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t\t<span class=\"keyword\">case</span> RequestFilePacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\thandleRequestPacket(data);</div><div class=\"line\"><span class=\"number\">15</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 初始化 header fields</span></div><div class=\"line\"><span class=\"number\">17</span>: \t\t\tresultStatus = RESULT_STATUS_HEADER;</div><div class=\"line\"><span class=\"number\">18</span>: \t\t\theader = data;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t\tfields = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">byte</span>[]&gt;((<span class=\"keyword\">int</span>) ByteUtil.readLength(data,</div><div class=\"line\"><span class=\"number\">20</span>: \t\t\t\t\t<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"number\">21</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">23</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_HEADER:</div><div class=\"line\"><span class=\"number\">24</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"><span class=\"number\">25</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">27</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">28</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t<span class=\"keyword\">case</span> EOFPacket.FIELD_COUNT: <span class=\"comment\">// 解析 fields 结束</span></div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tresultStatus = RESULT_STATUS_FIELD_EOF;</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\thandleFieldEofPacket(data);</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">33</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 解析 fields</span></div><div class=\"line\"><span class=\"number\">34</span>: \t\t\tfields.add(data);</div><div class=\"line\"><span class=\"number\">35</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">37</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_FIELD_EOF:</div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"><span class=\"number\">39</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t<span class=\"keyword\">case</span> EOFPacket.FIELD_COUNT: <span class=\"comment\">// 解析 每行记录 结束</span></div><div class=\"line\"><span class=\"number\">44</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\thandleRowEofPacket(data);</div><div class=\"line\"><span class=\"number\">46</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">47</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 每行记录</span></div><div class=\"line\"><span class=\"number\">48</span>: \t\t\thandleRowPacket(data);</div><div class=\"line\"><span class=\"number\">49</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">51</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">52</span>: \t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"unknown status!\"</span>);</div><div class=\"line\"><span class=\"number\">53</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"6-其他-：更新-删除\"><a href=\"#6-其他-：更新-删除\" class=\"headerlink\" title=\"6. 其他 ：更新 / 删除\"></a>6. 其他 ：更新 / 删除</h1><p>流程基本和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-insert/\">《MyCAT源码分析：【单库单表】插入》</a> 相同。我们就不另外文章解析。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/single-db-single-table-select/\">http://www.yunai.me/MyCAT/single-db-single-table-select/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 接收请求，解析 SQL</a></li>\n<li><a href=\"#\">3. 获得路由结果</a></li>\n<li><a href=\"#\">4. 获得 MySQL 连接，执行 SQL</a></li>\n<li><a href=\"#\">5. 响应执行 SQL 结果</a></li>\n<li><a href=\"#\">6. 其他 ：更新 / 删除</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><blockquote>\n<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>\n</blockquote>\n<p>本文讲解 【单库单表】查询 所涉及到的代码。</p>\n<p>😂内容和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-insert/\">《MyCAT 源码分析 —— 【单库单表】插入》</a> 超级相似，一方面本身流程基本相同，另外一方面文章结构没拆分好。我们使用 🚀 标记差异的逻辑。</p>\n<p>交互如下图：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/01.png\" alt=\"单库单表查询简图\"></p>\n<p>整个过程，MyCAT Server 流程如下：</p>\n<ol>\n<li>接收 MySQL Client 请求，解析 SQL。</li>\n<li>获得路由结果，进行路由。</li>\n<li>获得 MySQL 连接，执行 SQL。</li>\n<li>响应执行结果，发送结果给 MySQL Client。</li>\n</ol>\n<p>我们逐个步骤分析，一起来看看源码。</p>\n<h1 id=\"2-接收请求，解析-SQL\"><a href=\"#2-接收请求，解析-SQL\" class=\"headerlink\" title=\"2. 接收请求，解析 SQL\"></a>2. 接收请求，解析 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/02.png\" alt=\"【单库单表】查询（01主流程）\"></p>\n<h2 id=\"【1-2】\"><a href=\"#【1-2】\" class=\"headerlink\" title=\"【1 - 2】\"></a>【1 - 2】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>\n<h2 id=\"【3】\"><a href=\"#【3】\" class=\"headerlink\" title=\"【3】\"></a>【3】</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontendCommandHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">NIOHandler</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     </div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// .... 省略部分代码</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) <span class=\"comment\">// </span></div><div class=\"line\"> <span class=\"number\">9</span>:         &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_INIT_DB:</div><div class=\"line\"><span class=\"number\">11</span>:                 commands.doInitDB();</div><div class=\"line\"><span class=\"number\">12</span>:                 source.initDB(data);</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_QUERY: <span class=\"comment\">// 查询命令</span></div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 计数查询命令</span></div><div class=\"line\"><span class=\"number\">16</span>:                 commands.doQuery();</div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 执行查询命令</span></div><div class=\"line\"><span class=\"number\">18</span>:                 source.query(data);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">case</span> MySQLPacket.COM_PING:</div><div class=\"line\"><span class=\"number\">21</span>:                 commands.doPing();</div><div class=\"line\"><span class=\"number\">22</span>:                 source.ping();</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div></pre></td></tr></table></figure>\n<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href=\"http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>\n<h2 id=\"【4】\"><a href=\"#【4】\" class=\"headerlink\" title=\"【4】\"></a>【4】</h2><p>将 二进制数组 解析成 SQL。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"comment\">// 取得语句</span></div><div class=\"line\"> <span class=\"number\">4</span>: \tString sql = <span class=\"keyword\">null</span>;\t\t</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>: \t\tMySQLMessage mm = <span class=\"keyword\">new</span> MySQLMessage(data);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\tmm.position(<span class=\"number\">5</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: \t\tsql = mm.readString(charset);</div><div class=\"line\"> <span class=\"number\">9</span>: \t&#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</div><div class=\"line\"><span class=\"number\">10</span>: \t\twriteErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class=\"string\">\"Unknown charset '\"</span> + charset + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">12</span>: \t&#125;\t\t</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// 执行语句</span></div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">this</span>.query( sql );</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"【5】\"><a href=\"#【5】\" class=\"headerlink\" title=\"【5】\"></a>【5】</h2><p>解析 SQL 类型。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">query</span><span class=\"params\">(String sql)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"comment\">// 解析 SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">int</span> rs = ServerParse.parse(sql);</div><div class=\"line\"> <span class=\"number\">6</span>: \t<span class=\"keyword\">int</span> sqlType = rs &amp; <span class=\"number\">0xff</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: \t</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">switch</span> (sqlType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t<span class=\"comment\">//explain sql</span></div><div class=\"line\"><span class=\"number\">10</span>: \t<span class=\"keyword\">case</span> ServerParse.EXPLAIN:</div><div class=\"line\"><span class=\"number\">11</span>: \t\tExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>: \t<span class=\"keyword\">case</span> ServerParse.SELECT:</div><div class=\"line\"><span class=\"number\">16</span>: \t\tSelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">17</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">20</span>: \t\t<span class=\"keyword\">if</span>(readOnly)&#123;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t\tLOGGER.warn(<span class=\"keyword\">new</span> StringBuilder().append(<span class=\"string\">\"User readonly:\"</span>).append(sql).toString());</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\tc.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class=\"string\">\"User readonly\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">25</span>: \t\tc.execute(sql, rs &amp; <span class=\"number\">0xff</span>);</div><div class=\"line\"><span class=\"number\">26</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:</div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">32</span>: \t<span class=\"keyword\">int</span> length = stmt.length();</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class=\"line\"><span class=\"number\">34</span>: \t<span class=\"keyword\">int</span> rt = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"comment\">// .... 省略部分case\t\t\tcase 'I':</span></div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'i'</span>:</div><div class=\"line\"><span class=\"number\">39</span>: \t\t\trt = insertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">45</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'S'</span>:</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'s'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t\trt = sCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\t<span class=\"keyword\">if</span> (rt != OTHER) &#123;</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t\t<span class=\"keyword\">return</span> rt;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">52</span>: \t\t\t<span class=\"comment\">// .... 省略部分case</span></div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">56</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">58</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"🚀【6】【7】\"><a href=\"#🚀【6】【7】\" class=\"headerlink\" title=\"🚀【6】【7】\"></a>🚀【6】【7】</h2><p>解析 Select SQL 类型，分发到对应的逻辑。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(String stmt, ServerConnection c, <span class=\"keyword\">int</span> offs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"keyword\">int</span> offset = offs;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"keyword\">switch</span> (ServerParseSelect.parse(stmt, offs)) &#123; <span class=\"comment\">// 解析 Select SQL 类型</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.VERSION_COMMENT: <span class=\"comment\">// select @@VERSION_COMMENT;</span></div><div class=\"line\"> <span class=\"number\">6</span>: \t\tSelectVersionComment.response(c);</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.DATABASE: <span class=\"comment\">// select DATABASE();</span></div><div class=\"line\"> <span class=\"number\">9</span>: \t\tSelectDatabase.response(c);</div><div class=\"line\"><span class=\"number\">10</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">11</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.USER: <span class=\"comment\">// select CURRENT_USER();</span></div><div class=\"line\"><span class=\"number\">12</span>:         SelectUser.response(c);</div><div class=\"line\"><span class=\"number\">13</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.VERSION: <span class=\"comment\">// select VERSION();</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\tSelectVersion.response(c);</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">17</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.SESSION_INCREMENT: <span class=\"comment\">// select @@session.auto_increment_increment;</span></div><div class=\"line\"><span class=\"number\">18</span>: \t\tSessionIncrement.response(c);</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.SESSION_ISOLATION: <span class=\"comment\">// select @@session.tx_isolation;</span></div><div class=\"line\"><span class=\"number\">21</span>: \t\tSessionIsolation.response(c);</div><div class=\"line\"><span class=\"number\">22</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">23</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.LAST_INSERT_ID: <span class=\"comment\">// select LAST_INSERT_ID();</span></div><div class=\"line\"><span class=\"number\">24</span>: \t\t<span class=\"comment\">// ....省略代码</span></div><div class=\"line\"><span class=\"number\">25</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">26</span>: \t<span class=\"keyword\">case</span> ServerParseSelect.IDENTITY: <span class=\"comment\">// select @@identity</span></div><div class=\"line\"><span class=\"number\">27</span>: \t\t<span class=\"comment\">// ....省略代码</span></div><div class=\"line\"><span class=\"number\">28</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">case</span> ServerParseSelect.SELECT_VAR_ALL: <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">30</span>:         SelectVariables.execute(c,stmt);</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">case</span> ServerParseSelect.SESSION_TX_READ_ONLY: <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">33</span>:         SelectTxReadOnly.response(c);</div><div class=\"line\"><span class=\"number\">34</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">35</span>: \t<span class=\"keyword\">default</span>: <span class=\"comment\">// 其他，例如 select * from table</span></div><div class=\"line\"><span class=\"number\">36</span>: \t\tc.execute(stmt, ServerParse.SELECT);</div><div class=\"line\"><span class=\"number\">37</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerParseSelect.java】</span></div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parse</span><span class=\"params\">(String stmt, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">41</span>: \t<span class=\"keyword\">int</span> i = offset;</div><div class=\"line\"><span class=\"number\">42</span>: \t<span class=\"keyword\">for</span> (; i &lt; stmt.length(); ++i) &#123;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t<span class=\"keyword\">switch</span> (stmt.charAt(i)) &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">46</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'/'</span>:</div><div class=\"line\"><span class=\"number\">47</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'#'</span>:</div><div class=\"line\"><span class=\"number\">48</span>: \t\t\ti = ParseUtil.comment(stmt, i);</div><div class=\"line\"><span class=\"number\">49</span>: \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'@'</span>:</div><div class=\"line\"><span class=\"number\">51</span>: \t\t\t<span class=\"keyword\">return</span> select2Check(stmt, i);</div><div class=\"line\"><span class=\"number\">52</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:</div><div class=\"line\"><span class=\"number\">53</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'d'</span>:</div><div class=\"line\"><span class=\"number\">54</span>: \t\t\t<span class=\"keyword\">return</span> databaseCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">55</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'L'</span>:</div><div class=\"line\"><span class=\"number\">56</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'l'</span>:</div><div class=\"line\"><span class=\"number\">57</span>: \t\t\t<span class=\"keyword\">return</span> lastInsertCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">58</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'U'</span>:</div><div class=\"line\"><span class=\"number\">59</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'u'</span>:</div><div class=\"line\"><span class=\"number\">60</span>: \t\t\t<span class=\"keyword\">return</span> userCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">61</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</div><div class=\"line\"><span class=\"number\">62</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'c'</span>:</div><div class=\"line\"><span class=\"number\">63</span>: \t\t\t<span class=\"keyword\">return</span> currentUserCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">64</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'V'</span>:</div><div class=\"line\"><span class=\"number\">65</span>: \t\t<span class=\"keyword\">case</span> <span class=\"string\">'v'</span>:</div><div class=\"line\"><span class=\"number\">66</span>: \t\t\t<span class=\"keyword\">return</span> versionCheck(stmt, i);</div><div class=\"line\"><span class=\"number\">67</span>: \t\t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">68</span>: \t\t\t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">69</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">70</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">71</span>: \t<span class=\"keyword\">return</span> OTHER;</div><div class=\"line\"><span class=\"number\">72</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"【8】\"><a href=\"#【8】\" class=\"headerlink\" title=\"【8】\"></a>【8】</h2><p>执行 SQL，详细解析见下文，核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerConnection</span> <span class=\"keyword\">extends</span> <span class=\"title\">FrontendConnection</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(String sql, <span class=\"keyword\">int</span> type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: \t\tSchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">if</span> (schema == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t\twriteErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\t\t\t<span class=\"string\">\"Unknown MyCAT Database '\"</span> + db + <span class=\"string\">\"'\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>: \t\t<span class=\"comment\">// 路由到后端数据库，执行 SQL</span></div><div class=\"line\"><span class=\"number\">15</span>: \t\trouteEndExecuteSQL(sql, type, schema);</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: \t</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">routeEndExecuteSQL</span><span class=\"params\">(String sql, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> type, <span class=\"keyword\">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t<span class=\"comment\">// 路由计算</span></div><div class=\"line\"><span class=\"number\">20</span>: \t\tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t\trrs = MycatServer</div><div class=\"line\"><span class=\"number\">23</span>: \t\t\t\t\t.getInstance()</div><div class=\"line\"><span class=\"number\">24</span>: \t\t\t\t\t.getRouterservice()</div><div class=\"line\"><span class=\"number\">25</span>: \t\t\t\t\t.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\t\t\t\tschema, type, sql, <span class=\"keyword\">this</span>.charset, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>: \t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t\tStringBuilder s = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tLOGGER.warn(s.append(<span class=\"keyword\">this</span>).append(sql).toString() + <span class=\"string\">\" err:\"</span> + e.toString(),e);</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\tString msg = e.getMessage();</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\twriteErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class=\"keyword\">null</span> ? e.getClass().getSimpleName() : msg);</div><div class=\"line\"><span class=\"number\">33</span>: \t\t\t<span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">34</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"comment\">// 执行 SQL</span></div><div class=\"line\"><span class=\"number\">37</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>: \t\t\t<span class=\"comment\">// session执行</span></div><div class=\"line\"><span class=\"number\">39</span>: \t\t\tsession.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class=\"line\"><span class=\"number\">40</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t</div><div class=\"line\"><span class=\"number\">42</span>:  \t&#125;</div><div class=\"line\"><span class=\"number\">43</span>: </div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-获得路由结果\"><a href=\"#3-获得路由结果\" class=\"headerlink\" title=\"3. 获得路由结果\"></a>3. 获得路由结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/03.png\" alt=\"【单库单表】插入（02获取路由）\"></p>\n<h2 id=\"【-1-5-】\"><a href=\"#【-1-5-】\" class=\"headerlink\" title=\"【 1 -  5 】\"></a>【 1 -  5 】</h2><p>获得路由主流程。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class=\"line\"> <span class=\"number\">3</span>: \t\t<span class=\"keyword\">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class=\"line\"> 4: \t\t<span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \tRouteResultset rrs = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: \t<span class=\"comment\">// SELECT 类型的SQL, 检测缓存是否存在</span></div><div class=\"line\"> <span class=\"number\">8</span>: \t<span class=\"keyword\">if</span> (sqlType == ServerParse.SELECT) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>: \t\tcacheKey = schema.getName() + stmt;\t\t\t</div><div class=\"line\"><span class=\"number\">10</span>: \t\trrs = (RouteResultset) sqlRouteCache.get(cacheKey);</div><div class=\"line\"><span class=\"number\">11</span>: \t\t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>: \t\t\tcheckMigrateRule(schema.getName(),rrs,sqlType);</div><div class=\"line\"><span class=\"number\">13</span>: \t\t\t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\t&#125;</div><div class=\"line\"><span class=\"number\">15</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">16</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">19</span>: \t<span class=\"keyword\">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class=\"line\"><span class=\"number\">20</span>: \t<span class=\"keyword\">if</span>(hintLength != -<span class=\"number\">1</span>)&#123; <span class=\"comment\">// TODO 待读：hint</span></div><div class=\"line\"><span class=\"number\">21</span>: \t\t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">22</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">23</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>: \t\tstmt = stmt.trim();</div><div class=\"line\"><span class=\"number\">25</span>: \t\trrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\t\tcharset, sc, tableId2DataNodeCache);</div><div class=\"line\"><span class=\"number\">27</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>: \t<span class=\"comment\">// 记录查询命令路由结果缓存</span></div><div class=\"line\"><span class=\"number\">30</span>: \t<span class=\"keyword\">if</span> (rrs != <span class=\"keyword\">null</span> &amp;&amp; sqlType == ServerParse.SELECT &amp;&amp; rrs.isCacheAble()) &#123;</div><div class=\"line\"><span class=\"number\">31</span>: \t\tsqlRouteCache.putIfAbsent(cacheKey, rrs);</div><div class=\"line\"><span class=\"number\">32</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">33</span>: \t<span class=\"comment\">// .... 省略代码\t\treturn rrs;</span></div><div class=\"line\"><span class=\"number\">34</span>: &#125;</div><div class=\"line\"><span class=\"number\">35</span>: <span class=\"comment\">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class=\"line\"><span class=\"number\">36</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">37</span>: <span class=\"function\"><span class=\"keyword\">public</span> RouteResultset <span class=\"title\">route</span><span class=\"params\">(SystemConfig sysConfig, SchemaConfig schema, <span class=\"keyword\">int</span> sqlType, String origSQL,</span></span></div><div class=\"line\"><span class=\"number\">38</span>: \t\tString charset, ServerConnection sc, LayerCachePool cachePool) <span class=\"keyword\">throws</span> SQLNonTransientException &#123;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>: \t<span class=\"comment\">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class=\"line\"><span class=\"number\">43</span>: \t<span class=\"keyword\">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class=\"line\"><span class=\"number\">44</span>: \t\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">45</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>: \t<span class=\"comment\">// .... 省略代码</span></div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>: \t<span class=\"comment\">// 检查是否有分片</span></div><div class=\"line\"><span class=\"number\">50</span>: \t<span class=\"keyword\">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class=\"line\"><span class=\"number\">51</span>: \t\trrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class=\"line\"><span class=\"number\">52</span>: \t&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>: \t\tRouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class=\"line\"><span class=\"number\">54</span>: \t\t<span class=\"keyword\">if</span> (returnedSet == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">55</span>: \t\t\trrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class=\"line\"><span class=\"number\">56</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">57</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: \t<span class=\"keyword\">return</span> rrs;</div><div class=\"line\"><span class=\"number\">60</span>: &#125;</div></pre></td></tr></table></figure>\n<p>🚀【3】第 7 至 16 行 ：当 Select SQL 存在路由结果缓存时，直接返回缓存。<br>🚀【6】第 29 至 32 行 ：记录 Select SQL 路由结果到缓存。</p>\n<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>\n<h1 id=\"4-获得-MySQL-连接，执行-SQL\"><a href=\"#4-获得-MySQL-连接，执行-SQL\" class=\"headerlink\" title=\"4. 获得 MySQL 连接，执行 SQL\"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_29/03.png\" alt=\"【单库单表】查询（03执行 SQL）\"></p>\n<h2 id=\"【-1-8-】\"><a href=\"#【-1-8-】\" class=\"headerlink\" title=\"【 1 - 8 】\"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>\n<ul>\n<li>PhysicalDBNode ：物理数据库节点。</li>\n<li>PhysicalDatasource ：物理数据库数据源。</li>\n</ul>\n<h2 id=\"【-9-13-】\"><a href=\"#【-9-13-】\" class=\"headerlink\" title=\"【 9 - 13 】\"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>\n<h1 id=\"🚀-5-响应执行-SQL-结果\"><a href=\"#🚀-5-响应执行-SQL-结果\" class=\"headerlink\" title=\"🚀 5. 响应执行 SQL 结果\"></a>🚀 5. 响应执行 SQL 结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_05_30/04.png\" alt=\"【单库单表】查询（04执行响应）\"></p>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MySQLConnectionHandler.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">handleData</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] data)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>: \t<span class=\"keyword\">switch</span> (resultStatus) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_INIT:</div><div class=\"line\"> <span class=\"number\">6</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: \t\t<span class=\"keyword\">case</span> OkPacket.FIELD_COUNT:</div><div class=\"line\"> <span class=\"number\">8</span>: \t\t\thandleOkPacket(data);</div><div class=\"line\"> <span class=\"number\">9</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">10</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">11</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">12</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">13</span>: \t\t<span class=\"keyword\">case</span> RequestFilePacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">14</span>: \t\t\thandleRequestPacket(data);</div><div class=\"line\"><span class=\"number\">15</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">16</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 初始化 header fields</span></div><div class=\"line\"><span class=\"number\">17</span>: \t\t\tresultStatus = RESULT_STATUS_HEADER;</div><div class=\"line\"><span class=\"number\">18</span>: \t\t\theader = data;</div><div class=\"line\"><span class=\"number\">19</span>: \t\t\tfields = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">byte</span>[]&gt;((<span class=\"keyword\">int</span>) ByteUtil.readLength(data,</div><div class=\"line\"><span class=\"number\">20</span>: \t\t\t\t\t<span class=\"number\">4</span>));</div><div class=\"line\"><span class=\"number\">21</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">22</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">23</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_HEADER:</div><div class=\"line\"><span class=\"number\">24</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"><span class=\"number\">25</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">26</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">27</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">28</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>: \t\t<span class=\"keyword\">case</span> EOFPacket.FIELD_COUNT: <span class=\"comment\">// 解析 fields 结束</span></div><div class=\"line\"><span class=\"number\">30</span>: \t\t\tresultStatus = RESULT_STATUS_FIELD_EOF;</div><div class=\"line\"><span class=\"number\">31</span>: \t\t\thandleFieldEofPacket(data);</div><div class=\"line\"><span class=\"number\">32</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">33</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 解析 fields</span></div><div class=\"line\"><span class=\"number\">34</span>: \t\t\tfields.add(data);</div><div class=\"line\"><span class=\"number\">35</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">36</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">37</span>: \t<span class=\"keyword\">case</span> RESULT_STATUS_FIELD_EOF:</div><div class=\"line\"><span class=\"number\">38</span>: \t\t<span class=\"keyword\">switch</span> (data[<span class=\"number\">4</span>]) &#123;</div><div class=\"line\"><span class=\"number\">39</span>: \t\t<span class=\"keyword\">case</span> ErrorPacket.FIELD_COUNT:</div><div class=\"line\"><span class=\"number\">40</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">41</span>: \t\t\thandleErrorPacket(data);</div><div class=\"line\"><span class=\"number\">42</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">43</span>: \t\t<span class=\"keyword\">case</span> EOFPacket.FIELD_COUNT: <span class=\"comment\">// 解析 每行记录 结束</span></div><div class=\"line\"><span class=\"number\">44</span>: \t\t\tresultStatus = RESULT_STATUS_INIT;</div><div class=\"line\"><span class=\"number\">45</span>: \t\t\thandleRowEofPacket(data);</div><div class=\"line\"><span class=\"number\">46</span>: \t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">47</span>: \t\t<span class=\"keyword\">default</span>: <span class=\"comment\">// 每行记录</span></div><div class=\"line\"><span class=\"number\">48</span>: \t\t\thandleRowPacket(data);</div><div class=\"line\"><span class=\"number\">49</span>: \t\t&#125;</div><div class=\"line\"><span class=\"number\">50</span>: \t\t<span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">51</span>: \t<span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">52</span>: \t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"unknown status!\"</span>);</div><div class=\"line\"><span class=\"number\">53</span>: \t&#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"6-其他-：更新-删除\"><a href=\"#6-其他-：更新-删除\" class=\"headerlink\" title=\"6. 其他 ：更新 / 删除\"></a>6. 其他 ：更新 / 删除</h1><p>流程基本和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-insert/\">《MyCAT源码分析：【单库单表】插入》</a> 相同。我们就不另外文章解析。</p>\n"},{"title":"MyCAT 源码解析 —— 分片结果合并（一）","date":"2017-06-12T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/MyCAT/sharding-result-merge-first/](http://www.yunai.me/MyCAT/sharding-result-merge-first/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n# 1. 概述\n\n相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现**分片结果合并**。\n\n跨分片查询大体流程如下：\n\n![flow](http://www.yunai.me/images/MyCAT/2017_06_13/flow.png)\n\n和 [《【单库单表】查询》](http://www.yunai.me/Mycat/single-db-single-table-select/) 不同的两个过程：\n\n* 【2】多分片执行 SQL\n* 【4】合并多分片结果\n\n下面，我们来逐条讲解这两个过程。\n\n# 2. 多分片执行 SQL\n\n![execute_sql](http://www.yunai.me/images/MyCAT/2017_06_13/execute_sql.png)\n\n经过 SQL 解析后，计算出需要执行 SQL 的**分片节点**，遍历**分片节点**发送 SQL 进行执行。\n\n**核心代码**：\n\n* [MultiNodeQueryHandler.java#execute(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java)\n\n_**SQL 解析** 详细过程，我们另开文章，避免内容过多，影响大家对 **分片结果合并** 流程和逻辑的理解。_\n\n# 3. 合并多分片结果\n\n![handle_response](http://www.yunai.me/images/MyCAT/2017_06_13/handle_response.png)\n\n和 [《【单库单表】查询》](http://www.yunai.me/Mycat/single-db-single-table-select/) 不同，多个**分片节点**都会**分别**响应 _记录头(header)_ 和 _记录行(row)_ 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。\n\n```SQL\nFROM       // [1] 选择表\nWHERE      // [2] 过滤表\nGROUP BY   // [3] 分组\nSELECT     // [4] 普通字段，max / min / avg / sum / count 等函数，distinct\nHAVING     // [5] 再过滤表\nORDER BY   // [6] 排序\nLIMIT      // [7] 分页\n```\n\n## 3.1 记录头(header)\n\n多个**分片节点**响应时，会响应多次 _记录头(header)_ 。MyCAT 在实际处理时，只处理第一个返回的 _记录头(header)_ 。因此，在使用时要保证表的 Schema 相同。\n\n**分片节点**响应的 _记录头(header)_ 可以直接返回 MySQL Client 吗？答案是不可以。`AVG`函数 是特殊情况，MyCAT 需要将 `AVG` 拆成 `SUM` + `COUNT` 进行计算。举个例子：\n\n```SQL\n// [1] MySQL Client => MyCAT ：\nSELECT AVG(age) FROM student;\n\n// [2] MyCAT => MySQL Server ：\nSELECT SUM(age) AS AVG0SUM, COUNT(age) AS AVG0COUNT FROM student;\n\n// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)\n```\n\n**核心代码**：\n\n* [MultiNodeQueryHandler.java#fieldEofResponse(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java)。\n\n## 3.2 记录行(row)\n\n### 3.1 AbstractDataNodeMerge\n\nMyCAT 对分片结果合并通过 `AbstractDataNodeMerge` 子类来完成。\n\n![merge_service](http://www.yunai.me/images/MyCAT/2017_06_13/merge_service.png) \n\n`AbstractDataNodeMerge` ：\n\n* -packs ：待合并记录行(row)队列。队列尾部插入 `END_FLAG_PACK` 表示队列已结束。\n* -running ：合并逻辑是否正在执行中的标记。\n* ~onRowMetaData(...) ：根据**记录列信息(ColMeta)**构建对应的排序组件和聚合组件。需要子类进行实现。\n* ~onNewRecord(...) ：插入记录行(row) 到 `packs`。\n* ~outputMergeResult(...) ：插入 `END_FLAG_PACK` 到 `packs`。\n* ~run(...) ：执行**合并**分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。\n\n![AbstractDataNodeMerge_run.png](http://www.yunai.me/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png)\n\n**通过 `running` 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行*聚合*逻辑。当然，*排序*逻辑需要等到所有分片结果都返回才可以执行。**\n\n**核心代码**：\n\n* [AbstractDataNodeMerge.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java)\n* [DataNodeMergeManager.java#run(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java)\n\n### 3.2 DataNodeMergeManager\n\n`AbstractDataNodeMerge` 有两种子类实现：\n\n* `DataMergeService` ：基于**堆内内存**合并分片结果。\n* `DataNodeMergeManager` ：基于**堆外内存**合并分片结果。\n\n目前官方默认配置使用 `DataNodeMergeManager`。主要有如下优点：\n\n1. 可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。\n2. 减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。\n3. 更快的内存复制和读取速度，对排序和聚合带来很好的提速。\n\n如果对**堆外内存**不太了解，推荐阅读如下文章：\n\n1. [《从0到1起步-跟我进入堆外内存的奇妙世界》](http://www.jianshu.com/p/50be08b54bee)\n2. [《堆内内存还是堆外内存？》](http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory)\n3. [《JAVA堆外内存》](http://www.cnblogs.com/moonandstar08/p/5107648.html)\n4. [《JVM源码分析之堆外内存完全解读》](https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE)\n\n本文主要分析 `DataNodeMergeManager` 实现，`DataMergeService` 可以自己阅读或者等待后续文章（😈**欢迎订阅我的公众号噢**）。\n\n`DataNodeMergeManager` 有三个组件：\n\n* `globalSorter` ：`UnsafeExternalRowSorter` => 实现记录行(row)**合并并排序**逻辑。\n* `globalMergeResult` ：`UnsafeExternalRowSorter` => 实现记录行(row)**合并不排序**逻辑。\n* `unsafeRowGrouper` ： `UnsafeRowGrouper` => 实现记录行(row)**聚合**逻辑。\n\n`DataNodeMergeManager#run(...)` 逻辑如下：\n\n* [1] 写入记录行(row)到 `UnsafeRow`。\n* [2] 根据情况将 `UnsafeRow` 插入对应组件。\n* [3] 当所有 `UnsafeRow` 插入完后，根据情况使用组件聚合、排序。\n\n| 是否排序 | 是否聚合 | 依赖组件 | [2] | [3] |\n| --- | --- | --- | --- | --- |\n| 否 | 否 | `globalSorter` | 插入 `globalSorter` | 使用 `globalSorter` 合并并排序 |\n| 是 | 否 | `globalMergeResult` | 插入 `globalMergeResult` | 使用 `globalMergeResult` 合并不排序 |\n| 否 | 是 | `unsafeRowGrouper` + `globalSorter` | 插入 `unsafeRowGrouper` 进行聚合 | 使用 `globalSorter` 合并并排序 |\n| 是 | 是 | `unsafeRowGrouper` + `globalMergeResult` | 插入 `unsafeRowGrouper` 进行聚合 | 使用 `globalMergeResult` 合并不排序 |\n\n**核心代码**：\n\n* [DataNodeMergeManager.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java)。\n\n🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。\n\n### 3.3 UnsafeRow\n\n![unsafe_row](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row.png)\n\n记录行(row)写到 `UnsafeRow` 的 `baseObject` 属性，结构如下：\n\n![unsafe_row_object](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_object.png)\n![unsafe_row_2.png](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_2.png)\n\n* 拆分成三个区域，**每个区域按照格子记录信息，每个格子 64bits(8 Bytes)**。\n* 记录行(row)按照字段顺序位置记录到 `baseObject`。\n* [1] 空标记位区域 ：标记字段对应的值是否为 NULL。\n    * 当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。\n    * 因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(`bitSetWidthInBytes`) = 字段占用的格子数 * 64 bits。\n* [2] 位置长度区域 ：记录字段对应的值在`[3]区域`所在的位置和长度。\n    * 每个字段记录`[2]区域`的位置 = `baseOffset` + `bitSetWidthInBytes` + 8 Bytes * 字段顺序。\n    * 占用一个格子，前 32 bits 为`[3]区域`的位置，后 32 bits 为字段对应的值长度。\n* [3] 值区域 ：记录字段对应的值。\n    * 每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。\n    * 因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。\n\n**写入 `UnsafeRow`，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。**  \n\n🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 `Spark`，是不是更加有动力列😈。\n\n**核心代码**：\n\n* [UnsafeRow.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java)\n* [BufferHolder.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java)\n* [UnsafeRowWriter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java)\n\n### 3.4 UnsafeExternalRowSorter\n\n如果使用 Java 实现 `SELECT * FROM student ORDER BY age desc, nickname asc`，不考虑算法优化的情况下，我们可以简单如下实现：\n\n```Java\nCollections.sort(students, new Comparator<Comparable>() {\n       @Override\n       public int compare(Student o1, Student o2) {\n           int cmp = compare(o2.age, o1.age);\n           return cmp != 0 ? cmp : compare(o1.nickname, o2.nickname);\n       }\n   }\n});\n```\n\n从功能上，`UnsafeExternalRowSorter` 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。\n\n![sorter_write](http://www.yunai.me/images/MyCAT/2017_06_13/sorter_write.jpeg)\n\n`UnsafeRow` 会写入到两个地方：\n\n1. `List<MemoryBlock>` ：内存块数组。当前 `MemoryBlock` 无法容纳写入的 `UnsafeRow` 时，生成新的 `MemoryBlock` 提供写入。每条 `UnsafeRow` 存储在 `MemoryBlock` 由 长度 + 字节内容 组成。\n2. `LongArray` ：每条 `UnsafeRow` 存储在 `LongArray` 由两部分组成：address + prefix。\n    * `address` ：`UnsafeRow` 存储在 `List<MemoryBlock>` 的位置。前 13 bits 记录所在 `MemoryBlock` 的 index，后 51 bit 记录在 `MemoryBlock` 的 offset。\n    * `prefix` ：`UnsafeRow` 第一个排序字段**值**前 64 bits 计算的值。\n\n**`UnsafeExternalRowSorter` 排序实现方式** ：提供 **[TimSort](http://blog.csdn.net/yangzhongblog/article/details/8184707)** 和 **RadixSort** 两种排序算法，前者为默认实现。**TimSort** 折半查找时，使用 `LongArray`，先比较 `prefix`，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 `LongArray` 操作，`List<MemoryBlock>` 只作为原始数据。\n\n另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂\n\n核心源码：\n\n*  [UnsafeExternalRowSorter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java)\n*  [UnsafeExternalRowSorter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java)\n*  [TimSort.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java)\n\n### 3.5 UnsafeRowGrouper\n\n如果使用 Java 实现 `SELECT nickname, COUNT(*) FROM student group by nickname`，不考虑算法优化的情况下，我们可以简单如下实现：\n\n```Java\nMap<String, List<Object>> map = new HashMap<>();\n// 聚合\nfor (student : students) {\n    if (map.contains(student.nickname)) {\n        map.put(student.nickname, map.get(student.nickname).get(1) + 1);\n    } else {\n        List<Object> value = new Array<>();\n        value.add(nickname);\n        value.add(1);\n        map.put(student.nickname, value);\n    }\n}\n// 输出\nfor (value : map.values) {\n    System.out.println(value);\n}\n```\n\n从功能上，`UnsafeRowGrouper` 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。\n\n😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。\n\n\n# 4. 救护中心\n\n看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。\n\n最后的最后，感谢耐心阅读本文的同学。\n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n\n","source":"_posts/MyCAT/2017_06_13_MyCAT源码分析——分片结果合并.md","raw":"title: MyCAT 源码解析 —— 分片结果合并（一）\ndate: 2017-06-13\ntags:\ncategories: MyCAT\npermalink: MyCAT/sharding-result-merge-first\n\n---\n\n>  原文地址：[http://www.yunai.me/MyCAT/sharding-result-merge-first/](http://www.yunai.me/MyCAT/sharding-result-merge-first/)  \n> `MyCat-Server` **带注释代码**地址 ：[https://github.com/YunaiV/Mycat-Server](https://github.com/YunaiV/Mycat-Server)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n# 1. 概述\n\n相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现**分片结果合并**。\n\n跨分片查询大体流程如下：\n\n![flow](http://www.yunai.me/images/MyCAT/2017_06_13/flow.png)\n\n和 [《【单库单表】查询》](http://www.yunai.me/Mycat/single-db-single-table-select/) 不同的两个过程：\n\n* 【2】多分片执行 SQL\n* 【4】合并多分片结果\n\n下面，我们来逐条讲解这两个过程。\n\n# 2. 多分片执行 SQL\n\n![execute_sql](http://www.yunai.me/images/MyCAT/2017_06_13/execute_sql.png)\n\n经过 SQL 解析后，计算出需要执行 SQL 的**分片节点**，遍历**分片节点**发送 SQL 进行执行。\n\n**核心代码**：\n\n* [MultiNodeQueryHandler.java#execute(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java)\n\n_**SQL 解析** 详细过程，我们另开文章，避免内容过多，影响大家对 **分片结果合并** 流程和逻辑的理解。_\n\n# 3. 合并多分片结果\n\n![handle_response](http://www.yunai.me/images/MyCAT/2017_06_13/handle_response.png)\n\n和 [《【单库单表】查询》](http://www.yunai.me/Mycat/single-db-single-table-select/) 不同，多个**分片节点**都会**分别**响应 _记录头(header)_ 和 _记录行(row)_ 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。\n\n```SQL\nFROM       // [1] 选择表\nWHERE      // [2] 过滤表\nGROUP BY   // [3] 分组\nSELECT     // [4] 普通字段，max / min / avg / sum / count 等函数，distinct\nHAVING     // [5] 再过滤表\nORDER BY   // [6] 排序\nLIMIT      // [7] 分页\n```\n\n## 3.1 记录头(header)\n\n多个**分片节点**响应时，会响应多次 _记录头(header)_ 。MyCAT 在实际处理时，只处理第一个返回的 _记录头(header)_ 。因此，在使用时要保证表的 Schema 相同。\n\n**分片节点**响应的 _记录头(header)_ 可以直接返回 MySQL Client 吗？答案是不可以。`AVG`函数 是特殊情况，MyCAT 需要将 `AVG` 拆成 `SUM` + `COUNT` 进行计算。举个例子：\n\n```SQL\n// [1] MySQL Client => MyCAT ：\nSELECT AVG(age) FROM student;\n\n// [2] MyCAT => MySQL Server ：\nSELECT SUM(age) AS AVG0SUM, COUNT(age) AS AVG0COUNT FROM student;\n\n// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)\n```\n\n**核心代码**：\n\n* [MultiNodeQueryHandler.java#fieldEofResponse(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java)。\n\n## 3.2 记录行(row)\n\n### 3.1 AbstractDataNodeMerge\n\nMyCAT 对分片结果合并通过 `AbstractDataNodeMerge` 子类来完成。\n\n![merge_service](http://www.yunai.me/images/MyCAT/2017_06_13/merge_service.png) \n\n`AbstractDataNodeMerge` ：\n\n* -packs ：待合并记录行(row)队列。队列尾部插入 `END_FLAG_PACK` 表示队列已结束。\n* -running ：合并逻辑是否正在执行中的标记。\n* ~onRowMetaData(...) ：根据**记录列信息(ColMeta)**构建对应的排序组件和聚合组件。需要子类进行实现。\n* ~onNewRecord(...) ：插入记录行(row) 到 `packs`。\n* ~outputMergeResult(...) ：插入 `END_FLAG_PACK` 到 `packs`。\n* ~run(...) ：执行**合并**分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。\n\n![AbstractDataNodeMerge_run.png](http://www.yunai.me/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png)\n\n**通过 `running` 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行*聚合*逻辑。当然，*排序*逻辑需要等到所有分片结果都返回才可以执行。**\n\n**核心代码**：\n\n* [AbstractDataNodeMerge.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java)\n* [DataNodeMergeManager.java#run(...)](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java)\n\n### 3.2 DataNodeMergeManager\n\n`AbstractDataNodeMerge` 有两种子类实现：\n\n* `DataMergeService` ：基于**堆内内存**合并分片结果。\n* `DataNodeMergeManager` ：基于**堆外内存**合并分片结果。\n\n目前官方默认配置使用 `DataNodeMergeManager`。主要有如下优点：\n\n1. 可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。\n2. 减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。\n3. 更快的内存复制和读取速度，对排序和聚合带来很好的提速。\n\n如果对**堆外内存**不太了解，推荐阅读如下文章：\n\n1. [《从0到1起步-跟我进入堆外内存的奇妙世界》](http://www.jianshu.com/p/50be08b54bee)\n2. [《堆内内存还是堆外内存？》](http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory)\n3. [《JAVA堆外内存》](http://www.cnblogs.com/moonandstar08/p/5107648.html)\n4. [《JVM源码分析之堆外内存完全解读》](https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE)\n\n本文主要分析 `DataNodeMergeManager` 实现，`DataMergeService` 可以自己阅读或者等待后续文章（😈**欢迎订阅我的公众号噢**）。\n\n`DataNodeMergeManager` 有三个组件：\n\n* `globalSorter` ：`UnsafeExternalRowSorter` => 实现记录行(row)**合并并排序**逻辑。\n* `globalMergeResult` ：`UnsafeExternalRowSorter` => 实现记录行(row)**合并不排序**逻辑。\n* `unsafeRowGrouper` ： `UnsafeRowGrouper` => 实现记录行(row)**聚合**逻辑。\n\n`DataNodeMergeManager#run(...)` 逻辑如下：\n\n* [1] 写入记录行(row)到 `UnsafeRow`。\n* [2] 根据情况将 `UnsafeRow` 插入对应组件。\n* [3] 当所有 `UnsafeRow` 插入完后，根据情况使用组件聚合、排序。\n\n| 是否排序 | 是否聚合 | 依赖组件 | [2] | [3] |\n| --- | --- | --- | --- | --- |\n| 否 | 否 | `globalSorter` | 插入 `globalSorter` | 使用 `globalSorter` 合并并排序 |\n| 是 | 否 | `globalMergeResult` | 插入 `globalMergeResult` | 使用 `globalMergeResult` 合并不排序 |\n| 否 | 是 | `unsafeRowGrouper` + `globalSorter` | 插入 `unsafeRowGrouper` 进行聚合 | 使用 `globalSorter` 合并并排序 |\n| 是 | 是 | `unsafeRowGrouper` + `globalMergeResult` | 插入 `unsafeRowGrouper` 进行聚合 | 使用 `globalMergeResult` 合并不排序 |\n\n**核心代码**：\n\n* [DataNodeMergeManager.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java)。\n\n🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。\n\n### 3.3 UnsafeRow\n\n![unsafe_row](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row.png)\n\n记录行(row)写到 `UnsafeRow` 的 `baseObject` 属性，结构如下：\n\n![unsafe_row_object](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_object.png)\n![unsafe_row_2.png](http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_2.png)\n\n* 拆分成三个区域，**每个区域按照格子记录信息，每个格子 64bits(8 Bytes)**。\n* 记录行(row)按照字段顺序位置记录到 `baseObject`。\n* [1] 空标记位区域 ：标记字段对应的值是否为 NULL。\n    * 当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。\n    * 因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(`bitSetWidthInBytes`) = 字段占用的格子数 * 64 bits。\n* [2] 位置长度区域 ：记录字段对应的值在`[3]区域`所在的位置和长度。\n    * 每个字段记录`[2]区域`的位置 = `baseOffset` + `bitSetWidthInBytes` + 8 Bytes * 字段顺序。\n    * 占用一个格子，前 32 bits 为`[3]区域`的位置，后 32 bits 为字段对应的值长度。\n* [3] 值区域 ：记录字段对应的值。\n    * 每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。\n    * 因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。\n\n**写入 `UnsafeRow`，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。**  \n\n🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 `Spark`，是不是更加有动力列😈。\n\n**核心代码**：\n\n* [UnsafeRow.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java)\n* [BufferHolder.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java)\n* [UnsafeRowWriter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java)\n\n### 3.4 UnsafeExternalRowSorter\n\n如果使用 Java 实现 `SELECT * FROM student ORDER BY age desc, nickname asc`，不考虑算法优化的情况下，我们可以简单如下实现：\n\n```Java\nCollections.sort(students, new Comparator<Comparable>() {\n       @Override\n       public int compare(Student o1, Student o2) {\n           int cmp = compare(o2.age, o1.age);\n           return cmp != 0 ? cmp : compare(o1.nickname, o2.nickname);\n       }\n   }\n});\n```\n\n从功能上，`UnsafeExternalRowSorter` 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。\n\n![sorter_write](http://www.yunai.me/images/MyCAT/2017_06_13/sorter_write.jpeg)\n\n`UnsafeRow` 会写入到两个地方：\n\n1. `List<MemoryBlock>` ：内存块数组。当前 `MemoryBlock` 无法容纳写入的 `UnsafeRow` 时，生成新的 `MemoryBlock` 提供写入。每条 `UnsafeRow` 存储在 `MemoryBlock` 由 长度 + 字节内容 组成。\n2. `LongArray` ：每条 `UnsafeRow` 存储在 `LongArray` 由两部分组成：address + prefix。\n    * `address` ：`UnsafeRow` 存储在 `List<MemoryBlock>` 的位置。前 13 bits 记录所在 `MemoryBlock` 的 index，后 51 bit 记录在 `MemoryBlock` 的 offset。\n    * `prefix` ：`UnsafeRow` 第一个排序字段**值**前 64 bits 计算的值。\n\n**`UnsafeExternalRowSorter` 排序实现方式** ：提供 **[TimSort](http://blog.csdn.net/yangzhongblog/article/details/8184707)** 和 **RadixSort** 两种排序算法，前者为默认实现。**TimSort** 折半查找时，使用 `LongArray`，先比较 `prefix`，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 `LongArray` 操作，`List<MemoryBlock>` 只作为原始数据。\n\n另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂\n\n核心源码：\n\n*  [UnsafeExternalRowSorter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java)\n*  [UnsafeExternalRowSorter.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java)\n*  [TimSort.java](https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java)\n\n### 3.5 UnsafeRowGrouper\n\n如果使用 Java 实现 `SELECT nickname, COUNT(*) FROM student group by nickname`，不考虑算法优化的情况下，我们可以简单如下实现：\n\n```Java\nMap<String, List<Object>> map = new HashMap<>();\n// 聚合\nfor (student : students) {\n    if (map.contains(student.nickname)) {\n        map.put(student.nickname, map.get(student.nickname).get(1) + 1);\n    } else {\n        List<Object> value = new Array<>();\n        value.add(nickname);\n        value.add(1);\n        map.put(student.nickname, value);\n    }\n}\n// 输出\nfor (value : map.values) {\n    System.out.println(value);\n}\n```\n\n从功能上，`UnsafeRowGrouper` 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。\n\n😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。\n\n\n# 4. 救护中心\n\n看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。\n\n最后的最后，感谢耐心阅读本文的同学。\n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n\n","slug":"MyCAT/sharding-result-merge-first","published":1,"updated":"2017-06-15T11:20:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza3000dag5dnwirg1d1","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/sharding-result-merge-first/\">http://www.yunai.me/MyCAT/sharding-result-merge-first/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现<strong>分片结果合并</strong>。</p>\n<p>跨分片查询大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/flow.png\" alt=\"flow\"></p>\n<p>和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-select/\">《【单库单表】查询》</a> 不同的两个过程：</p>\n<ul>\n<li>【2】多分片执行 SQL</li>\n<li>【4】合并多分片结果</li>\n</ul>\n<p>下面，我们来逐条讲解这两个过程。</p>\n<h1 id=\"2-多分片执行-SQL\"><a href=\"#2-多分片执行-SQL\" class=\"headerlink\" title=\"2. 多分片执行 SQL\"></a>2. 多分片执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/execute_sql.png\" alt=\"execute_sql\"></p>\n<p>经过 SQL 解析后，计算出需要执行 SQL 的<strong>分片节点</strong>，遍历<strong>分片节点</strong>发送 SQL 进行执行。</p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java\" target=\"_blank\" rel=\"external\">MultiNodeQueryHandler.java#execute(…)</a></li>\n</ul>\n<p><em><strong>SQL 解析</strong> 详细过程，我们另开文章，避免内容过多，影响大家对 <strong>分片结果合并</strong> 流程和逻辑的理解。</em></p>\n<h1 id=\"3-合并多分片结果\"><a href=\"#3-合并多分片结果\" class=\"headerlink\" title=\"3. 合并多分片结果\"></a>3. 合并多分片结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/handle_response.png\" alt=\"handle_response\"></p>\n<p>和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-select/\">《【单库单表】查询》</a> 不同，多个<strong>分片节点</strong>都会<strong>分别</strong>响应 <em>记录头(header)</em> 和 <em>记录行(row)</em> 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\">FROM       // [1] 选择表</div><div class=\"line\">WHERE      // [2] 过滤表</div><div class=\"line\">GROUP BY   // [3] 分组</div><div class=\"line\"><span class=\"keyword\">SELECT</span>     // [<span class=\"number\">4</span>] 普通字段，<span class=\"keyword\">max</span> / <span class=\"keyword\">min</span> / <span class=\"keyword\">avg</span> / <span class=\"keyword\">sum</span> / <span class=\"keyword\">count</span> 等函数，<span class=\"keyword\">distinct</span></div><div class=\"line\"><span class=\"keyword\">HAVING</span>     // [<span class=\"number\">5</span>] 再过滤表</div><div class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span>   // [<span class=\"number\">6</span>] 排序</div><div class=\"line\"><span class=\"keyword\">LIMIT</span>      // [<span class=\"number\">7</span>] 分页</div></pre></td></tr></table></figure>\n<h2 id=\"3-1-记录头-header\"><a href=\"#3-1-记录头-header\" class=\"headerlink\" title=\"3.1 记录头(header)\"></a>3.1 记录头(header)</h2><p>多个<strong>分片节点</strong>响应时，会响应多次 <em>记录头(header)</em> 。MyCAT 在实际处理时，只处理第一个返回的 <em>记录头(header)</em> 。因此，在使用时要保证表的 Schema 相同。</p>\n<p><strong>分片节点</strong>响应的 <em>记录头(header)</em> 可以直接返回 MySQL Client 吗？答案是不可以。<code>AVG</code>函数 是特殊情况，MyCAT 需要将 <code>AVG</code> 拆成 <code>SUM</code> + <code>COUNT</code> 进行计算。举个例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">// [1] MySQL Client =&gt; MyCAT ：</div><div class=\"line\">SELECT AVG(age) FROM student;</div><div class=\"line\"></div><div class=\"line\">// [2] MyCAT =&gt; MySQL Server ：</div><div class=\"line\">SELECT SUM(age) AS AVG0SUM, COUNT(age) AS AVG0COUNT FROM student;</div><div class=\"line\"></div><div class=\"line\">// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)</div></pre></td></tr></table></figure>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java\" target=\"_blank\" rel=\"external\">MultiNodeQueryHandler.java#fieldEofResponse(…)</a>。</li>\n</ul>\n<h2 id=\"3-2-记录行-row\"><a href=\"#3-2-记录行-row\" class=\"headerlink\" title=\"3.2 记录行(row)\"></a>3.2 记录行(row)</h2><h3 id=\"3-1-AbstractDataNodeMerge\"><a href=\"#3-1-AbstractDataNodeMerge\" class=\"headerlink\" title=\"3.1 AbstractDataNodeMerge\"></a>3.1 AbstractDataNodeMerge</h3><p>MyCAT 对分片结果合并通过 <code>AbstractDataNodeMerge</code> 子类来完成。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/merge_service.png\" alt=\"merge_service\"> </p>\n<p><code>AbstractDataNodeMerge</code> ：</p>\n<ul>\n<li>-packs ：待合并记录行(row)队列。队列尾部插入 <code>END_FLAG_PACK</code> 表示队列已结束。</li>\n<li>-running ：合并逻辑是否正在执行中的标记。</li>\n<li>~onRowMetaData(…) ：根据<strong>记录列信息(ColMeta)</strong>构建对应的排序组件和聚合组件。需要子类进行实现。</li>\n<li>~onNewRecord(…) ：插入记录行(row) 到 <code>packs</code>。</li>\n<li>~outputMergeResult(…) ：插入 <code>END_FLAG_PACK</code> 到 <code>packs</code>。</li>\n<li>~run(…) ：执行<strong>合并</strong>分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png\" alt=\"AbstractDataNodeMerge_run.png\"></p>\n<p><strong>通过 <code>running</code> 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行<em>聚合</em>逻辑。当然，<em>排序</em>逻辑需要等到所有分片结果都返回才可以执行。</strong></p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java\" target=\"_blank\" rel=\"external\">AbstractDataNodeMerge.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java\" target=\"_blank\" rel=\"external\">DataNodeMergeManager.java#run(…)</a></li>\n</ul>\n<h3 id=\"3-2-DataNodeMergeManager\"><a href=\"#3-2-DataNodeMergeManager\" class=\"headerlink\" title=\"3.2 DataNodeMergeManager\"></a>3.2 DataNodeMergeManager</h3><p><code>AbstractDataNodeMerge</code> 有两种子类实现：</p>\n<ul>\n<li><code>DataMergeService</code> ：基于<strong>堆内内存</strong>合并分片结果。</li>\n<li><code>DataNodeMergeManager</code> ：基于<strong>堆外内存</strong>合并分片结果。</li>\n</ul>\n<p>目前官方默认配置使用 <code>DataNodeMergeManager</code>。主要有如下优点：</p>\n<ol>\n<li>可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。</li>\n<li>减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。</li>\n<li>更快的内存复制和读取速度，对排序和聚合带来很好的提速。</li>\n</ol>\n<p>如果对<strong>堆外内存</strong>不太了解，推荐阅读如下文章：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/50be08b54bee\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《从0到1起步-跟我进入堆外内存的奇妙世界》</a></li>\n<li><a href=\"http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《堆内内存还是堆外内存？》</a></li>\n<li><a href=\"http://www.cnblogs.com/moonandstar08/p/5107648.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《JAVA堆外内存》</a></li>\n<li><a href=\"https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《JVM源码分析之堆外内存完全解读》</a></li>\n</ol>\n<p>本文主要分析 <code>DataNodeMergeManager</code> 实现，<code>DataMergeService</code> 可以自己阅读或者等待后续文章（😈<strong>欢迎订阅我的公众号噢</strong>）。</p>\n<p><code>DataNodeMergeManager</code> 有三个组件：</p>\n<ul>\n<li><code>globalSorter</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并并排序</strong>逻辑。</li>\n<li><code>globalMergeResult</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并不排序</strong>逻辑。</li>\n<li><code>unsafeRowGrouper</code> ： <code>UnsafeRowGrouper</code> =&gt; 实现记录行(row)<strong>聚合</strong>逻辑。</li>\n</ul>\n<p><code>DataNodeMergeManager#run(...)</code> 逻辑如下：</p>\n<ul>\n<li>[1] 写入记录行(row)到 <code>UnsafeRow</code>。</li>\n<li>[2] 根据情况将 <code>UnsafeRow</code> 插入对应组件。</li>\n<li>[3] 当所有 <code>UnsafeRow</code> 插入完后，根据情况使用组件聚合、排序。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>是否排序</th>\n<th>是否聚合</th>\n<th>依赖组件</th>\n<th>[2]</th>\n<th>[3]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>否</td>\n<td>否</td>\n<td><code>globalSorter</code></td>\n<td>插入 <code>globalSorter</code></td>\n<td>使用 <code>globalSorter</code> 合并并排序</td>\n</tr>\n<tr>\n<td>是</td>\n<td>否</td>\n<td><code>globalMergeResult</code></td>\n<td>插入 <code>globalMergeResult</code></td>\n<td>使用 <code>globalMergeResult</code> 合并不排序</td>\n</tr>\n<tr>\n<td>否</td>\n<td>是</td>\n<td><code>unsafeRowGrouper</code> + <code>globalSorter</code></td>\n<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>\n<td>使用 <code>globalSorter</code> 合并并排序</td>\n</tr>\n<tr>\n<td>是</td>\n<td>是</td>\n<td><code>unsafeRowGrouper</code> + <code>globalMergeResult</code></td>\n<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>\n<td>使用 <code>globalMergeResult</code> 合并不排序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java\" target=\"_blank\" rel=\"external\">DataNodeMergeManager.java</a>。</li>\n</ul>\n<p>🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。</p>\n<h3 id=\"3-3-UnsafeRow\"><a href=\"#3-3-UnsafeRow\" class=\"headerlink\" title=\"3.3 UnsafeRow\"></a>3.3 UnsafeRow</h3><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row.png\" alt=\"unsafe_row\"></p>\n<p>记录行(row)写到 <code>UnsafeRow</code> 的 <code>baseObject</code> 属性，结构如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_object.png\" alt=\"unsafe_row_object\"><br><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_2.png\" alt=\"unsafe_row_2.png\"></p>\n<ul>\n<li>拆分成三个区域，<strong>每个区域按照格子记录信息，每个格子 64bits(8 Bytes)</strong>。</li>\n<li>记录行(row)按照字段顺序位置记录到 <code>baseObject</code>。</li>\n<li>[1] 空标记位区域 ：标记字段对应的值是否为 NULL。<ul>\n<li>当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。</li>\n<li>因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(<code>bitSetWidthInBytes</code>) = 字段占用的格子数 * 64 bits。</li>\n</ul>\n</li>\n<li>[2] 位置长度区域 ：记录字段对应的值在<code>[3]区域</code>所在的位置和长度。<ul>\n<li>每个字段记录<code>[2]区域</code>的位置 = <code>baseOffset</code> + <code>bitSetWidthInBytes</code> + 8 Bytes * 字段顺序。</li>\n<li>占用一个格子，前 32 bits 为<code>[3]区域</code>的位置，后 32 bits 为字段对应的值长度。</li>\n</ul>\n</li>\n<li>[3] 值区域 ：记录字段对应的值。<ul>\n<li>每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。</li>\n<li>因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。</li>\n</ul>\n</li>\n</ul>\n<p><strong>写入 <code>UnsafeRow</code>，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。</strong>  </p>\n<p>🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 <code>Spark</code>，是不是更加有动力列😈。</p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java\" target=\"_blank\" rel=\"external\">UnsafeRow.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java\" target=\"_blank\" rel=\"external\">BufferHolder.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java\" target=\"_blank\" rel=\"external\">UnsafeRowWriter.java</a></li>\n</ul>\n<h3 id=\"3-4-UnsafeExternalRowSorter\"><a href=\"#3-4-UnsafeExternalRowSorter\" class=\"headerlink\" title=\"3.4 UnsafeExternalRowSorter\"></a>3.4 UnsafeExternalRowSorter</h3><p>如果使用 Java 实现 <code>SELECT * FROM student ORDER BY age desc, nickname asc</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Collections.sort(students, <span class=\"keyword\">new</span> Comparator&lt;Comparable&gt;() &#123;</div><div class=\"line\">       <span class=\"meta\">@Override</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Student o1, Student o2)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> cmp = compare(o2.age, o1.age);</div><div class=\"line\">           <span class=\"keyword\">return</span> cmp != <span class=\"number\">0</span> ? cmp : compare(o1.nickname, o2.nickname);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>从功能上，<code>UnsafeExternalRowSorter</code> 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/sorter_write.jpeg\" alt=\"sorter_write\"></p>\n<p><code>UnsafeRow</code> 会写入到两个地方：</p>\n<ol>\n<li><code>List&lt;MemoryBlock&gt;</code> ：内存块数组。当前 <code>MemoryBlock</code> 无法容纳写入的 <code>UnsafeRow</code> 时，生成新的 <code>MemoryBlock</code> 提供写入。每条 <code>UnsafeRow</code> 存储在 <code>MemoryBlock</code> 由 长度 + 字节内容 组成。</li>\n<li><code>LongArray</code> ：每条 <code>UnsafeRow</code> 存储在 <code>LongArray</code> 由两部分组成：address + prefix。<ul>\n<li><code>address</code> ：<code>UnsafeRow</code> 存储在 <code>List&lt;MemoryBlock&gt;</code> 的位置。前 13 bits 记录所在 <code>MemoryBlock</code> 的 index，后 51 bit 记录在 <code>MemoryBlock</code> 的 offset。</li>\n<li><code>prefix</code> ：<code>UnsafeRow</code> 第一个排序字段<strong>值</strong>前 64 bits 计算的值。</li>\n</ul>\n</li>\n</ol>\n<p><strong><code>UnsafeExternalRowSorter</code> 排序实现方式</strong> ：提供 <strong><a href=\"http://blog.csdn.net/yangzhongblog/article/details/8184707\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TimSort</a></strong> 和 <strong>RadixSort</strong> 两种排序算法，前者为默认实现。<strong>TimSort</strong> 折半查找时，使用 <code>LongArray</code>，先比较 <code>prefix</code>，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 <code>LongArray</code> 操作，<code>List&lt;MemoryBlock&gt;</code> 只作为原始数据。</p>\n<p>另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂</p>\n<p>核心源码：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java\" target=\"_blank\" rel=\"external\">UnsafeExternalRowSorter.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java\" target=\"_blank\" rel=\"external\">UnsafeExternalRowSorter.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java\" target=\"_blank\" rel=\"external\">TimSort.java</a></li>\n</ul>\n<h3 id=\"3-5-UnsafeRowGrouper\"><a href=\"#3-5-UnsafeRowGrouper\" class=\"headerlink\" title=\"3.5 UnsafeRowGrouper\"></a>3.5 UnsafeRowGrouper</h3><p>如果使用 Java 实现 <code>SELECT nickname, COUNT(*) FROM student group by nickname</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Map&lt;String, List&lt;Object&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"comment\">// 聚合</span></div><div class=\"line\"><span class=\"keyword\">for</span> (student : students) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (map.contains(student.nickname)) &#123;</div><div class=\"line\">        map.put(student.nickname, map.get(student.nickname).get(<span class=\"number\">1</span>) + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        List&lt;Object&gt; value = <span class=\"keyword\">new</span> Array&lt;&gt;();</div><div class=\"line\">        value.add(nickname);</div><div class=\"line\">        value.add(<span class=\"number\">1</span>);</div><div class=\"line\">        map.put(student.nickname, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">for</span> (value : map.values) &#123;</div><div class=\"line\">    System.out.println(value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从功能上，<code>UnsafeRowGrouper</code> 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。</p>\n<p>😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。</p>\n<h1 id=\"4-救护中心\"><a href=\"#4-救护中心\" class=\"headerlink\" title=\"4. 救护中心\"></a>4. 救护中心</h1><p>看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。</p>\n<p>最后的最后，感谢耐心阅读本文的同学。</p>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/MyCAT/sharding-result-merge-first/\">http://www.yunai.me/MyCAT/sharding-result-merge-first/</a><br><code>MyCat-Server</code> <strong>带注释代码</strong>地址 ：<a href=\"https://github.com/YunaiV/Mycat-Server\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/Mycat-Server</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现<strong>分片结果合并</strong>。</p>\n<p>跨分片查询大体流程如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/flow.png\" alt=\"flow\"></p>\n<p>和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-select/\">《【单库单表】查询》</a> 不同的两个过程：</p>\n<ul>\n<li>【2】多分片执行 SQL</li>\n<li>【4】合并多分片结果</li>\n</ul>\n<p>下面，我们来逐条讲解这两个过程。</p>\n<h1 id=\"2-多分片执行-SQL\"><a href=\"#2-多分片执行-SQL\" class=\"headerlink\" title=\"2. 多分片执行 SQL\"></a>2. 多分片执行 SQL</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/execute_sql.png\" alt=\"execute_sql\"></p>\n<p>经过 SQL 解析后，计算出需要执行 SQL 的<strong>分片节点</strong>，遍历<strong>分片节点</strong>发送 SQL 进行执行。</p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java\" target=\"_blank\" rel=\"external\">MultiNodeQueryHandler.java#execute(…)</a></li>\n</ul>\n<p><em><strong>SQL 解析</strong> 详细过程，我们另开文章，避免内容过多，影响大家对 <strong>分片结果合并</strong> 流程和逻辑的理解。</em></p>\n<h1 id=\"3-合并多分片结果\"><a href=\"#3-合并多分片结果\" class=\"headerlink\" title=\"3. 合并多分片结果\"></a>3. 合并多分片结果</h1><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/handle_response.png\" alt=\"handle_response\"></p>\n<p>和 <a href=\"http://www.yunai.me/Mycat/single-db-single-table-select/\">《【单库单表】查询》</a> 不同，多个<strong>分片节点</strong>都会<strong>分别</strong>响应 <em>记录头(header)</em> 和 <em>记录行(row)</em> 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><div class=\"line\">FROM       // [1] 选择表</div><div class=\"line\">WHERE      // [2] 过滤表</div><div class=\"line\">GROUP BY   // [3] 分组</div><div class=\"line\"><span class=\"keyword\">SELECT</span>     // [<span class=\"number\">4</span>] 普通字段，<span class=\"keyword\">max</span> / <span class=\"keyword\">min</span> / <span class=\"keyword\">avg</span> / <span class=\"keyword\">sum</span> / <span class=\"keyword\">count</span> 等函数，<span class=\"keyword\">distinct</span></div><div class=\"line\"><span class=\"keyword\">HAVING</span>     // [<span class=\"number\">5</span>] 再过滤表</div><div class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span>   // [<span class=\"number\">6</span>] 排序</div><div class=\"line\"><span class=\"keyword\">LIMIT</span>      // [<span class=\"number\">7</span>] 分页</div></pre></td></tr></table></figure>\n<h2 id=\"3-1-记录头-header\"><a href=\"#3-1-记录头-header\" class=\"headerlink\" title=\"3.1 记录头(header)\"></a>3.1 记录头(header)</h2><p>多个<strong>分片节点</strong>响应时，会响应多次 <em>记录头(header)</em> 。MyCAT 在实际处理时，只处理第一个返回的 <em>记录头(header)</em> 。因此，在使用时要保证表的 Schema 相同。</p>\n<p><strong>分片节点</strong>响应的 <em>记录头(header)</em> 可以直接返回 MySQL Client 吗？答案是不可以。<code>AVG</code>函数 是特殊情况，MyCAT 需要将 <code>AVG</code> 拆成 <code>SUM</code> + <code>COUNT</code> 进行计算。举个例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">// [1] MySQL Client =&gt; MyCAT ：</div><div class=\"line\">SELECT AVG(age) FROM student;</div><div class=\"line\"></div><div class=\"line\">// [2] MyCAT =&gt; MySQL Server ：</div><div class=\"line\">SELECT SUM(age) AS AVG0SUM, COUNT(age) AS AVG0COUNT FROM student;</div><div class=\"line\"></div><div class=\"line\">// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)</div></pre></td></tr></table></figure>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java\" target=\"_blank\" rel=\"external\">MultiNodeQueryHandler.java#fieldEofResponse(…)</a>。</li>\n</ul>\n<h2 id=\"3-2-记录行-row\"><a href=\"#3-2-记录行-row\" class=\"headerlink\" title=\"3.2 记录行(row)\"></a>3.2 记录行(row)</h2><h3 id=\"3-1-AbstractDataNodeMerge\"><a href=\"#3-1-AbstractDataNodeMerge\" class=\"headerlink\" title=\"3.1 AbstractDataNodeMerge\"></a>3.1 AbstractDataNodeMerge</h3><p>MyCAT 对分片结果合并通过 <code>AbstractDataNodeMerge</code> 子类来完成。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/merge_service.png\" alt=\"merge_service\"> </p>\n<p><code>AbstractDataNodeMerge</code> ：</p>\n<ul>\n<li>-packs ：待合并记录行(row)队列。队列尾部插入 <code>END_FLAG_PACK</code> 表示队列已结束。</li>\n<li>-running ：合并逻辑是否正在执行中的标记。</li>\n<li>~onRowMetaData(…) ：根据<strong>记录列信息(ColMeta)</strong>构建对应的排序组件和聚合组件。需要子类进行实现。</li>\n<li>~onNewRecord(…) ：插入记录行(row) 到 <code>packs</code>。</li>\n<li>~outputMergeResult(…) ：插入 <code>END_FLAG_PACK</code> 到 <code>packs</code>。</li>\n<li>~run(…) ：执行<strong>合并</strong>分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png\" alt=\"AbstractDataNodeMerge_run.png\"></p>\n<p><strong>通过 <code>running</code> 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行<em>聚合</em>逻辑。当然，<em>排序</em>逻辑需要等到所有分片结果都返回才可以执行。</strong></p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java\" target=\"_blank\" rel=\"external\">AbstractDataNodeMerge.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java\" target=\"_blank\" rel=\"external\">DataNodeMergeManager.java#run(…)</a></li>\n</ul>\n<h3 id=\"3-2-DataNodeMergeManager\"><a href=\"#3-2-DataNodeMergeManager\" class=\"headerlink\" title=\"3.2 DataNodeMergeManager\"></a>3.2 DataNodeMergeManager</h3><p><code>AbstractDataNodeMerge</code> 有两种子类实现：</p>\n<ul>\n<li><code>DataMergeService</code> ：基于<strong>堆内内存</strong>合并分片结果。</li>\n<li><code>DataNodeMergeManager</code> ：基于<strong>堆外内存</strong>合并分片结果。</li>\n</ul>\n<p>目前官方默认配置使用 <code>DataNodeMergeManager</code>。主要有如下优点：</p>\n<ol>\n<li>可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。</li>\n<li>减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。</li>\n<li>更快的内存复制和读取速度，对排序和聚合带来很好的提速。</li>\n</ol>\n<p>如果对<strong>堆外内存</strong>不太了解，推荐阅读如下文章：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/50be08b54bee\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《从0到1起步-跟我进入堆外内存的奇妙世界》</a></li>\n<li><a href=\"http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《堆内内存还是堆外内存？》</a></li>\n<li><a href=\"http://www.cnblogs.com/moonandstar08/p/5107648.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《JAVA堆外内存》</a></li>\n<li><a href=\"https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《JVM源码分析之堆外内存完全解读》</a></li>\n</ol>\n<p>本文主要分析 <code>DataNodeMergeManager</code> 实现，<code>DataMergeService</code> 可以自己阅读或者等待后续文章（😈<strong>欢迎订阅我的公众号噢</strong>）。</p>\n<p><code>DataNodeMergeManager</code> 有三个组件：</p>\n<ul>\n<li><code>globalSorter</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并并排序</strong>逻辑。</li>\n<li><code>globalMergeResult</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并不排序</strong>逻辑。</li>\n<li><code>unsafeRowGrouper</code> ： <code>UnsafeRowGrouper</code> =&gt; 实现记录行(row)<strong>聚合</strong>逻辑。</li>\n</ul>\n<p><code>DataNodeMergeManager#run(...)</code> 逻辑如下：</p>\n<ul>\n<li>[1] 写入记录行(row)到 <code>UnsafeRow</code>。</li>\n<li>[2] 根据情况将 <code>UnsafeRow</code> 插入对应组件。</li>\n<li>[3] 当所有 <code>UnsafeRow</code> 插入完后，根据情况使用组件聚合、排序。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>是否排序</th>\n<th>是否聚合</th>\n<th>依赖组件</th>\n<th>[2]</th>\n<th>[3]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>否</td>\n<td>否</td>\n<td><code>globalSorter</code></td>\n<td>插入 <code>globalSorter</code></td>\n<td>使用 <code>globalSorter</code> 合并并排序</td>\n</tr>\n<tr>\n<td>是</td>\n<td>否</td>\n<td><code>globalMergeResult</code></td>\n<td>插入 <code>globalMergeResult</code></td>\n<td>使用 <code>globalMergeResult</code> 合并不排序</td>\n</tr>\n<tr>\n<td>否</td>\n<td>是</td>\n<td><code>unsafeRowGrouper</code> + <code>globalSorter</code></td>\n<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>\n<td>使用 <code>globalSorter</code> 合并并排序</td>\n</tr>\n<tr>\n<td>是</td>\n<td>是</td>\n<td><code>unsafeRowGrouper</code> + <code>globalMergeResult</code></td>\n<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>\n<td>使用 <code>globalMergeResult</code> 合并不排序</td>\n</tr>\n</tbody>\n</table>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java\" target=\"_blank\" rel=\"external\">DataNodeMergeManager.java</a>。</li>\n</ul>\n<p>🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。</p>\n<h3 id=\"3-3-UnsafeRow\"><a href=\"#3-3-UnsafeRow\" class=\"headerlink\" title=\"3.3 UnsafeRow\"></a>3.3 UnsafeRow</h3><p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row.png\" alt=\"unsafe_row\"></p>\n<p>记录行(row)写到 <code>UnsafeRow</code> 的 <code>baseObject</code> 属性，结构如下：</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_object.png\" alt=\"unsafe_row_object\"><br><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_2.png\" alt=\"unsafe_row_2.png\"></p>\n<ul>\n<li>拆分成三个区域，<strong>每个区域按照格子记录信息，每个格子 64bits(8 Bytes)</strong>。</li>\n<li>记录行(row)按照字段顺序位置记录到 <code>baseObject</code>。</li>\n<li>[1] 空标记位区域 ：标记字段对应的值是否为 NULL。<ul>\n<li>当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。</li>\n<li>因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(<code>bitSetWidthInBytes</code>) = 字段占用的格子数 * 64 bits。</li>\n</ul>\n</li>\n<li>[2] 位置长度区域 ：记录字段对应的值在<code>[3]区域</code>所在的位置和长度。<ul>\n<li>每个字段记录<code>[2]区域</code>的位置 = <code>baseOffset</code> + <code>bitSetWidthInBytes</code> + 8 Bytes * 字段顺序。</li>\n<li>占用一个格子，前 32 bits 为<code>[3]区域</code>的位置，后 32 bits 为字段对应的值长度。</li>\n</ul>\n</li>\n<li>[3] 值区域 ：记录字段对应的值。<ul>\n<li>每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。</li>\n<li>因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。</li>\n</ul>\n</li>\n</ul>\n<p><strong>写入 <code>UnsafeRow</code>，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。</strong>  </p>\n<p>🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 <code>Spark</code>，是不是更加有动力列😈。</p>\n<p><strong>核心代码</strong>：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java\" target=\"_blank\" rel=\"external\">UnsafeRow.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java\" target=\"_blank\" rel=\"external\">BufferHolder.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java\" target=\"_blank\" rel=\"external\">UnsafeRowWriter.java</a></li>\n</ul>\n<h3 id=\"3-4-UnsafeExternalRowSorter\"><a href=\"#3-4-UnsafeExternalRowSorter\" class=\"headerlink\" title=\"3.4 UnsafeExternalRowSorter\"></a>3.4 UnsafeExternalRowSorter</h3><p>如果使用 Java 实现 <code>SELECT * FROM student ORDER BY age desc, nickname asc</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Collections.sort(students, <span class=\"keyword\">new</span> Comparator&lt;Comparable&gt;() &#123;</div><div class=\"line\">       <span class=\"meta\">@Override</span></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Student o1, Student o2)</span> </span>&#123;</div><div class=\"line\">           <span class=\"keyword\">int</span> cmp = compare(o2.age, o1.age);</div><div class=\"line\">           <span class=\"keyword\">return</span> cmp != <span class=\"number\">0</span> ? cmp : compare(o1.nickname, o2.nickname);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>从功能上，<code>UnsafeExternalRowSorter</code> 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。</p>\n<p><img src=\"http://www.yunai.me/images/MyCAT/2017_06_13/sorter_write.jpeg\" alt=\"sorter_write\"></p>\n<p><code>UnsafeRow</code> 会写入到两个地方：</p>\n<ol>\n<li><code>List&lt;MemoryBlock&gt;</code> ：内存块数组。当前 <code>MemoryBlock</code> 无法容纳写入的 <code>UnsafeRow</code> 时，生成新的 <code>MemoryBlock</code> 提供写入。每条 <code>UnsafeRow</code> 存储在 <code>MemoryBlock</code> 由 长度 + 字节内容 组成。</li>\n<li><code>LongArray</code> ：每条 <code>UnsafeRow</code> 存储在 <code>LongArray</code> 由两部分组成：address + prefix。<ul>\n<li><code>address</code> ：<code>UnsafeRow</code> 存储在 <code>List&lt;MemoryBlock&gt;</code> 的位置。前 13 bits 记录所在 <code>MemoryBlock</code> 的 index，后 51 bit 记录在 <code>MemoryBlock</code> 的 offset。</li>\n<li><code>prefix</code> ：<code>UnsafeRow</code> 第一个排序字段<strong>值</strong>前 64 bits 计算的值。</li>\n</ul>\n</li>\n</ol>\n<p><strong><code>UnsafeExternalRowSorter</code> 排序实现方式</strong> ：提供 <strong><a href=\"http://blog.csdn.net/yangzhongblog/article/details/8184707\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">TimSort</a></strong> 和 <strong>RadixSort</strong> 两种排序算法，前者为默认实现。<strong>TimSort</strong> 折半查找时，使用 <code>LongArray</code>，先比较 <code>prefix</code>，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 <code>LongArray</code> 操作，<code>List&lt;MemoryBlock&gt;</code> 只作为原始数据。</p>\n<p>另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂</p>\n<p>核心源码：</p>\n<ul>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java\" target=\"_blank\" rel=\"external\">UnsafeExternalRowSorter.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java\" target=\"_blank\" rel=\"external\">UnsafeExternalRowSorter.java</a></li>\n<li><a href=\"https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java\" target=\"_blank\" rel=\"external\">TimSort.java</a></li>\n</ul>\n<h3 id=\"3-5-UnsafeRowGrouper\"><a href=\"#3-5-UnsafeRowGrouper\" class=\"headerlink\" title=\"3.5 UnsafeRowGrouper\"></a>3.5 UnsafeRowGrouper</h3><p>如果使用 Java 实现 <code>SELECT nickname, COUNT(*) FROM student group by nickname</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Map&lt;String, List&lt;Object&gt;&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"comment\">// 聚合</span></div><div class=\"line\"><span class=\"keyword\">for</span> (student : students) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (map.contains(student.nickname)) &#123;</div><div class=\"line\">        map.put(student.nickname, map.get(student.nickname).get(<span class=\"number\">1</span>) + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        List&lt;Object&gt; value = <span class=\"keyword\">new</span> Array&lt;&gt;();</div><div class=\"line\">        value.add(nickname);</div><div class=\"line\">        value.add(<span class=\"number\">1</span>);</div><div class=\"line\">        map.put(student.nickname, value);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 输出</span></div><div class=\"line\"><span class=\"keyword\">for</span> (value : map.values) &#123;</div><div class=\"line\">    System.out.println(value);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从功能上，<code>UnsafeRowGrouper</code> 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。</p>\n<p>😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。</p>\n<h1 id=\"4-救护中心\"><a href=\"#4-救护中心\" class=\"headerlink\" title=\"4. 救护中心\"></a>4. 救护中心</h1><p>看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。</p>\n<p>最后的最后，感谢耐心阅读本文的同学。</p>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n"},{"title":"Nginx 动态配置 upstream","date":"2017-01-06T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/Nginx/nginx-dynamic-upstream/](http://www.yunai.me/Nginx/nginx-dynamic-upstream/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n随着SOA、微服务越来越流行，注册发现服务已经成为架构里的标配。无论是在选择Dubbo、Dubbox、Spring Cloud都提供了对应的方案，我们不需要每次新增一个节点，就去修改对应配置。那么在使用Nginx的时候我们该怎么做呢？\n参考类似服务发现的方案，我们选择了微博开源的nginx插件：https://github.com/weibocom/nginx-upsync-module 。\n\n## 基于tengine安装 ##\n* tengine：2.2.0（基于nginx1.8.1+）\n* nginx-upsync-module：v1.0.0（基于nginx1.8.1+）\n* 注册发现服务：etcd 3.0.15\n\n问题：\n\n* nginx的error.log不断报错`recv() failed (104: Connection reset by peer)` 。\n    \n    原因：该问题使用etcd会存在。作者在commit#89bf40fb60268062aaeac3780ad8d56f0834c400已经修复。由于该修复的提交是基于nginx 1.9.1+，我们无法直接在tegine2.2.0上使用。等待作者回复如何解决中。\n    补充说明：即使报该错误，实际不影响插件的功能。\n    \n    \n## 基于nginx安装 ##\n\n*由于基于tegine2.2.0会报错，因此我们尝试使用nginx官方版本安装*\n\n* nginx：1.10.1\n* nginx-upsync-module：commit#6e1a9fe9117361539837efc81ac45303d7494dbe（基于nginx1.9.1+）\n* 注册发现服务：etcd 3.0.15   \n\n问题：\n\n* 如果我们需要使用`nginx_upstream_check_module` 插件，需要使用https://github.com/yaoweibin/nginx_upstream_check_module 下的，不然`make`时会报错。另外在`patch -p1 < check.patch`时，请cd nginx的目录下，输入`patch -p1 < /path/to/nginx_http_upstream_check_module/check.patch`。这点README.md也说了，当时太着急，没去看，卡了半小时。\n\n    >  \n        $ wget 'http://nginx.org/download/nginx-1.0.14.tar.gz'\n        $ tar -xzvf nginx-1.0.14.tar.gz\n        $ cd nginx-1.0.14/\n        $ patch -p1 < /path/to/nginx_http_upstream_check_module/check.patch\n        $ ./configure --add-module=/path/to/nginx_http_upstream_check_module\n        $ make\n        $ make install\n\n## 基于docker安装 ##\n\nTODO\n\n## 原理 ##\n\n1. 实时性：upstream更新依赖注册中心提供的查询的http接口。这点和Dubbo、Spring Cloud的注册发现的实时性有些不同。如果对实时性要求特别高，可以调整`upsync_interval`参数。\n2. Zookeeper的支持：目前官方暂时未提供相应的支持。考虑到很多团队是使用Zookeeper作为服务发现，另外维护一个etcd、consul集群是有相应学习成本和运维成本的。那么怎么办？我们可以封装Zookeeper提供http接口给`nginx-upsync-module`使用，当然接口形式得满足consual或者etcd提供的http接口。\n\n## 参考文章 ##\n\n1. nginx动态配置及服务发现那些事：http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/\n\n","source":"_posts/Nginx/2017_01_07_Nginx动态配置upstream.md","raw":"title: Nginx 动态配置 upstream\ndate: 2017-01-07\ntags:\ncategories: Nginx\npermalink: Nginx/nginx-dynamic-upstream\n\n-------\n\n>  原文地址：[http://www.yunai.me/Nginx/nginx-dynamic-upstream/](http://www.yunai.me/Nginx/nginx-dynamic-upstream/)  \n> **😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n随着SOA、微服务越来越流行，注册发现服务已经成为架构里的标配。无论是在选择Dubbo、Dubbox、Spring Cloud都提供了对应的方案，我们不需要每次新增一个节点，就去修改对应配置。那么在使用Nginx的时候我们该怎么做呢？\n参考类似服务发现的方案，我们选择了微博开源的nginx插件：https://github.com/weibocom/nginx-upsync-module 。\n\n## 基于tengine安装 ##\n* tengine：2.2.0（基于nginx1.8.1+）\n* nginx-upsync-module：v1.0.0（基于nginx1.8.1+）\n* 注册发现服务：etcd 3.0.15\n\n问题：\n\n* nginx的error.log不断报错`recv() failed (104: Connection reset by peer)` 。\n    \n    原因：该问题使用etcd会存在。作者在commit#89bf40fb60268062aaeac3780ad8d56f0834c400已经修复。由于该修复的提交是基于nginx 1.9.1+，我们无法直接在tegine2.2.0上使用。等待作者回复如何解决中。\n    补充说明：即使报该错误，实际不影响插件的功能。\n    \n    \n## 基于nginx安装 ##\n\n*由于基于tegine2.2.0会报错，因此我们尝试使用nginx官方版本安装*\n\n* nginx：1.10.1\n* nginx-upsync-module：commit#6e1a9fe9117361539837efc81ac45303d7494dbe（基于nginx1.9.1+）\n* 注册发现服务：etcd 3.0.15   \n\n问题：\n\n* 如果我们需要使用`nginx_upstream_check_module` 插件，需要使用https://github.com/yaoweibin/nginx_upstream_check_module 下的，不然`make`时会报错。另外在`patch -p1 < check.patch`时，请cd nginx的目录下，输入`patch -p1 < /path/to/nginx_http_upstream_check_module/check.patch`。这点README.md也说了，当时太着急，没去看，卡了半小时。\n\n    >  \n        $ wget 'http://nginx.org/download/nginx-1.0.14.tar.gz'\n        $ tar -xzvf nginx-1.0.14.tar.gz\n        $ cd nginx-1.0.14/\n        $ patch -p1 < /path/to/nginx_http_upstream_check_module/check.patch\n        $ ./configure --add-module=/path/to/nginx_http_upstream_check_module\n        $ make\n        $ make install\n\n## 基于docker安装 ##\n\nTODO\n\n## 原理 ##\n\n1. 实时性：upstream更新依赖注册中心提供的查询的http接口。这点和Dubbo、Spring Cloud的注册发现的实时性有些不同。如果对实时性要求特别高，可以调整`upsync_interval`参数。\n2. Zookeeper的支持：目前官方暂时未提供相应的支持。考虑到很多团队是使用Zookeeper作为服务发现，另外维护一个etcd、consul集群是有相应学习成本和运维成本的。那么怎么办？我们可以封装Zookeeper提供http接口给`nginx-upsync-module`使用，当然接口形式得满足consual或者etcd提供的http接口。\n\n## 参考文章 ##\n\n1. nginx动态配置及服务发现那些事：http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/\n\n","slug":"Nginx/nginx-dynamic-upstream","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza4000fag5d3ttocjsy","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Nginx/nginx-dynamic-upstream/\">http://www.yunai.me/Nginx/nginx-dynamic-upstream/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<p>随着SOA、微服务越来越流行，注册发现服务已经成为架构里的标配。无论是在选择Dubbo、Dubbox、Spring Cloud都提供了对应的方案，我们不需要每次新增一个节点，就去修改对应配置。那么在使用Nginx的时候我们该怎么做呢？<br>参考类似服务发现的方案，我们选择了微博开源的nginx插件：<a href=\"https://github.com/weibocom/nginx-upsync-module\" target=\"_blank\" rel=\"external\">https://github.com/weibocom/nginx-upsync-module</a> 。</p>\n<h2 id=\"基于tengine安装\"><a href=\"#基于tengine安装\" class=\"headerlink\" title=\"基于tengine安装\"></a>基于tengine安装</h2><ul>\n<li>tengine：2.2.0（基于nginx1.8.1+）</li>\n<li>nginx-upsync-module：v1.0.0（基于nginx1.8.1+）</li>\n<li>注册发现服务：etcd 3.0.15</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li><p>nginx的error.log不断报错<code>recv() failed (104: Connection reset by peer)</code> 。</p>\n<p>  原因：该问题使用etcd会存在。作者在commit#89bf40fb60268062aaeac3780ad8d56f0834c400已经修复。由于该修复的提交是基于nginx 1.9.1+，我们无法直接在tegine2.2.0上使用。等待作者回复如何解决中。<br>  补充说明：即使报该错误，实际不影响插件的功能。</p>\n</li>\n</ul>\n<h2 id=\"基于nginx安装\"><a href=\"#基于nginx安装\" class=\"headerlink\" title=\"基于nginx安装\"></a>基于nginx安装</h2><p><em>由于基于tegine2.2.0会报错，因此我们尝试使用nginx官方版本安装</em></p>\n<ul>\n<li>nginx：1.10.1</li>\n<li>nginx-upsync-module：commit#6e1a9fe9117361539837efc81ac45303d7494dbe（基于nginx1.9.1+）</li>\n<li>注册发现服务：etcd 3.0.15   </li>\n</ul>\n<p>问题：</p>\n<ul>\n<li><p>如果我们需要使用<code>nginx_upstream_check_module</code> 插件，需要使用<a href=\"https://github.com/yaoweibin/nginx_upstream_check_module\" target=\"_blank\" rel=\"external\">https://github.com/yaoweibin/nginx_upstream_check_module</a> 下的，不然<code>make</code>时会报错。另外在<code>patch -p1 &lt; check.patch</code>时，请cd nginx的目录下，输入<code>patch -p1 &lt; /path/to/nginx_http_upstream_check_module/check.patch</code>。这点README.md也说了，当时太着急，没去看，卡了半小时。</p>\n<blockquote>\n<pre><code>$ wget &apos;http://nginx.org/download/nginx-1.0.14.tar.gz&apos;\n$ tar -xzvf nginx-1.0.14.tar.gz\n$ cd nginx-1.0.14/\n$ patch -p1 &lt; /path/to/nginx_http_upstream_check_module/check.patch\n$ ./configure --add-module=/path/to/nginx_http_upstream_check_module\n$ make\n$ make install\n</code></pre></blockquote>\n</li>\n</ul>\n<h2 id=\"基于docker安装\"><a href=\"#基于docker安装\" class=\"headerlink\" title=\"基于docker安装\"></a>基于docker安装</h2><p>TODO</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>实时性：upstream更新依赖注册中心提供的查询的http接口。这点和Dubbo、Spring Cloud的注册发现的实时性有些不同。如果对实时性要求特别高，可以调整<code>upsync_interval</code>参数。</li>\n<li>Zookeeper的支持：目前官方暂时未提供相应的支持。考虑到很多团队是使用Zookeeper作为服务发现，另外维护一个etcd、consul集群是有相应学习成本和运维成本的。那么怎么办？我们可以封装Zookeeper提供http接口给<code>nginx-upsync-module</code>使用，当然接口形式得满足consual或者etcd提供的http接口。</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ol>\n<li>nginx动态配置及服务发现那些事：<a href=\"http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/Nginx/nginx-dynamic-upstream/\">http://www.yunai.me/Nginx/nginx-dynamic-upstream/</a><br><strong>😈每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<p>随着SOA、微服务越来越流行，注册发现服务已经成为架构里的标配。无论是在选择Dubbo、Dubbox、Spring Cloud都提供了对应的方案，我们不需要每次新增一个节点，就去修改对应配置。那么在使用Nginx的时候我们该怎么做呢？<br>参考类似服务发现的方案，我们选择了微博开源的nginx插件：<a href=\"https://github.com/weibocom/nginx-upsync-module\" target=\"_blank\" rel=\"external\">https://github.com/weibocom/nginx-upsync-module</a> 。</p>\n<h2 id=\"基于tengine安装\"><a href=\"#基于tengine安装\" class=\"headerlink\" title=\"基于tengine安装\"></a>基于tengine安装</h2><ul>\n<li>tengine：2.2.0（基于nginx1.8.1+）</li>\n<li>nginx-upsync-module：v1.0.0（基于nginx1.8.1+）</li>\n<li>注册发现服务：etcd 3.0.15</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li><p>nginx的error.log不断报错<code>recv() failed (104: Connection reset by peer)</code> 。</p>\n<p>  原因：该问题使用etcd会存在。作者在commit#89bf40fb60268062aaeac3780ad8d56f0834c400已经修复。由于该修复的提交是基于nginx 1.9.1+，我们无法直接在tegine2.2.0上使用。等待作者回复如何解决中。<br>  补充说明：即使报该错误，实际不影响插件的功能。</p>\n</li>\n</ul>\n<h2 id=\"基于nginx安装\"><a href=\"#基于nginx安装\" class=\"headerlink\" title=\"基于nginx安装\"></a>基于nginx安装</h2><p><em>由于基于tegine2.2.0会报错，因此我们尝试使用nginx官方版本安装</em></p>\n<ul>\n<li>nginx：1.10.1</li>\n<li>nginx-upsync-module：commit#6e1a9fe9117361539837efc81ac45303d7494dbe（基于nginx1.9.1+）</li>\n<li>注册发现服务：etcd 3.0.15   </li>\n</ul>\n<p>问题：</p>\n<ul>\n<li><p>如果我们需要使用<code>nginx_upstream_check_module</code> 插件，需要使用<a href=\"https://github.com/yaoweibin/nginx_upstream_check_module\" target=\"_blank\" rel=\"external\">https://github.com/yaoweibin/nginx_upstream_check_module</a> 下的，不然<code>make</code>时会报错。另外在<code>patch -p1 &lt; check.patch</code>时，请cd nginx的目录下，输入<code>patch -p1 &lt; /path/to/nginx_http_upstream_check_module/check.patch</code>。这点README.md也说了，当时太着急，没去看，卡了半小时。</p>\n<blockquote>\n<pre><code>$ wget &apos;http://nginx.org/download/nginx-1.0.14.tar.gz&apos;\n$ tar -xzvf nginx-1.0.14.tar.gz\n$ cd nginx-1.0.14/\n$ patch -p1 &lt; /path/to/nginx_http_upstream_check_module/check.patch\n$ ./configure --add-module=/path/to/nginx_http_upstream_check_module\n$ make\n$ make install\n</code></pre></blockquote>\n</li>\n</ul>\n<h2 id=\"基于docker安装\"><a href=\"#基于docker安装\" class=\"headerlink\" title=\"基于docker安装\"></a>基于docker安装</h2><p>TODO</p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ol>\n<li>实时性：upstream更新依赖注册中心提供的查询的http接口。这点和Dubbo、Spring Cloud的注册发现的实时性有些不同。如果对实时性要求特别高，可以调整<code>upsync_interval</code>参数。</li>\n<li>Zookeeper的支持：目前官方暂时未提供相应的支持。考虑到很多团队是使用Zookeeper作为服务发现，另外维护一个etcd、consul集群是有相应学习成本和运维成本的。那么怎么办？我们可以封装Zookeeper提供http接口给<code>nginx-upsync-module</code>使用，当然接口形式得满足consual或者etcd提供的http接口。</li>\n</ol>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ol>\n<li>nginx动态配置及服务发现那些事：<a href=\"http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">http://xiaorui.cc/2016/10/16/nginx动态配置及服务发现那些事/</a></li>\n</ol>\n"},{"title":"为什么阅读 RocketMQ 源码？","date":"2017-03-22T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/](http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## 为什么阅读RocketMQ源码？\n\n* 深入了解 MQ ，知其然知其所以然，如何实现高性能、高可用\n* 最终一致行，是如何通过 MQ 进行实现\n* 了解 Netty 在分布式中间件如何实现网络通信以及各种异常场景的处理\n* 了解 MQ 消息存储，特别是磁盘 IO 部分\n* **最重要的**，希望通过阅读源码，在技术上的认知和能力上，有新的突破\n\n## 步骤\n\n- [ ] namesrv 启动\n- [ ] broker 启动\n- [ ] producer 启动\n- [ ] consumer 启动\n- [ ] 消息模型\n    - [ ] 消息唯一编号\n- [x] producer 发消息\n- [x] broker 收消息\n- [x] broker 发消息\n- [x] consumer 收消息\n    - [x] 多消费者\n    - [x] 重试消息\n- [x] consumer 消息确认\n- [x] consumer 负载均衡\n- [x] broker 队列模型\n- [x] broker store 消息存储\n- [x] 顺序消息\n- [ ] 事务消息\n- [x] 定时(延迟)消息\n- [x] pub/sub模型\n- [x] namesrv 集群\n- [x] broker 主从 \n- [x] filtersrv 过滤消息\n- [ ] remoting 调用（server、client）\n- [ ] 跨机房\n- [ ] Hook 机制\n- [ ] Tool-Admin\n- [ ] Tool-Command\n- [ ] Tool-Monitor\n- [ ] broker 主备切换\n","source":"_posts/RocketMQ/2017_03_23_为什么阅读RocketMQ源码？.md","raw":"title: 为什么阅读 RocketMQ 源码？\ndate: 2017-03-23\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/why-read-RocketMQ-source-code\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/](http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## 为什么阅读RocketMQ源码？\n\n* 深入了解 MQ ，知其然知其所以然，如何实现高性能、高可用\n* 最终一致行，是如何通过 MQ 进行实现\n* 了解 Netty 在分布式中间件如何实现网络通信以及各种异常场景的处理\n* 了解 MQ 消息存储，特别是磁盘 IO 部分\n* **最重要的**，希望通过阅读源码，在技术上的认知和能力上，有新的突破\n\n## 步骤\n\n- [ ] namesrv 启动\n- [ ] broker 启动\n- [ ] producer 启动\n- [ ] consumer 启动\n- [ ] 消息模型\n    - [ ] 消息唯一编号\n- [x] producer 发消息\n- [x] broker 收消息\n- [x] broker 发消息\n- [x] consumer 收消息\n    - [x] 多消费者\n    - [x] 重试消息\n- [x] consumer 消息确认\n- [x] consumer 负载均衡\n- [x] broker 队列模型\n- [x] broker store 消息存储\n- [x] 顺序消息\n- [ ] 事务消息\n- [x] 定时(延迟)消息\n- [x] pub/sub模型\n- [x] namesrv 集群\n- [x] broker 主从 \n- [x] filtersrv 过滤消息\n- [ ] remoting 调用（server、client）\n- [ ] 跨机房\n- [ ] Hook 机制\n- [ ] Tool-Admin\n- [ ] Tool-Command\n- [ ] Tool-Monitor\n- [ ] broker 主备切换\n","slug":"RocketMQ/why-read-RocketMQ-source-code","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza6000gag5deyrl6gjs","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/\">http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"为什么阅读RocketMQ源码？\"><a href=\"#为什么阅读RocketMQ源码？\" class=\"headerlink\" title=\"为什么阅读RocketMQ源码？\"></a>为什么阅读RocketMQ源码？</h2><ul>\n<li>深入了解 MQ ，知其然知其所以然，如何实现高性能、高可用</li>\n<li>最终一致行，是如何通过 MQ 进行实现</li>\n<li>了解 Netty 在分布式中间件如何实现网络通信以及各种异常场景的处理</li>\n<li>了解 MQ 消息存储，特别是磁盘 IO 部分</li>\n<li><strong>最重要的</strong>，希望通过阅读源码，在技术上的认知和能力上，有新的突破</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>[ ] namesrv 启动</li>\n<li>[ ] broker 启动</li>\n<li>[ ] producer 启动</li>\n<li>[ ] consumer 启动</li>\n<li>[ ] 消息模型<ul>\n<li>[ ] 消息唯一编号</li>\n</ul>\n</li>\n<li>[x] producer 发消息</li>\n<li>[x] broker 收消息</li>\n<li>[x] broker 发消息</li>\n<li>[x] consumer 收消息<ul>\n<li>[x] 多消费者</li>\n<li>[x] 重试消息</li>\n</ul>\n</li>\n<li>[x] consumer 消息确认</li>\n<li>[x] consumer 负载均衡</li>\n<li>[x] broker 队列模型</li>\n<li>[x] broker store 消息存储</li>\n<li>[x] 顺序消息</li>\n<li>[ ] 事务消息</li>\n<li>[x] 定时(延迟)消息</li>\n<li>[x] pub/sub模型</li>\n<li>[x] namesrv 集群</li>\n<li>[x] broker 主从 </li>\n<li>[x] filtersrv 过滤消息</li>\n<li>[ ] remoting 调用（server、client）</li>\n<li>[ ] 跨机房</li>\n<li>[ ] Hook 机制</li>\n<li>[ ] Tool-Admin</li>\n<li>[ ] Tool-Command</li>\n<li>[ ] Tool-Monitor</li>\n<li>[ ] broker 主备切换</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/\">http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"为什么阅读RocketMQ源码？\"><a href=\"#为什么阅读RocketMQ源码？\" class=\"headerlink\" title=\"为什么阅读RocketMQ源码？\"></a>为什么阅读RocketMQ源码？</h2><ul>\n<li>深入了解 MQ ，知其然知其所以然，如何实现高性能、高可用</li>\n<li>最终一致行，是如何通过 MQ 进行实现</li>\n<li>了解 Netty 在分布式中间件如何实现网络通信以及各种异常场景的处理</li>\n<li>了解 MQ 消息存储，特别是磁盘 IO 部分</li>\n<li><strong>最重要的</strong>，希望通过阅读源码，在技术上的认知和能力上，有新的突破</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>[ ] namesrv 启动</li>\n<li>[ ] broker 启动</li>\n<li>[ ] producer 启动</li>\n<li>[ ] consumer 启动</li>\n<li>[ ] 消息模型<ul>\n<li>[ ] 消息唯一编号</li>\n</ul>\n</li>\n<li>[x] producer 发消息</li>\n<li>[x] broker 收消息</li>\n<li>[x] broker 发消息</li>\n<li>[x] consumer 收消息<ul>\n<li>[x] 多消费者</li>\n<li>[x] 重试消息</li>\n</ul>\n</li>\n<li>[x] consumer 消息确认</li>\n<li>[x] consumer 负载均衡</li>\n<li>[x] broker 队列模型</li>\n<li>[x] broker store 消息存储</li>\n<li>[x] 顺序消息</li>\n<li>[ ] 事务消息</li>\n<li>[x] 定时(延迟)消息</li>\n<li>[x] pub/sub模型</li>\n<li>[x] namesrv 集群</li>\n<li>[x] broker 主从 </li>\n<li>[x] filtersrv 过滤消息</li>\n<li>[ ] remoting 调用（server、client）</li>\n<li>[ ] 跨机房</li>\n<li>[ ] Hook 机制</li>\n<li>[ ] Tool-Admin</li>\n<li>[ ] Tool-Command</li>\n<li>[ ] Tool-Monitor</li>\n<li>[ ] broker 主备切换</li>\n</ul>\n"},{"title":"RocketMQ 之 Namesrv 小结","date":"2017-04-04T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/namesrv-intro/](http://www.yunai.me/RocketMQ/namesrv-intro/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## Namesrv组件\n\n* KVConfigManager：KV配置管理\n   * key-value配置管理，增删改查\n* RouteInfoManager：路由信息管理\n   * 注册Broker，提供Broker信息（名字、角色编号、地址、集群名）\n   * 注册Topic，提供Topic信息（Topic名、读写权限、队列情况）\n\n","source":"_posts/RocketMQ/2017_04_05_RocketMQ之Namesrv小结.md","raw":"title: RocketMQ 之 Namesrv 小结\ndate: 2017-04-05\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/namesrv-intro\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/namesrv-intro/](http://www.yunai.me/RocketMQ/namesrv-intro/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n## Namesrv组件\n\n* KVConfigManager：KV配置管理\n   * key-value配置管理，增删改查\n* RouteInfoManager：路由信息管理\n   * 注册Broker，提供Broker信息（名字、角色编号、地址、集群名）\n   * 注册Topic，提供Topic信息（Topic名、读写权限、队列情况）\n\n","slug":"RocketMQ/namesrv-intro","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza8000jag5dx8ksyc5u","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/namesrv-intro/\">http://www.yunai.me/RocketMQ/namesrv-intro/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"Namesrv组件\"><a href=\"#Namesrv组件\" class=\"headerlink\" title=\"Namesrv组件\"></a>Namesrv组件</h2><ul>\n<li>KVConfigManager：KV配置管理<ul>\n<li>key-value配置管理，增删改查</li>\n</ul>\n</li>\n<li>RouteInfoManager：路由信息管理<ul>\n<li>注册Broker，提供Broker信息（名字、角色编号、地址、集群名）</li>\n<li>注册Topic，提供Topic信息（Topic名、读写权限、队列情况）</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/namesrv-intro/\">http://www.yunai.me/RocketMQ/namesrv-intro/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<h2 id=\"Namesrv组件\"><a href=\"#Namesrv组件\" class=\"headerlink\" title=\"Namesrv组件\"></a>Namesrv组件</h2><ul>\n<li>KVConfigManager：KV配置管理<ul>\n<li>key-value配置管理，增删改查</li>\n</ul>\n</li>\n<li>RouteInfoManager：路由信息管理<ul>\n<li>注册Broker，提供Broker信息（名字、角色编号、地址、集群名）</li>\n<li>注册Topic，提供Topic信息（Topic名、读写权限、队列情况）</li>\n</ul>\n</li>\n</ul>\n"},{"title":"RocketMQ 源码分析 —— Topic","date":"2017-04-06T16:00:00.000Z","_content":"","source":"_posts/RocketMQ/2017_04_07_RocketMQ源码分析——Topic.md","raw":"title: RocketMQ 源码分析 —— Topic\ndate: 2017-04-07\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/topic\n\n---","slug":"RocketMQ/topic","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kza9000kag5d4a9hxani","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RocketMQ 源码分析 —— Message","date":"2017-04-07T16:00:00.000Z","_content":"","source":"_posts/RocketMQ/2017_04_08_RocketMQ源码分析——Message基础.md","raw":"title: RocketMQ 源码分析 —— Message\ndate: 2017-04-08\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message\n\n---","slug":"RocketMQ/message","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzab000nag5d0sfei1b8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RocketMQ 源码分析 —— Message 发送与接收","date":"2017-04-17T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-send-and-receive/](http://www.yunai.me/RocketMQ/message-send-and-receive/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、Producer 发送消息](#)\n\t- [DefaultMQProducer#send(Message)](#)\n\t- [DefaultMQProducerImpl#sendDefaultImpl()](#)\n\t\t- [DefaultMQProducerImpl#tryToFindTopicPublishInfo()](#)\n\t\t- [MQFaultStrategy](#)\n\t\t\t- [MQFaultStrategy](#)\n\t\t\t- [LatencyFaultTolerance](#)\n\t\t\t- [LatencyFaultToleranceImpl](#)\n\t\t\t- [FaultItem](#)\n\t\t- [DefaultMQProducerImpl#sendKernelImpl()](#)\n- [3、Broker 接收消息](#)\n\t- [SendMessageProcessor#sendMessage](#)\n\t\t- [AbstractSendMessageProcessor#msgCheck](#)\n\t- [DefaultMessageStore#putMessage](#)\n- [4、某种结尾](#)\n\n# 1、概述\n\n1. `Producer` 发送消息。主要是**同步**发送消息源码，涉及到 异步/Oneway发送消息，事务消息会跳过。\n2. `Broker` 接收消息。(*存储消息在[《RocketMQ 源码分析 —— Message 存储》](http://www.yunai.me/RocketMQ/message-store/)解析*)\n\n> ![Producer发送消息全局顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/01.png)\n\n# 2、Producer 发送消息\n\n > ![Producer发送消息顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/02.png)\n\n## DefaultMQProducer#send(Message)\n\n```Java\n  1: @Override\n  2: public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  3:     return this.defaultMQProducerImpl.send(msg);\n  4: }\n```\n\n* 说明：发送同步消息，`DefaultMQProducer#send(Message)` 对 `DefaultMQProducerImpl#send(Message)` 进行封装。  \n\n## DefaultMQProducerImpl#sendDefaultImpl()\n\n```Java\n  1: public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  2:     return send(msg, this.defaultMQProducer.getSendMsgTimeout());\n  3: }\n  4: \n  5: public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  6:     return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);\n  7: }\n  8: \n  9: private SendResult sendDefaultImpl(//\n 10:     Message msg, //\n 11:     final CommunicationMode communicationMode, //\n 12:     final SendCallback sendCallback, //\n 13:     final long timeout//\n 14: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 15:     // 校验 Producer 处于运行状态\n 16:     this.makeSureStateOK();\n 17:     // 校验消息格式\n 18:     Validators.checkMessage(msg, this.defaultMQProducer);\n 19:     //\n 20:     final long invokeID = random.nextLong(); // 调用编号；用于下面打印日志，标记为同一次发送消息\n 21:     long beginTimestampFirst = System.currentTimeMillis();\n 22:     long beginTimestampPrev = beginTimestampFirst;\n 23:     long endTimestamp = beginTimestampFirst;\n 24:     // 获取 Topic路由信息\n 25:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 26:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 27:         MessageQueue mq = null; // 最后选择消息要发送到的队列\n 28:         Exception exception = null;\n 29:         SendResult sendResult = null; // 最后一次发送结果\n 30:         int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; // 同步多次调用\n 31:         int times = 0; // 第几次发送\n 32:         String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名\n 33:         // 循环调用发送消息，直到成功\n 34:         for (; times < timesTotal; times++) {\n 35:             String lastBrokerName = null == mq ? null : mq.getBrokerName();\n 36:             MessageQueue tmpmq = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); // 选择消息要发送到的队列\n 37:             if (tmpmq != null) {\n 38:                 mq = tmpmq;\n 39:                 brokersSent[times] = mq.getBrokerName();\n 40:                 try {\n 41:                     beginTimestampPrev = System.currentTimeMillis();\n 42:                     // 调用发送消息核心方法\n 43:                     sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);\n 44:                     endTimestamp = System.currentTimeMillis();\n 45:                     // 更新Broker可用性信息\n 46:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n 47:                     switch (communicationMode) {\n 48:                         case ASYNC:\n 49:                             return null;\n 50:                         case ONEWAY:\n 51:                             return null;\n 52:                         case SYNC:\n 53:                             if (sendResult.getSendStatus() != SendStatus.SEND_OK) {\n 54:                                 if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { // 同步发送成功但存储有问题时 && 配置存储异常时重新发送开关 时，进行重试\n 55:                                     continue;\n 56:                                 }\n 57:                             }\n 58:                             return sendResult;\n 59:                         default:\n 60:                             break;\n 61:                     }\n 62:                 } catch (RemotingException e) { // 打印异常，更新Broker可用性信息，更新继续循环\n 63:                     endTimestamp = System.currentTimeMillis();\n 64:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 65:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 66:                     log.warn(msg.toString());\n 67:                     exception = e;\n 68:                     continue;\n 69:                 } catch (MQClientException e) { // 打印异常，更新Broker可用性信息，继续循环\n 70:                     endTimestamp = System.currentTimeMillis();\n 71:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 72:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 73:                     log.warn(msg.toString());\n 74:                     exception = e;\n 75:                     continue;\n 76:                 } catch (MQBrokerException e) { // 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环\n 77:                     endTimestamp = System.currentTimeMillis();\n 78:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 79:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 80:                     log.warn(msg.toString());\n 81:                     exception = e;\n 82:                     switch (e.getResponseCode()) {\n 83:                         // 如下异常continue，进行发送消息重试\n 84:                         case ResponseCode.TOPIC_NOT_EXIST:\n 85:                         case ResponseCode.SERVICE_NOT_AVAILABLE:\n 86:                         case ResponseCode.SYSTEM_ERROR:\n 87:                         case ResponseCode.NO_PERMISSION:\n 88:                         case ResponseCode.NO_BUYER_ID:\n 89:                         case ResponseCode.NOT_IN_CURRENT_UNIT:\n 90:                             continue;\n 91:                         // 如果有发送结果，进行返回，否则，抛出异常；\n 92:                         default:\n 93:                             if (sendResult != null) {\n 94:                                 return sendResult;\n 95:                             }\n 96:                             throw e;\n 97:                     }\n 98:                 } catch (InterruptedException e) {\n 99:                     endTimestamp = System.currentTimeMillis();\n100:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n101:                     log.warn(String.format(\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n102:                     log.warn(msg.toString());\n103:                     throw e;\n104:                 }\n105:             } else {\n106:                 break;\n107:             }\n108:         }\n109:         // 返回发送结果\n110:         if (sendResult != null) {\n111:             return sendResult;\n112:         }\n113:         // 根据不同情况，抛出不同的异常\n114:         String info = String.format(\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\", times, System.currentTimeMillis() - beginTimestampFirst,\n115:                 msg.getTopic(), Arrays.toString(brokersSent)) + FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);\n116:         MQClientException mqClientException = new MQClientException(info, exception);\n117:         if (exception instanceof MQBrokerException) {\n118:             mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());\n119:         } else if (exception instanceof RemotingConnectException) {\n120:             mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);\n121:         } else if (exception instanceof RemotingTimeoutException) {\n122:             mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);\n123:         } else if (exception instanceof MQClientException) {\n124:             mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);\n125:         }\n126:         throw mqClientException;\n127:     }\n128:     // Namesrv找不到异常\n129:     List<String> nsList = this.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();\n130:     if (null == nsList || nsList.isEmpty()) {\n131:         throw new MQClientException(\n132:             \"No name server address, please set it.\" + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), null).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);\n133:     }\n134:     // 消息路由找不到异常\n135:     throw new MQClientException(\"No route info of this topic, \" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),\n136:         null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);\n137: }\n```\n* 说明 ：发送消息。步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。\n* 第 1  至 7 行：对`sendsendDefaultImpl(...)`进行封装。\n* 第 20 行 ：`invokeID`仅仅用于打印日志，无实际的业务用途。\n* 第 25 行 ：获取 Topic路由信息， 详细解析见：[DefaultMQProducerImpl#tryToFindTopicPublishInfo()](#defaultmqproducerimpltrytofindtopicpublishinfo)\n* 第 30 & 34 行 ：计算调用发送消息到成功为止的最大次数，并进行循环。同步或异步发送消息会调用多次，默认配置为3次。\n* 第 36 行 ：选择消息要发送到的队列，详细解析见：[MQFaultStrategy](#mqfaultstrategy)\n* 第 43 行 ：调用发送消息核心方法，详细解析见：[DefaultMQProducerImpl#sendKernelImpl()](#defaultmqproducerimplsendkernelimpl)\n* 第 46 行 ：更新`Broker`可用性信息。在选择发送到的消息队列时，会参考`Broker`发送消息的延迟，详细解析见：[MQFaultStrategy](#mqfaultstrategy)\n* 第 62 至 68 行：当抛出`RemotingException`时，如果进行消息发送失败重试，则**可能导致消息发送重复**。例如，发送消息超时(`RemotingTimeoutException`)，实际`Broker`接收到该消息并处理成功。因此，`Consumer`在消费时，需要保证幂等性。\n\n### DefaultMQProducerImpl#tryToFindTopicPublishInfo()\n\n```Java\n  1: private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {\n  2:     // 缓存中获取 Topic发布信息\n  3:     TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);\n  4:     // 当无可用的 Topic发布信息时，从Namesrv获取一次\n  5:     if (null == topicPublishInfo || !topicPublishInfo.ok()) {\n  6:         this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());\n  7:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n  8:         topicPublishInfo = this.topicPublishInfoTable.get(topic);\n  9:     }\n 10:     // 若获取的 Topic发布信息时候可用，则返回\n 11:     if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) {\n 12:         return topicPublishInfo;\n 13:     } else { // 使用 {@link DefaultMQProducer#createTopicKey} 对应的 Topic发布信息。用于 Topic发布信息不存在 && Broker支持自动创建Topic\n 14:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);\n 15:         topicPublishInfo = this.topicPublishInfoTable.get(topic);\n 16:         return topicPublishInfo;\n 17:     }\n 18: }\n```\n* 说明 ：获得 Topic发布信息。优先从缓存`topicPublishInfoTable`，其次从`Namesrv`中获得。\n* 第 3 行 ：从缓存`topicPublishInfoTable`中获得 Topic发布信息。\n* 第 5 至 9 行 ：从 `Namesrv` 中获得 Topic发布信息。\n* 第 13 至 17 行 ：当从 `Namesrv` 无法获取时，使用 `{@link DefaultMQProducer#createTopicKey}` 对应的 Topic发布信息。目的是当 `Broker` 开启自动创建 Topic开关时，`Broker` 接收到消息后自动创建Topic，详细解析见[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n\n### MQFaultStrategy\n\n> ![Latency类图](http://www.yunai.me/images/RocketMQ/2017_04_18/03.png)\n\n#### MQFaultStrategy\n\n```Java\n  1: public class MQFaultStrategy {\n  2:     private final static Logger log = ClientLogger.getLog();\n  3: \n  4:     /**\n  5:      * 延迟故障容错，维护每个Broker的发送消息的延迟\n  6:      * key：brokerName\n  7:      */\n  8:     private final LatencyFaultTolerance<String> latencyFaultTolerance = new LatencyFaultToleranceImpl();\n  9:     /**\n 10:      * 发送消息延迟容错开关\n 11:      */\n 12:     private boolean sendLatencyFaultEnable = false;\n 13:     /**\n 14:      * 延迟级别数组\n 15:      */\n 16:     private long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L};\n 17:     /**\n 18:      * 不可用时长数组\n 19:      */\n 20:     private long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L};\n 21: \n 22:     /**\n 23:      * 根据 Topic发布信息 选择一个消息队列\n 24:      *\n 25:      * @param tpInfo Topic发布信息\n 26:      * @param lastBrokerName brokerName\n 27:      * @return 消息队列\n 28:      */\n 29:     public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {\n 30:         if (this.sendLatencyFaultEnable) {\n 31:             try {\n 32:                 // 获取 brokerName=lastBrokerName && 可用的一个消息队列\n 33:                 int index = tpInfo.getSendWhichQueue().getAndIncrement();\n 34:                 for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {\n 35:                     int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();\n 36:                     if (pos < 0)\n 37:                         pos = 0;\n 38:                     MessageQueue mq = tpInfo.getMessageQueueList().get(pos);\n 39:                     if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {\n 40:                         if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))\n 41:                             return mq;\n 42:                     }\n 43:                 }\n 44:                 // 选择一个相对好的broker，并获得其对应的一个消息队列，不考虑该队列的可用性\n 45:                 final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();\n 46:                 int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);\n 47:                 if (writeQueueNums > 0) {\n 48:                     final MessageQueue mq = tpInfo.selectOneMessageQueue();\n 49:                     if (notBestBroker != null) {\n 50:                         mq.setBrokerName(notBestBroker);\n 51:                         mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);\n 52:                     }\n 53:                     return mq;\n 54:                 } else {\n 55:                     latencyFaultTolerance.remove(notBestBroker);\n 56:                 }\n 57:             } catch (Exception e) {\n 58:                 log.error(\"Error occurred when selecting message queue\", e);\n 59:             }\n 60:             // 选择一个消息队列，不考虑队列的可用性\n 61:             return tpInfo.selectOneMessageQueue();\n 62:         }\n 63:         // 获得 lastBrokerName 对应的一个消息队列，不考虑该队列的可用性\n 64:         return tpInfo.selectOneMessageQueue(lastBrokerName);\n 65:     }\n 66: \n 67:     /**\n 68:      * 更新延迟容错信息\n 69:      *\n 70:      * @param brokerName brokerName\n 71:      * @param currentLatency 延迟\n 72:      * @param isolation 是否隔离。当开启隔离时，默认延迟为30000。目前主要用于发送消息异常时\n 73:      */\n 74:     public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {\n 75:         if (this.sendLatencyFaultEnable) {\n 76:             long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);\n 77:             this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);\n 78:         }\n 79:     }\n 80: \n 81:     /**\n 82:      * 计算延迟对应的不可用时间\n 83:      *\n 84:      * @param currentLatency 延迟\n 85:      * @return 不可用时间\n 86:      */\n 87:     private long computeNotAvailableDuration(final long currentLatency) {\n 88:         for (int i = latencyMax.length - 1; i >= 0; i--) {\n 89:             if (currentLatency >= latencyMax[i])\n 90:                 return this.notAvailableDuration[i];\n 91:         }\n 92:         return 0;\n 93:     }\n```\n* 说明 ：`Producer`消息发送容错策略。默认情况下容错策略关闭，即`sendLatencyFaultEnable=false`。\n* 第 30 至 62 行 ：容错策略选择消息队列逻辑。优先获取可用队列，其次选择一个broker获取队列，最差返回任意broker的一个队列。\n* 第 64 行 ：未开启容错策略选择消息队列逻辑。\n* 第 74 至 79 行 ：更新延迟容错信息。当 `Producer` 发送消息时间过长，则逻辑认为N秒内不可用。按照`latencyMax`，`notAvailableDuration`的配置，对应如下：\n\n    | Producer发送消息消耗时长 | Broker不可用时长 |\n    | --- | --- |\n    | >= 15000 ms | 600 * 1000 ms  |\n    | >= 3000 ms | 180 * 1000 ms  |\n    | >= 2000 ms | 120 * 1000 ms  |\n    | >= 1000 ms | 60 * 1000 ms  |\n    | >= 550 ms | 30 * 1000 ms |\n    | >= 100 ms | 0 ms |\n    | >= 50 ms | 0 ms |\n\n#### LatencyFaultTolerance\n\n```Java\n  1: public interface LatencyFaultTolerance<T> {\n  2: \n  3:     /**\n  4:      * 更新对应的延迟和不可用时长\n  5:      *\n  6:      * @param name 对象\n  7:      * @param currentLatency 延迟\n  8:      * @param notAvailableDuration 不可用时长\n  9:      */\n 10:     void updateFaultItem(final T name, final long currentLatency, final long notAvailableDuration);\n 11: \n 12:     /**\n 13:      * 对象是否可用\n 14:      *\n 15:      * @param name 对象\n 16:      * @return 是否可用\n 17:      */\n 18:     boolean isAvailable(final T name);\n 19: \n 20:     /**\n 21:      * 移除对象\n 22:      *\n 23:      * @param name 对象\n 24:      */\n 25:     void remove(final T name);\n 26: \n 27:     /**\n 28:      * 获取一个对象\n 29:      *\n 30:      * @return 对象\n 31:      */\n 32:     T pickOneAtLeast();\n 33: }\n```\n* 说明 ：延迟故障容错接口\n\n#### LatencyFaultToleranceImpl\n\n```Java\n  1: public class LatencyFaultToleranceImpl implements LatencyFaultTolerance<String> {\n  2: \n  3:     /**\n  4:      * 对象故障信息Table\n  5:      */\n  6:     private final ConcurrentHashMap<String, FaultItem> faultItemTable = new ConcurrentHashMap<>(16);\n  7:     /**\n  8:      * 对象选择Index\n  9:      * @see #pickOneAtLeast()\n 10:      */\n 11:     private final ThreadLocalIndex whichItemWorst = new ThreadLocalIndex();\n 12: \n 13:     @Override\n 14:     public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) {\n 15:         FaultItem old = this.faultItemTable.get(name);\n 16:         if (null == old) {\n 17:             // 创建对象\n 18:             final FaultItem faultItem = new FaultItem(name);\n 19:             faultItem.setCurrentLatency(currentLatency);\n 20:             faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 21:             // 更新对象\n 22:             old = this.faultItemTable.putIfAbsent(name, faultItem);\n 23:             if (old != null) {\n 24:                 old.setCurrentLatency(currentLatency);\n 25:                 old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 26:             }\n 27:         } else { // 更新对象\n 28:             old.setCurrentLatency(currentLatency);\n 29:             old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 30:         }\n 31:     }\n 32: \n 33:     @Override\n 34:     public boolean isAvailable(final String name) {\n 35:         final FaultItem faultItem = this.faultItemTable.get(name);\n 36:         if (faultItem != null) {\n 37:             return faultItem.isAvailable();\n 38:         }\n 39:         return true;\n 40:     }\n 41: \n 42:     @Override\n 43:     public void remove(final String name) {\n 44:         this.faultItemTable.remove(name);\n 45:     }\n 46: \n 47:     /**\n 48:      * 选择一个相对优秀的对象\n 49:      *\n 50:      * @return 对象\n 51:      */\n 52:     @Override\n 53:     public String pickOneAtLeast() {\n 54:         // 创建数组\n 55:         final Enumeration<FaultItem> elements = this.faultItemTable.elements();\n 56:         List<FaultItem> tmpList = new LinkedList<>();\n 57:         while (elements.hasMoreElements()) {\n 58:             final FaultItem faultItem = elements.nextElement();\n 59:             tmpList.add(faultItem);\n 60:         }\n 61:         //\n 62:         if (!tmpList.isEmpty()) {\n 63:             // 打乱 + 排序。TODO 疑问：应该只能二选一。猜测Collections.shuffle(tmpList)去掉。\n 64:             Collections.shuffle(tmpList);\n 65:             Collections.sort(tmpList);\n 66:             // 选择顺序在前一半的对象\n 67:             final int half = tmpList.size() / 2;\n 68:             if (half <= 0) {\n 69:                 return tmpList.get(0).getName();\n 70:             } else {\n 71:                 final int i = this.whichItemWorst.getAndIncrement() % half;\n 72:                 return tmpList.get(i).getName();\n 73:             }\n 74:         }\n 75:         return null;\n 76:     }\n 77: }\n```\n\n* 说明 ：延迟故障容错实现。维护每个对象的信息。\n\n#### FaultItem\n\n```Java\n  1: class FaultItem implements Comparable<FaultItem> {\n  2:     /**\n  3:      * 对象名\n  4:      */\n  5:     private final String name;\n  6:     /**\n  7:      * 延迟\n  8:      */\n  9:     private volatile long currentLatency;\n 10:     /**\n 11:      * 开始可用时间\n 12:      */\n 13:     private volatile long startTimestamp;\n 14: \n 15:     public FaultItem(final String name) {\n 16:         this.name = name;\n 17:     }\n 18: \n 19:     /**\n 20:      * 比较对象\n 21:      * 可用性 > 延迟 > 开始可用时间\n 22:      *\n 23:      * @param other other\n 24:      * @return 升序\n 25:      */\n 26:     @Override\n 27:     public int compareTo(final FaultItem other) {\n 28:         if (this.isAvailable() != other.isAvailable()) {\n 29:             if (this.isAvailable())\n 30:                 return -1;\n 31: \n 32:             if (other.isAvailable())\n 33:                 return 1;\n 34:         }\n 35: \n 36:         if (this.currentLatency < other.currentLatency)\n 37:             return -1;\n 38:         else if (this.currentLatency > other.currentLatency) {\n 39:             return 1;\n 40:         }\n 41: \n 42:         if (this.startTimestamp < other.startTimestamp)\n 43:             return -1;\n 44:         else if (this.startTimestamp > other.startTimestamp) {\n 45:             return 1;\n 46:         }\n 47: \n 48:         return 0;\n 49:     }\n 50: \n 51:     /**\n 52:      * 是否可用：当开始可用时间大于当前时间\n 53:      *\n 54:      * @return 是否可用\n 55:      */\n 56:     public boolean isAvailable() {\n 57:         return (System.currentTimeMillis() - startTimestamp) >= 0;\n 58:     }\n 59: \n 60:     @Override\n 61:     public int hashCode() {\n 62:         int result = getName() != null ? getName().hashCode() : 0;\n 63:         result = 31 * result + (int) (getCurrentLatency() ^ (getCurrentLatency() >>> 32));\n 64:         result = 31 * result + (int) (getStartTimestamp() ^ (getStartTimestamp() >>> 32));\n 65:         return result;\n 66:     }\n 67: \n 68:     @Override\n 69:     public boolean equals(final Object o) {\n 70:         if (this == o)\n 71:             return true;\n 72:         if (!(o instanceof FaultItem))\n 73:             return false;\n 74: \n 75:         final FaultItem faultItem = (FaultItem) o;\n 76: \n 77:         if (getCurrentLatency() != faultItem.getCurrentLatency())\n 78:             return false;\n 79:         if (getStartTimestamp() != faultItem.getStartTimestamp())\n 80:             return false;\n 81:         return getName() != null ? getName().equals(faultItem.getName()) : faultItem.getName() == null;\n 82: \n 83:     }\n 84: }\n```\n* 说明 ：对象故障信息。维护对象的名字、延迟、开始可用的时间。\n\n### DefaultMQProducerImpl#sendKernelImpl()\n\n```Java\n  1: private SendResult sendKernelImpl(final Message msg, //\n  2:     final MessageQueue mq, //\n  3:     final CommunicationMode communicationMode, //\n  4:     final SendCallback sendCallback, //\n  5:     final TopicPublishInfo topicPublishInfo, //\n  6:     final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  7:     // 获取 broker地址\n  8:     String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n  9:     if (null == brokerAddr) {\n 10:         tryToFindTopicPublishInfo(mq.getTopic());\n 11:         brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n 12:     }\n 13:     //\n 14:     SendMessageContext context = null;\n 15:     if (brokerAddr != null) {\n 16:         // 是否使用broker vip通道。broker会开启两个端口对外服务。\n 17:         brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);\n 18:         byte[] prevBody = msg.getBody(); // 记录消息内容。下面逻辑可能改变消息内容，例如消息压缩。\n 19:         try {\n 20:             // 设置唯一编号\n 21:             MessageClientIDSetter.setUniqID(msg);\n 22:             // 消息压缩\n 23:             int sysFlag = 0;\n 24:             if (this.tryToCompressMessage(msg)) {\n 25:                 sysFlag |= MessageSysFlag.COMPRESSED_FLAG;\n 26:             }\n 27:             // 事务\n 28:             final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n 29:             if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {\n 30:                 sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;\n 31:             }\n 32:             // hook：发送消息校验\n 33:             if (hasCheckForbiddenHook()) {\n 34:                 CheckForbiddenContext checkForbiddenContext = new CheckForbiddenContext();\n 35:                 checkForbiddenContext.setNameSrvAddr(this.defaultMQProducer.getNamesrvAddr());\n 36:                 checkForbiddenContext.setGroup(this.defaultMQProducer.getProducerGroup());\n 37:                 checkForbiddenContext.setCommunicationMode(communicationMode);\n 38:                 checkForbiddenContext.setBrokerAddr(brokerAddr);\n 39:                 checkForbiddenContext.setMessage(msg);\n 40:                 checkForbiddenContext.setMq(mq);\n 41:                 checkForbiddenContext.setUnitMode(this.isUnitMode());\n 42:                 this.executeCheckForbiddenHook(checkForbiddenContext);\n 43:             }\n 44:             // hook：发送消息前逻辑\n 45:             if (this.hasSendMessageHook()) {\n 46:                 context = new SendMessageContext();\n 47:                 context.setProducer(this);\n 48:                 context.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n 49:                 context.setCommunicationMode(communicationMode);\n 50:                 context.setBornHost(this.defaultMQProducer.getClientIP());\n 51:                 context.setBrokerAddr(brokerAddr);\n 52:                 context.setMessage(msg);\n 53:                 context.setMq(mq);\n 54:                 String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n 55:                 if (isTrans != null && isTrans.equals(\"true\")) {\n 56:                     context.setMsgType(MessageType.Trans_Msg_Half);\n 57:                 }\n 58:                 if (msg.getProperty(\"__STARTDELIVERTIME\") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) {\n 59:                     context.setMsgType(MessageType.Delay_Msg);\n 60:                 }\n 61:                 this.executeSendMessageHookBefore(context);\n 62:             }\n 63:             // 构建发送消息请求\n 64:             SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n 65:             requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n 66:             requestHeader.setTopic(msg.getTopic());\n 67:             requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());\n 68:             requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());\n 69:             requestHeader.setQueueId(mq.getQueueId());\n 70:             requestHeader.setSysFlag(sysFlag);\n 71:             requestHeader.setBornTimestamp(System.currentTimeMillis());\n 72:             requestHeader.setFlag(msg.getFlag());\n 73:             requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));\n 74:             requestHeader.setReconsumeTimes(0);\n 75:             requestHeader.setUnitMode(this.isUnitMode());\n 76:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { // 消息重发Topic\n 77:                 String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);\n 78:                 if (reconsumeTimes != null) {\n 79:                     requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));\n 80:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);\n 81:                 }\n 82:                 String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);\n 83:                 if (maxReconsumeTimes != null) {\n 84:                     requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));\n 85:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);\n 86:                 }\n 87:             }\n 88:             // 发送消息\n 89:             SendResult sendResult = null;\n 90:             switch (communicationMode) {\n 91:                 case ASYNC:\n 92:                     sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n 93:                         brokerAddr, // 1\n 94:                         mq.getBrokerName(), // 2\n 95:                         msg, // 3\n 96:                         requestHeader, // 4\n 97:                         timeout, // 5\n 98:                         communicationMode, // 6\n 99:                         sendCallback, // 7\n100:                         topicPublishInfo, // 8\n101:                         this.mQClientFactory, // 9\n102:                         this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10\n103:                         context, //\n104:                         this);\n105:                     break;\n106:                 case ONEWAY:\n107:                 case SYNC:\n108:                     sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(\n109:                         brokerAddr,\n110:                         mq.getBrokerName(),\n111:                         msg,\n112:                         requestHeader,\n113:                         timeout,\n114:                         communicationMode,\n115:                         context,\n116:                         this);\n117:                     break;\n118:                 default:\n119:                     assert false;\n120:                     break;\n121:             }\n122:             // hook：发送消息后逻辑\n123:             if (this.hasSendMessageHook()) {\n124:                 context.setSendResult(sendResult);\n125:                 this.executeSendMessageHookAfter(context);\n126:             }\n127:             // 返回发送结果\n128:             return sendResult;\n129:         } catch (RemotingException e) {\n130:             if (this.hasSendMessageHook()) {\n131:                 context.setException(e);\n132:                 this.executeSendMessageHookAfter(context);\n133:             }\n134:             throw e;\n135:         } catch (MQBrokerException e) {\n136:             if (this.hasSendMessageHook()) {\n137:                 context.setException(e);\n138:                 this.executeSendMessageHookAfter(context);\n139:             }\n140:             throw e;\n141:         } catch (InterruptedException e) {\n142:             if (this.hasSendMessageHook()) {\n143:                 context.setException(e);\n144:                 this.executeSendMessageHookAfter(context);\n145:             }\n146:             throw e;\n147:         } finally {\n148:             msg.setBody(prevBody);\n149:         }\n150:     }\n151:     // broker为空抛出异常\n152:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n153: }\n```\n* 说明 ：发送消息核心方法。该方法真正发起网络请求，发送消息给 `Broker`。\n* 第 21 行 ：生产消息编号，详细解析见[《RocketMQ 源码分析 —— Message 基础》](http://www.yunai.me/RocketMQ/message/)。\n* 第 64 至 121 行 ：构建发送消息请求`SendMessageRequestHeader`。\n* 第 107 至 117 行 ：执行 `MQClientInstance#sendMessage(...)` 发起网络请求。\n\n# 3、Broker 接收消息\n\n> ![接收发送消息API顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/04.png)\n\n## SendMessageProcessor#sendMessage\n\n```Java\n  1: @Override\n  2: public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {\n  3:     SendMessageContext mqtraceContext;\n  4:     switch (request.getCode()) {\n  5:         case RequestCode.CONSUMER_SEND_MSG_BACK:\n  6:             return this.consumerSendMsgBack(ctx, request);\n  7:         default:\n  8:             // 解析请求\n  9:             SendMessageRequestHeader requestHeader = parseRequestHeader(request);\n 10:             if (requestHeader == null) {\n 11:                 return null;\n 12:             }\n 13:             // 发送请求Context。在 hook 场景下使用\n 14:             mqtraceContext = buildMsgContext(ctx, requestHeader);\n 15:             // hook：处理发送消息前逻辑\n 16:             this.executeSendMessageHookBefore(ctx, request, mqtraceContext);\n 17:             // 处理发送消息逻辑\n 18:             final RemotingCommand response = this.sendMessage(ctx, request, mqtraceContext, requestHeader);\n 19:             // hook：处理发送消息后逻辑\n 20:             this.executeSendMessageHookAfter(response, mqtraceContext);\n 21:             return response;\n 22:     }\n 23: }\n 24: \n 25: private RemotingCommand sendMessage(final ChannelHandlerContext ctx, //\n 26:     final RemotingCommand request, //\n 27:     final SendMessageContext sendMessageContext, //\n 28:     final SendMessageRequestHeader requestHeader) throws RemotingCommandException {\n 29: \n 30:     // 初始化响应\n 31:     final RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);\n 32:     final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader) response.readCustomHeader();\n 33:     response.setOpaque(request.getOpaque());\n 34:     response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());\n 35:     response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(this.brokerController.getBrokerConfig().isTraceOn()));\n 36: \n 37:     if (log.isDebugEnabled()) {\n 38:         log.debug(\"receive SendMessage request command, {}\", request);\n 39:     }\n 40: \n 41:     // 如果未开始接收消息，抛出系统异常\n 42:     @SuppressWarnings(\"SpellCheckingInspection\")\n 43:     final long startTimstamp = this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();\n 44:     if (this.brokerController.getMessageStore().now() < startTimstamp) {\n 45:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 46:         response.setRemark(String.format(\"broker unable to service, until %s\", UtilAll.timeMillisToHumanString2(startTimstamp)));\n 47:         return response;\n 48:     }\n 49: \n 50:     // 消息配置(Topic配置）校验\n 51:     response.setCode(-1);\n 52:     super.msgCheck(ctx, requestHeader, response);\n 53:     if (response.getCode() != -1) {\n 54:         return response;\n 55:     }\n 56: \n 57:     final byte[] body = request.getBody();\n 58: \n 59:     // 如果队列小于0，从可用队列随机选择\n 60:     int queueIdInt = requestHeader.getQueueId();\n 61:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 62:     if (queueIdInt < 0) {\n 63:         queueIdInt = Math.abs(this.random.nextInt() % 99999999) % topicConfig.getWriteQueueNums();\n 64:     }\n 65: \n 66:     //\n 67:     int sysFlag = requestHeader.getSysFlag();\n 68:     if (TopicFilterType.MULTI_TAG == topicConfig.getTopicFilterType()) {\n 69:         sysFlag |= MessageSysFlag.MULTI_TAGS_FLAG;\n 70:     }\n 71: \n 72:     // 对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)\n 73:     String newTopic = requestHeader.getTopic();\n 74:     if (null != newTopic && newTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 75:         // 获取订阅分组配置\n 76:         String groupName = newTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n 77:         SubscriptionGroupConfig subscriptionGroupConfig =\n 78:             this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(groupName);\n 79:         if (null == subscriptionGroupConfig) {\n 80:             response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 81:             response.setRemark(\"subscription group not exist, \" + groupName + \" \" + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));\n 82:             return response;\n 83:         }\n 84:         // 计算最大可消费次数\n 85:         int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 86:         if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 87:             maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 88:         }\n 89:         int reconsumeTimes = requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes();\n 90:         if (reconsumeTimes >= maxReconsumeTimes) { // 超过最大消费次数\n 91:             newTopic = MixAll.getDLQTopic(groupName);\n 92:             queueIdInt = Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;\n 93:             topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, //\n 94:                 DLQ_NUMS_PER_GROUP, //\n 95:                 PermName.PERM_WRITE, 0\n 96:             );\n 97:             if (null == topicConfig) {\n 98:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n 99:                 response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n100:                 return response;\n101:             }\n102:         }\n103:     }\n104: \n105:     // 创建MessageExtBrokerInner\n106:     MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n107:     msgInner.setTopic(newTopic);\n108:     msgInner.setBody(body);\n109:     msgInner.setFlag(requestHeader.getFlag());\n110:     MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));\n111:     msgInner.setPropertiesString(requestHeader.getProperties());\n112:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(topicConfig.getTopicFilterType(), msgInner.getTags()));\n113:     msgInner.setQueueId(queueIdInt);\n114:     msgInner.setSysFlag(sysFlag);\n115:     msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n116:     msgInner.setBornHost(ctx.channel().remoteAddress());\n117:     msgInner.setStoreHost(this.getStoreHost());\n118:     msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n119: \n120:     // 校验是否不允许发送事务消息\n121:     if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n122:         String traFlag = msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n123:         if (traFlag != null) {\n124:             response.setCode(ResponseCode.NO_PERMISSION);\n125:             response.setRemark(\n126:                 \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \"] sending transaction message is forbidden\");\n127:             return response;\n128:         }\n129:     }\n130: \n131:     // 添加消息\n132:     PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);\n133:     if (putMessageResult != null) {\n134:         boolean sendOK = false;\n135: \n136:         switch (putMessageResult.getPutMessageStatus()) {\n137:             // Success\n138:             case PUT_OK:\n139:                 sendOK = true;\n140:                 response.setCode(ResponseCode.SUCCESS);\n141:                 break;\n142:             case FLUSH_DISK_TIMEOUT:\n143:                 response.setCode(ResponseCode.FLUSH_DISK_TIMEOUT);\n144:                 sendOK = true;\n145:                 break;\n146:             case FLUSH_SLAVE_TIMEOUT:\n147:                 response.setCode(ResponseCode.FLUSH_SLAVE_TIMEOUT);\n148:                 sendOK = true;\n149:                 break;\n150:             case SLAVE_NOT_AVAILABLE:\n151:                 response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);\n152:                 sendOK = true;\n153:                 break;\n154: \n155:             // Failed\n156:             case CREATE_MAPEDFILE_FAILED:\n157:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n158:                 response.setRemark(\"create mapped file failed, server is busy or broken.\");\n159:                 break;\n160:             case MESSAGE_ILLEGAL:\n161:             case PROPERTIES_SIZE_EXCEEDED:\n162:                 response.setCode(ResponseCode.MESSAGE_ILLEGAL);\n163:                 response.setRemark(\n164:                     \"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\");\n165:                 break;\n166:             case SERVICE_NOT_AVAILABLE:\n167:                 response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n168:                 response.setRemark(\n169:                     \"service not available now, maybe disk full, \" + diskUtil() + \", maybe your broker machine memory too small.\");\n170:                 break;\n171:             case OS_PAGECACHE_BUSY:\n172:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n173:                 response.setRemark(\"[PC_SYNCHRONIZED]broker busy, start flow control for a while\");\n174:                 break;\n175:             case UNKNOWN_ERROR:\n176:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n177:                 response.setRemark(\"UNKNOWN_ERROR\");\n178:                 break;\n179:             default:\n180:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n181:                 response.setRemark(\"UNKNOWN_ERROR DEFAULT\");\n182:                 break;\n183:         }\n184: \n185:         String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);\n186:         if (sendOK) {\n187:             // 统计\n188:             this.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic());\n189:             this.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());\n190:             this.brokerController.getBrokerStatsManager().incBrokerPutNums();\n191: \n192:             // 响应\n193:             response.setRemark(null);\n194:             responseHeader.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());\n195:             responseHeader.setQueueId(queueIdInt);\n196:             responseHeader.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());\n197:             doResponse(ctx, request, response);\n198: \n199:             // hook：设置发送成功到context\n200:             if (hasSendMessageHook()) {\n201:                 sendMessageContext.setMsgId(responseHeader.getMsgId());\n202:                 sendMessageContext.setQueueId(responseHeader.getQueueId());\n203:                 sendMessageContext.setQueueOffset(responseHeader.getQueueOffset());\n204: \n205:                 int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();\n206:                 int wroteSize = putMessageResult.getAppendMessageResult().getWroteBytes();\n207:                 int incValue = (int) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT) * commercialBaseCount;\n208: \n209:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_SUCCESS);\n210:                 sendMessageContext.setCommercialSendTimes(incValue);\n211:                 sendMessageContext.setCommercialSendSize(wroteSize);\n212:                 sendMessageContext.setCommercialOwner(owner);\n213:             }\n214:             return null;\n215:         } else {\n216:             // hook：设置发送失败到context\n217:             if (hasSendMessageHook()) {\n218:                 int wroteSize = request.getBody().length;\n219:                 int incValue = (int) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT);\n220: \n221:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_FAILURE);\n222:                 sendMessageContext.setCommercialSendTimes(incValue);\n223:                 sendMessageContext.setCommercialSendSize(wroteSize);\n224:                 sendMessageContext.setCommercialOwner(owner);\n225:             }\n226:         }\n227:     } else {\n228:         response.setCode(ResponseCode.SYSTEM_ERROR);\n229:         response.setRemark(\"store putMessage return null\");\n230:     }\n231: \n232:     return response;\n233: }\n```\n* `#processRequest()` 说明 ：处理消息请求。\n* `#sendMessage()` 说明 ：发送消息，并返回发送消息结果。\n* 第 51 至 55 行 ：消息配置(Topic配置）校验，详细解析见：[AbstractSendMessageProcessor#msgCheck()](#abstractsendmessageprocessormsgcheck)。\n* 第 60 至 64 行 ：消息队列编号小于0时，`Broker` 可以设置随机选择一个消息队列。\n* 第 72 至 103 行 ：对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名， 即加  死信队 (Dead Letter Queue)，详细解析见：[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n* 第 105 至 118 行 ：创建`MessageExtBrokerInner`。\n* 第 132 ：存储消息，详细解析见：[DefaultMessageStore#putMessage()](defaultmessagestoreputmessage)。\n* 第 133 至 183 行 ：处理消息发送结果，设置响应结果和提示。\n* 第 186 至 214 行 ：发送成功，响应。这里`doResponse(ctx, request, response)`进行响应，最后`return null`，原因是：响应给 `Producer` 可能发生异常，`#doResponse(ctx, request, response)`捕捉了该异常并输出日志。这样做的话，我们进行排查 `Broker` 接收消息成功后响应是否存在异常会方便很多。\n\n### AbstractSendMessageProcessor#msgCheck\n\n```Java\n  1: protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,\n  2:                                    final SendMessageRequestHeader requestHeader, final RemotingCommand response) {\n  3:     // 检查 broker 是否有写入权限\n  4:     if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())\n  5:         && this.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) {\n  6:         response.setCode(ResponseCode.NO_PERMISSION);\n  7:         response.setRemark(\"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n  8:             + \"] sending message is forbidden\");\n  9:         return response;\n 10:     }\n 11:     // 检查topic是否可以被发送。目前是{@link MixAll.DEFAULT_TOPIC}不被允许发送\n 12:     if (!this.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) {\n 13:         String errorMsg = \"the topic[\" + requestHeader.getTopic() + \"] is conflict with system reserved words.\";\n 14:         log.warn(errorMsg);\n 15:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 16:         response.setRemark(errorMsg);\n 17:         return response;\n 18:     }\n 19:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 20:     if (null == topicConfig) { // 不能存在topicConfig，则进行创建\n 21:         int topicSysFlag = 0;\n 22:         if (requestHeader.isUnitMode()) {\n 23:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 24:                 topicSysFlag = TopicSysFlag.buildSysFlag(false, true);\n 25:             } else {\n 26:                 topicSysFlag = TopicSysFlag.buildSysFlag(true, false);\n 27:             }\n 28:         }\n 29:         // 创建topic配置\n 30:         log.warn(\"the topic {} not exist, producer: {}\", requestHeader.getTopic(), ctx.channel().remoteAddress());\n 31:         topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(//\n 32:             requestHeader.getTopic(), //\n 33:             requestHeader.getDefaultTopic(), //\n 34:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()), //\n 35:             requestHeader.getDefaultTopicQueueNums(), topicSysFlag);\n 36:         if (null == topicConfig) {\n 37:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 38:                 topicConfig =\n 39:                     this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(\n 40:                         requestHeader.getTopic(), 1, PermName.PERM_WRITE | PermName.PERM_READ,\n 41:                         topicSysFlag);\n 42:             }\n 43:         }\n 44:         // 如果没配置\n 45:         if (null == topicConfig) {\n 46:             response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n 47:             response.setRemark(\"topic[\" + requestHeader.getTopic() + \"] not exist, apply first please!\"\n 48:                 + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));\n 49:             return response;\n 50:         }\n 51:     }\n 52:     // 队列编号是否正确\n 53:     int queueIdInt = requestHeader.getQueueId();\n 54:     int idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());\n 55:     if (queueIdInt >= idValid) {\n 56:         String errorInfo = String.format(\"request queueId[%d] is illegal, %s Producer: %s\",\n 57:             queueIdInt,\n 58:             topicConfig.toString(),\n 59:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n 60:         log.warn(errorInfo);\n 61:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 62:         response.setRemark(errorInfo);\n 63:         return response;\n 64:     }\n 65:     return response;\n 66: }\n```\n* 说明：校验消息是否正确，主要是Topic配置方面，例如：`Broker` 是否有写入权限，topic配置是否存在，队列编号是否正确。\n* 第 11 至 18 行 ：检查Topic是否可以被发送。目前是 `{@link MixAll.DEFAULT_TOPIC}` 不被允许发送。\n* 第 20 至 51 行 ：当找不到Topic配置，则进行创建。当然，创建会存在不成功的情况，例如说：`defaultTopic` 的Topic配置不存在，又或者是 存在但是不允许继承，详细解析见[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n\n## DefaultMessageStore#putMessage\n\n```Java\n  1: public PutMessageResult putMessage(MessageExtBrokerInner msg) {\n  2:     if (this.shutdown) {\n  3:         log.warn(\"message store has shutdown, so putMessage is forbidden\");\n  4:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n  5:     }\n  6: \n  7:     // 从节点不允许写入\n  8:     if (BrokerRole.SLAVE == this.messageStoreConfig.getBrokerRole()) {\n  9:         long value = this.printTimes.getAndIncrement();\n 10:         if ((value % 50000) == 0) {\n 11:             log.warn(\"message store is slave mode, so putMessage is forbidden \");\n 12:         }\n 13: \n 14:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n 15:     }\n 16: \n 17:     // store是否允许写入\n 18:     if (!this.runningFlags.isWriteable()) {\n 19:         long value = this.printTimes.getAndIncrement();\n 20:         if ((value % 50000) == 0) {\n 21:             log.warn(\"message store is not writeable, so putMessage is forbidden \" + this.runningFlags.getFlagBits());\n 22:         }\n 23: \n 24:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n 25:     } else {\n 26:         this.printTimes.set(0);\n 27:     }\n 28: \n 29:     // 消息过长\n 30:     if (msg.getTopic().length() > Byte.MAX_VALUE) {\n 31:         log.warn(\"putMessage message topic length too long \" + msg.getTopic().length());\n 32:         return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n 33:     }\n 34: \n 35:     // 消息附加属性过长\n 36:     if (msg.getPropertiesString() != null && msg.getPropertiesString().length() > Short.MAX_VALUE) {\n 37:         log.warn(\"putMessage message properties length too long \" + msg.getPropertiesString().length());\n 38:         return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null);\n 39:     }\n 40: \n 41:     if (this.isOSPageCacheBusy()) {\n 42:         return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, null);\n 43:     }\n 44: \n 45:     long beginTime = this.getSystemClock().now();\n 46:     // 添加消息到commitLog\n 47:     PutMessageResult result = this.commitLog.putMessage(msg);\n 48: \n 49:     long eclipseTime = this.getSystemClock().now() - beginTime;\n 50:     if (eclipseTime > 500) {\n 51:         log.warn(\"putMessage not in lock eclipse time(ms)={}, bodyLength={}\", eclipseTime, msg.getBody().length);\n 52:     }\n 53:     this.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);\n 54: \n 55:     if (null == result || !result.isOk()) {\n 56:         this.storeStatsService.getPutMessageFailedTimes().incrementAndGet();\n 57:     }\n 58: \n 59:     return result;\n 60: }\n```\n* 说明：存储消息封装，最终存储需要 `CommitLog` 实现。\n* 第 7 至 27 行 ：校验 `Broker` 是否可以写入。\n* 第 29 至 39 行 ：消息格式与大小校验。\n* 第 47 行 ：调用 `CommitLong` 进行存储，详细逻辑见：[《RocketMQ 源码分析 —— Message 存储》](http://www.yunai.me/RocketMQ/message-store/)\n\n# 4、某种结尾\n\n感谢阅读、收藏、点赞本文的工程师同学。\n\n阅读源码是件令自己很愉悦的事情，编写源码解析是让自己脑细胞死伤无数的过程，痛并快乐着。\n\n如果有内容写的存在错误，或是不清晰的地方，见笑了，🙂。欢迎加 QQ：7685413 我们一起探讨，共进步。\n\n再次感谢阅读、收藏、点赞本文的工程师同学。\n\n\n\n\n\n\n\n\n\n","source":"_posts/RocketMQ/2017_04_18_RocketMQ源码分析——Message发送与接收.md","raw":"title: RocketMQ 源码分析 —— Message 发送与接收\ndate: 2017-04-18\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-send-and-receive\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-send-and-receive/](http://www.yunai.me/RocketMQ/message-send-and-receive/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、Producer 发送消息](#)\n\t- [DefaultMQProducer#send(Message)](#)\n\t- [DefaultMQProducerImpl#sendDefaultImpl()](#)\n\t\t- [DefaultMQProducerImpl#tryToFindTopicPublishInfo()](#)\n\t\t- [MQFaultStrategy](#)\n\t\t\t- [MQFaultStrategy](#)\n\t\t\t- [LatencyFaultTolerance](#)\n\t\t\t- [LatencyFaultToleranceImpl](#)\n\t\t\t- [FaultItem](#)\n\t\t- [DefaultMQProducerImpl#sendKernelImpl()](#)\n- [3、Broker 接收消息](#)\n\t- [SendMessageProcessor#sendMessage](#)\n\t\t- [AbstractSendMessageProcessor#msgCheck](#)\n\t- [DefaultMessageStore#putMessage](#)\n- [4、某种结尾](#)\n\n# 1、概述\n\n1. `Producer` 发送消息。主要是**同步**发送消息源码，涉及到 异步/Oneway发送消息，事务消息会跳过。\n2. `Broker` 接收消息。(*存储消息在[《RocketMQ 源码分析 —— Message 存储》](http://www.yunai.me/RocketMQ/message-store/)解析*)\n\n> ![Producer发送消息全局顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/01.png)\n\n# 2、Producer 发送消息\n\n > ![Producer发送消息顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/02.png)\n\n## DefaultMQProducer#send(Message)\n\n```Java\n  1: @Override\n  2: public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  3:     return this.defaultMQProducerImpl.send(msg);\n  4: }\n```\n\n* 说明：发送同步消息，`DefaultMQProducer#send(Message)` 对 `DefaultMQProducerImpl#send(Message)` 进行封装。  \n\n## DefaultMQProducerImpl#sendDefaultImpl()\n\n```Java\n  1: public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  2:     return send(msg, this.defaultMQProducer.getSendMsgTimeout());\n  3: }\n  4: \n  5: public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  6:     return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);\n  7: }\n  8: \n  9: private SendResult sendDefaultImpl(//\n 10:     Message msg, //\n 11:     final CommunicationMode communicationMode, //\n 12:     final SendCallback sendCallback, //\n 13:     final long timeout//\n 14: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 15:     // 校验 Producer 处于运行状态\n 16:     this.makeSureStateOK();\n 17:     // 校验消息格式\n 18:     Validators.checkMessage(msg, this.defaultMQProducer);\n 19:     //\n 20:     final long invokeID = random.nextLong(); // 调用编号；用于下面打印日志，标记为同一次发送消息\n 21:     long beginTimestampFirst = System.currentTimeMillis();\n 22:     long beginTimestampPrev = beginTimestampFirst;\n 23:     long endTimestamp = beginTimestampFirst;\n 24:     // 获取 Topic路由信息\n 25:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 26:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 27:         MessageQueue mq = null; // 最后选择消息要发送到的队列\n 28:         Exception exception = null;\n 29:         SendResult sendResult = null; // 最后一次发送结果\n 30:         int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; // 同步多次调用\n 31:         int times = 0; // 第几次发送\n 32:         String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名\n 33:         // 循环调用发送消息，直到成功\n 34:         for (; times < timesTotal; times++) {\n 35:             String lastBrokerName = null == mq ? null : mq.getBrokerName();\n 36:             MessageQueue tmpmq = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); // 选择消息要发送到的队列\n 37:             if (tmpmq != null) {\n 38:                 mq = tmpmq;\n 39:                 brokersSent[times] = mq.getBrokerName();\n 40:                 try {\n 41:                     beginTimestampPrev = System.currentTimeMillis();\n 42:                     // 调用发送消息核心方法\n 43:                     sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);\n 44:                     endTimestamp = System.currentTimeMillis();\n 45:                     // 更新Broker可用性信息\n 46:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n 47:                     switch (communicationMode) {\n 48:                         case ASYNC:\n 49:                             return null;\n 50:                         case ONEWAY:\n 51:                             return null;\n 52:                         case SYNC:\n 53:                             if (sendResult.getSendStatus() != SendStatus.SEND_OK) {\n 54:                                 if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { // 同步发送成功但存储有问题时 && 配置存储异常时重新发送开关 时，进行重试\n 55:                                     continue;\n 56:                                 }\n 57:                             }\n 58:                             return sendResult;\n 59:                         default:\n 60:                             break;\n 61:                     }\n 62:                 } catch (RemotingException e) { // 打印异常，更新Broker可用性信息，更新继续循环\n 63:                     endTimestamp = System.currentTimeMillis();\n 64:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 65:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 66:                     log.warn(msg.toString());\n 67:                     exception = e;\n 68:                     continue;\n 69:                 } catch (MQClientException e) { // 打印异常，更新Broker可用性信息，继续循环\n 70:                     endTimestamp = System.currentTimeMillis();\n 71:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 72:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 73:                     log.warn(msg.toString());\n 74:                     exception = e;\n 75:                     continue;\n 76:                 } catch (MQBrokerException e) { // 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环\n 77:                     endTimestamp = System.currentTimeMillis();\n 78:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);\n 79:                     log.warn(String.format(\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n 80:                     log.warn(msg.toString());\n 81:                     exception = e;\n 82:                     switch (e.getResponseCode()) {\n 83:                         // 如下异常continue，进行发送消息重试\n 84:                         case ResponseCode.TOPIC_NOT_EXIST:\n 85:                         case ResponseCode.SERVICE_NOT_AVAILABLE:\n 86:                         case ResponseCode.SYSTEM_ERROR:\n 87:                         case ResponseCode.NO_PERMISSION:\n 88:                         case ResponseCode.NO_BUYER_ID:\n 89:                         case ResponseCode.NOT_IN_CURRENT_UNIT:\n 90:                             continue;\n 91:                         // 如果有发送结果，进行返回，否则，抛出异常；\n 92:                         default:\n 93:                             if (sendResult != null) {\n 94:                                 return sendResult;\n 95:                             }\n 96:                             throw e;\n 97:                     }\n 98:                 } catch (InterruptedException e) {\n 99:                     endTimestamp = System.currentTimeMillis();\n100:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n101:                     log.warn(String.format(\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\", invokeID, endTimestamp - beginTimestampPrev, mq), e);\n102:                     log.warn(msg.toString());\n103:                     throw e;\n104:                 }\n105:             } else {\n106:                 break;\n107:             }\n108:         }\n109:         // 返回发送结果\n110:         if (sendResult != null) {\n111:             return sendResult;\n112:         }\n113:         // 根据不同情况，抛出不同的异常\n114:         String info = String.format(\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\", times, System.currentTimeMillis() - beginTimestampFirst,\n115:                 msg.getTopic(), Arrays.toString(brokersSent)) + FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);\n116:         MQClientException mqClientException = new MQClientException(info, exception);\n117:         if (exception instanceof MQBrokerException) {\n118:             mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());\n119:         } else if (exception instanceof RemotingConnectException) {\n120:             mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);\n121:         } else if (exception instanceof RemotingTimeoutException) {\n122:             mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);\n123:         } else if (exception instanceof MQClientException) {\n124:             mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);\n125:         }\n126:         throw mqClientException;\n127:     }\n128:     // Namesrv找不到异常\n129:     List<String> nsList = this.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();\n130:     if (null == nsList || nsList.isEmpty()) {\n131:         throw new MQClientException(\n132:             \"No name server address, please set it.\" + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), null).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);\n133:     }\n134:     // 消息路由找不到异常\n135:     throw new MQClientException(\"No route info of this topic, \" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),\n136:         null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);\n137: }\n```\n* 说明 ：发送消息。步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。\n* 第 1  至 7 行：对`sendsendDefaultImpl(...)`进行封装。\n* 第 20 行 ：`invokeID`仅仅用于打印日志，无实际的业务用途。\n* 第 25 行 ：获取 Topic路由信息， 详细解析见：[DefaultMQProducerImpl#tryToFindTopicPublishInfo()](#defaultmqproducerimpltrytofindtopicpublishinfo)\n* 第 30 & 34 行 ：计算调用发送消息到成功为止的最大次数，并进行循环。同步或异步发送消息会调用多次，默认配置为3次。\n* 第 36 行 ：选择消息要发送到的队列，详细解析见：[MQFaultStrategy](#mqfaultstrategy)\n* 第 43 行 ：调用发送消息核心方法，详细解析见：[DefaultMQProducerImpl#sendKernelImpl()](#defaultmqproducerimplsendkernelimpl)\n* 第 46 行 ：更新`Broker`可用性信息。在选择发送到的消息队列时，会参考`Broker`发送消息的延迟，详细解析见：[MQFaultStrategy](#mqfaultstrategy)\n* 第 62 至 68 行：当抛出`RemotingException`时，如果进行消息发送失败重试，则**可能导致消息发送重复**。例如，发送消息超时(`RemotingTimeoutException`)，实际`Broker`接收到该消息并处理成功。因此，`Consumer`在消费时，需要保证幂等性。\n\n### DefaultMQProducerImpl#tryToFindTopicPublishInfo()\n\n```Java\n  1: private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {\n  2:     // 缓存中获取 Topic发布信息\n  3:     TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);\n  4:     // 当无可用的 Topic发布信息时，从Namesrv获取一次\n  5:     if (null == topicPublishInfo || !topicPublishInfo.ok()) {\n  6:         this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());\n  7:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);\n  8:         topicPublishInfo = this.topicPublishInfoTable.get(topic);\n  9:     }\n 10:     // 若获取的 Topic发布信息时候可用，则返回\n 11:     if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) {\n 12:         return topicPublishInfo;\n 13:     } else { // 使用 {@link DefaultMQProducer#createTopicKey} 对应的 Topic发布信息。用于 Topic发布信息不存在 && Broker支持自动创建Topic\n 14:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);\n 15:         topicPublishInfo = this.topicPublishInfoTable.get(topic);\n 16:         return topicPublishInfo;\n 17:     }\n 18: }\n```\n* 说明 ：获得 Topic发布信息。优先从缓存`topicPublishInfoTable`，其次从`Namesrv`中获得。\n* 第 3 行 ：从缓存`topicPublishInfoTable`中获得 Topic发布信息。\n* 第 5 至 9 行 ：从 `Namesrv` 中获得 Topic发布信息。\n* 第 13 至 17 行 ：当从 `Namesrv` 无法获取时，使用 `{@link DefaultMQProducer#createTopicKey}` 对应的 Topic发布信息。目的是当 `Broker` 开启自动创建 Topic开关时，`Broker` 接收到消息后自动创建Topic，详细解析见[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n\n### MQFaultStrategy\n\n> ![Latency类图](http://www.yunai.me/images/RocketMQ/2017_04_18/03.png)\n\n#### MQFaultStrategy\n\n```Java\n  1: public class MQFaultStrategy {\n  2:     private final static Logger log = ClientLogger.getLog();\n  3: \n  4:     /**\n  5:      * 延迟故障容错，维护每个Broker的发送消息的延迟\n  6:      * key：brokerName\n  7:      */\n  8:     private final LatencyFaultTolerance<String> latencyFaultTolerance = new LatencyFaultToleranceImpl();\n  9:     /**\n 10:      * 发送消息延迟容错开关\n 11:      */\n 12:     private boolean sendLatencyFaultEnable = false;\n 13:     /**\n 14:      * 延迟级别数组\n 15:      */\n 16:     private long[] latencyMax = {50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L};\n 17:     /**\n 18:      * 不可用时长数组\n 19:      */\n 20:     private long[] notAvailableDuration = {0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L};\n 21: \n 22:     /**\n 23:      * 根据 Topic发布信息 选择一个消息队列\n 24:      *\n 25:      * @param tpInfo Topic发布信息\n 26:      * @param lastBrokerName brokerName\n 27:      * @return 消息队列\n 28:      */\n 29:     public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {\n 30:         if (this.sendLatencyFaultEnable) {\n 31:             try {\n 32:                 // 获取 brokerName=lastBrokerName && 可用的一个消息队列\n 33:                 int index = tpInfo.getSendWhichQueue().getAndIncrement();\n 34:                 for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {\n 35:                     int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();\n 36:                     if (pos < 0)\n 37:                         pos = 0;\n 38:                     MessageQueue mq = tpInfo.getMessageQueueList().get(pos);\n 39:                     if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {\n 40:                         if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))\n 41:                             return mq;\n 42:                     }\n 43:                 }\n 44:                 // 选择一个相对好的broker，并获得其对应的一个消息队列，不考虑该队列的可用性\n 45:                 final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();\n 46:                 int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);\n 47:                 if (writeQueueNums > 0) {\n 48:                     final MessageQueue mq = tpInfo.selectOneMessageQueue();\n 49:                     if (notBestBroker != null) {\n 50:                         mq.setBrokerName(notBestBroker);\n 51:                         mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);\n 52:                     }\n 53:                     return mq;\n 54:                 } else {\n 55:                     latencyFaultTolerance.remove(notBestBroker);\n 56:                 }\n 57:             } catch (Exception e) {\n 58:                 log.error(\"Error occurred when selecting message queue\", e);\n 59:             }\n 60:             // 选择一个消息队列，不考虑队列的可用性\n 61:             return tpInfo.selectOneMessageQueue();\n 62:         }\n 63:         // 获得 lastBrokerName 对应的一个消息队列，不考虑该队列的可用性\n 64:         return tpInfo.selectOneMessageQueue(lastBrokerName);\n 65:     }\n 66: \n 67:     /**\n 68:      * 更新延迟容错信息\n 69:      *\n 70:      * @param brokerName brokerName\n 71:      * @param currentLatency 延迟\n 72:      * @param isolation 是否隔离。当开启隔离时，默认延迟为30000。目前主要用于发送消息异常时\n 73:      */\n 74:     public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) {\n 75:         if (this.sendLatencyFaultEnable) {\n 76:             long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);\n 77:             this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);\n 78:         }\n 79:     }\n 80: \n 81:     /**\n 82:      * 计算延迟对应的不可用时间\n 83:      *\n 84:      * @param currentLatency 延迟\n 85:      * @return 不可用时间\n 86:      */\n 87:     private long computeNotAvailableDuration(final long currentLatency) {\n 88:         for (int i = latencyMax.length - 1; i >= 0; i--) {\n 89:             if (currentLatency >= latencyMax[i])\n 90:                 return this.notAvailableDuration[i];\n 91:         }\n 92:         return 0;\n 93:     }\n```\n* 说明 ：`Producer`消息发送容错策略。默认情况下容错策略关闭，即`sendLatencyFaultEnable=false`。\n* 第 30 至 62 行 ：容错策略选择消息队列逻辑。优先获取可用队列，其次选择一个broker获取队列，最差返回任意broker的一个队列。\n* 第 64 行 ：未开启容错策略选择消息队列逻辑。\n* 第 74 至 79 行 ：更新延迟容错信息。当 `Producer` 发送消息时间过长，则逻辑认为N秒内不可用。按照`latencyMax`，`notAvailableDuration`的配置，对应如下：\n\n    | Producer发送消息消耗时长 | Broker不可用时长 |\n    | --- | --- |\n    | >= 15000 ms | 600 * 1000 ms  |\n    | >= 3000 ms | 180 * 1000 ms  |\n    | >= 2000 ms | 120 * 1000 ms  |\n    | >= 1000 ms | 60 * 1000 ms  |\n    | >= 550 ms | 30 * 1000 ms |\n    | >= 100 ms | 0 ms |\n    | >= 50 ms | 0 ms |\n\n#### LatencyFaultTolerance\n\n```Java\n  1: public interface LatencyFaultTolerance<T> {\n  2: \n  3:     /**\n  4:      * 更新对应的延迟和不可用时长\n  5:      *\n  6:      * @param name 对象\n  7:      * @param currentLatency 延迟\n  8:      * @param notAvailableDuration 不可用时长\n  9:      */\n 10:     void updateFaultItem(final T name, final long currentLatency, final long notAvailableDuration);\n 11: \n 12:     /**\n 13:      * 对象是否可用\n 14:      *\n 15:      * @param name 对象\n 16:      * @return 是否可用\n 17:      */\n 18:     boolean isAvailable(final T name);\n 19: \n 20:     /**\n 21:      * 移除对象\n 22:      *\n 23:      * @param name 对象\n 24:      */\n 25:     void remove(final T name);\n 26: \n 27:     /**\n 28:      * 获取一个对象\n 29:      *\n 30:      * @return 对象\n 31:      */\n 32:     T pickOneAtLeast();\n 33: }\n```\n* 说明 ：延迟故障容错接口\n\n#### LatencyFaultToleranceImpl\n\n```Java\n  1: public class LatencyFaultToleranceImpl implements LatencyFaultTolerance<String> {\n  2: \n  3:     /**\n  4:      * 对象故障信息Table\n  5:      */\n  6:     private final ConcurrentHashMap<String, FaultItem> faultItemTable = new ConcurrentHashMap<>(16);\n  7:     /**\n  8:      * 对象选择Index\n  9:      * @see #pickOneAtLeast()\n 10:      */\n 11:     private final ThreadLocalIndex whichItemWorst = new ThreadLocalIndex();\n 12: \n 13:     @Override\n 14:     public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) {\n 15:         FaultItem old = this.faultItemTable.get(name);\n 16:         if (null == old) {\n 17:             // 创建对象\n 18:             final FaultItem faultItem = new FaultItem(name);\n 19:             faultItem.setCurrentLatency(currentLatency);\n 20:             faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 21:             // 更新对象\n 22:             old = this.faultItemTable.putIfAbsent(name, faultItem);\n 23:             if (old != null) {\n 24:                 old.setCurrentLatency(currentLatency);\n 25:                 old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 26:             }\n 27:         } else { // 更新对象\n 28:             old.setCurrentLatency(currentLatency);\n 29:             old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);\n 30:         }\n 31:     }\n 32: \n 33:     @Override\n 34:     public boolean isAvailable(final String name) {\n 35:         final FaultItem faultItem = this.faultItemTable.get(name);\n 36:         if (faultItem != null) {\n 37:             return faultItem.isAvailable();\n 38:         }\n 39:         return true;\n 40:     }\n 41: \n 42:     @Override\n 43:     public void remove(final String name) {\n 44:         this.faultItemTable.remove(name);\n 45:     }\n 46: \n 47:     /**\n 48:      * 选择一个相对优秀的对象\n 49:      *\n 50:      * @return 对象\n 51:      */\n 52:     @Override\n 53:     public String pickOneAtLeast() {\n 54:         // 创建数组\n 55:         final Enumeration<FaultItem> elements = this.faultItemTable.elements();\n 56:         List<FaultItem> tmpList = new LinkedList<>();\n 57:         while (elements.hasMoreElements()) {\n 58:             final FaultItem faultItem = elements.nextElement();\n 59:             tmpList.add(faultItem);\n 60:         }\n 61:         //\n 62:         if (!tmpList.isEmpty()) {\n 63:             // 打乱 + 排序。TODO 疑问：应该只能二选一。猜测Collections.shuffle(tmpList)去掉。\n 64:             Collections.shuffle(tmpList);\n 65:             Collections.sort(tmpList);\n 66:             // 选择顺序在前一半的对象\n 67:             final int half = tmpList.size() / 2;\n 68:             if (half <= 0) {\n 69:                 return tmpList.get(0).getName();\n 70:             } else {\n 71:                 final int i = this.whichItemWorst.getAndIncrement() % half;\n 72:                 return tmpList.get(i).getName();\n 73:             }\n 74:         }\n 75:         return null;\n 76:     }\n 77: }\n```\n\n* 说明 ：延迟故障容错实现。维护每个对象的信息。\n\n#### FaultItem\n\n```Java\n  1: class FaultItem implements Comparable<FaultItem> {\n  2:     /**\n  3:      * 对象名\n  4:      */\n  5:     private final String name;\n  6:     /**\n  7:      * 延迟\n  8:      */\n  9:     private volatile long currentLatency;\n 10:     /**\n 11:      * 开始可用时间\n 12:      */\n 13:     private volatile long startTimestamp;\n 14: \n 15:     public FaultItem(final String name) {\n 16:         this.name = name;\n 17:     }\n 18: \n 19:     /**\n 20:      * 比较对象\n 21:      * 可用性 > 延迟 > 开始可用时间\n 22:      *\n 23:      * @param other other\n 24:      * @return 升序\n 25:      */\n 26:     @Override\n 27:     public int compareTo(final FaultItem other) {\n 28:         if (this.isAvailable() != other.isAvailable()) {\n 29:             if (this.isAvailable())\n 30:                 return -1;\n 31: \n 32:             if (other.isAvailable())\n 33:                 return 1;\n 34:         }\n 35: \n 36:         if (this.currentLatency < other.currentLatency)\n 37:             return -1;\n 38:         else if (this.currentLatency > other.currentLatency) {\n 39:             return 1;\n 40:         }\n 41: \n 42:         if (this.startTimestamp < other.startTimestamp)\n 43:             return -1;\n 44:         else if (this.startTimestamp > other.startTimestamp) {\n 45:             return 1;\n 46:         }\n 47: \n 48:         return 0;\n 49:     }\n 50: \n 51:     /**\n 52:      * 是否可用：当开始可用时间大于当前时间\n 53:      *\n 54:      * @return 是否可用\n 55:      */\n 56:     public boolean isAvailable() {\n 57:         return (System.currentTimeMillis() - startTimestamp) >= 0;\n 58:     }\n 59: \n 60:     @Override\n 61:     public int hashCode() {\n 62:         int result = getName() != null ? getName().hashCode() : 0;\n 63:         result = 31 * result + (int) (getCurrentLatency() ^ (getCurrentLatency() >>> 32));\n 64:         result = 31 * result + (int) (getStartTimestamp() ^ (getStartTimestamp() >>> 32));\n 65:         return result;\n 66:     }\n 67: \n 68:     @Override\n 69:     public boolean equals(final Object o) {\n 70:         if (this == o)\n 71:             return true;\n 72:         if (!(o instanceof FaultItem))\n 73:             return false;\n 74: \n 75:         final FaultItem faultItem = (FaultItem) o;\n 76: \n 77:         if (getCurrentLatency() != faultItem.getCurrentLatency())\n 78:             return false;\n 79:         if (getStartTimestamp() != faultItem.getStartTimestamp())\n 80:             return false;\n 81:         return getName() != null ? getName().equals(faultItem.getName()) : faultItem.getName() == null;\n 82: \n 83:     }\n 84: }\n```\n* 说明 ：对象故障信息。维护对象的名字、延迟、开始可用的时间。\n\n### DefaultMQProducerImpl#sendKernelImpl()\n\n```Java\n  1: private SendResult sendKernelImpl(final Message msg, //\n  2:     final MessageQueue mq, //\n  3:     final CommunicationMode communicationMode, //\n  4:     final SendCallback sendCallback, //\n  5:     final TopicPublishInfo topicPublishInfo, //\n  6:     final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  7:     // 获取 broker地址\n  8:     String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n  9:     if (null == brokerAddr) {\n 10:         tryToFindTopicPublishInfo(mq.getTopic());\n 11:         brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());\n 12:     }\n 13:     //\n 14:     SendMessageContext context = null;\n 15:     if (brokerAddr != null) {\n 16:         // 是否使用broker vip通道。broker会开启两个端口对外服务。\n 17:         brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);\n 18:         byte[] prevBody = msg.getBody(); // 记录消息内容。下面逻辑可能改变消息内容，例如消息压缩。\n 19:         try {\n 20:             // 设置唯一编号\n 21:             MessageClientIDSetter.setUniqID(msg);\n 22:             // 消息压缩\n 23:             int sysFlag = 0;\n 24:             if (this.tryToCompressMessage(msg)) {\n 25:                 sysFlag |= MessageSysFlag.COMPRESSED_FLAG;\n 26:             }\n 27:             // 事务\n 28:             final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n 29:             if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {\n 30:                 sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;\n 31:             }\n 32:             // hook：发送消息校验\n 33:             if (hasCheckForbiddenHook()) {\n 34:                 CheckForbiddenContext checkForbiddenContext = new CheckForbiddenContext();\n 35:                 checkForbiddenContext.setNameSrvAddr(this.defaultMQProducer.getNamesrvAddr());\n 36:                 checkForbiddenContext.setGroup(this.defaultMQProducer.getProducerGroup());\n 37:                 checkForbiddenContext.setCommunicationMode(communicationMode);\n 38:                 checkForbiddenContext.setBrokerAddr(brokerAddr);\n 39:                 checkForbiddenContext.setMessage(msg);\n 40:                 checkForbiddenContext.setMq(mq);\n 41:                 checkForbiddenContext.setUnitMode(this.isUnitMode());\n 42:                 this.executeCheckForbiddenHook(checkForbiddenContext);\n 43:             }\n 44:             // hook：发送消息前逻辑\n 45:             if (this.hasSendMessageHook()) {\n 46:                 context = new SendMessageContext();\n 47:                 context.setProducer(this);\n 48:                 context.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n 49:                 context.setCommunicationMode(communicationMode);\n 50:                 context.setBornHost(this.defaultMQProducer.getClientIP());\n 51:                 context.setBrokerAddr(brokerAddr);\n 52:                 context.setMessage(msg);\n 53:                 context.setMq(mq);\n 54:                 String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n 55:                 if (isTrans != null && isTrans.equals(\"true\")) {\n 56:                     context.setMsgType(MessageType.Trans_Msg_Half);\n 57:                 }\n 58:                 if (msg.getProperty(\"__STARTDELIVERTIME\") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) {\n 59:                     context.setMsgType(MessageType.Delay_Msg);\n 60:                 }\n 61:                 this.executeSendMessageHookBefore(context);\n 62:             }\n 63:             // 构建发送消息请求\n 64:             SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();\n 65:             requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n 66:             requestHeader.setTopic(msg.getTopic());\n 67:             requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());\n 68:             requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());\n 69:             requestHeader.setQueueId(mq.getQueueId());\n 70:             requestHeader.setSysFlag(sysFlag);\n 71:             requestHeader.setBornTimestamp(System.currentTimeMillis());\n 72:             requestHeader.setFlag(msg.getFlag());\n 73:             requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));\n 74:             requestHeader.setReconsumeTimes(0);\n 75:             requestHeader.setUnitMode(this.isUnitMode());\n 76:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { // 消息重发Topic\n 77:                 String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);\n 78:                 if (reconsumeTimes != null) {\n 79:                     requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));\n 80:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);\n 81:                 }\n 82:                 String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);\n 83:                 if (maxReconsumeTimes != null) {\n 84:                     requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));\n 85:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);\n 86:                 }\n 87:             }\n 88:             // 发送消息\n 89:             SendResult sendResult = null;\n 90:             switch (communicationMode) {\n 91:                 case ASYNC:\n 92:                     sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(//\n 93:                         brokerAddr, // 1\n 94:                         mq.getBrokerName(), // 2\n 95:                         msg, // 3\n 96:                         requestHeader, // 4\n 97:                         timeout, // 5\n 98:                         communicationMode, // 6\n 99:                         sendCallback, // 7\n100:                         topicPublishInfo, // 8\n101:                         this.mQClientFactory, // 9\n102:                         this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), // 10\n103:                         context, //\n104:                         this);\n105:                     break;\n106:                 case ONEWAY:\n107:                 case SYNC:\n108:                     sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(\n109:                         brokerAddr,\n110:                         mq.getBrokerName(),\n111:                         msg,\n112:                         requestHeader,\n113:                         timeout,\n114:                         communicationMode,\n115:                         context,\n116:                         this);\n117:                     break;\n118:                 default:\n119:                     assert false;\n120:                     break;\n121:             }\n122:             // hook：发送消息后逻辑\n123:             if (this.hasSendMessageHook()) {\n124:                 context.setSendResult(sendResult);\n125:                 this.executeSendMessageHookAfter(context);\n126:             }\n127:             // 返回发送结果\n128:             return sendResult;\n129:         } catch (RemotingException e) {\n130:             if (this.hasSendMessageHook()) {\n131:                 context.setException(e);\n132:                 this.executeSendMessageHookAfter(context);\n133:             }\n134:             throw e;\n135:         } catch (MQBrokerException e) {\n136:             if (this.hasSendMessageHook()) {\n137:                 context.setException(e);\n138:                 this.executeSendMessageHookAfter(context);\n139:             }\n140:             throw e;\n141:         } catch (InterruptedException e) {\n142:             if (this.hasSendMessageHook()) {\n143:                 context.setException(e);\n144:                 this.executeSendMessageHookAfter(context);\n145:             }\n146:             throw e;\n147:         } finally {\n148:             msg.setBody(prevBody);\n149:         }\n150:     }\n151:     // broker为空抛出异常\n152:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n153: }\n```\n* 说明 ：发送消息核心方法。该方法真正发起网络请求，发送消息给 `Broker`。\n* 第 21 行 ：生产消息编号，详细解析见[《RocketMQ 源码分析 —— Message 基础》](http://www.yunai.me/RocketMQ/message/)。\n* 第 64 至 121 行 ：构建发送消息请求`SendMessageRequestHeader`。\n* 第 107 至 117 行 ：执行 `MQClientInstance#sendMessage(...)` 发起网络请求。\n\n# 3、Broker 接收消息\n\n> ![接收发送消息API顺序图](http://www.yunai.me/images/RocketMQ/2017_04_18/04.png)\n\n## SendMessageProcessor#sendMessage\n\n```Java\n  1: @Override\n  2: public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {\n  3:     SendMessageContext mqtraceContext;\n  4:     switch (request.getCode()) {\n  5:         case RequestCode.CONSUMER_SEND_MSG_BACK:\n  6:             return this.consumerSendMsgBack(ctx, request);\n  7:         default:\n  8:             // 解析请求\n  9:             SendMessageRequestHeader requestHeader = parseRequestHeader(request);\n 10:             if (requestHeader == null) {\n 11:                 return null;\n 12:             }\n 13:             // 发送请求Context。在 hook 场景下使用\n 14:             mqtraceContext = buildMsgContext(ctx, requestHeader);\n 15:             // hook：处理发送消息前逻辑\n 16:             this.executeSendMessageHookBefore(ctx, request, mqtraceContext);\n 17:             // 处理发送消息逻辑\n 18:             final RemotingCommand response = this.sendMessage(ctx, request, mqtraceContext, requestHeader);\n 19:             // hook：处理发送消息后逻辑\n 20:             this.executeSendMessageHookAfter(response, mqtraceContext);\n 21:             return response;\n 22:     }\n 23: }\n 24: \n 25: private RemotingCommand sendMessage(final ChannelHandlerContext ctx, //\n 26:     final RemotingCommand request, //\n 27:     final SendMessageContext sendMessageContext, //\n 28:     final SendMessageRequestHeader requestHeader) throws RemotingCommandException {\n 29: \n 30:     // 初始化响应\n 31:     final RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);\n 32:     final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader) response.readCustomHeader();\n 33:     response.setOpaque(request.getOpaque());\n 34:     response.addExtField(MessageConst.PROPERTY_MSG_REGION, this.brokerController.getBrokerConfig().getRegionId());\n 35:     response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(this.brokerController.getBrokerConfig().isTraceOn()));\n 36: \n 37:     if (log.isDebugEnabled()) {\n 38:         log.debug(\"receive SendMessage request command, {}\", request);\n 39:     }\n 40: \n 41:     // 如果未开始接收消息，抛出系统异常\n 42:     @SuppressWarnings(\"SpellCheckingInspection\")\n 43:     final long startTimstamp = this.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();\n 44:     if (this.brokerController.getMessageStore().now() < startTimstamp) {\n 45:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 46:         response.setRemark(String.format(\"broker unable to service, until %s\", UtilAll.timeMillisToHumanString2(startTimstamp)));\n 47:         return response;\n 48:     }\n 49: \n 50:     // 消息配置(Topic配置）校验\n 51:     response.setCode(-1);\n 52:     super.msgCheck(ctx, requestHeader, response);\n 53:     if (response.getCode() != -1) {\n 54:         return response;\n 55:     }\n 56: \n 57:     final byte[] body = request.getBody();\n 58: \n 59:     // 如果队列小于0，从可用队列随机选择\n 60:     int queueIdInt = requestHeader.getQueueId();\n 61:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 62:     if (queueIdInt < 0) {\n 63:         queueIdInt = Math.abs(this.random.nextInt() % 99999999) % topicConfig.getWriteQueueNums();\n 64:     }\n 65: \n 66:     //\n 67:     int sysFlag = requestHeader.getSysFlag();\n 68:     if (TopicFilterType.MULTI_TAG == topicConfig.getTopicFilterType()) {\n 69:         sysFlag |= MessageSysFlag.MULTI_TAGS_FLAG;\n 70:     }\n 71: \n 72:     // 对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)\n 73:     String newTopic = requestHeader.getTopic();\n 74:     if (null != newTopic && newTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 75:         // 获取订阅分组配置\n 76:         String groupName = newTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n 77:         SubscriptionGroupConfig subscriptionGroupConfig =\n 78:             this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(groupName);\n 79:         if (null == subscriptionGroupConfig) {\n 80:             response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 81:             response.setRemark(\"subscription group not exist, \" + groupName + \" \" + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));\n 82:             return response;\n 83:         }\n 84:         // 计算最大可消费次数\n 85:         int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 86:         if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 87:             maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 88:         }\n 89:         int reconsumeTimes = requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes();\n 90:         if (reconsumeTimes >= maxReconsumeTimes) { // 超过最大消费次数\n 91:             newTopic = MixAll.getDLQTopic(groupName);\n 92:             queueIdInt = Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;\n 93:             topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, //\n 94:                 DLQ_NUMS_PER_GROUP, //\n 95:                 PermName.PERM_WRITE, 0\n 96:             );\n 97:             if (null == topicConfig) {\n 98:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n 99:                 response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n100:                 return response;\n101:             }\n102:         }\n103:     }\n104: \n105:     // 创建MessageExtBrokerInner\n106:     MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n107:     msgInner.setTopic(newTopic);\n108:     msgInner.setBody(body);\n109:     msgInner.setFlag(requestHeader.getFlag());\n110:     MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));\n111:     msgInner.setPropertiesString(requestHeader.getProperties());\n112:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(topicConfig.getTopicFilterType(), msgInner.getTags()));\n113:     msgInner.setQueueId(queueIdInt);\n114:     msgInner.setSysFlag(sysFlag);\n115:     msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n116:     msgInner.setBornHost(ctx.channel().remoteAddress());\n117:     msgInner.setStoreHost(this.getStoreHost());\n118:     msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n119: \n120:     // 校验是否不允许发送事务消息\n121:     if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n122:         String traFlag = msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n123:         if (traFlag != null) {\n124:             response.setCode(ResponseCode.NO_PERMISSION);\n125:             response.setRemark(\n126:                 \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \"] sending transaction message is forbidden\");\n127:             return response;\n128:         }\n129:     }\n130: \n131:     // 添加消息\n132:     PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);\n133:     if (putMessageResult != null) {\n134:         boolean sendOK = false;\n135: \n136:         switch (putMessageResult.getPutMessageStatus()) {\n137:             // Success\n138:             case PUT_OK:\n139:                 sendOK = true;\n140:                 response.setCode(ResponseCode.SUCCESS);\n141:                 break;\n142:             case FLUSH_DISK_TIMEOUT:\n143:                 response.setCode(ResponseCode.FLUSH_DISK_TIMEOUT);\n144:                 sendOK = true;\n145:                 break;\n146:             case FLUSH_SLAVE_TIMEOUT:\n147:                 response.setCode(ResponseCode.FLUSH_SLAVE_TIMEOUT);\n148:                 sendOK = true;\n149:                 break;\n150:             case SLAVE_NOT_AVAILABLE:\n151:                 response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);\n152:                 sendOK = true;\n153:                 break;\n154: \n155:             // Failed\n156:             case CREATE_MAPEDFILE_FAILED:\n157:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n158:                 response.setRemark(\"create mapped file failed, server is busy or broken.\");\n159:                 break;\n160:             case MESSAGE_ILLEGAL:\n161:             case PROPERTIES_SIZE_EXCEEDED:\n162:                 response.setCode(ResponseCode.MESSAGE_ILLEGAL);\n163:                 response.setRemark(\n164:                     \"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\");\n165:                 break;\n166:             case SERVICE_NOT_AVAILABLE:\n167:                 response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n168:                 response.setRemark(\n169:                     \"service not available now, maybe disk full, \" + diskUtil() + \", maybe your broker machine memory too small.\");\n170:                 break;\n171:             case OS_PAGECACHE_BUSY:\n172:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n173:                 response.setRemark(\"[PC_SYNCHRONIZED]broker busy, start flow control for a while\");\n174:                 break;\n175:             case UNKNOWN_ERROR:\n176:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n177:                 response.setRemark(\"UNKNOWN_ERROR\");\n178:                 break;\n179:             default:\n180:                 response.setCode(ResponseCode.SYSTEM_ERROR);\n181:                 response.setRemark(\"UNKNOWN_ERROR DEFAULT\");\n182:                 break;\n183:         }\n184: \n185:         String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);\n186:         if (sendOK) {\n187:             // 统计\n188:             this.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic());\n189:             this.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());\n190:             this.brokerController.getBrokerStatsManager().incBrokerPutNums();\n191: \n192:             // 响应\n193:             response.setRemark(null);\n194:             responseHeader.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());\n195:             responseHeader.setQueueId(queueIdInt);\n196:             responseHeader.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());\n197:             doResponse(ctx, request, response);\n198: \n199:             // hook：设置发送成功到context\n200:             if (hasSendMessageHook()) {\n201:                 sendMessageContext.setMsgId(responseHeader.getMsgId());\n202:                 sendMessageContext.setQueueId(responseHeader.getQueueId());\n203:                 sendMessageContext.setQueueOffset(responseHeader.getQueueOffset());\n204: \n205:                 int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();\n206:                 int wroteSize = putMessageResult.getAppendMessageResult().getWroteBytes();\n207:                 int incValue = (int) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT) * commercialBaseCount;\n208: \n209:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_SUCCESS);\n210:                 sendMessageContext.setCommercialSendTimes(incValue);\n211:                 sendMessageContext.setCommercialSendSize(wroteSize);\n212:                 sendMessageContext.setCommercialOwner(owner);\n213:             }\n214:             return null;\n215:         } else {\n216:             // hook：设置发送失败到context\n217:             if (hasSendMessageHook()) {\n218:                 int wroteSize = request.getBody().length;\n219:                 int incValue = (int) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT);\n220: \n221:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_FAILURE);\n222:                 sendMessageContext.setCommercialSendTimes(incValue);\n223:                 sendMessageContext.setCommercialSendSize(wroteSize);\n224:                 sendMessageContext.setCommercialOwner(owner);\n225:             }\n226:         }\n227:     } else {\n228:         response.setCode(ResponseCode.SYSTEM_ERROR);\n229:         response.setRemark(\"store putMessage return null\");\n230:     }\n231: \n232:     return response;\n233: }\n```\n* `#processRequest()` 说明 ：处理消息请求。\n* `#sendMessage()` 说明 ：发送消息，并返回发送消息结果。\n* 第 51 至 55 行 ：消息配置(Topic配置）校验，详细解析见：[AbstractSendMessageProcessor#msgCheck()](#abstractsendmessageprocessormsgcheck)。\n* 第 60 至 64 行 ：消息队列编号小于0时，`Broker` 可以设置随机选择一个消息队列。\n* 第 72 至 103 行 ：对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名， 即加  死信队 (Dead Letter Queue)，详细解析见：[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n* 第 105 至 118 行 ：创建`MessageExtBrokerInner`。\n* 第 132 ：存储消息，详细解析见：[DefaultMessageStore#putMessage()](defaultmessagestoreputmessage)。\n* 第 133 至 183 行 ：处理消息发送结果，设置响应结果和提示。\n* 第 186 至 214 行 ：发送成功，响应。这里`doResponse(ctx, request, response)`进行响应，最后`return null`，原因是：响应给 `Producer` 可能发生异常，`#doResponse(ctx, request, response)`捕捉了该异常并输出日志。这样做的话，我们进行排查 `Broker` 接收消息成功后响应是否存在异常会方便很多。\n\n### AbstractSendMessageProcessor#msgCheck\n\n```Java\n  1: protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,\n  2:                                    final SendMessageRequestHeader requestHeader, final RemotingCommand response) {\n  3:     // 检查 broker 是否有写入权限\n  4:     if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())\n  5:         && this.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) {\n  6:         response.setCode(ResponseCode.NO_PERMISSION);\n  7:         response.setRemark(\"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n  8:             + \"] sending message is forbidden\");\n  9:         return response;\n 10:     }\n 11:     // 检查topic是否可以被发送。目前是{@link MixAll.DEFAULT_TOPIC}不被允许发送\n 12:     if (!this.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) {\n 13:         String errorMsg = \"the topic[\" + requestHeader.getTopic() + \"] is conflict with system reserved words.\";\n 14:         log.warn(errorMsg);\n 15:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 16:         response.setRemark(errorMsg);\n 17:         return response;\n 18:     }\n 19:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 20:     if (null == topicConfig) { // 不能存在topicConfig，则进行创建\n 21:         int topicSysFlag = 0;\n 22:         if (requestHeader.isUnitMode()) {\n 23:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 24:                 topicSysFlag = TopicSysFlag.buildSysFlag(false, true);\n 25:             } else {\n 26:                 topicSysFlag = TopicSysFlag.buildSysFlag(true, false);\n 27:             }\n 28:         }\n 29:         // 创建topic配置\n 30:         log.warn(\"the topic {} not exist, producer: {}\", requestHeader.getTopic(), ctx.channel().remoteAddress());\n 31:         topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(//\n 32:             requestHeader.getTopic(), //\n 33:             requestHeader.getDefaultTopic(), //\n 34:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()), //\n 35:             requestHeader.getDefaultTopicQueueNums(), topicSysFlag);\n 36:         if (null == topicConfig) {\n 37:             if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 38:                 topicConfig =\n 39:                     this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(\n 40:                         requestHeader.getTopic(), 1, PermName.PERM_WRITE | PermName.PERM_READ,\n 41:                         topicSysFlag);\n 42:             }\n 43:         }\n 44:         // 如果没配置\n 45:         if (null == topicConfig) {\n 46:             response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n 47:             response.setRemark(\"topic[\" + requestHeader.getTopic() + \"] not exist, apply first please!\"\n 48:                 + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));\n 49:             return response;\n 50:         }\n 51:     }\n 52:     // 队列编号是否正确\n 53:     int queueIdInt = requestHeader.getQueueId();\n 54:     int idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());\n 55:     if (queueIdInt >= idValid) {\n 56:         String errorInfo = String.format(\"request queueId[%d] is illegal, %s Producer: %s\",\n 57:             queueIdInt,\n 58:             topicConfig.toString(),\n 59:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()));\n 60:         log.warn(errorInfo);\n 61:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 62:         response.setRemark(errorInfo);\n 63:         return response;\n 64:     }\n 65:     return response;\n 66: }\n```\n* 说明：校验消息是否正确，主要是Topic配置方面，例如：`Broker` 是否有写入权限，topic配置是否存在，队列编号是否正确。\n* 第 11 至 18 行 ：检查Topic是否可以被发送。目前是 `{@link MixAll.DEFAULT_TOPIC}` 不被允许发送。\n* 第 20 至 51 行 ：当找不到Topic配置，则进行创建。当然，创建会存在不成功的情况，例如说：`defaultTopic` 的Topic配置不存在，又或者是 存在但是不允许继承，详细解析见[《RocketMQ 源码分析 —— Topic》](http://www.yunai.me/RocketMQ/topic/)。\n\n## DefaultMessageStore#putMessage\n\n```Java\n  1: public PutMessageResult putMessage(MessageExtBrokerInner msg) {\n  2:     if (this.shutdown) {\n  3:         log.warn(\"message store has shutdown, so putMessage is forbidden\");\n  4:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n  5:     }\n  6: \n  7:     // 从节点不允许写入\n  8:     if (BrokerRole.SLAVE == this.messageStoreConfig.getBrokerRole()) {\n  9:         long value = this.printTimes.getAndIncrement();\n 10:         if ((value % 50000) == 0) {\n 11:             log.warn(\"message store is slave mode, so putMessage is forbidden \");\n 12:         }\n 13: \n 14:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n 15:     }\n 16: \n 17:     // store是否允许写入\n 18:     if (!this.runningFlags.isWriteable()) {\n 19:         long value = this.printTimes.getAndIncrement();\n 20:         if ((value % 50000) == 0) {\n 21:             log.warn(\"message store is not writeable, so putMessage is forbidden \" + this.runningFlags.getFlagBits());\n 22:         }\n 23: \n 24:         return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);\n 25:     } else {\n 26:         this.printTimes.set(0);\n 27:     }\n 28: \n 29:     // 消息过长\n 30:     if (msg.getTopic().length() > Byte.MAX_VALUE) {\n 31:         log.warn(\"putMessage message topic length too long \" + msg.getTopic().length());\n 32:         return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n 33:     }\n 34: \n 35:     // 消息附加属性过长\n 36:     if (msg.getPropertiesString() != null && msg.getPropertiesString().length() > Short.MAX_VALUE) {\n 37:         log.warn(\"putMessage message properties length too long \" + msg.getPropertiesString().length());\n 38:         return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null);\n 39:     }\n 40: \n 41:     if (this.isOSPageCacheBusy()) {\n 42:         return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, null);\n 43:     }\n 44: \n 45:     long beginTime = this.getSystemClock().now();\n 46:     // 添加消息到commitLog\n 47:     PutMessageResult result = this.commitLog.putMessage(msg);\n 48: \n 49:     long eclipseTime = this.getSystemClock().now() - beginTime;\n 50:     if (eclipseTime > 500) {\n 51:         log.warn(\"putMessage not in lock eclipse time(ms)={}, bodyLength={}\", eclipseTime, msg.getBody().length);\n 52:     }\n 53:     this.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);\n 54: \n 55:     if (null == result || !result.isOk()) {\n 56:         this.storeStatsService.getPutMessageFailedTimes().incrementAndGet();\n 57:     }\n 58: \n 59:     return result;\n 60: }\n```\n* 说明：存储消息封装，最终存储需要 `CommitLog` 实现。\n* 第 7 至 27 行 ：校验 `Broker` 是否可以写入。\n* 第 29 至 39 行 ：消息格式与大小校验。\n* 第 47 行 ：调用 `CommitLong` 进行存储，详细逻辑见：[《RocketMQ 源码分析 —— Message 存储》](http://www.yunai.me/RocketMQ/message-store/)\n\n# 4、某种结尾\n\n感谢阅读、收藏、点赞本文的工程师同学。\n\n阅读源码是件令自己很愉悦的事情，编写源码解析是让自己脑细胞死伤无数的过程，痛并快乐着。\n\n如果有内容写的存在错误，或是不清晰的地方，见笑了，🙂。欢迎加 QQ：7685413 我们一起探讨，共进步。\n\n再次感谢阅读、收藏、点赞本文的工程师同学。\n\n\n\n\n\n\n\n\n\n","slug":"RocketMQ/message-send-and-receive","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzac000oag5dpqvzeged","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">http://www.yunai.me/RocketMQ/message-send-and-receive/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、Producer 发送消息</a><ul>\n<li><a href=\"#\">DefaultMQProducer#send(Message)</a></li>\n<li><a href=\"#\">DefaultMQProducerImpl#sendDefaultImpl()</a><ul>\n<li><a href=\"#\">DefaultMQProducerImpl#tryToFindTopicPublishInfo()</a></li>\n<li><a href=\"#\">MQFaultStrategy</a><ul>\n<li><a href=\"#\">MQFaultStrategy</a></li>\n<li><a href=\"#\">LatencyFaultTolerance</a></li>\n<li><a href=\"#\">LatencyFaultToleranceImpl</a></li>\n<li><a href=\"#\">FaultItem</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMQProducerImpl#sendKernelImpl()</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">3、Broker 接收消息</a><ul>\n<li><a href=\"#\">SendMessageProcessor#sendMessage</a><ul>\n<li><a href=\"#\">AbstractSendMessageProcessor#msgCheck</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMessageStore#putMessage</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4、某种结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><ol>\n<li><code>Producer</code> 发送消息。主要是<strong>同步</strong>发送消息源码，涉及到 异步/Oneway发送消息，事务消息会跳过。</li>\n<li><code>Broker</code> 接收消息。(<em>存储消息在<a href=\"http://www.yunai.me/RocketMQ/message-store/\">《RocketMQ 源码分析 —— Message 存储》</a>解析</em>)</li>\n</ol>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/01.png\" alt=\"Producer发送消息全局顺序图\"></p>\n</blockquote>\n<h1 id=\"2、Producer-发送消息\"><a href=\"#2、Producer-发送消息\" class=\"headerlink\" title=\"2、Producer 发送消息\"></a>2、Producer 发送消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/02.png\" alt=\"Producer发送消息顺序图\"></p>\n</blockquote>\n<h2 id=\"DefaultMQProducer-send-Message\"><a href=\"#DefaultMQProducer-send-Message\" class=\"headerlink\" title=\"DefaultMQProducer#send(Message)\"></a>DefaultMQProducer#send(Message)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultMQProducerImpl.send(msg);</div><div class=\"line\"><span class=\"number\">4</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：发送同步消息，<code>DefaultMQProducer#send(Message)</code> 对 <code>DefaultMQProducerImpl#send(Message)</code> 进行封装。  </li>\n</ul>\n<h2 id=\"DefaultMQProducerImpl-sendDefaultImpl\"><a href=\"#DefaultMQProducerImpl-sendDefaultImpl\" class=\"headerlink\" title=\"DefaultMQProducerImpl#sendDefaultImpl()\"></a>DefaultMQProducerImpl#sendDefaultImpl()</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">return</span> send(msg, <span class=\"keyword\">this</span>.defaultMQProducer.getSendMsgTimeout());</div><div class=\"line\">  <span class=\"number\">3</span>: &#125;</div><div class=\"line\">  <span class=\"number\">4</span>: </div><div class=\"line\">  <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class=\"keyword\">null</span>, timeout);</div><div class=\"line\">  <span class=\"number\">7</span>: &#125;</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendDefaultImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">10</span>:     Message msg, //</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"> <span class=\"number\">14</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"comment\">// 校验 Producer 处于运行状态</span></div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"comment\">// 校验消息格式</span></div><div class=\"line\"> <span class=\"number\">18</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> invokeID = random.nextLong(); <span class=\"comment\">// 调用编号；用于下面打印日志，标记为同一次发送消息</span></div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">long</span> beginTimestampFirst = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"keyword\">long</span> beginTimestampPrev = beginTimestampFirst;</div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"keyword\">long</span> endTimestamp = beginTimestampFirst;</div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"comment\">// 获取 Topic路由信息</span></div><div class=\"line\"> <span class=\"number\">25</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:         MessageQueue mq = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后选择消息要发送到的队列</span></div><div class=\"line\"> <span class=\"number\">28</span>:         Exception exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">29</span>:         SendResult sendResult = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后一次发送结果</span></div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class=\"number\">1</span>; <span class=\"comment\">// 同步多次调用</span></div><div class=\"line\"> <span class=\"number\">31</span>:         <span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; <span class=\"comment\">// 第几次发送</span></div><div class=\"line\"> <span class=\"number\">32</span>:         String[] brokersSent = <span class=\"keyword\">new</span> String[timesTotal]; <span class=\"comment\">// 存储每次发送消息选择的broker名</span></div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"comment\">// 循环调用发送消息，直到成功</span></div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:             String lastBrokerName = <span class=\"keyword\">null</span> == mq ? <span class=\"keyword\">null</span> : mq.getBrokerName();</div><div class=\"line\"> <span class=\"number\">36</span>:             MessageQueue tmpmq = <span class=\"keyword\">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName); <span class=\"comment\">// 选择消息要发送到的队列</span></div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (tmpmq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 mq = tmpmq;</div><div class=\"line\"> <span class=\"number\">39</span>:                 brokersSent[times] = mq.getBrokerName();</div><div class=\"line\"> <span class=\"number\">40</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:                     beginTimestampPrev = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"comment\">// 调用发送消息核心方法</span></div><div class=\"line\"> <span class=\"number\">43</span>:                     sendResult = <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class=\"line\"> <span class=\"number\">44</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">45</span>:                     <span class=\"comment\">// 更新Broker可用性信息</span></div><div class=\"line\"> <span class=\"number\">46</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">47</span>:                     <span class=\"keyword\">switch</span> (communicationMode) &#123;</div><div class=\"line\"> <span class=\"number\">48</span>:                         <span class=\"keyword\">case</span> ASYNC:</div><div class=\"line\"> <span class=\"number\">49</span>:                             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">50</span>:                         <span class=\"keyword\">case</span> ONEWAY:</div><div class=\"line\"> <span class=\"number\">51</span>:                             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">52</span>:                         <span class=\"keyword\">case</span> SYNC:</div><div class=\"line\"> <span class=\"number\">53</span>:                             <span class=\"keyword\">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</div><div class=\"line\"> <span class=\"number\">54</span>:                                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123; <span class=\"comment\">// 同步发送成功但存储有问题时 &amp;&amp; 配置存储异常时重新发送开关 时，进行重试</span></div><div class=\"line\"> <span class=\"number\">55</span>:                                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">57</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:                             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"> <span class=\"number\">59</span>:                         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">60</span>:                             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">62</span>:                 &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，更新继续循环</span></div><div class=\"line\"> <span class=\"number\">63</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">64</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">65</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">66</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">67</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">68</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:                 &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，继续循环</span></div><div class=\"line\"> <span class=\"number\">70</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">71</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">72</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">73</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">74</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">75</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">76</span>:                 &#125; <span class=\"keyword\">catch</span> (MQBrokerException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环</span></div><div class=\"line\"> <span class=\"number\">77</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">78</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">79</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">80</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">81</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">82</span>:                     <span class=\"keyword\">switch</span> (e.getResponseCode()) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:                         <span class=\"comment\">// 如下异常continue，进行发送消息重试</span></div><div class=\"line\"> <span class=\"number\">84</span>:                         <span class=\"keyword\">case</span> ResponseCode.TOPIC_NOT_EXIST:</div><div class=\"line\"> <span class=\"number\">85</span>:                         <span class=\"keyword\">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</div><div class=\"line\"> <span class=\"number\">86</span>:                         <span class=\"keyword\">case</span> ResponseCode.SYSTEM_ERROR:</div><div class=\"line\"> <span class=\"number\">87</span>:                         <span class=\"keyword\">case</span> ResponseCode.NO_PERMISSION:</div><div class=\"line\"> <span class=\"number\">88</span>:                         <span class=\"keyword\">case</span> ResponseCode.NO_BUYER_ID:</div><div class=\"line\"> <span class=\"number\">89</span>:                         <span class=\"keyword\">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</div><div class=\"line\"> <span class=\"number\">90</span>:                             <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 如果有发送结果，进行返回，否则，抛出异常；</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">93</span>:                             <span class=\"keyword\">if</span> (sendResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:                                 <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"> <span class=\"number\">95</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">96</span>:                             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"> <span class=\"number\">97</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:                 &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">100</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">101</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"><span class=\"number\">102</span>:                     log.warn(msg.toString());</div><div class=\"line\"><span class=\"number\">103</span>:                     <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">104</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">105</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">107</span>:             &#125;</div><div class=\"line\"><span class=\"number\">108</span>:         &#125;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"comment\">// 返回发送结果</span></div><div class=\"line\"><span class=\"number\">110</span>:         <span class=\"keyword\">if</span> (sendResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">111</span>:             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"comment\">// 根据不同情况，抛出不同的异常</span></div><div class=\"line\"><span class=\"number\">114</span>:         String info = String.format(<span class=\"string\">\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\"</span>, times, System.currentTimeMillis() - beginTimestampFirst,</div><div class=\"line\"><span class=\"number\">115</span>:                 msg.getTopic(), Arrays.toString(brokersSent)) + FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</div><div class=\"line\"><span class=\"number\">116</span>:         MQClientException mqClientException = <span class=\"keyword\">new</span> MQClientException(info, exception);</div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> MQBrokerException) &#123;</div><div class=\"line\"><span class=\"number\">118</span>:             mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</div><div class=\"line\"><span class=\"number\">119</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> RemotingConnectException) &#123;</div><div class=\"line\"><span class=\"number\">120</span>:             mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</div><div class=\"line\"><span class=\"number\">121</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> RemotingTimeoutException) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:             mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</div><div class=\"line\"><span class=\"number\">123</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> MQClientException) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</div><div class=\"line\"><span class=\"number\">125</span>:         &#125;</div><div class=\"line\"><span class=\"number\">126</span>:         <span class=\"keyword\">throw</span> mqClientException;</div><div class=\"line\"><span class=\"number\">127</span>:     &#125;</div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// Namesrv找不到异常</span></div><div class=\"line\"><span class=\"number\">129</span>:     List&lt;String&gt; nsList = <span class=\"keyword\">this</span>.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</div><div class=\"line\"><span class=\"number\">130</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == nsList || nsList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(</div><div class=\"line\"><span class=\"number\">132</span>:             <span class=\"string\">\"No name server address, please set it.\"</span> + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), <span class=\"keyword\">null</span>).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</div><div class=\"line\"><span class=\"number\">133</span>:     &#125;</div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"comment\">// 消息路由找不到异常</span></div><div class=\"line\"><span class=\"number\">135</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"No route info of this topic, \"</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</div><div class=\"line\"><span class=\"number\">137</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发送消息。步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。</li>\n<li>第 1  至 7 行：对<code>sendsendDefaultImpl(...)</code>进行封装。</li>\n<li>第 20 行 ：<code>invokeID</code>仅仅用于打印日志，无实际的业务用途。</li>\n<li>第 25 行 ：获取 Topic路由信息， 详细解析见：<a href=\"#defaultmqproducerimpltrytofindtopicpublishinfo\">DefaultMQProducerImpl#tryToFindTopicPublishInfo()</a></li>\n<li>第 30 &amp; 34 行 ：计算调用发送消息到成功为止的最大次数，并进行循环。同步或异步发送消息会调用多次，默认配置为3次。</li>\n<li>第 36 行 ：选择消息要发送到的队列，详细解析见：<a href=\"#mqfaultstrategy\">MQFaultStrategy</a></li>\n<li>第 43 行 ：调用发送消息核心方法，详细解析见：<a href=\"#defaultmqproducerimplsendkernelimpl\">DefaultMQProducerImpl#sendKernelImpl()</a></li>\n<li>第 46 行 ：更新<code>Broker</code>可用性信息。在选择发送到的消息队列时，会参考<code>Broker</code>发送消息的延迟，详细解析见：<a href=\"#mqfaultstrategy\">MQFaultStrategy</a></li>\n<li>第 62 至 68 行：当抛出<code>RemotingException</code>时，如果进行消息发送失败重试，则<strong>可能导致消息发送重复</strong>。例如，发送消息超时(<code>RemotingTimeoutException</code>)，实际<code>Broker</code>接收到该消息并处理成功。因此，<code>Consumer</code>在消费时，需要保证幂等性。</li>\n</ul>\n<h3 id=\"DefaultMQProducerImpl-tryToFindTopicPublishInfo\"><a href=\"#DefaultMQProducerImpl-tryToFindTopicPublishInfo\" class=\"headerlink\" title=\"DefaultMQProducerImpl#tryToFindTopicPublishInfo()\"></a>DefaultMQProducerImpl#tryToFindTopicPublishInfo()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> TopicPublishInfo <span class=\"title\">tryToFindTopicPublishInfo</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 缓存中获取 Topic发布信息</span></div><div class=\"line\"> <span class=\"number\">3</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// 当无可用的 Topic发布信息时，从Namesrv获取一次</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class=\"keyword\">new</span> TopicPublishInfo());</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</div><div class=\"line\"> <span class=\"number\">8</span>:         topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"comment\">// 若获取的 Topic发布信息时候可用，则返回</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">return</span> topicPublishInfo;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 使用 &#123;@link DefaultMQProducer#createTopicKey&#125; 对应的 Topic发布信息。用于 Topic发布信息不存在 &amp;&amp; Broker支持自动创建Topic</span></div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class=\"keyword\">true</span>, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"><span class=\"number\">15</span>:         topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">return</span> topicPublishInfo;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获得 Topic发布信息。优先从缓存<code>topicPublishInfoTable</code>，其次从<code>Namesrv</code>中获得。</li>\n<li>第 3 行 ：从缓存<code>topicPublishInfoTable</code>中获得 Topic发布信息。</li>\n<li>第 5 至 9 行 ：从 <code>Namesrv</code> 中获得 Topic发布信息。</li>\n<li>第 13 至 17 行 ：当从 <code>Namesrv</code> 无法获取时，使用 <code>{@link DefaultMQProducer#createTopicKey}</code> 对应的 Topic发布信息。目的是当 <code>Broker</code> 开启自动创建 Topic开关时，<code>Broker</code> 接收到消息后自动创建Topic，详细解析见<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n</ul>\n<h3 id=\"MQFaultStrategy\"><a href=\"#MQFaultStrategy\" class=\"headerlink\" title=\"MQFaultStrategy\"></a>MQFaultStrategy</h3><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/03.png\" alt=\"Latency类图\"></p>\n</blockquote>\n<h4 id=\"MQFaultStrategy-1\"><a href=\"#MQFaultStrategy-1\" class=\"headerlink\" title=\"MQFaultStrategy\"></a>MQFaultStrategy</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MQFaultStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 5:      * 延迟故障容错，维护每个Broker的发送消息的延迟</div><div class=\"line\"> 6:      * key：brokerName</div><div class=\"line\"> 7:      */</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class=\"keyword\">new</span> LatencyFaultToleranceImpl();</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">10:      * 发送消息延迟容错开关</div><div class=\"line\">11:      */</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> sendLatencyFaultEnable = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">14:      * 延迟级别数组</div><div class=\"line\">15:      */</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] latencyMax = &#123;<span class=\"number\">50L</span>, <span class=\"number\">100L</span>, <span class=\"number\">550L</span>, <span class=\"number\">1000L</span>, <span class=\"number\">2000L</span>, <span class=\"number\">3000L</span>, <span class=\"number\">15000L</span>&#125;;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">18:      * 不可用时长数组</div><div class=\"line\">19:      */</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] notAvailableDuration = &#123;<span class=\"number\">0L</span>, <span class=\"number\">0L</span>, <span class=\"number\">30000L</span>, <span class=\"number\">60000L</span>, <span class=\"number\">120000L</span>, <span class=\"number\">180000L</span>, <span class=\"number\">600000L</span>&#125;;</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">23:      * 根据 Topic发布信息 选择一个消息队列</div><div class=\"line\">24:      *</div><div class=\"line\">25:      * <span class=\"doctag\">@param</span> tpInfo Topic发布信息</div><div class=\"line\">26:      * <span class=\"doctag\">@param</span> lastBrokerName brokerName</div><div class=\"line\">27:      * <span class=\"doctag\">@return</span> 消息队列</div><div class=\"line\">28:      */</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">selectOneMessageQueue</span><span class=\"params\">(<span class=\"keyword\">final</span> TopicPublishInfo tpInfo, <span class=\"keyword\">final</span> String lastBrokerName)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sendLatencyFaultEnable) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"comment\">// 获取 brokerName=lastBrokerName &amp;&amp; 可用的一个消息队列</span></div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">37</span>:                         pos = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">38</span>:                     MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class=\"line\"><span class=\"number\">39</span>:                     <span class=\"keyword\">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</div><div class=\"line\"><span class=\"number\">41</span>:                             <span class=\"keyword\">return</span> mq;</div><div class=\"line\"><span class=\"number\">42</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"comment\">// 选择一个相对好的broker，并获得其对应的一个消息队列，不考虑该队列的可用性</span></div><div class=\"line\"><span class=\"number\">45</span>:                 <span class=\"keyword\">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">if</span> (writeQueueNums &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                     <span class=\"keyword\">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</div><div class=\"line\"><span class=\"number\">49</span>:                     <span class=\"keyword\">if</span> (notBestBroker != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:                         mq.setBrokerName(notBestBroker);</div><div class=\"line\"><span class=\"number\">51</span>:                         mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</div><div class=\"line\"><span class=\"number\">52</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">53</span>:                     <span class=\"keyword\">return</span> mq;</div><div class=\"line\"><span class=\"number\">54</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                     latencyFaultTolerance.remove(notBestBroker);</div><div class=\"line\"><span class=\"number\">56</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">57</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:                 log.error(<span class=\"string\">\"Error occurred when selecting message queue\"</span>, e);</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"comment\">// 选择一个消息队列，不考虑队列的可用性</span></div><div class=\"line\"><span class=\"number\">61</span>:             <span class=\"keyword\">return</span> tpInfo.selectOneMessageQueue();</div><div class=\"line\"><span class=\"number\">62</span>:         &#125;</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"comment\">// 获得 lastBrokerName 对应的一个消息队列，不考虑该队列的可用性</span></div><div class=\"line\"><span class=\"number\">64</span>:         <span class=\"keyword\">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</div><div class=\"line\"><span class=\"number\">65</span>:     &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">68:      * 更新延迟容错信息</div><div class=\"line\">69:      *</div><div class=\"line\">70:      * <span class=\"doctag\">@param</span> brokerName brokerName</div><div class=\"line\">71:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\">72:      * <span class=\"doctag\">@param</span> isolation 是否隔离。当开启隔离时，默认延迟为30000。目前主要用于发送消息异常时</div><div class=\"line\">73:      */</div><div class=\"line\"><span class=\"number\">74</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String brokerName, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">boolean</span> isolation)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sendLatencyFaultEnable) &#123;</div><div class=\"line\"><span class=\"number\">76</span>:             <span class=\"keyword\">long</span> duration = computeNotAvailableDuration(isolation ? <span class=\"number\">30000</span> : currentLatency);</div><div class=\"line\"><span class=\"number\">77</span>:             <span class=\"keyword\">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</div><div class=\"line\"><span class=\"number\">78</span>:         &#125;</div><div class=\"line\"><span class=\"number\">79</span>:     &#125;</div><div class=\"line\"><span class=\"number\">80</span>: </div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">82:      * 计算延迟对应的不可用时间</div><div class=\"line\">83:      *</div><div class=\"line\">84:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\">85:      * <span class=\"doctag\">@return</span> 不可用时间</div><div class=\"line\">86:      */</div><div class=\"line\"><span class=\"number\">87</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeNotAvailableDuration</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">88</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = latencyMax.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\"><span class=\"number\">89</span>:             <span class=\"keyword\">if</span> (currentLatency &gt;= latencyMax[i])</div><div class=\"line\"><span class=\"number\">90</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.notAvailableDuration[i];</div><div class=\"line\"><span class=\"number\">91</span>:         &#125;</div><div class=\"line\"><span class=\"number\">92</span>:         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">93</span>:     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<code>Producer</code>消息发送容错策略。默认情况下容错策略关闭，即<code>sendLatencyFaultEnable=false</code>。</li>\n<li>第 30 至 62 行 ：容错策略选择消息队列逻辑。优先获取可用队列，其次选择一个broker获取队列，最差返回任意broker的一个队列。</li>\n<li>第 64 行 ：未开启容错策略选择消息队列逻辑。</li>\n<li><p>第 74 至 79 行 ：更新延迟容错信息。当 <code>Producer</code> 发送消息时间过长，则逻辑认为N秒内不可用。按照<code>latencyMax</code>，<code>notAvailableDuration</code>的配置，对应如下：</p>\n<p>  | Producer发送消息消耗时长 | Broker不可用时长 |<br>  | — | — |<br>  | &gt;= 15000 ms | 600 <em> 1000 ms  |<br>  | &gt;= 3000 ms | 180 </em> 1000 ms  |<br>  | &gt;= 2000 ms | 120 <em> 1000 ms  |<br>  | &gt;= 1000 ms | 60 </em> 1000 ms  |<br>  | &gt;= 550 ms | 30 * 1000 ms |<br>  | &gt;= 100 ms | 0 ms |<br>  | &gt;= 50 ms | 0 ms |</p>\n</li>\n</ul>\n<h4 id=\"LatencyFaultTolerance\"><a href=\"#LatencyFaultTolerance\" class=\"headerlink\" title=\"LatencyFaultTolerance\"></a>LatencyFaultTolerance</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LatencyFaultTolerance</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 更新对应的延迟和不可用时长</div><div class=\"line\"> 5:      *</div><div class=\"line\"> 6:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\"> 7:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\"> 8:      * <span class=\"doctag\">@param</span> notAvailableDuration 不可用时长</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> T name, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> notAvailableDuration)</span></span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">13:      * 对象是否可用</div><div class=\"line\">14:      *</div><div class=\"line\">15:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\">16:      * <span class=\"doctag\">@return</span> 是否可用</div><div class=\"line\">17:      */</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">21:      * 移除对象</div><div class=\"line\">22:      *</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\">24:      */</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">28:      * 获取一个对象</div><div class=\"line\">29:      *</div><div class=\"line\">30:      * <span class=\"doctag\">@return</span> 对象</div><div class=\"line\">31:      */</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"function\">T <span class=\"title\">pickOneAtLeast</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"number\">33</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：延迟故障容错接口</li>\n</ul>\n<h4 id=\"LatencyFaultToleranceImpl\"><a href=\"#LatencyFaultToleranceImpl\" class=\"headerlink\" title=\"LatencyFaultToleranceImpl\"></a>LatencyFaultToleranceImpl</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LatencyFaultToleranceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">LatencyFaultTolerance</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 对象故障信息Table</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">16</span>);</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 8:      * 对象选择Index</div><div class=\"line\"> 9:      * <span class=\"doctag\">@see</span> #pickOneAtLeast()</div><div class=\"line\">10:      */</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadLocalIndex whichItemWorst = <span class=\"keyword\">new</span> ThreadLocalIndex();</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String name, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> notAvailableDuration)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">15</span>:         FaultItem old = <span class=\"keyword\">this</span>.faultItemTable.get(name);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == old) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"comment\">// 创建对象</span></div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">final</span> FaultItem faultItem = <span class=\"keyword\">new</span> FaultItem(name);</div><div class=\"line\"><span class=\"number\">19</span>:             faultItem.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">20</span>:             faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 更新对象</span></div><div class=\"line\"><span class=\"number\">22</span>:             old = <span class=\"keyword\">this</span>.faultItemTable.putIfAbsent(name, faultItem);</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 old.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">25</span>:                 old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">26</span>:             &#125;</div><div class=\"line\"><span class=\"number\">27</span>:         &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 更新对象</span></div><div class=\"line\"><span class=\"number\">28</span>:             old.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">29</span>:             old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">30</span>:         &#125;</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">final</span> FaultItem faultItem = <span class=\"keyword\">this</span>.faultItemTable.get(name);</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (faultItem != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">return</span> faultItem.isAvailable();</div><div class=\"line\"><span class=\"number\">38</span>:         &#125;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">this</span>.faultItemTable.remove(name);</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">48:      * 选择一个相对优秀的对象</div><div class=\"line\">49:      *</div><div class=\"line\">50:      * <span class=\"doctag\">@return</span> 对象</div><div class=\"line\">51:      */</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pickOneAtLeast</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"comment\">// 创建数组</span></div><div class=\"line\"><span class=\"number\">55</span>:         <span class=\"keyword\">final</span> Enumeration&lt;FaultItem&gt; elements = <span class=\"keyword\">this</span>.faultItemTable.elements();</div><div class=\"line\"><span class=\"number\">56</span>:         List&lt;FaultItem&gt; tmpList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">while</span> (elements.hasMoreElements()) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:             <span class=\"keyword\">final</span> FaultItem faultItem = elements.nextElement();</div><div class=\"line\"><span class=\"number\">59</span>:             tmpList.add(faultItem);</div><div class=\"line\"><span class=\"number\">60</span>:         &#125;</div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">if</span> (!tmpList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:             <span class=\"comment\">// 打乱 + 排序。TODO 疑问：应该只能二选一。猜测Collections.shuffle(tmpList)去掉。</span></div><div class=\"line\"><span class=\"number\">64</span>:             Collections.shuffle(tmpList);</div><div class=\"line\"><span class=\"number\">65</span>:             Collections.sort(tmpList);</div><div class=\"line\"><span class=\"number\">66</span>:             <span class=\"comment\">// 选择顺序在前一半的对象</span></div><div class=\"line\"><span class=\"number\">67</span>:             <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> half = tmpList.size() / <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">if</span> (half &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">69</span>:                 <span class=\"keyword\">return</span> tmpList.get(<span class=\"number\">0</span>).getName();</div><div class=\"line\"><span class=\"number\">70</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">71</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i = <span class=\"keyword\">this</span>.whichItemWorst.getAndIncrement() % half;</div><div class=\"line\"><span class=\"number\">72</span>:                 <span class=\"keyword\">return</span> tmpList.get(i).getName();</div><div class=\"line\"><span class=\"number\">73</span>:             &#125;</div><div class=\"line\"><span class=\"number\">74</span>:         &#125;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">76</span>:     &#125;</div><div class=\"line\"><span class=\"number\">77</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：延迟故障容错实现。维护每个对象的信息。</li>\n</ul>\n<h4 id=\"FaultItem\"><a href=\"#FaultItem\" class=\"headerlink\" title=\"FaultItem\"></a>FaultItem</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FaultItem</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">FaultItem</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 对象名</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 7:      * 延迟</div><div class=\"line\"> 8:      */</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> currentLatency;</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">11:      * 开始可用时间</div><div class=\"line\">12:      */</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> startTimestamp;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">20:      * 比较对象</div><div class=\"line\">21:      * 可用性 &gt; 延迟 &gt; 开始可用时间</div><div class=\"line\">22:      *</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> other other</div><div class=\"line\">24:      * <span class=\"doctag\">@return</span> 升序</div><div class=\"line\">25:      */</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">final</span> FaultItem other)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAvailable() != other.isAvailable()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAvailable())</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (other.isAvailable())</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentLatency &lt; other.currentLatency)</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentLatency &gt; other.currentLatency) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.startTimestamp &lt; other.startTimestamp)</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.startTimestamp &gt; other.startTimestamp) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125;</div><div class=\"line\"><span class=\"number\">47</span>: </div><div class=\"line\"><span class=\"number\">48</span>:         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">49</span>:     &#125;</div><div class=\"line\"><span class=\"number\">50</span>: </div><div class=\"line\"><span class=\"number\">51</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">52:      * 是否可用：当开始可用时间大于当前时间</div><div class=\"line\">53:      *</div><div class=\"line\">54:      * <span class=\"doctag\">@return</span> 是否可用</div><div class=\"line\">55:      */</div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">return</span> (System.currentTimeMillis() - startTimestamp) &gt;= <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">int</span> result = getName() != <span class=\"keyword\">null</span> ? getName().hashCode() : <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">63</span>:         result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (getCurrentLatency() ^ (getCurrentLatency() &gt;&gt;&gt; <span class=\"number\">32</span>));</div><div class=\"line\"><span class=\"number\">64</span>:         result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (getStartTimestamp() ^ (getStartTimestamp() &gt;&gt;&gt; <span class=\"number\">32</span>));</div><div class=\"line\"><span class=\"number\">65</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">66</span>:     &#125;</div><div class=\"line\"><span class=\"number\">67</span>: </div><div class=\"line\"><span class=\"number\">68</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(<span class=\"keyword\">final</span> Object o)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o)</div><div class=\"line\"><span class=\"number\">71</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">72</span>:         <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> FaultItem))</div><div class=\"line\"><span class=\"number\">73</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">74</span>: </div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">final</span> FaultItem faultItem = (FaultItem) o;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:         <span class=\"keyword\">if</span> (getCurrentLatency() != faultItem.getCurrentLatency())</div><div class=\"line\"><span class=\"number\">78</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">79</span>:         <span class=\"keyword\">if</span> (getStartTimestamp() != faultItem.getStartTimestamp())</div><div class=\"line\"><span class=\"number\">80</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">81</span>:         <span class=\"keyword\">return</span> getName() != <span class=\"keyword\">null</span> ? getName().equals(faultItem.getName()) : faultItem.getName() == <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">82</span>: </div><div class=\"line\"><span class=\"number\">83</span>:     &#125;</div><div class=\"line\"><span class=\"number\">84</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：对象故障信息。维护对象的名字、延迟、开始可用的时间。</li>\n</ul>\n<h3 id=\"DefaultMQProducerImpl-sendKernelImpl\"><a href=\"#DefaultMQProducerImpl-sendKernelImpl\" class=\"headerlink\" title=\"DefaultMQProducerImpl#sendKernelImpl()\"></a>DefaultMQProducerImpl#sendKernelImpl()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendKernelImpl</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg, //</span></span></div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> MessageQueue mq, //</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> TopicPublishInfo topicPublishInfo, //</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">// 获取 broker地址</span></div><div class=\"line\">  <span class=\"number\">8</span>:     String brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == brokerAddr) &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:         tryToFindTopicPublishInfo(mq.getTopic());</div><div class=\"line\"> <span class=\"number\">11</span>:         brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\"> <span class=\"number\">12</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">14</span>:     SendMessageContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (brokerAddr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"comment\">// 是否使用broker vip通道。broker会开启两个端口对外服务。</span></div><div class=\"line\"> <span class=\"number\">17</span>:         brokerAddr = MixAll.brokerVIPChannel(<span class=\"keyword\">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">byte</span>[] prevBody = msg.getBody(); <span class=\"comment\">// 记录消息内容。下面逻辑可能改变消息内容，例如消息压缩。</span></div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"comment\">// 设置唯一编号</span></div><div class=\"line\"> <span class=\"number\">21</span>:             MessageClientIDSetter.setUniqID(msg);</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"comment\">// 消息压缩</span></div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"keyword\">int</span> sysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tryToCompressMessage(msg)) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                 sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</div><div class=\"line\"> <span class=\"number\">26</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"comment\">// 事务</span></div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"> <span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (tranMsg != <span class=\"keyword\">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                 sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</div><div class=\"line\"> <span class=\"number\">31</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">32</span>:             <span class=\"comment\">// hook：发送消息校验</span></div><div class=\"line\"> <span class=\"number\">33</span>:             <span class=\"keyword\">if</span> (hasCheckForbiddenHook()) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 CheckForbiddenContext checkForbiddenContext = <span class=\"keyword\">new</span> CheckForbiddenContext();</div><div class=\"line\"> <span class=\"number\">35</span>:                 checkForbiddenContext.setNameSrvAddr(<span class=\"keyword\">this</span>.defaultMQProducer.getNamesrvAddr());</div><div class=\"line\"> <span class=\"number\">36</span>:                 checkForbiddenContext.setGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">37</span>:                 checkForbiddenContext.setCommunicationMode(communicationMode);</div><div class=\"line\"> <span class=\"number\">38</span>:                 checkForbiddenContext.setBrokerAddr(brokerAddr);</div><div class=\"line\"> <span class=\"number\">39</span>:                 checkForbiddenContext.setMessage(msg);</div><div class=\"line\"> <span class=\"number\">40</span>:                 checkForbiddenContext.setMq(mq);</div><div class=\"line\"> <span class=\"number\">41</span>:                 checkForbiddenContext.setUnitMode(<span class=\"keyword\">this</span>.isUnitMode());</div><div class=\"line\"> <span class=\"number\">42</span>:                 <span class=\"keyword\">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</div><div class=\"line\"> <span class=\"number\">43</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">44</span>:             <span class=\"comment\">// hook：发送消息前逻辑</span></div><div class=\"line\"> <span class=\"number\">45</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"> <span class=\"number\">46</span>:                 context = <span class=\"keyword\">new</span> SendMessageContext();</div><div class=\"line\"> <span class=\"number\">47</span>:                 context.setProducer(<span class=\"keyword\">this</span>);</div><div class=\"line\"> <span class=\"number\">48</span>:                 context.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">49</span>:                 context.setCommunicationMode(communicationMode);</div><div class=\"line\"> <span class=\"number\">50</span>:                 context.setBornHost(<span class=\"keyword\">this</span>.defaultMQProducer.getClientIP());</div><div class=\"line\"> <span class=\"number\">51</span>:                 context.setBrokerAddr(brokerAddr);</div><div class=\"line\"> <span class=\"number\">52</span>:                 context.setMessage(msg);</div><div class=\"line\"> <span class=\"number\">53</span>:                 context.setMq(mq);</div><div class=\"line\"> <span class=\"number\">54</span>:                 String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">if</span> (isTrans != <span class=\"keyword\">null</span> &amp;&amp; isTrans.equals(<span class=\"string\">\"true\"</span>)) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     context.setMsgType(MessageType.Trans_Msg_Half);</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:                 <span class=\"keyword\">if</span> (msg.getProperty(<span class=\"string\">\"__STARTDELIVERTIME\"</span>) != <span class=\"keyword\">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                     context.setMsgType(MessageType.Delay_Msg);</div><div class=\"line\"> <span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">61</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookBefore(context);</div><div class=\"line\"> <span class=\"number\">62</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"comment\">// 构建发送消息请求</span></div><div class=\"line\"> <span class=\"number\">64</span>:             SendMessageRequestHeader requestHeader = <span class=\"keyword\">new</span> SendMessageRequestHeader();</div><div class=\"line\"> <span class=\"number\">65</span>:             requestHeader.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">66</span>:             requestHeader.setTopic(msg.getTopic());</div><div class=\"line\"> <span class=\"number\">67</span>:             requestHeader.setDefaultTopic(<span class=\"keyword\">this</span>.defaultMQProducer.getCreateTopicKey());</div><div class=\"line\"> <span class=\"number\">68</span>:             requestHeader.setDefaultTopicQueueNums(<span class=\"keyword\">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</div><div class=\"line\"> <span class=\"number\">69</span>:             requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\"> <span class=\"number\">70</span>:             requestHeader.setSysFlag(sysFlag);</div><div class=\"line\"> <span class=\"number\">71</span>:             requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class=\"line\"> <span class=\"number\">72</span>:             requestHeader.setFlag(msg.getFlag());</div><div class=\"line\"> <span class=\"number\">73</span>:             requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"> <span class=\"number\">74</span>:             requestHeader.setReconsumeTimes(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">75</span>:             requestHeader.setUnitMode(<span class=\"keyword\">this</span>.isUnitMode());</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123; <span class=\"comment\">// 消息重发Topic</span></div><div class=\"line\"> <span class=\"number\">77</span>:                 String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class=\"line\"> <span class=\"number\">78</span>:                 <span class=\"keyword\">if</span> (reconsumeTimes != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:                     requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class=\"line\"> <span class=\"number\">80</span>:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class=\"line\"> <span class=\"number\">81</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:                 String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class=\"line\"> <span class=\"number\">83</span>:                 <span class=\"keyword\">if</span> (maxReconsumeTimes != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:                     requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class=\"line\"> <span class=\"number\">85</span>:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class=\"line\"> <span class=\"number\">86</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">87</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">88</span>:             <span class=\"comment\">// 发送消息</span></div><div class=\"line\"> <span class=\"number\">89</span>:             SendResult sendResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:             <span class=\"keyword\">switch</span> (communicationMode) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:                 <span class=\"keyword\">case</span> ASYNC:</div><div class=\"line\"> <span class=\"number\">92</span>:                     sendResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">93</span>:                         brokerAddr, <span class=\"comment\">// 1</span></div><div class=\"line\"> <span class=\"number\">94</span>:                         mq.getBrokerName(), <span class=\"comment\">// 2</span></div><div class=\"line\"> <span class=\"number\">95</span>:                         msg, <span class=\"comment\">// 3</span></div><div class=\"line\"> <span class=\"number\">96</span>:                         requestHeader, <span class=\"comment\">// 4</span></div><div class=\"line\"> <span class=\"number\">97</span>:                         timeout, <span class=\"comment\">// 5</span></div><div class=\"line\"> <span class=\"number\">98</span>:                         communicationMode, <span class=\"comment\">// 6</span></div><div class=\"line\"> <span class=\"number\">99</span>:                         sendCallback, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">100</span>:                         topicPublishInfo, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">101</span>:                         <span class=\"keyword\">this</span>.mQClientFactory, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">102</span>:                         <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">103</span>:                         context, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">104</span>:                         <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">105</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">case</span> ONEWAY:</div><div class=\"line\"><span class=\"number\">107</span>:                 <span class=\"keyword\">case</span> SYNC:</div><div class=\"line\"><span class=\"number\">108</span>:                     sendResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class=\"line\"><span class=\"number\">109</span>:                         brokerAddr,</div><div class=\"line\"><span class=\"number\">110</span>:                         mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">111</span>:                         msg,</div><div class=\"line\"><span class=\"number\">112</span>:                         requestHeader,</div><div class=\"line\"><span class=\"number\">113</span>:                         timeout,</div><div class=\"line\"><span class=\"number\">114</span>:                         communicationMode,</div><div class=\"line\"><span class=\"number\">115</span>:                         context,</div><div class=\"line\"><span class=\"number\">116</span>:                         <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">117</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">118</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">119</span>:                     <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">120</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">121</span>:             &#125;</div><div class=\"line\"><span class=\"number\">122</span>:             <span class=\"comment\">// hook：发送消息后逻辑</span></div><div class=\"line\"><span class=\"number\">123</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:                 context.setSendResult(sendResult);</div><div class=\"line\"><span class=\"number\">125</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">126</span>:             &#125;</div><div class=\"line\"><span class=\"number\">127</span>:             <span class=\"comment\">// 返回发送结果</span></div><div class=\"line\"><span class=\"number\">128</span>:             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">132</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">133</span>:             &#125;</div><div class=\"line\"><span class=\"number\">134</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">135</span>:         &#125; <span class=\"keyword\">catch</span> (MQBrokerException e) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">137</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">139</span>:             &#125;</div><div class=\"line\"><span class=\"number\">140</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">141</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">144</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">145</span>:             &#125;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">147</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:             msg.setBody(prevBody);</div><div class=\"line\"><span class=\"number\">149</span>:         &#125;</div><div class=\"line\"><span class=\"number\">150</span>:     &#125;</div><div class=\"line\"><span class=\"number\">151</span>:     <span class=\"comment\">// broker为空抛出异常</span></div><div class=\"line\"><span class=\"number\">152</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">153</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发送消息核心方法。该方法真正发起网络请求，发送消息给 <code>Broker</code>。</li>\n<li>第 21 行 ：生产消息编号，详细解析见<a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message 基础》</a>。</li>\n<li>第 64 至 121 行 ：构建发送消息请求<code>SendMessageRequestHeader</code>。</li>\n<li>第 107 至 117 行 ：执行 <code>MQClientInstance#sendMessage(...)</code> 发起网络请求。</li>\n</ul>\n<h1 id=\"3、Broker-接收消息\"><a href=\"#3、Broker-接收消息\" class=\"headerlink\" title=\"3、Broker 接收消息\"></a>3、Broker 接收消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/04.png\" alt=\"接收发送消息API顺序图\"></p>\n</blockquote>\n<h2 id=\"SendMessageProcessor-sendMessage\"><a href=\"#SendMessageProcessor-sendMessage\" class=\"headerlink\" title=\"SendMessageProcessor#sendMessage\"></a>SendMessageProcessor#sendMessage</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     SendMessageContext mqtraceContext;</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">switch</span> (request.getCode()) &#123;</div><div class=\"line\">  <span class=\"number\">5</span>:         <span class=\"keyword\">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</div><div class=\"line\">  <span class=\"number\">6</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.consumerSendMsgBack(ctx, request);</div><div class=\"line\">  <span class=\"number\">7</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"comment\">// 解析请求</span></div><div class=\"line\">  <span class=\"number\">9</span>:             SendMessageRequestHeader requestHeader = parseRequestHeader(request);</div><div class=\"line\"> <span class=\"number\">10</span>:             <span class=\"keyword\">if</span> (requestHeader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">12</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">13</span>:             <span class=\"comment\">// 发送请求Context。在 hook 场景下使用</span></div><div class=\"line\"> <span class=\"number\">14</span>:             mqtraceContext = buildMsgContext(ctx, requestHeader);</div><div class=\"line\"> <span class=\"number\">15</span>:             <span class=\"comment\">// hook：处理发送消息前逻辑</span></div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"keyword\">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"comment\">// 处理发送消息逻辑</span></div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">final</span> RemotingCommand response = <span class=\"keyword\">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"comment\">// hook：处理发送消息后逻辑</span></div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">22</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">23</span>: &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, //</span></span></div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"keyword\">final</span> RemotingCommand request, //</div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"keyword\">final</span> SendMessageContext sendMessageContext, //</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">final</span> SendMessageRequestHeader requestHeader) <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"comment\">// 初始化响应</span></div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"keyword\">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader) response.readCustomHeader();</div><div class=\"line\"> <span class=\"number\">33</span>:     response.setOpaque(request.getOpaque());</div><div class=\"line\"> <span class=\"number\">34</span>:     response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getRegionId());</div><div class=\"line\"> <span class=\"number\">35</span>:     response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isTraceOn()));</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:         log.debug(<span class=\"string\">\"receive SendMessage request command, &#123;&#125;\"</span>, request);</div><div class=\"line\"> <span class=\"number\">39</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:     <span class=\"comment\">// 如果未开始接收消息，抛出系统异常</span></div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"SpellCheckingInspection\"</span>)</div><div class=\"line\"> <span class=\"number\">43</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startTimstamp = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</div><div class=\"line\"> <span class=\"number\">44</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</div><div class=\"line\"> <span class=\"number\">45</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">46</span>:         response.setRemark(String.format(<span class=\"string\">\"broker unable to service, until %s\"</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">48</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"comment\">// 消息配置(Topic配置）校验</span></div><div class=\"line\"> <span class=\"number\">51</span>:     response.setCode(-<span class=\"number\">1</span>);</div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"keyword\">super</span>.msgCheck(ctx, requestHeader, response);</div><div class=\"line\"> <span class=\"number\">53</span>:     <span class=\"keyword\">if</span> (response.getCode() != -<span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">54</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">55</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">56</span>: </div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] body = request.getBody();</div><div class=\"line\"> <span class=\"number\">58</span>: </div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"comment\">// 如果队列小于0，从可用队列随机选择</span></div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"keyword\">int</span> queueIdInt = requestHeader.getQueueId();</div><div class=\"line\"> <span class=\"number\">61</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">62</span>:     <span class=\"keyword\">if</span> (queueIdInt &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:         queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % topicConfig.getWriteQueueNums();</div><div class=\"line\"> <span class=\"number\">64</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">67</span>:     <span class=\"keyword\">int</span> sysFlag = requestHeader.getSysFlag();</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">if</span> (TopicFilterType.MULTI_TAG == topicConfig.getTopicFilterType()) &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:         sysFlag |= MessageSysFlag.MULTI_TAGS_FLAG;</div><div class=\"line\"> <span class=\"number\">70</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"comment\">// 对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)</span></div><div class=\"line\"> <span class=\"number\">73</span>:     String newTopic = requestHeader.getTopic();</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != newTopic &amp;&amp; newTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"comment\">// 获取订阅分组配置</span></div><div class=\"line\"> <span class=\"number\">76</span>:         String groupName = newTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());</div><div class=\"line\"> <span class=\"number\">77</span>:         SubscriptionGroupConfig subscriptionGroupConfig =</div><div class=\"line\"> <span class=\"number\">78</span>:             <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(groupName);</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">81</span>:             response.setRemark(<span class=\"string\">\"subscription group not exist, \"</span> + groupName + <span class=\"string\">\" \"</span> + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</div><div class=\"line\"> <span class=\"number\">82</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"comment\">// 计算最大可消费次数</span></div><div class=\"line\"> <span class=\"number\">85</span>:         <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:             maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">88</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">int</span> reconsumeTimes = requestHeader.getReconsumeTimes() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : requestHeader.getReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">if</span> (reconsumeTimes &gt;= maxReconsumeTimes) &#123; <span class=\"comment\">// 超过最大消费次数</span></div><div class=\"line\"> <span class=\"number\">91</span>:             newTopic = MixAll.getDLQTopic(groupName);</div><div class=\"line\"> <span class=\"number\">92</span>:             queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % DLQ_NUMS_PER_GROUP;</div><div class=\"line\"> <span class=\"number\">93</span>:             topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">94</span>:                 DLQ_NUMS_PER_GROUP, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">95</span>:                 PermName.PERM_WRITE, <span class=\"number\">0</span></div><div class=\"line\"> <span class=\"number\">96</span>:             );</div><div class=\"line\"> <span class=\"number\">97</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">99</span>:                 response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">101</span>:             &#125;</div><div class=\"line\"><span class=\"number\">102</span>:         &#125;</div><div class=\"line\"><span class=\"number\">103</span>:     &#125;</div><div class=\"line\"><span class=\"number\">104</span>: </div><div class=\"line\"><span class=\"number\">105</span>:     <span class=\"comment\">// 创建MessageExtBrokerInner</span></div><div class=\"line\"><span class=\"number\">106</span>:     MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">107</span>:     msgInner.setTopic(newTopic);</div><div class=\"line\"><span class=\"number\">108</span>:     msgInner.setBody(body);</div><div class=\"line\"><span class=\"number\">109</span>:     msgInner.setFlag(requestHeader.getFlag());</div><div class=\"line\"><span class=\"number\">110</span>:     MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</div><div class=\"line\"><span class=\"number\">111</span>:     msgInner.setPropertiesString(requestHeader.getProperties());</div><div class=\"line\"><span class=\"number\">112</span>:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(topicConfig.getTopicFilterType(), msgInner.getTags()));</div><div class=\"line\"><span class=\"number\">113</span>:     msgInner.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">114</span>:     msgInner.setSysFlag(sysFlag);</div><div class=\"line\"><span class=\"number\">115</span>:     msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">116</span>:     msgInner.setBornHost(ctx.channel().remoteAddress());</div><div class=\"line\"><span class=\"number\">117</span>:     msgInner.setStoreHost(<span class=\"keyword\">this</span>.getStoreHost());</div><div class=\"line\"><span class=\"number\">118</span>:     msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : requestHeader.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:     <span class=\"comment\">// 校验是否不允许发送事务消息</span></div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:         String traFlag = msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">if</span> (traFlag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"><span class=\"number\">125</span>:             response.setRemark(</div><div class=\"line\"><span class=\"number\">126</span>:                 <span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class=\"string\">\"] sending transaction message is forbidden\"</span>);</div><div class=\"line\"><span class=\"number\">127</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">128</span>:         &#125;</div><div class=\"line\"><span class=\"number\">129</span>:     &#125;</div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:     <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">132</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">134</span>:         <span class=\"keyword\">boolean</span> sendOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">135</span>: </div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">137</span>:             <span class=\"comment\">// Success</span></div><div class=\"line\"><span class=\"number\">138</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">139</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">140</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">141</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"><span class=\"number\">143</span>:                 response.setCode(ResponseCode.FLUSH_DISK_TIMEOUT);</div><div class=\"line\"><span class=\"number\">144</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">145</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"><span class=\"number\">147</span>:                 response.setCode(ResponseCode.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">148</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">149</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:             <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">151</span>:                 response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">152</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">153</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">154</span>: </div><div class=\"line\"><span class=\"number\">155</span>:             <span class=\"comment\">// Failed</span></div><div class=\"line\"><span class=\"number\">156</span>:             <span class=\"keyword\">case</span> CREATE_MAPEDFILE_FAILED:</div><div class=\"line\"><span class=\"number\">157</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">158</span>:                 response.setRemark(<span class=\"string\">\"create mapped file failed, server is busy or broken.\"</span>);</div><div class=\"line\"><span class=\"number\">159</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">160</span>:             <span class=\"keyword\">case</span> MESSAGE_ILLEGAL:</div><div class=\"line\"><span class=\"number\">161</span>:             <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"><span class=\"number\">162</span>:                 response.setCode(ResponseCode.MESSAGE_ILLEGAL);</div><div class=\"line\"><span class=\"number\">163</span>:                 response.setRemark(</div><div class=\"line\"><span class=\"number\">164</span>:                     <span class=\"string\">\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\"</span>);</div><div class=\"line\"><span class=\"number\">165</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">166</span>:             <span class=\"keyword\">case</span> SERVICE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">167</span>:                 response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">168</span>:                 response.setRemark(</div><div class=\"line\"><span class=\"number\">169</span>:                     <span class=\"string\">\"service not available now, maybe disk full, \"</span> + diskUtil() + <span class=\"string\">\", maybe your broker machine memory too small.\"</span>);</div><div class=\"line\"><span class=\"number\">170</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">171</span>:             <span class=\"keyword\">case</span> OS_PAGECACHE_BUSY:</div><div class=\"line\"><span class=\"number\">172</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">173</span>:                 response.setRemark(<span class=\"string\">\"[PC_SYNCHRONIZED]broker busy, start flow control for a while\"</span>);</div><div class=\"line\"><span class=\"number\">174</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">175</span>:             <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"><span class=\"number\">176</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">177</span>:                 response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR\"</span>);</div><div class=\"line\"><span class=\"number\">178</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">179</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">180</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">181</span>:                 response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR DEFAULT\"</span>);</div><div class=\"line\"><span class=\"number\">182</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">183</span>:         &#125;</div><div class=\"line\"><span class=\"number\">184</span>: </div><div class=\"line\"><span class=\"number\">185</span>:         String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);</div><div class=\"line\"><span class=\"number\">186</span>:         <span class=\"keyword\">if</span> (sendOK) &#123;</div><div class=\"line\"><span class=\"number\">187</span>:             <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">188</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic());</div><div class=\"line\"><span class=\"number\">189</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());</div><div class=\"line\"><span class=\"number\">190</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incBrokerPutNums();</div><div class=\"line\"><span class=\"number\">191</span>: </div><div class=\"line\"><span class=\"number\">192</span>:             <span class=\"comment\">// 响应</span></div><div class=\"line\"><span class=\"number\">193</span>:             response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">194</span>:             responseHeader.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());</div><div class=\"line\"><span class=\"number\">195</span>:             responseHeader.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">196</span>:             responseHeader.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());</div><div class=\"line\"><span class=\"number\">197</span>:             doResponse(ctx, request, response);</div><div class=\"line\"><span class=\"number\">198</span>: </div><div class=\"line\"><span class=\"number\">199</span>:             <span class=\"comment\">// hook：设置发送成功到context</span></div><div class=\"line\"><span class=\"number\">200</span>:             <span class=\"keyword\">if</span> (hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">201</span>:                 sendMessageContext.setMsgId(responseHeader.getMsgId());</div><div class=\"line\"><span class=\"number\">202</span>:                 sendMessageContext.setQueueId(responseHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">203</span>:                 sendMessageContext.setQueueOffset(responseHeader.getQueueOffset());</div><div class=\"line\"><span class=\"number\">204</span>: </div><div class=\"line\"><span class=\"number\">205</span>:                 <span class=\"keyword\">int</span> commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();</div><div class=\"line\"><span class=\"number\">206</span>:                 <span class=\"keyword\">int</span> wroteSize = putMessageResult.getAppendMessageResult().getWroteBytes();</div><div class=\"line\"><span class=\"number\">207</span>:                 <span class=\"keyword\">int</span> incValue = (<span class=\"keyword\">int</span>) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT) * commercialBaseCount;</div><div class=\"line\"><span class=\"number\">208</span>: </div><div class=\"line\"><span class=\"number\">209</span>:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_SUCCESS);</div><div class=\"line\"><span class=\"number\">210</span>:                 sendMessageContext.setCommercialSendTimes(incValue);</div><div class=\"line\"><span class=\"number\">211</span>:                 sendMessageContext.setCommercialSendSize(wroteSize);</div><div class=\"line\"><span class=\"number\">212</span>:                 sendMessageContext.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">213</span>:             &#125;</div><div class=\"line\"><span class=\"number\">214</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">215</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">216</span>:             <span class=\"comment\">// hook：设置发送失败到context</span></div><div class=\"line\"><span class=\"number\">217</span>:             <span class=\"keyword\">if</span> (hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">218</span>:                 <span class=\"keyword\">int</span> wroteSize = request.getBody().length;</div><div class=\"line\"><span class=\"number\">219</span>:                 <span class=\"keyword\">int</span> incValue = (<span class=\"keyword\">int</span>) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT);</div><div class=\"line\"><span class=\"number\">220</span>: </div><div class=\"line\"><span class=\"number\">221</span>:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_FAILURE);</div><div class=\"line\"><span class=\"number\">222</span>:                 sendMessageContext.setCommercialSendTimes(incValue);</div><div class=\"line\"><span class=\"number\">223</span>:                 sendMessageContext.setCommercialSendSize(wroteSize);</div><div class=\"line\"><span class=\"number\">224</span>:                 sendMessageContext.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">225</span>:             &#125;</div><div class=\"line\"><span class=\"number\">226</span>:         &#125;</div><div class=\"line\"><span class=\"number\">227</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">228</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">229</span>:         response.setRemark(<span class=\"string\">\"store putMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">230</span>:     &#125;</div><div class=\"line\"><span class=\"number\">231</span>: </div><div class=\"line\"><span class=\"number\">232</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">233</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#processRequest()</code> 说明 ：处理消息请求。</li>\n<li><code>#sendMessage()</code> 说明 ：发送消息，并返回发送消息结果。</li>\n<li>第 51 至 55 行 ：消息配置(Topic配置）校验，详细解析见：<a href=\"#abstractsendmessageprocessormsgcheck\">AbstractSendMessageProcessor#msgCheck()</a>。</li>\n<li>第 60 至 64 行 ：消息队列编号小于0时，<code>Broker</code> 可以设置随机选择一个消息队列。</li>\n<li>第 72 至 103 行 ：对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成”%DLQ%” + 分组名， 即加  死信队 (Dead Letter Queue)，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n<li>第 105 至 118 行 ：创建<code>MessageExtBrokerInner</code>。</li>\n<li>第 132 ：存储消息，详细解析见：<a href=\"defaultmessagestoreputmessage\">DefaultMessageStore#putMessage()</a>。</li>\n<li>第 133 至 183 行 ：处理消息发送结果，设置响应结果和提示。</li>\n<li>第 186 至 214 行 ：发送成功，响应。这里<code>doResponse(ctx, request, response)</code>进行响应，最后<code>return null</code>，原因是：响应给 <code>Producer</code> 可能发生异常，<code>#doResponse(ctx, request, response)</code>捕捉了该异常并输出日志。这样做的话，我们进行排查 <code>Broker</code> 接收消息成功后响应是否存在异常会方便很多。</li>\n</ul>\n<h3 id=\"AbstractSendMessageProcessor-msgCheck\"><a href=\"#AbstractSendMessageProcessor-msgCheck\" class=\"headerlink\" title=\"AbstractSendMessageProcessor#msgCheck\"></a>AbstractSendMessageProcessor#msgCheck</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">protected</span> RemotingCommand <span class=\"title\">msgCheck</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx,</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:                                    <span class=\"keyword\">final</span> SendMessageRequestHeader requestHeader, <span class=\"keyword\">final</span> RemotingCommand response) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 检查 broker 是否有写入权限</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())</div><div class=\"line\"> <span class=\"number\">5</span>:         &amp;&amp; <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">7</span>:         response.setRemark(<span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</div><div class=\"line\"> <span class=\"number\">8</span>:             + <span class=\"string\">\"] sending message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">// 检查topic是否可以被发送。目前是&#123;@link MixAll.DEFAULT_TOPIC&#125;不被允许发送</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:         String errorMsg = <span class=\"string\">\"the topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] is conflict with system reserved words.\"</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         log.warn(errorMsg);</div><div class=\"line\"><span class=\"number\">15</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">16</span>:         response.setRemark(errorMsg);</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123; <span class=\"comment\">// 不能存在topicConfig，则进行创建</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">int</span> topicSysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (requestHeader.isUnitMode()) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"comment\">// 创建topic配置</span></div><div class=\"line\"><span class=\"number\">30</span>:         log.warn(<span class=\"string\">\"the topic &#123;&#125; not exist, producer: &#123;&#125;\"</span>, requestHeader.getTopic(), ctx.channel().remoteAddress());</div><div class=\"line\"><span class=\"number\">31</span>:         topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">32</span>:             requestHeader.getTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">33</span>:             requestHeader.getDefaultTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">34</span>:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">35</span>:             requestHeader.getDefaultTopicQueueNums(), topicSysFlag);</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 topicConfig =</div><div class=\"line\"><span class=\"number\">39</span>:                     <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</div><div class=\"line\"><span class=\"number\">40</span>:                         requestHeader.getTopic(), <span class=\"number\">1</span>, PermName.PERM_WRITE | PermName.PERM_READ,</div><div class=\"line\"><span class=\"number\">41</span>:                         topicSysFlag);</div><div class=\"line\"><span class=\"number\">42</span>:             &#125;</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"comment\">// 如果没配置</span></div><div class=\"line\"><span class=\"number\">45</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:             response.setCode(ResponseCode.TOPIC_NOT_EXIST);</div><div class=\"line\"><span class=\"number\">47</span>:             response.setRemark(<span class=\"string\">\"topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] not exist, apply first please!\"</span></div><div class=\"line\"><span class=\"number\">48</span>:                 + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</div><div class=\"line\"><span class=\"number\">49</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">50</span>:         &#125;</div><div class=\"line\"><span class=\"number\">51</span>:     &#125;</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"comment\">// 队列编号是否正确</span></div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"keyword\">int</span> queueIdInt = requestHeader.getQueueId();</div><div class=\"line\"><span class=\"number\">54</span>:     <span class=\"keyword\">int</span> idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());</div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (queueIdInt &gt;= idValid) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:         String errorInfo = String.format(<span class=\"string\">\"request queueId[%d] is illegal, %s Producer: %s\"</span>,</div><div class=\"line\"><span class=\"number\">57</span>:             queueIdInt,</div><div class=\"line\"><span class=\"number\">58</span>:             topicConfig.toString(),</div><div class=\"line\"><span class=\"number\">59</span>:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</div><div class=\"line\"><span class=\"number\">60</span>:         log.warn(errorInfo);</div><div class=\"line\"><span class=\"number\">61</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">62</span>:         response.setRemark(errorInfo);</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">64</span>:     &#125;</div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">66</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：校验消息是否正确，主要是Topic配置方面，例如：<code>Broker</code> 是否有写入权限，topic配置是否存在，队列编号是否正确。</li>\n<li>第 11 至 18 行 ：检查Topic是否可以被发送。目前是 <code>{@link MixAll.DEFAULT_TOPIC}</code> 不被允许发送。</li>\n<li>第 20 至 51 行 ：当找不到Topic配置，则进行创建。当然，创建会存在不成功的情况，例如说：<code>defaultTopic</code> 的Topic配置不存在，又或者是 存在但是不允许继承，详细解析见<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n</ul>\n<h2 id=\"DefaultMessageStore-putMessage\"><a href=\"#DefaultMessageStore-putMessage\" class=\"headerlink\" title=\"DefaultMessageStore#putMessage\"></a>DefaultMessageStore#putMessage</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.shutdown) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         log.warn(<span class=\"string\">\"message store has shutdown, so putMessage is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">5</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 从节点不允许写入</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (BrokerRole.SLAVE == <span class=\"keyword\">this</span>.messageStoreConfig.getBrokerRole()) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">long</span> value = <span class=\"keyword\">this</span>.printTimes.getAndIncrement();</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">if</span> ((value % <span class=\"number\">50000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             log.warn(<span class=\"string\">\"message store is slave mode, so putMessage is forbidden \"</span>);</div><div class=\"line\"><span class=\"number\">12</span>:         &#125;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">15</span>:     &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">// store是否允许写入</span></div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.runningFlags.isWriteable()) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">long</span> value = <span class=\"keyword\">this</span>.printTimes.getAndIncrement();</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"keyword\">if</span> ((value % <span class=\"number\">50000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:             log.warn(<span class=\"string\">\"message store is not writeable, so putMessage is forbidden \"</span> + <span class=\"keyword\">this</span>.runningFlags.getFlagBits());</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">25</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">this</span>.printTimes.set(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">27</span>:     &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"comment\">// 消息过长</span></div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         log.warn(<span class=\"string\">\"putMessage message topic length too long \"</span> + msg.getTopic().length());</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">33</span>:     &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"comment\">// 消息附加属性过长</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">if</span> (msg.getPropertiesString() != <span class=\"keyword\">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:         log.warn(<span class=\"string\">\"putMessage message properties length too long \"</span> + msg.getPropertiesString().length());</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>:     &#125;</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isOSPageCacheBusy()) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"keyword\">long</span> beginTime = <span class=\"keyword\">this</span>.getSystemClock().now();</div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"comment\">// 添加消息到commitLog</span></div><div class=\"line\"><span class=\"number\">47</span>:     PutMessageResult result = <span class=\"keyword\">this</span>.commitLog.putMessage(msg);</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:     <span class=\"keyword\">long</span> eclipseTime = <span class=\"keyword\">this</span>.getSystemClock().now() - beginTime;</div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"keyword\">if</span> (eclipseTime &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         log.warn(<span class=\"string\">\"putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;\"</span>, eclipseTime, msg.getBody().length);</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"keyword\">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == result || !result.isOk()) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:         <span class=\"keyword\">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</div><div class=\"line\"><span class=\"number\">57</span>:     &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">60</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：存储消息封装，最终存储需要 <code>CommitLog</code> 实现。</li>\n<li>第 7 至 27 行 ：校验 <code>Broker</code> 是否可以写入。</li>\n<li>第 29 至 39 行 ：消息格式与大小校验。</li>\n<li>第 47 行 ：调用 <code>CommitLong</code> 进行存储，详细逻辑见：<a href=\"http://www.yunai.me/RocketMQ/message-store/\">《RocketMQ 源码分析 —— Message 存储》</a></li>\n</ul>\n<h1 id=\"4、某种结尾\"><a href=\"#4、某种结尾\" class=\"headerlink\" title=\"4、某种结尾\"></a>4、某种结尾</h1><p>感谢阅读、收藏、点赞本文的工程师同学。</p>\n<p>阅读源码是件令自己很愉悦的事情，编写源码解析是让自己脑细胞死伤无数的过程，痛并快乐着。</p>\n<p>如果有内容写的存在错误，或是不清晰的地方，见笑了，🙂。欢迎加 QQ：7685413 我们一起探讨，共进步。</p>\n<p>再次感谢阅读、收藏、点赞本文的工程师同学。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">http://www.yunai.me/RocketMQ/message-send-and-receive/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、Producer 发送消息</a><ul>\n<li><a href=\"#\">DefaultMQProducer#send(Message)</a></li>\n<li><a href=\"#\">DefaultMQProducerImpl#sendDefaultImpl()</a><ul>\n<li><a href=\"#\">DefaultMQProducerImpl#tryToFindTopicPublishInfo()</a></li>\n<li><a href=\"#\">MQFaultStrategy</a><ul>\n<li><a href=\"#\">MQFaultStrategy</a></li>\n<li><a href=\"#\">LatencyFaultTolerance</a></li>\n<li><a href=\"#\">LatencyFaultToleranceImpl</a></li>\n<li><a href=\"#\">FaultItem</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMQProducerImpl#sendKernelImpl()</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">3、Broker 接收消息</a><ul>\n<li><a href=\"#\">SendMessageProcessor#sendMessage</a><ul>\n<li><a href=\"#\">AbstractSendMessageProcessor#msgCheck</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMessageStore#putMessage</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4、某种结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><ol>\n<li><code>Producer</code> 发送消息。主要是<strong>同步</strong>发送消息源码，涉及到 异步/Oneway发送消息，事务消息会跳过。</li>\n<li><code>Broker</code> 接收消息。(<em>存储消息在<a href=\"http://www.yunai.me/RocketMQ/message-store/\">《RocketMQ 源码分析 —— Message 存储》</a>解析</em>)</li>\n</ol>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/01.png\" alt=\"Producer发送消息全局顺序图\"></p>\n</blockquote>\n<h1 id=\"2、Producer-发送消息\"><a href=\"#2、Producer-发送消息\" class=\"headerlink\" title=\"2、Producer 发送消息\"></a>2、Producer 发送消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/02.png\" alt=\"Producer发送消息顺序图\"></p>\n</blockquote>\n<h2 id=\"DefaultMQProducer-send-Message\"><a href=\"#DefaultMQProducer-send-Message\" class=\"headerlink\" title=\"DefaultMQProducer#send(Message)\"></a>DefaultMQProducer#send(Message)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultMQProducerImpl.send(msg);</div><div class=\"line\"><span class=\"number\">4</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：发送同步消息，<code>DefaultMQProducer#send(Message)</code> 对 <code>DefaultMQProducerImpl#send(Message)</code> 进行封装。  </li>\n</ul>\n<h2 id=\"DefaultMQProducerImpl-sendDefaultImpl\"><a href=\"#DefaultMQProducerImpl-sendDefaultImpl\" class=\"headerlink\" title=\"DefaultMQProducerImpl#sendDefaultImpl()\"></a>DefaultMQProducerImpl#sendDefaultImpl()</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">return</span> send(msg, <span class=\"keyword\">this</span>.defaultMQProducer.getSendMsgTimeout());</div><div class=\"line\">  <span class=\"number\">3</span>: &#125;</div><div class=\"line\">  <span class=\"number\">4</span>: </div><div class=\"line\">  <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">public</span> SendResult <span class=\"title\">send</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class=\"keyword\">null</span>, timeout);</div><div class=\"line\">  <span class=\"number\">7</span>: &#125;</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendDefaultImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">10</span>:     Message msg, //</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"> <span class=\"number\">14</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"comment\">// 校验 Producer 处于运行状态</span></div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"comment\">// 校验消息格式</span></div><div class=\"line\"> <span class=\"number\">18</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> invokeID = random.nextLong(); <span class=\"comment\">// 调用编号；用于下面打印日志，标记为同一次发送消息</span></div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">long</span> beginTimestampFirst = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"keyword\">long</span> beginTimestampPrev = beginTimestampFirst;</div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"keyword\">long</span> endTimestamp = beginTimestampFirst;</div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"comment\">// 获取 Topic路由信息</span></div><div class=\"line\"> <span class=\"number\">25</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:         MessageQueue mq = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后选择消息要发送到的队列</span></div><div class=\"line\"> <span class=\"number\">28</span>:         Exception exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">29</span>:         SendResult sendResult = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后一次发送结果</span></div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class=\"number\">1</span>; <span class=\"comment\">// 同步多次调用</span></div><div class=\"line\"> <span class=\"number\">31</span>:         <span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; <span class=\"comment\">// 第几次发送</span></div><div class=\"line\"> <span class=\"number\">32</span>:         String[] brokersSent = <span class=\"keyword\">new</span> String[timesTotal]; <span class=\"comment\">// 存储每次发送消息选择的broker名</span></div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"comment\">// 循环调用发送消息，直到成功</span></div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:             String lastBrokerName = <span class=\"keyword\">null</span> == mq ? <span class=\"keyword\">null</span> : mq.getBrokerName();</div><div class=\"line\"> <span class=\"number\">36</span>:             MessageQueue tmpmq = <span class=\"keyword\">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName); <span class=\"comment\">// 选择消息要发送到的队列</span></div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (tmpmq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 mq = tmpmq;</div><div class=\"line\"> <span class=\"number\">39</span>:                 brokersSent[times] = mq.getBrokerName();</div><div class=\"line\"> <span class=\"number\">40</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:                     beginTimestampPrev = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"comment\">// 调用发送消息核心方法</span></div><div class=\"line\"> <span class=\"number\">43</span>:                     sendResult = <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class=\"line\"> <span class=\"number\">44</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">45</span>:                     <span class=\"comment\">// 更新Broker可用性信息</span></div><div class=\"line\"> <span class=\"number\">46</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">47</span>:                     <span class=\"keyword\">switch</span> (communicationMode) &#123;</div><div class=\"line\"> <span class=\"number\">48</span>:                         <span class=\"keyword\">case</span> ASYNC:</div><div class=\"line\"> <span class=\"number\">49</span>:                             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">50</span>:                         <span class=\"keyword\">case</span> ONEWAY:</div><div class=\"line\"> <span class=\"number\">51</span>:                             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">52</span>:                         <span class=\"keyword\">case</span> SYNC:</div><div class=\"line\"> <span class=\"number\">53</span>:                             <span class=\"keyword\">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</div><div class=\"line\"> <span class=\"number\">54</span>:                                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123; <span class=\"comment\">// 同步发送成功但存储有问题时 &amp;&amp; 配置存储异常时重新发送开关 时，进行重试</span></div><div class=\"line\"> <span class=\"number\">55</span>:                                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">57</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:                             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"> <span class=\"number\">59</span>:                         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">60</span>:                             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">62</span>:                 &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，更新继续循环</span></div><div class=\"line\"> <span class=\"number\">63</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">64</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">65</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">66</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">67</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">68</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:                 &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，继续循环</span></div><div class=\"line\"> <span class=\"number\">70</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">71</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">72</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">73</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">74</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">75</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">76</span>:                 &#125; <span class=\"keyword\">catch</span> (MQBrokerException e) &#123; <span class=\"comment\">// 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环</span></div><div class=\"line\"> <span class=\"number\">77</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">78</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">79</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"> <span class=\"number\">80</span>:                     log.warn(msg.toString());</div><div class=\"line\"> <span class=\"number\">81</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">82</span>:                     <span class=\"keyword\">switch</span> (e.getResponseCode()) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:                         <span class=\"comment\">// 如下异常continue，进行发送消息重试</span></div><div class=\"line\"> <span class=\"number\">84</span>:                         <span class=\"keyword\">case</span> ResponseCode.TOPIC_NOT_EXIST:</div><div class=\"line\"> <span class=\"number\">85</span>:                         <span class=\"keyword\">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</div><div class=\"line\"> <span class=\"number\">86</span>:                         <span class=\"keyword\">case</span> ResponseCode.SYSTEM_ERROR:</div><div class=\"line\"> <span class=\"number\">87</span>:                         <span class=\"keyword\">case</span> ResponseCode.NO_PERMISSION:</div><div class=\"line\"> <span class=\"number\">88</span>:                         <span class=\"keyword\">case</span> ResponseCode.NO_BUYER_ID:</div><div class=\"line\"> <span class=\"number\">89</span>:                         <span class=\"keyword\">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</div><div class=\"line\"> <span class=\"number\">90</span>:                             <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 如果有发送结果，进行返回，否则，抛出异常；</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">93</span>:                             <span class=\"keyword\">if</span> (sendResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:                                 <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"> <span class=\"number\">95</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">96</span>:                             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"> <span class=\"number\">97</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:                 &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">100</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">101</span>:                     log.warn(String.format(<span class=\"string\">\"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s\"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</div><div class=\"line\"><span class=\"number\">102</span>:                     log.warn(msg.toString());</div><div class=\"line\"><span class=\"number\">103</span>:                     <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">104</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">105</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">107</span>:             &#125;</div><div class=\"line\"><span class=\"number\">108</span>:         &#125;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"comment\">// 返回发送结果</span></div><div class=\"line\"><span class=\"number\">110</span>:         <span class=\"keyword\">if</span> (sendResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">111</span>:             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"comment\">// 根据不同情况，抛出不同的异常</span></div><div class=\"line\"><span class=\"number\">114</span>:         String info = String.format(<span class=\"string\">\"Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s\"</span>, times, System.currentTimeMillis() - beginTimestampFirst,</div><div class=\"line\"><span class=\"number\">115</span>:                 msg.getTopic(), Arrays.toString(brokersSent)) + FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</div><div class=\"line\"><span class=\"number\">116</span>:         MQClientException mqClientException = <span class=\"keyword\">new</span> MQClientException(info, exception);</div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> MQBrokerException) &#123;</div><div class=\"line\"><span class=\"number\">118</span>:             mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</div><div class=\"line\"><span class=\"number\">119</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> RemotingConnectException) &#123;</div><div class=\"line\"><span class=\"number\">120</span>:             mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</div><div class=\"line\"><span class=\"number\">121</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> RemotingTimeoutException) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:             mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</div><div class=\"line\"><span class=\"number\">123</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (exception <span class=\"keyword\">instanceof</span> MQClientException) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</div><div class=\"line\"><span class=\"number\">125</span>:         &#125;</div><div class=\"line\"><span class=\"number\">126</span>:         <span class=\"keyword\">throw</span> mqClientException;</div><div class=\"line\"><span class=\"number\">127</span>:     &#125;</div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// Namesrv找不到异常</span></div><div class=\"line\"><span class=\"number\">129</span>:     List&lt;String&gt; nsList = <span class=\"keyword\">this</span>.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</div><div class=\"line\"><span class=\"number\">130</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == nsList || nsList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(</div><div class=\"line\"><span class=\"number\">132</span>:             <span class=\"string\">\"No name server address, please set it.\"</span> + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), <span class=\"keyword\">null</span>).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</div><div class=\"line\"><span class=\"number\">133</span>:     &#125;</div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"comment\">// 消息路由找不到异常</span></div><div class=\"line\"><span class=\"number\">135</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"No route info of this topic, \"</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</div><div class=\"line\"><span class=\"number\">137</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发送消息。步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。</li>\n<li>第 1  至 7 行：对<code>sendsendDefaultImpl(...)</code>进行封装。</li>\n<li>第 20 行 ：<code>invokeID</code>仅仅用于打印日志，无实际的业务用途。</li>\n<li>第 25 行 ：获取 Topic路由信息， 详细解析见：<a href=\"#defaultmqproducerimpltrytofindtopicpublishinfo\">DefaultMQProducerImpl#tryToFindTopicPublishInfo()</a></li>\n<li>第 30 &amp; 34 行 ：计算调用发送消息到成功为止的最大次数，并进行循环。同步或异步发送消息会调用多次，默认配置为3次。</li>\n<li>第 36 行 ：选择消息要发送到的队列，详细解析见：<a href=\"#mqfaultstrategy\">MQFaultStrategy</a></li>\n<li>第 43 行 ：调用发送消息核心方法，详细解析见：<a href=\"#defaultmqproducerimplsendkernelimpl\">DefaultMQProducerImpl#sendKernelImpl()</a></li>\n<li>第 46 行 ：更新<code>Broker</code>可用性信息。在选择发送到的消息队列时，会参考<code>Broker</code>发送消息的延迟，详细解析见：<a href=\"#mqfaultstrategy\">MQFaultStrategy</a></li>\n<li>第 62 至 68 行：当抛出<code>RemotingException</code>时，如果进行消息发送失败重试，则<strong>可能导致消息发送重复</strong>。例如，发送消息超时(<code>RemotingTimeoutException</code>)，实际<code>Broker</code>接收到该消息并处理成功。因此，<code>Consumer</code>在消费时，需要保证幂等性。</li>\n</ul>\n<h3 id=\"DefaultMQProducerImpl-tryToFindTopicPublishInfo\"><a href=\"#DefaultMQProducerImpl-tryToFindTopicPublishInfo\" class=\"headerlink\" title=\"DefaultMQProducerImpl#tryToFindTopicPublishInfo()\"></a>DefaultMQProducerImpl#tryToFindTopicPublishInfo()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> TopicPublishInfo <span class=\"title\">tryToFindTopicPublishInfo</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 缓存中获取 Topic发布信息</span></div><div class=\"line\"> <span class=\"number\">3</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// 当无可用的 Topic发布信息时，从Namesrv获取一次</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class=\"keyword\">new</span> TopicPublishInfo());</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</div><div class=\"line\"> <span class=\"number\">8</span>:         topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"comment\">// 若获取的 Topic发布信息时候可用，则返回</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">return</span> topicPublishInfo;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 使用 &#123;@link DefaultMQProducer#createTopicKey&#125; 对应的 Topic发布信息。用于 Topic发布信息不存在 &amp;&amp; Broker支持自动创建Topic</span></div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class=\"keyword\">true</span>, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"><span class=\"number\">15</span>:         topicPublishInfo = <span class=\"keyword\">this</span>.topicPublishInfoTable.get(topic);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">return</span> topicPublishInfo;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获得 Topic发布信息。优先从缓存<code>topicPublishInfoTable</code>，其次从<code>Namesrv</code>中获得。</li>\n<li>第 3 行 ：从缓存<code>topicPublishInfoTable</code>中获得 Topic发布信息。</li>\n<li>第 5 至 9 行 ：从 <code>Namesrv</code> 中获得 Topic发布信息。</li>\n<li>第 13 至 17 行 ：当从 <code>Namesrv</code> 无法获取时，使用 <code>{@link DefaultMQProducer#createTopicKey}</code> 对应的 Topic发布信息。目的是当 <code>Broker</code> 开启自动创建 Topic开关时，<code>Broker</code> 接收到消息后自动创建Topic，详细解析见<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n</ul>\n<h3 id=\"MQFaultStrategy\"><a href=\"#MQFaultStrategy\" class=\"headerlink\" title=\"MQFaultStrategy\"></a>MQFaultStrategy</h3><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/03.png\" alt=\"Latency类图\"></p>\n</blockquote>\n<h4 id=\"MQFaultStrategy-1\"><a href=\"#MQFaultStrategy-1\" class=\"headerlink\" title=\"MQFaultStrategy\"></a>MQFaultStrategy</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MQFaultStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 5:      * 延迟故障容错，维护每个Broker的发送消息的延迟</div><div class=\"line\"> 6:      * key：brokerName</div><div class=\"line\"> 7:      */</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class=\"keyword\">new</span> LatencyFaultToleranceImpl();</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">10:      * 发送消息延迟容错开关</div><div class=\"line\">11:      */</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> sendLatencyFaultEnable = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">14:      * 延迟级别数组</div><div class=\"line\">15:      */</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] latencyMax = &#123;<span class=\"number\">50L</span>, <span class=\"number\">100L</span>, <span class=\"number\">550L</span>, <span class=\"number\">1000L</span>, <span class=\"number\">2000L</span>, <span class=\"number\">3000L</span>, <span class=\"number\">15000L</span>&#125;;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">18:      * 不可用时长数组</div><div class=\"line\">19:      */</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span>[] notAvailableDuration = &#123;<span class=\"number\">0L</span>, <span class=\"number\">0L</span>, <span class=\"number\">30000L</span>, <span class=\"number\">60000L</span>, <span class=\"number\">120000L</span>, <span class=\"number\">180000L</span>, <span class=\"number\">600000L</span>&#125;;</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">23:      * 根据 Topic发布信息 选择一个消息队列</div><div class=\"line\">24:      *</div><div class=\"line\">25:      * <span class=\"doctag\">@param</span> tpInfo Topic发布信息</div><div class=\"line\">26:      * <span class=\"doctag\">@param</span> lastBrokerName brokerName</div><div class=\"line\">27:      * <span class=\"doctag\">@return</span> 消息队列</div><div class=\"line\">28:      */</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">selectOneMessageQueue</span><span class=\"params\">(<span class=\"keyword\">final</span> TopicPublishInfo tpInfo, <span class=\"keyword\">final</span> String lastBrokerName)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sendLatencyFaultEnable) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"comment\">// 获取 brokerName=lastBrokerName &amp;&amp; 可用的一个消息队列</span></div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">if</span> (pos &lt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">37</span>:                         pos = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">38</span>:                     MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</div><div class=\"line\"><span class=\"number\">39</span>:                     <span class=\"keyword\">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</div><div class=\"line\"><span class=\"number\">41</span>:                             <span class=\"keyword\">return</span> mq;</div><div class=\"line\"><span class=\"number\">42</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"comment\">// 选择一个相对好的broker，并获得其对应的一个消息队列，不考虑该队列的可用性</span></div><div class=\"line\"><span class=\"number\">45</span>:                 <span class=\"keyword\">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">if</span> (writeQueueNums &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                     <span class=\"keyword\">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</div><div class=\"line\"><span class=\"number\">49</span>:                     <span class=\"keyword\">if</span> (notBestBroker != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:                         mq.setBrokerName(notBestBroker);</div><div class=\"line\"><span class=\"number\">51</span>:                         mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</div><div class=\"line\"><span class=\"number\">52</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">53</span>:                     <span class=\"keyword\">return</span> mq;</div><div class=\"line\"><span class=\"number\">54</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                     latencyFaultTolerance.remove(notBestBroker);</div><div class=\"line\"><span class=\"number\">56</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">57</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:                 log.error(<span class=\"string\">\"Error occurred when selecting message queue\"</span>, e);</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"comment\">// 选择一个消息队列，不考虑队列的可用性</span></div><div class=\"line\"><span class=\"number\">61</span>:             <span class=\"keyword\">return</span> tpInfo.selectOneMessageQueue();</div><div class=\"line\"><span class=\"number\">62</span>:         &#125;</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"comment\">// 获得 lastBrokerName 对应的一个消息队列，不考虑该队列的可用性</span></div><div class=\"line\"><span class=\"number\">64</span>:         <span class=\"keyword\">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</div><div class=\"line\"><span class=\"number\">65</span>:     &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">68:      * 更新延迟容错信息</div><div class=\"line\">69:      *</div><div class=\"line\">70:      * <span class=\"doctag\">@param</span> brokerName brokerName</div><div class=\"line\">71:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\">72:      * <span class=\"doctag\">@param</span> isolation 是否隔离。当开启隔离时，默认延迟为30000。目前主要用于发送消息异常时</div><div class=\"line\">73:      */</div><div class=\"line\"><span class=\"number\">74</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String brokerName, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">boolean</span> isolation)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.sendLatencyFaultEnable) &#123;</div><div class=\"line\"><span class=\"number\">76</span>:             <span class=\"keyword\">long</span> duration = computeNotAvailableDuration(isolation ? <span class=\"number\">30000</span> : currentLatency);</div><div class=\"line\"><span class=\"number\">77</span>:             <span class=\"keyword\">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</div><div class=\"line\"><span class=\"number\">78</span>:         &#125;</div><div class=\"line\"><span class=\"number\">79</span>:     &#125;</div><div class=\"line\"><span class=\"number\">80</span>: </div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">82:      * 计算延迟对应的不可用时间</div><div class=\"line\">83:      *</div><div class=\"line\">84:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\">85:      * <span class=\"doctag\">@return</span> 不可用时间</div><div class=\"line\">86:      */</div><div class=\"line\"><span class=\"number\">87</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeNotAvailableDuration</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">88</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = latencyMax.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</div><div class=\"line\"><span class=\"number\">89</span>:             <span class=\"keyword\">if</span> (currentLatency &gt;= latencyMax[i])</div><div class=\"line\"><span class=\"number\">90</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.notAvailableDuration[i];</div><div class=\"line\"><span class=\"number\">91</span>:         &#125;</div><div class=\"line\"><span class=\"number\">92</span>:         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">93</span>:     &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<code>Producer</code>消息发送容错策略。默认情况下容错策略关闭，即<code>sendLatencyFaultEnable=false</code>。</li>\n<li>第 30 至 62 行 ：容错策略选择消息队列逻辑。优先获取可用队列，其次选择一个broker获取队列，最差返回任意broker的一个队列。</li>\n<li>第 64 行 ：未开启容错策略选择消息队列逻辑。</li>\n<li><p>第 74 至 79 行 ：更新延迟容错信息。当 <code>Producer</code> 发送消息时间过长，则逻辑认为N秒内不可用。按照<code>latencyMax</code>，<code>notAvailableDuration</code>的配置，对应如下：</p>\n<p>  | Producer发送消息消耗时长 | Broker不可用时长 |<br>  | — | — |<br>  | &gt;= 15000 ms | 600 <em> 1000 ms  |<br>  | &gt;= 3000 ms | 180 </em> 1000 ms  |<br>  | &gt;= 2000 ms | 120 <em> 1000 ms  |<br>  | &gt;= 1000 ms | 60 </em> 1000 ms  |<br>  | &gt;= 550 ms | 30 * 1000 ms |<br>  | &gt;= 100 ms | 0 ms |<br>  | &gt;= 50 ms | 0 ms |</p>\n</li>\n</ul>\n<h4 id=\"LatencyFaultTolerance\"><a href=\"#LatencyFaultTolerance\" class=\"headerlink\" title=\"LatencyFaultTolerance\"></a>LatencyFaultTolerance</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LatencyFaultTolerance</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 更新对应的延迟和不可用时长</div><div class=\"line\"> 5:      *</div><div class=\"line\"> 6:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\"> 7:      * <span class=\"doctag\">@param</span> currentLatency 延迟</div><div class=\"line\"> 8:      * <span class=\"doctag\">@param</span> notAvailableDuration 不可用时长</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> T name, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> notAvailableDuration)</span></span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">13:      * 对象是否可用</div><div class=\"line\">14:      *</div><div class=\"line\">15:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\">16:      * <span class=\"doctag\">@return</span> 是否可用</div><div class=\"line\">17:      */</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">21:      * 移除对象</div><div class=\"line\">22:      *</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> name 对象</div><div class=\"line\">24:      */</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">final</span> T name)</span></span>;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">28:      * 获取一个对象</div><div class=\"line\">29:      *</div><div class=\"line\">30:      * <span class=\"doctag\">@return</span> 对象</div><div class=\"line\">31:      */</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"function\">T <span class=\"title\">pickOneAtLeast</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"number\">33</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：延迟故障容错接口</li>\n</ul>\n<h4 id=\"LatencyFaultToleranceImpl\"><a href=\"#LatencyFaultToleranceImpl\" class=\"headerlink\" title=\"LatencyFaultToleranceImpl\"></a>LatencyFaultToleranceImpl</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LatencyFaultToleranceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">LatencyFaultTolerance</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 对象故障信息Table</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">16</span>);</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 8:      * 对象选择Index</div><div class=\"line\"> 9:      * <span class=\"doctag\">@see</span> #pickOneAtLeast()</div><div class=\"line\">10:      */</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadLocalIndex whichItemWorst = <span class=\"keyword\">new</span> ThreadLocalIndex();</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateFaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String name, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentLatency, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> notAvailableDuration)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">15</span>:         FaultItem old = <span class=\"keyword\">this</span>.faultItemTable.get(name);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == old) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"comment\">// 创建对象</span></div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">final</span> FaultItem faultItem = <span class=\"keyword\">new</span> FaultItem(name);</div><div class=\"line\"><span class=\"number\">19</span>:             faultItem.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">20</span>:             faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 更新对象</span></div><div class=\"line\"><span class=\"number\">22</span>:             old = <span class=\"keyword\">this</span>.faultItemTable.putIfAbsent(name, faultItem);</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 old.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">25</span>:                 old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">26</span>:             &#125;</div><div class=\"line\"><span class=\"number\">27</span>:         &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 更新对象</span></div><div class=\"line\"><span class=\"number\">28</span>:             old.setCurrentLatency(currentLatency);</div><div class=\"line\"><span class=\"number\">29</span>:             old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</div><div class=\"line\"><span class=\"number\">30</span>:         &#125;</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">final</span> FaultItem faultItem = <span class=\"keyword\">this</span>.faultItemTable.get(name);</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (faultItem != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">return</span> faultItem.isAvailable();</div><div class=\"line\"><span class=\"number\">38</span>:         &#125;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">this</span>.faultItemTable.remove(name);</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">48:      * 选择一个相对优秀的对象</div><div class=\"line\">49:      *</div><div class=\"line\">50:      * <span class=\"doctag\">@return</span> 对象</div><div class=\"line\">51:      */</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">pickOneAtLeast</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"comment\">// 创建数组</span></div><div class=\"line\"><span class=\"number\">55</span>:         <span class=\"keyword\">final</span> Enumeration&lt;FaultItem&gt; elements = <span class=\"keyword\">this</span>.faultItemTable.elements();</div><div class=\"line\"><span class=\"number\">56</span>:         List&lt;FaultItem&gt; tmpList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">while</span> (elements.hasMoreElements()) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:             <span class=\"keyword\">final</span> FaultItem faultItem = elements.nextElement();</div><div class=\"line\"><span class=\"number\">59</span>:             tmpList.add(faultItem);</div><div class=\"line\"><span class=\"number\">60</span>:         &#125;</div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">if</span> (!tmpList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:             <span class=\"comment\">// 打乱 + 排序。TODO 疑问：应该只能二选一。猜测Collections.shuffle(tmpList)去掉。</span></div><div class=\"line\"><span class=\"number\">64</span>:             Collections.shuffle(tmpList);</div><div class=\"line\"><span class=\"number\">65</span>:             Collections.sort(tmpList);</div><div class=\"line\"><span class=\"number\">66</span>:             <span class=\"comment\">// 选择顺序在前一半的对象</span></div><div class=\"line\"><span class=\"number\">67</span>:             <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> half = tmpList.size() / <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">if</span> (half &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">69</span>:                 <span class=\"keyword\">return</span> tmpList.get(<span class=\"number\">0</span>).getName();</div><div class=\"line\"><span class=\"number\">70</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">71</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i = <span class=\"keyword\">this</span>.whichItemWorst.getAndIncrement() % half;</div><div class=\"line\"><span class=\"number\">72</span>:                 <span class=\"keyword\">return</span> tmpList.get(i).getName();</div><div class=\"line\"><span class=\"number\">73</span>:             &#125;</div><div class=\"line\"><span class=\"number\">74</span>:         &#125;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">76</span>:     &#125;</div><div class=\"line\"><span class=\"number\">77</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：延迟故障容错实现。维护每个对象的信息。</li>\n</ul>\n<h4 id=\"FaultItem\"><a href=\"#FaultItem\" class=\"headerlink\" title=\"FaultItem\"></a>FaultItem</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FaultItem</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">FaultItem</span>&gt; </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 对象名</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 7:      * 延迟</div><div class=\"line\"> 8:      */</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> currentLatency;</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">11:      * 开始可用时间</div><div class=\"line\">12:      */</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> startTimestamp;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FaultItem</span><span class=\"params\">(<span class=\"keyword\">final</span> String name)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">20:      * 比较对象</div><div class=\"line\">21:      * 可用性 &gt; 延迟 &gt; 开始可用时间</div><div class=\"line\">22:      *</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> other other</div><div class=\"line\">24:      * <span class=\"doctag\">@return</span> 升序</div><div class=\"line\">25:      */</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">final</span> FaultItem other)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAvailable() != other.isAvailable()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAvailable())</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (other.isAvailable())</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentLatency &lt; other.currentLatency)</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.currentLatency &gt; other.currentLatency) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.startTimestamp &lt; other.startTimestamp)</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.startTimestamp &gt; other.startTimestamp) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125;</div><div class=\"line\"><span class=\"number\">47</span>: </div><div class=\"line\"><span class=\"number\">48</span>:         <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">49</span>:     &#125;</div><div class=\"line\"><span class=\"number\">50</span>: </div><div class=\"line\"><span class=\"number\">51</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">52:      * 是否可用：当开始可用时间大于当前时间</div><div class=\"line\">53:      *</div><div class=\"line\">54:      * <span class=\"doctag\">@return</span> 是否可用</div><div class=\"line\">55:      */</div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">return</span> (System.currentTimeMillis() - startTimestamp) &gt;= <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">int</span> result = getName() != <span class=\"keyword\">null</span> ? getName().hashCode() : <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">63</span>:         result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (getCurrentLatency() ^ (getCurrentLatency() &gt;&gt;&gt; <span class=\"number\">32</span>));</div><div class=\"line\"><span class=\"number\">64</span>:         result = <span class=\"number\">31</span> * result + (<span class=\"keyword\">int</span>) (getStartTimestamp() ^ (getStartTimestamp() &gt;&gt;&gt; <span class=\"number\">32</span>));</div><div class=\"line\"><span class=\"number\">65</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">66</span>:     &#125;</div><div class=\"line\"><span class=\"number\">67</span>: </div><div class=\"line\"><span class=\"number\">68</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(<span class=\"keyword\">final</span> Object o)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == o)</div><div class=\"line\"><span class=\"number\">71</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">72</span>:         <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> FaultItem))</div><div class=\"line\"><span class=\"number\">73</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">74</span>: </div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">final</span> FaultItem faultItem = (FaultItem) o;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:         <span class=\"keyword\">if</span> (getCurrentLatency() != faultItem.getCurrentLatency())</div><div class=\"line\"><span class=\"number\">78</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">79</span>:         <span class=\"keyword\">if</span> (getStartTimestamp() != faultItem.getStartTimestamp())</div><div class=\"line\"><span class=\"number\">80</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">81</span>:         <span class=\"keyword\">return</span> getName() != <span class=\"keyword\">null</span> ? getName().equals(faultItem.getName()) : faultItem.getName() == <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">82</span>: </div><div class=\"line\"><span class=\"number\">83</span>:     &#125;</div><div class=\"line\"><span class=\"number\">84</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：对象故障信息。维护对象的名字、延迟、开始可用的时间。</li>\n</ul>\n<h3 id=\"DefaultMQProducerImpl-sendKernelImpl\"><a href=\"#DefaultMQProducerImpl-sendKernelImpl\" class=\"headerlink\" title=\"DefaultMQProducerImpl#sendKernelImpl()\"></a>DefaultMQProducerImpl#sendKernelImpl()</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendKernelImpl</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg, //</span></span></div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> MessageQueue mq, //</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> TopicPublishInfo topicPublishInfo, //</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">// 获取 broker地址</span></div><div class=\"line\">  <span class=\"number\">8</span>:     String brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == brokerAddr) &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:         tryToFindTopicPublishInfo(mq.getTopic());</div><div class=\"line\"> <span class=\"number\">11</span>:         brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</div><div class=\"line\"> <span class=\"number\">12</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">14</span>:     SendMessageContext context = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (brokerAddr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"comment\">// 是否使用broker vip通道。broker会开启两个端口对外服务。</span></div><div class=\"line\"> <span class=\"number\">17</span>:         brokerAddr = MixAll.brokerVIPChannel(<span class=\"keyword\">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">byte</span>[] prevBody = msg.getBody(); <span class=\"comment\">// 记录消息内容。下面逻辑可能改变消息内容，例如消息压缩。</span></div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"comment\">// 设置唯一编号</span></div><div class=\"line\"> <span class=\"number\">21</span>:             MessageClientIDSetter.setUniqID(msg);</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"comment\">// 消息压缩</span></div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"keyword\">int</span> sysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.tryToCompressMessage(msg)) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                 sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</div><div class=\"line\"> <span class=\"number\">26</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"comment\">// 事务</span></div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"> <span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (tranMsg != <span class=\"keyword\">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                 sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</div><div class=\"line\"> <span class=\"number\">31</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">32</span>:             <span class=\"comment\">// hook：发送消息校验</span></div><div class=\"line\"> <span class=\"number\">33</span>:             <span class=\"keyword\">if</span> (hasCheckForbiddenHook()) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 CheckForbiddenContext checkForbiddenContext = <span class=\"keyword\">new</span> CheckForbiddenContext();</div><div class=\"line\"> <span class=\"number\">35</span>:                 checkForbiddenContext.setNameSrvAddr(<span class=\"keyword\">this</span>.defaultMQProducer.getNamesrvAddr());</div><div class=\"line\"> <span class=\"number\">36</span>:                 checkForbiddenContext.setGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">37</span>:                 checkForbiddenContext.setCommunicationMode(communicationMode);</div><div class=\"line\"> <span class=\"number\">38</span>:                 checkForbiddenContext.setBrokerAddr(brokerAddr);</div><div class=\"line\"> <span class=\"number\">39</span>:                 checkForbiddenContext.setMessage(msg);</div><div class=\"line\"> <span class=\"number\">40</span>:                 checkForbiddenContext.setMq(mq);</div><div class=\"line\"> <span class=\"number\">41</span>:                 checkForbiddenContext.setUnitMode(<span class=\"keyword\">this</span>.isUnitMode());</div><div class=\"line\"> <span class=\"number\">42</span>:                 <span class=\"keyword\">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</div><div class=\"line\"> <span class=\"number\">43</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">44</span>:             <span class=\"comment\">// hook：发送消息前逻辑</span></div><div class=\"line\"> <span class=\"number\">45</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"> <span class=\"number\">46</span>:                 context = <span class=\"keyword\">new</span> SendMessageContext();</div><div class=\"line\"> <span class=\"number\">47</span>:                 context.setProducer(<span class=\"keyword\">this</span>);</div><div class=\"line\"> <span class=\"number\">48</span>:                 context.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">49</span>:                 context.setCommunicationMode(communicationMode);</div><div class=\"line\"> <span class=\"number\">50</span>:                 context.setBornHost(<span class=\"keyword\">this</span>.defaultMQProducer.getClientIP());</div><div class=\"line\"> <span class=\"number\">51</span>:                 context.setBrokerAddr(brokerAddr);</div><div class=\"line\"> <span class=\"number\">52</span>:                 context.setMessage(msg);</div><div class=\"line\"> <span class=\"number\">53</span>:                 context.setMq(mq);</div><div class=\"line\"> <span class=\"number\">54</span>:                 String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">if</span> (isTrans != <span class=\"keyword\">null</span> &amp;&amp; isTrans.equals(<span class=\"string\">\"true\"</span>)) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     context.setMsgType(MessageType.Trans_Msg_Half);</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:                 <span class=\"keyword\">if</span> (msg.getProperty(<span class=\"string\">\"__STARTDELIVERTIME\"</span>) != <span class=\"keyword\">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                     context.setMsgType(MessageType.Delay_Msg);</div><div class=\"line\"> <span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">61</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookBefore(context);</div><div class=\"line\"> <span class=\"number\">62</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"comment\">// 构建发送消息请求</span></div><div class=\"line\"> <span class=\"number\">64</span>:             SendMessageRequestHeader requestHeader = <span class=\"keyword\">new</span> SendMessageRequestHeader();</div><div class=\"line\"> <span class=\"number\">65</span>:             requestHeader.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">66</span>:             requestHeader.setTopic(msg.getTopic());</div><div class=\"line\"> <span class=\"number\">67</span>:             requestHeader.setDefaultTopic(<span class=\"keyword\">this</span>.defaultMQProducer.getCreateTopicKey());</div><div class=\"line\"> <span class=\"number\">68</span>:             requestHeader.setDefaultTopicQueueNums(<span class=\"keyword\">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</div><div class=\"line\"> <span class=\"number\">69</span>:             requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\"> <span class=\"number\">70</span>:             requestHeader.setSysFlag(sysFlag);</div><div class=\"line\"> <span class=\"number\">71</span>:             requestHeader.setBornTimestamp(System.currentTimeMillis());</div><div class=\"line\"> <span class=\"number\">72</span>:             requestHeader.setFlag(msg.getFlag());</div><div class=\"line\"> <span class=\"number\">73</span>:             requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"> <span class=\"number\">74</span>:             requestHeader.setReconsumeTimes(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">75</span>:             requestHeader.setUnitMode(<span class=\"keyword\">this</span>.isUnitMode());</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123; <span class=\"comment\">// 消息重发Topic</span></div><div class=\"line\"> <span class=\"number\">77</span>:                 String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</div><div class=\"line\"> <span class=\"number\">78</span>:                 <span class=\"keyword\">if</span> (reconsumeTimes != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:                     requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</div><div class=\"line\"> <span class=\"number\">80</span>:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</div><div class=\"line\"> <span class=\"number\">81</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:                 String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</div><div class=\"line\"> <span class=\"number\">83</span>:                 <span class=\"keyword\">if</span> (maxReconsumeTimes != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:                     requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</div><div class=\"line\"> <span class=\"number\">85</span>:                     MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</div><div class=\"line\"> <span class=\"number\">86</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">87</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">88</span>:             <span class=\"comment\">// 发送消息</span></div><div class=\"line\"> <span class=\"number\">89</span>:             SendResult sendResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:             <span class=\"keyword\">switch</span> (communicationMode) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:                 <span class=\"keyword\">case</span> ASYNC:</div><div class=\"line\"> <span class=\"number\">92</span>:                     sendResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">93</span>:                         brokerAddr, <span class=\"comment\">// 1</span></div><div class=\"line\"> <span class=\"number\">94</span>:                         mq.getBrokerName(), <span class=\"comment\">// 2</span></div><div class=\"line\"> <span class=\"number\">95</span>:                         msg, <span class=\"comment\">// 3</span></div><div class=\"line\"> <span class=\"number\">96</span>:                         requestHeader, <span class=\"comment\">// 4</span></div><div class=\"line\"> <span class=\"number\">97</span>:                         timeout, <span class=\"comment\">// 5</span></div><div class=\"line\"> <span class=\"number\">98</span>:                         communicationMode, <span class=\"comment\">// 6</span></div><div class=\"line\"> <span class=\"number\">99</span>:                         sendCallback, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">100</span>:                         topicPublishInfo, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">101</span>:                         <span class=\"keyword\">this</span>.mQClientFactory, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">102</span>:                         <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">103</span>:                         context, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">104</span>:                         <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">105</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">case</span> ONEWAY:</div><div class=\"line\"><span class=\"number\">107</span>:                 <span class=\"keyword\">case</span> SYNC:</div><div class=\"line\"><span class=\"number\">108</span>:                     sendResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</div><div class=\"line\"><span class=\"number\">109</span>:                         brokerAddr,</div><div class=\"line\"><span class=\"number\">110</span>:                         mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">111</span>:                         msg,</div><div class=\"line\"><span class=\"number\">112</span>:                         requestHeader,</div><div class=\"line\"><span class=\"number\">113</span>:                         timeout,</div><div class=\"line\"><span class=\"number\">114</span>:                         communicationMode,</div><div class=\"line\"><span class=\"number\">115</span>:                         context,</div><div class=\"line\"><span class=\"number\">116</span>:                         <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">117</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">118</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">119</span>:                     <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">120</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">121</span>:             &#125;</div><div class=\"line\"><span class=\"number\">122</span>:             <span class=\"comment\">// hook：发送消息后逻辑</span></div><div class=\"line\"><span class=\"number\">123</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:                 context.setSendResult(sendResult);</div><div class=\"line\"><span class=\"number\">125</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">126</span>:             &#125;</div><div class=\"line\"><span class=\"number\">127</span>:             <span class=\"comment\">// 返回发送结果</span></div><div class=\"line\"><span class=\"number\">128</span>:             <span class=\"keyword\">return</span> sendResult;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">132</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">133</span>:             &#125;</div><div class=\"line\"><span class=\"number\">134</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">135</span>:         &#125; <span class=\"keyword\">catch</span> (MQBrokerException e) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">137</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">139</span>:             &#125;</div><div class=\"line\"><span class=\"number\">140</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">141</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:                 context.setException(e);</div><div class=\"line\"><span class=\"number\">144</span>:                 <span class=\"keyword\">this</span>.executeSendMessageHookAfter(context);</div><div class=\"line\"><span class=\"number\">145</span>:             &#125;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">147</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:             msg.setBody(prevBody);</div><div class=\"line\"><span class=\"number\">149</span>:         &#125;</div><div class=\"line\"><span class=\"number\">150</span>:     &#125;</div><div class=\"line\"><span class=\"number\">151</span>:     <span class=\"comment\">// broker为空抛出异常</span></div><div class=\"line\"><span class=\"number\">152</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">153</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发送消息核心方法。该方法真正发起网络请求，发送消息给 <code>Broker</code>。</li>\n<li>第 21 行 ：生产消息编号，详细解析见<a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message 基础》</a>。</li>\n<li>第 64 至 121 行 ：构建发送消息请求<code>SendMessageRequestHeader</code>。</li>\n<li>第 107 至 117 行 ：执行 <code>MQClientInstance#sendMessage(...)</code> 发起网络请求。</li>\n</ul>\n<h1 id=\"3、Broker-接收消息\"><a href=\"#3、Broker-接收消息\" class=\"headerlink\" title=\"3、Broker 接收消息\"></a>3、Broker 接收消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_18/04.png\" alt=\"接收发送消息API顺序图\"></p>\n</blockquote>\n<h2 id=\"SendMessageProcessor-sendMessage\"><a href=\"#SendMessageProcessor-sendMessage\" class=\"headerlink\" title=\"SendMessageProcessor#sendMessage\"></a>SendMessageProcessor#sendMessage</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     SendMessageContext mqtraceContext;</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">switch</span> (request.getCode()) &#123;</div><div class=\"line\">  <span class=\"number\">5</span>:         <span class=\"keyword\">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</div><div class=\"line\">  <span class=\"number\">6</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.consumerSendMsgBack(ctx, request);</div><div class=\"line\">  <span class=\"number\">7</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"comment\">// 解析请求</span></div><div class=\"line\">  <span class=\"number\">9</span>:             SendMessageRequestHeader requestHeader = parseRequestHeader(request);</div><div class=\"line\"> <span class=\"number\">10</span>:             <span class=\"keyword\">if</span> (requestHeader == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">12</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">13</span>:             <span class=\"comment\">// 发送请求Context。在 hook 场景下使用</span></div><div class=\"line\"> <span class=\"number\">14</span>:             mqtraceContext = buildMsgContext(ctx, requestHeader);</div><div class=\"line\"> <span class=\"number\">15</span>:             <span class=\"comment\">// hook：处理发送消息前逻辑</span></div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"keyword\">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"comment\">// 处理发送消息逻辑</span></div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">final</span> RemotingCommand response = <span class=\"keyword\">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"comment\">// hook：处理发送消息后逻辑</span></div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">22</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">23</span>: &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, //</span></span></div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"keyword\">final</span> RemotingCommand request, //</div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"keyword\">final</span> SendMessageContext sendMessageContext, //</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">final</span> SendMessageRequestHeader requestHeader) <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"comment\">// 初始化响应</span></div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"keyword\">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader) response.readCustomHeader();</div><div class=\"line\"> <span class=\"number\">33</span>:     response.setOpaque(request.getOpaque());</div><div class=\"line\"> <span class=\"number\">34</span>:     response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getRegionId());</div><div class=\"line\"> <span class=\"number\">35</span>:     response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isTraceOn()));</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:         log.debug(<span class=\"string\">\"receive SendMessage request command, &#123;&#125;\"</span>, request);</div><div class=\"line\"> <span class=\"number\">39</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:     <span class=\"comment\">// 如果未开始接收消息，抛出系统异常</span></div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"SpellCheckingInspection\"</span>)</div><div class=\"line\"> <span class=\"number\">43</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startTimstamp = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</div><div class=\"line\"> <span class=\"number\">44</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStore().now() &lt; startTimstamp) &#123;</div><div class=\"line\"> <span class=\"number\">45</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">46</span>:         response.setRemark(String.format(<span class=\"string\">\"broker unable to service, until %s\"</span>, UtilAll.timeMillisToHumanString2(startTimstamp)));</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">48</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"comment\">// 消息配置(Topic配置）校验</span></div><div class=\"line\"> <span class=\"number\">51</span>:     response.setCode(-<span class=\"number\">1</span>);</div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"keyword\">super</span>.msgCheck(ctx, requestHeader, response);</div><div class=\"line\"> <span class=\"number\">53</span>:     <span class=\"keyword\">if</span> (response.getCode() != -<span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">54</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">55</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">56</span>: </div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] body = request.getBody();</div><div class=\"line\"> <span class=\"number\">58</span>: </div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"comment\">// 如果队列小于0，从可用队列随机选择</span></div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"keyword\">int</span> queueIdInt = requestHeader.getQueueId();</div><div class=\"line\"> <span class=\"number\">61</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">62</span>:     <span class=\"keyword\">if</span> (queueIdInt &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:         queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % topicConfig.getWriteQueueNums();</div><div class=\"line\"> <span class=\"number\">64</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">67</span>:     <span class=\"keyword\">int</span> sysFlag = requestHeader.getSysFlag();</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">if</span> (TopicFilterType.MULTI_TAG == topicConfig.getTopicFilterType()) &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:         sysFlag |= MessageSysFlag.MULTI_TAGS_FLAG;</div><div class=\"line\"> <span class=\"number\">70</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"comment\">// 对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)</span></div><div class=\"line\"> <span class=\"number\">73</span>:     String newTopic = requestHeader.getTopic();</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != newTopic &amp;&amp; newTopic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"comment\">// 获取订阅分组配置</span></div><div class=\"line\"> <span class=\"number\">76</span>:         String groupName = newTopic.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());</div><div class=\"line\"> <span class=\"number\">77</span>:         SubscriptionGroupConfig subscriptionGroupConfig =</div><div class=\"line\"> <span class=\"number\">78</span>:             <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(groupName);</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">81</span>:             response.setRemark(<span class=\"string\">\"subscription group not exist, \"</span> + groupName + <span class=\"string\">\" \"</span> + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</div><div class=\"line\"> <span class=\"number\">82</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"comment\">// 计算最大可消费次数</span></div><div class=\"line\"> <span class=\"number\">85</span>:         <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:             maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">88</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">int</span> reconsumeTimes = requestHeader.getReconsumeTimes() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : requestHeader.getReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">if</span> (reconsumeTimes &gt;= maxReconsumeTimes) &#123; <span class=\"comment\">// 超过最大消费次数</span></div><div class=\"line\"> <span class=\"number\">91</span>:             newTopic = MixAll.getDLQTopic(groupName);</div><div class=\"line\"> <span class=\"number\">92</span>:             queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % DLQ_NUMS_PER_GROUP;</div><div class=\"line\"> <span class=\"number\">93</span>:             topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">94</span>:                 DLQ_NUMS_PER_GROUP, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">95</span>:                 PermName.PERM_WRITE, <span class=\"number\">0</span></div><div class=\"line\"> <span class=\"number\">96</span>:             );</div><div class=\"line\"> <span class=\"number\">97</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">99</span>:                 response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">101</span>:             &#125;</div><div class=\"line\"><span class=\"number\">102</span>:         &#125;</div><div class=\"line\"><span class=\"number\">103</span>:     &#125;</div><div class=\"line\"><span class=\"number\">104</span>: </div><div class=\"line\"><span class=\"number\">105</span>:     <span class=\"comment\">// 创建MessageExtBrokerInner</span></div><div class=\"line\"><span class=\"number\">106</span>:     MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">107</span>:     msgInner.setTopic(newTopic);</div><div class=\"line\"><span class=\"number\">108</span>:     msgInner.setBody(body);</div><div class=\"line\"><span class=\"number\">109</span>:     msgInner.setFlag(requestHeader.getFlag());</div><div class=\"line\"><span class=\"number\">110</span>:     MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</div><div class=\"line\"><span class=\"number\">111</span>:     msgInner.setPropertiesString(requestHeader.getProperties());</div><div class=\"line\"><span class=\"number\">112</span>:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(topicConfig.getTopicFilterType(), msgInner.getTags()));</div><div class=\"line\"><span class=\"number\">113</span>:     msgInner.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">114</span>:     msgInner.setSysFlag(sysFlag);</div><div class=\"line\"><span class=\"number\">115</span>:     msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">116</span>:     msgInner.setBornHost(ctx.channel().remoteAddress());</div><div class=\"line\"><span class=\"number\">117</span>:     msgInner.setStoreHost(<span class=\"keyword\">this</span>.getStoreHost());</div><div class=\"line\"><span class=\"number\">118</span>:     msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : requestHeader.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:     <span class=\"comment\">// 校验是否不允许发送事务消息</span></div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:         String traFlag = msgInner.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">if</span> (traFlag != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"><span class=\"number\">125</span>:             response.setRemark(</div><div class=\"line\"><span class=\"number\">126</span>:                 <span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class=\"string\">\"] sending transaction message is forbidden\"</span>);</div><div class=\"line\"><span class=\"number\">127</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">128</span>:         &#125;</div><div class=\"line\"><span class=\"number\">129</span>:     &#125;</div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:     <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">132</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">134</span>:         <span class=\"keyword\">boolean</span> sendOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">135</span>: </div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">137</span>:             <span class=\"comment\">// Success</span></div><div class=\"line\"><span class=\"number\">138</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">139</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">140</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">141</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"><span class=\"number\">143</span>:                 response.setCode(ResponseCode.FLUSH_DISK_TIMEOUT);</div><div class=\"line\"><span class=\"number\">144</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">145</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"><span class=\"number\">147</span>:                 response.setCode(ResponseCode.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">148</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">149</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:             <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">151</span>:                 response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">152</span>:                 sendOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">153</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">154</span>: </div><div class=\"line\"><span class=\"number\">155</span>:             <span class=\"comment\">// Failed</span></div><div class=\"line\"><span class=\"number\">156</span>:             <span class=\"keyword\">case</span> CREATE_MAPEDFILE_FAILED:</div><div class=\"line\"><span class=\"number\">157</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">158</span>:                 response.setRemark(<span class=\"string\">\"create mapped file failed, server is busy or broken.\"</span>);</div><div class=\"line\"><span class=\"number\">159</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">160</span>:             <span class=\"keyword\">case</span> MESSAGE_ILLEGAL:</div><div class=\"line\"><span class=\"number\">161</span>:             <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"><span class=\"number\">162</span>:                 response.setCode(ResponseCode.MESSAGE_ILLEGAL);</div><div class=\"line\"><span class=\"number\">163</span>:                 response.setRemark(</div><div class=\"line\"><span class=\"number\">164</span>:                     <span class=\"string\">\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\"</span>);</div><div class=\"line\"><span class=\"number\">165</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">166</span>:             <span class=\"keyword\">case</span> SERVICE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">167</span>:                 response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">168</span>:                 response.setRemark(</div><div class=\"line\"><span class=\"number\">169</span>:                     <span class=\"string\">\"service not available now, maybe disk full, \"</span> + diskUtil() + <span class=\"string\">\", maybe your broker machine memory too small.\"</span>);</div><div class=\"line\"><span class=\"number\">170</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">171</span>:             <span class=\"keyword\">case</span> OS_PAGECACHE_BUSY:</div><div class=\"line\"><span class=\"number\">172</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">173</span>:                 response.setRemark(<span class=\"string\">\"[PC_SYNCHRONIZED]broker busy, start flow control for a while\"</span>);</div><div class=\"line\"><span class=\"number\">174</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">175</span>:             <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"><span class=\"number\">176</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">177</span>:                 response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR\"</span>);</div><div class=\"line\"><span class=\"number\">178</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">179</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">180</span>:                 response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">181</span>:                 response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR DEFAULT\"</span>);</div><div class=\"line\"><span class=\"number\">182</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">183</span>:         &#125;</div><div class=\"line\"><span class=\"number\">184</span>: </div><div class=\"line\"><span class=\"number\">185</span>:         String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);</div><div class=\"line\"><span class=\"number\">186</span>:         <span class=\"keyword\">if</span> (sendOK) &#123;</div><div class=\"line\"><span class=\"number\">187</span>:             <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">188</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic());</div><div class=\"line\"><span class=\"number\">189</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getWroteBytes());</div><div class=\"line\"><span class=\"number\">190</span>:             <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incBrokerPutNums();</div><div class=\"line\"><span class=\"number\">191</span>: </div><div class=\"line\"><span class=\"number\">192</span>:             <span class=\"comment\">// 响应</span></div><div class=\"line\"><span class=\"number\">193</span>:             response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">194</span>:             responseHeader.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());</div><div class=\"line\"><span class=\"number\">195</span>:             responseHeader.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">196</span>:             responseHeader.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());</div><div class=\"line\"><span class=\"number\">197</span>:             doResponse(ctx, request, response);</div><div class=\"line\"><span class=\"number\">198</span>: </div><div class=\"line\"><span class=\"number\">199</span>:             <span class=\"comment\">// hook：设置发送成功到context</span></div><div class=\"line\"><span class=\"number\">200</span>:             <span class=\"keyword\">if</span> (hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">201</span>:                 sendMessageContext.setMsgId(responseHeader.getMsgId());</div><div class=\"line\"><span class=\"number\">202</span>:                 sendMessageContext.setQueueId(responseHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">203</span>:                 sendMessageContext.setQueueOffset(responseHeader.getQueueOffset());</div><div class=\"line\"><span class=\"number\">204</span>: </div><div class=\"line\"><span class=\"number\">205</span>:                 <span class=\"keyword\">int</span> commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();</div><div class=\"line\"><span class=\"number\">206</span>:                 <span class=\"keyword\">int</span> wroteSize = putMessageResult.getAppendMessageResult().getWroteBytes();</div><div class=\"line\"><span class=\"number\">207</span>:                 <span class=\"keyword\">int</span> incValue = (<span class=\"keyword\">int</span>) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT) * commercialBaseCount;</div><div class=\"line\"><span class=\"number\">208</span>: </div><div class=\"line\"><span class=\"number\">209</span>:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_SUCCESS);</div><div class=\"line\"><span class=\"number\">210</span>:                 sendMessageContext.setCommercialSendTimes(incValue);</div><div class=\"line\"><span class=\"number\">211</span>:                 sendMessageContext.setCommercialSendSize(wroteSize);</div><div class=\"line\"><span class=\"number\">212</span>:                 sendMessageContext.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">213</span>:             &#125;</div><div class=\"line\"><span class=\"number\">214</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">215</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">216</span>:             <span class=\"comment\">// hook：设置发送失败到context</span></div><div class=\"line\"><span class=\"number\">217</span>:             <span class=\"keyword\">if</span> (hasSendMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">218</span>:                 <span class=\"keyword\">int</span> wroteSize = request.getBody().length;</div><div class=\"line\"><span class=\"number\">219</span>:                 <span class=\"keyword\">int</span> incValue = (<span class=\"keyword\">int</span>) Math.ceil(wroteSize / BrokerStatsManager.SIZE_PER_COUNT);</div><div class=\"line\"><span class=\"number\">220</span>: </div><div class=\"line\"><span class=\"number\">221</span>:                 sendMessageContext.setCommercialSendStats(BrokerStatsManager.StatsType.SEND_FAILURE);</div><div class=\"line\"><span class=\"number\">222</span>:                 sendMessageContext.setCommercialSendTimes(incValue);</div><div class=\"line\"><span class=\"number\">223</span>:                 sendMessageContext.setCommercialSendSize(wroteSize);</div><div class=\"line\"><span class=\"number\">224</span>:                 sendMessageContext.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">225</span>:             &#125;</div><div class=\"line\"><span class=\"number\">226</span>:         &#125;</div><div class=\"line\"><span class=\"number\">227</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">228</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">229</span>:         response.setRemark(<span class=\"string\">\"store putMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">230</span>:     &#125;</div><div class=\"line\"><span class=\"number\">231</span>: </div><div class=\"line\"><span class=\"number\">232</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">233</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#processRequest()</code> 说明 ：处理消息请求。</li>\n<li><code>#sendMessage()</code> 说明 ：发送消息，并返回发送消息结果。</li>\n<li>第 51 至 55 行 ：消息配置(Topic配置）校验，详细解析见：<a href=\"#abstractsendmessageprocessormsgcheck\">AbstractSendMessageProcessor#msgCheck()</a>。</li>\n<li>第 60 至 64 行 ：消息队列编号小于0时，<code>Broker</code> 可以设置随机选择一个消息队列。</li>\n<li>第 72 至 103 行 ：对RETRY类型的消息处理。如果超过最大消费次数，则topic修改成”%DLQ%” + 分组名， 即加  死信队 (Dead Letter Queue)，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n<li>第 105 至 118 行 ：创建<code>MessageExtBrokerInner</code>。</li>\n<li>第 132 ：存储消息，详细解析见：<a href=\"defaultmessagestoreputmessage\">DefaultMessageStore#putMessage()</a>。</li>\n<li>第 133 至 183 行 ：处理消息发送结果，设置响应结果和提示。</li>\n<li>第 186 至 214 行 ：发送成功，响应。这里<code>doResponse(ctx, request, response)</code>进行响应，最后<code>return null</code>，原因是：响应给 <code>Producer</code> 可能发生异常，<code>#doResponse(ctx, request, response)</code>捕捉了该异常并输出日志。这样做的话，我们进行排查 <code>Broker</code> 接收消息成功后响应是否存在异常会方便很多。</li>\n</ul>\n<h3 id=\"AbstractSendMessageProcessor-msgCheck\"><a href=\"#AbstractSendMessageProcessor-msgCheck\" class=\"headerlink\" title=\"AbstractSendMessageProcessor#msgCheck\"></a>AbstractSendMessageProcessor#msgCheck</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">protected</span> RemotingCommand <span class=\"title\">msgCheck</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx,</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:                                    <span class=\"keyword\">final</span> SendMessageRequestHeader requestHeader, <span class=\"keyword\">final</span> RemotingCommand response) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 检查 broker 是否有写入权限</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())</div><div class=\"line\"> <span class=\"number\">5</span>:         &amp;&amp; <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">7</span>:         response.setRemark(<span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</div><div class=\"line\"> <span class=\"number\">8</span>:             + <span class=\"string\">\"] sending message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">// 检查topic是否可以被发送。目前是&#123;@link MixAll.DEFAULT_TOPIC&#125;不被允许发送</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:         String errorMsg = <span class=\"string\">\"the topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] is conflict with system reserved words.\"</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         log.warn(errorMsg);</div><div class=\"line\"><span class=\"number\">15</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">16</span>:         response.setRemark(errorMsg);</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123; <span class=\"comment\">// 不能存在topicConfig，则进行创建</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">int</span> topicSysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (requestHeader.isUnitMode()) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"comment\">// 创建topic配置</span></div><div class=\"line\"><span class=\"number\">30</span>:         log.warn(<span class=\"string\">\"the topic &#123;&#125; not exist, producer: &#123;&#125;\"</span>, requestHeader.getTopic(), ctx.channel().remoteAddress());</div><div class=\"line\"><span class=\"number\">31</span>:         topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageMethod(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">32</span>:             requestHeader.getTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">33</span>:             requestHeader.getDefaultTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">34</span>:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">35</span>:             requestHeader.getDefaultTopicQueueNums(), topicSysFlag);</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 topicConfig =</div><div class=\"line\"><span class=\"number\">39</span>:                     <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</div><div class=\"line\"><span class=\"number\">40</span>:                         requestHeader.getTopic(), <span class=\"number\">1</span>, PermName.PERM_WRITE | PermName.PERM_READ,</div><div class=\"line\"><span class=\"number\">41</span>:                         topicSysFlag);</div><div class=\"line\"><span class=\"number\">42</span>:             &#125;</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"comment\">// 如果没配置</span></div><div class=\"line\"><span class=\"number\">45</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:             response.setCode(ResponseCode.TOPIC_NOT_EXIST);</div><div class=\"line\"><span class=\"number\">47</span>:             response.setRemark(<span class=\"string\">\"topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] not exist, apply first please!\"</span></div><div class=\"line\"><span class=\"number\">48</span>:                 + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</div><div class=\"line\"><span class=\"number\">49</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">50</span>:         &#125;</div><div class=\"line\"><span class=\"number\">51</span>:     &#125;</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"comment\">// 队列编号是否正确</span></div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"keyword\">int</span> queueIdInt = requestHeader.getQueueId();</div><div class=\"line\"><span class=\"number\">54</span>:     <span class=\"keyword\">int</span> idValid = Math.max(topicConfig.getWriteQueueNums(), topicConfig.getReadQueueNums());</div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (queueIdInt &gt;= idValid) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:         String errorInfo = String.format(<span class=\"string\">\"request queueId[%d] is illegal, %s Producer: %s\"</span>,</div><div class=\"line\"><span class=\"number\">57</span>:             queueIdInt,</div><div class=\"line\"><span class=\"number\">58</span>:             topicConfig.toString(),</div><div class=\"line\"><span class=\"number\">59</span>:             RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</div><div class=\"line\"><span class=\"number\">60</span>:         log.warn(errorInfo);</div><div class=\"line\"><span class=\"number\">61</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">62</span>:         response.setRemark(errorInfo);</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">64</span>:     &#125;</div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">66</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：校验消息是否正确，主要是Topic配置方面，例如：<code>Broker</code> 是否有写入权限，topic配置是否存在，队列编号是否正确。</li>\n<li>第 11 至 18 行 ：检查Topic是否可以被发送。目前是 <code>{@link MixAll.DEFAULT_TOPIC}</code> 不被允许发送。</li>\n<li>第 20 至 51 行 ：当找不到Topic配置，则进行创建。当然，创建会存在不成功的情况，例如说：<code>defaultTopic</code> 的Topic配置不存在，又或者是 存在但是不允许继承，详细解析见<a href=\"http://www.yunai.me/RocketMQ/topic/\">《RocketMQ 源码分析 —— Topic》</a>。</li>\n</ul>\n<h2 id=\"DefaultMessageStore-putMessage\"><a href=\"#DefaultMessageStore-putMessage\" class=\"headerlink\" title=\"DefaultMessageStore#putMessage\"></a>DefaultMessageStore#putMessage</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.shutdown) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         log.warn(<span class=\"string\">\"message store has shutdown, so putMessage is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">5</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 从节点不允许写入</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (BrokerRole.SLAVE == <span class=\"keyword\">this</span>.messageStoreConfig.getBrokerRole()) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">long</span> value = <span class=\"keyword\">this</span>.printTimes.getAndIncrement();</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">if</span> ((value % <span class=\"number\">50000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             log.warn(<span class=\"string\">\"message store is slave mode, so putMessage is forbidden \"</span>);</div><div class=\"line\"><span class=\"number\">12</span>:         &#125;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">15</span>:     &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">// store是否允许写入</span></div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.runningFlags.isWriteable()) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">long</span> value = <span class=\"keyword\">this</span>.printTimes.getAndIncrement();</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"keyword\">if</span> ((value % <span class=\"number\">50000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:             log.warn(<span class=\"string\">\"message store is not writeable, so putMessage is forbidden \"</span> + <span class=\"keyword\">this</span>.runningFlags.getFlagBits());</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">25</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">this</span>.printTimes.set(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">27</span>:     &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"comment\">// 消息过长</span></div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         log.warn(<span class=\"string\">\"putMessage message topic length too long \"</span> + msg.getTopic().length());</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">33</span>:     &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"comment\">// 消息附加属性过长</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">if</span> (msg.getPropertiesString() != <span class=\"keyword\">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:         log.warn(<span class=\"string\">\"putMessage message properties length too long \"</span> + msg.getPropertiesString().length());</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>:     &#125;</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isOSPageCacheBusy()) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"keyword\">long</span> beginTime = <span class=\"keyword\">this</span>.getSystemClock().now();</div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"comment\">// 添加消息到commitLog</span></div><div class=\"line\"><span class=\"number\">47</span>:     PutMessageResult result = <span class=\"keyword\">this</span>.commitLog.putMessage(msg);</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:     <span class=\"keyword\">long</span> eclipseTime = <span class=\"keyword\">this</span>.getSystemClock().now() - beginTime;</div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"keyword\">if</span> (eclipseTime &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         log.warn(<span class=\"string\">\"putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;\"</span>, eclipseTime, msg.getBody().length);</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>:     <span class=\"keyword\">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == result || !result.isOk()) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:         <span class=\"keyword\">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</div><div class=\"line\"><span class=\"number\">57</span>:     &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">60</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：存储消息封装，最终存储需要 <code>CommitLog</code> 实现。</li>\n<li>第 7 至 27 行 ：校验 <code>Broker</code> 是否可以写入。</li>\n<li>第 29 至 39 行 ：消息格式与大小校验。</li>\n<li>第 47 行 ：调用 <code>CommitLong</code> 进行存储，详细逻辑见：<a href=\"http://www.yunai.me/RocketMQ/message-store/\">《RocketMQ 源码分析 —— Message 存储》</a></li>\n</ul>\n<h1 id=\"4、某种结尾\"><a href=\"#4、某种结尾\" class=\"headerlink\" title=\"4、某种结尾\"></a>4、某种结尾</h1><p>感谢阅读、收藏、点赞本文的工程师同学。</p>\n<p>阅读源码是件令自己很愉悦的事情，编写源码解析是让自己脑细胞死伤无数的过程，痛并快乐着。</p>\n<p>如果有内容写的存在错误，或是不清晰的地方，见笑了，🙂。欢迎加 QQ：7685413 我们一起探讨，共进步。</p>\n<p>再次感谢阅读、收藏、点赞本文的工程师同学。</p>\n"},{"title":"RocketMQ 源码分析 —— Store 初始化与关闭","date":"2017-05-11T16:00:00.000Z","_content":"","source":"_posts/RocketMQ/2017_05_12_RocketMQ源码分析——Store初始化与关闭.md","raw":"title: RocketMQ 源码分析 —— Store 初始化与关闭\ndate: 2017-05-12\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/store-init-and-shutdown\n\n-------","slug":"RocketMQ/store-init-and-shutdown","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzae000rag5d303o6ea0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RocketMQ 源码分析 —— Message 存储","date":"2017-04-22T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-store/](http://www.yunai.me/RocketMQ/message-store/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、CommitLog 结构](#)\n- [3、CommitLog 存储消息](#)\n\t- [CommitLog#putMessage(...)](#)\n\t- [MappedFileQueue#getLastMappedFile(...)](#)\n\t- [MappedFile#appendMessage(...)](#)\n\t- [DefaultAppendMessageCallback#doAppend(...)](#)\n\t- [FlushCommitLogService](#)\n\t\t- [MappedFile#落盘](#)\n\t\t- [FlushRealTimeService](#)\n\t\t- [CommitRealTimeService](#)\n\t\t- [GroupCommitService](#)\n- [结尾](#)\n\n# 1、概述\n\n本文接[《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)。\n主要解析 `CommitLog` 存储消息部分。\n\n# 2、CommitLog 结构\n\n`CommitLog`、`MappedFileQueue`、`MappedFile` 的关系如下：\n\n> ![CommitLog、MappedFileQueue、MappedFile的关系](http://www.yunai.me/images/RocketMQ/2017_04_23/02.png)\n`CommitLog` : `MappedFileQueue` : `MappedFile` = 1 : 1 : N。\n\n反应到系统文件如下：\n\n```bash\nYunai-MacdeMacBook-Pro-2:commitlog yunai$ pwd\n/Users/yunai/store/commitlog\nYunai-MacdeMacBook-Pro-2:commitlog yunai$ ls -l\ntotal 10485760\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:27 00000000000000000000\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:29 00000000001073741824\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000002147483648\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:33 00000000003221225472\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000004294967296\n```\n\n-------\n\n`CommitLog`、`MappedFileQueue`、`MappedFile` 的定义如下：\n\n* `MappedFile` ：00000000000000000000、00000000001073741824、00000000002147483648等文件。\n* `MappedFileQueue` ：`MappedFile` 所在的文件夹，对 `MappedFile` 进行封装成文件队列，对上层提供可无限使用的文件容量。\n    * 每个 `MappedFile` 统一文件大小。\n    * 文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 `CommitLog` 里默认为 1GB。\n* `CommitLog` ：针对 `MappedFileQueue` 的封装使用。\n\n`CommitLog` 目前存储在 `MappedFile` 有两种内容类型：\n\n1. MESSAGE ：消息。\n2. BLANK ：文件不足以存储消息时的空白占位。\n\n`CommitLog` 存储在 `MappedFile`的结构：\n\n> | MESSAGE[1] | MESSAGE[2]  | ... | MESSAGE[n - 1] | MESSAGE[n] | BLANK |\n> | --- | --- | --- | --- | --- | --- |\n\n`MESSAGE` 在 `CommitLog` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | MsgLen | 消息总长度 | Int | 4 |\n| 2 | MagicCode | MESSAGE_MAGIC_CODE | Int | 4 |\n| 3 | BodyCRC | 消息内容CRC | Int | 4 |\n| 4 | QueueId | 消息队列编号 | Int | 4 |\n| 5 | Flag |  flag | Int  | 4 |\n| 6 | QueueOffset | 消息队列位置 | Long | 8 |\n| 7 | PhysicalOffset | 物理位置。在 `CommitLog` 的顺序存储位置。 | Long | 8 |\n| 8 | SysFlag | MessageSysFlag | Int | 4 |\n| 9 | BornTimestamp | 生成消息时间戳 | Long | 8 |\n| 10 | BornHost  | 生效消息的地址+端口 | Long | 8 |\n| 11 | StoreTimestamp | 存储消息时间戳 | Long | 8 |\n| 12 | StoreHost | 存储消息的地址+端口 | Long | 8 |\n| 13 | ReconsumeTimes | 重新消费消息次数 | Int | 4 |\n| 14 | PreparedTransationOffset |  | Long | 8 |\n| 15 | BodyLength + Body  | 内容长度 + 内容 | Int + Bytes | 4 + bodyLength |\n| 16 | TopicLength + Topic | Topic长度 + Topic | Byte + Bytes | 1 + topicLength |\n| 17 | PropertiesLength + Properties | 拓展字段长度 + 拓展字段 | Short + Bytes | 2 + PropertiesLength |\n\n`BLANK` 在 `CommitLog` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | maxBlank | 空白长度 | Int | 4 |\n| 2 | MagicCode | BLANK_MAGIC_CODE | Int | 4 |\n\n# 3、CommitLog 存储消息\n\n> ![Broker存储发送消息顺序图](http://www.yunai.me/images/RocketMQ/2017_04_23/01.png)\n\n## CommitLog#putMessage(...)\n\n```Java\n  1: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  2:     // Set the storage time\n  3:     msg.setStoreTimestamp(System.currentTimeMillis());\n  4:     // Set the message body BODY CRC (consider the most appropriate setting\n  5:     // on the client)\n  6:     msg.setBodyCRC(UtilAll.crc32(msg.getBody()));\n  7:     // Back to Results\n  8:     AppendMessageResult result = null;\n  9: \n 10:     StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n 11: \n 12:     String topic = msg.getTopic();\n 13:     int queueId = msg.getQueueId();\n 14: \n 15:     // 事务相关 TODO 待读：事务相关\n 16:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n 17:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//\n 18:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n 19:         // Delay Delivery\n 20:         if (msg.getDelayTimeLevel() > 0) {\n 21:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 22:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n 23:             }\n 24: \n 25:             topic = ScheduleMessageService.SCHEDULE_TOPIC;\n 26:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n 27: \n 28:             // Backup real topic, queueId\n 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n 30:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n 31:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n 32: \n 33:             msg.setTopic(topic);\n 34:             msg.setQueueId(queueId);\n 35:         }\n 36:     }\n 37: \n 38:     long eclipseTimeInLock = 0;\n 39: \n 40:     // 获取写入映射文件\n 41:     MappedFile unlockMappedFile = null;\n 42:     MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n 43: \n 44:     // 获取写入锁\n 45:     lockForPutMessage(); //spin...\n 46:     try {\n 47:         long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n 48:         this.beginTimeInLock = beginLockTimestamp;\n 49: \n 50:         // Here settings are stored timestamp, in order to ensure an orderly\n 51:         // global\n 52:         msg.setStoreTimestamp(beginLockTimestamp);\n 53: \n 54:         // 当不存在映射文件时，进行创建\n 55:         if (null == mappedFile || mappedFile.isFull()) {\n 56:             mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n 57:         }\n 58:         if (null == mappedFile) {\n 59:             log.error(\"create maped file1 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n 60:             beginTimeInLock = 0;\n 61:             return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);\n 62:         }\n 63: \n 64:         // 存储消息\n 65:         result = mappedFile.appendMessage(msg, this.appendMessageCallback);\n 66:         switch (result.getStatus()) {\n 67:             case PUT_OK:\n 68:                 break;\n 69:             case END_OF_FILE: // 当文件尾时，获取新的映射文件，并进行插入\n 70:                 unlockMappedFile = mappedFile;\n 71:                 // Create a new file, re-write the message\n 72:                 mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n 73:                 if (null == mappedFile) {\n 74:                     // XXX: warn and notify me\n 75:                     log.error(\"create maped file2 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n 76:                     beginTimeInLock = 0;\n 77:                     return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);\n 78:                 }\n 79:                 result = mappedFile.appendMessage(msg, this.appendMessageCallback);\n 80:                 break;\n 81:             case MESSAGE_SIZE_EXCEEDED:\n 82:             case PROPERTIES_SIZE_EXCEEDED:\n 83:                 beginTimeInLock = 0;\n 84:                 return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);\n 85:             case UNKNOWN_ERROR:\n 86:                 beginTimeInLock = 0;\n 87:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);\n 88:             default:\n 89:                 beginTimeInLock = 0;\n 90:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);\n 91:         }\n 92: \n 93:         eclipseTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n 94:         beginTimeInLock = 0;\n 95:     } finally {\n 96:         // 释放写入锁\n 97:         releasePutMessageLock();\n 98:     }\n 99: \n100:     if (eclipseTimeInLock > 500) {\n101:         log.warn(\"[NOTIFYME]putMessage in lock cost time(ms)={}, bodyLength={} AppendMessageResult={}\", eclipseTimeInLock, msg.getBody().length, result);\n102:     }\n103: \n104:     // \n105:     if (null != unlockMappedFile && this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n106:         this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n107:     }\n108: \n109:     PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n110: \n111:     // Statistics\n112:     storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();\n113:     storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());\n114: \n115:     // 进行同步||异步 flush||commit\n116:     GroupCommitRequest request = null;\n117:     // Synchronization flush\n118:     if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {\n119:         final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;\n120:         if (msg.isWaitStoreMsgOK()) {\n121:             request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n122:             service.putRequest(request);\n123:             boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n124:             if (!flushOK) {\n125:                 log.error(\"do groupcommit, wait for flush failed, topic: \" + msg.getTopic() + \" tags: \" + msg.getTags()\n126:                     + \" client address: \" + msg.getBornHostString());\n127:                 putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);\n128:             }\n129:         } else {\n130:             service.wakeup();\n131:         }\n132:     }\n133:     // Asynchronous flush\n134:     else {\n135:         if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n136:             flushCommitLogService.wakeup(); // important：唤醒commitLog线程，进行flush\n137:         } else {\n138:             commitLogService.wakeup();\n139:         }\n140:     }\n141: \n142:     // Synchronous write double 如果是同步Master，同步到从节点 // TODO 待读：数据同步\n143:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {\n144:         HAService service = this.defaultMessageStore.getHaService();\n145:         if (msg.isWaitStoreMsgOK()) {\n146:             // Determine whether to wait\n147:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {\n148:                 if (null == request) {\n149:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n150:                 }\n151:                 service.putRequest(request);\n152: \n153:                 service.getWaitNotifyObject().wakeupAll();\n154: \n155:                 boolean flushOK =\n156:                     // TODO\n157:                     request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n158:                 if (!flushOK) {\n159:                     log.error(\"do sync transfer other node, wait return, but failed, topic: \" + msg.getTopic() + \" tags: \"\n160:                         + msg.getTags() + \" client address: \" + msg.getBornHostString());\n161:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);\n162:                 }\n163:             }\n164:             // Slave problem\n165:             else {\n166:                 // Tell the producer, slave not available\n167:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);\n168:             }\n169:         }\n170:     }\n171: \n172:     return putMessageResult;\n173: }\n```\n\n* 说明 ：存储消息，并返回存储结果。\n* 第 2 行 ：设置存储时间等。\n* 第 16 至 36 行 ：事务消息相关，暂未了解。\n* 第 45 & 97 行 ：获取锁与释放锁。\n* 第 52 行 ：再次设置存储时间。目前会有多处地方设置存储时间。\n* 第 55 至 62 行 ：获取 `MappedFile`，若不存在或已满，则进行创建。详细解析见：[MappedFileQueue#getLastMappedFile(...)](#mappedfilequeuegetlastmappedfile)。\n* 第 65 行 ：**插入消息**到 `MappedFile`，解析解析见：[MappedFile#appendMessage(...)](#mappedfileappendmessage)。\n* 第 69 至 80 行 ：`MappedFile` 已满，创建新的，再次**插入消息**。\n* 第 116 至 140 行 ：**消息刷盘**，即持久化到文件。上面**插入消息**实际未存储到硬盘。此处，根据不同的刷盘策略，执行会有不同。详细解析见：[FlushCommitLogService](#flushcommitlogservice)。\n* 第 143 至 173 行 ：`Broker` 主从同步。后面的文章会详细解析😈。\n\n## MappedFileQueue#getLastMappedFile(...)\n\n```Java\n  1: public MappedFile getLastMappedFile(final long startOffset, boolean needCreate) {\n  2:     long createOffset = -1; // 创建文件开始offset。-1时，不创建\n  3:     MappedFile mappedFileLast = getLastMappedFile();\n  4: \n  5:     if (mappedFileLast == null) { // 一个映射文件都不存在\n  6:         createOffset = startOffset - (startOffset % this.mappedFileSize);\n  7:     }\n  8: \n  9:     if (mappedFileLast != null && mappedFileLast.isFull()) { // 最后一个文件已满\n 10:         createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;\n 11:     }\n 12: \n 13:     if (createOffset != -1 && needCreate) { // 创建文件\n 14:         String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);\n 15:         String nextNextFilePath = this.storePath + File.separator\n 16:             + UtilAll.offset2FileName(createOffset + this.mappedFileSize);\n 17:         MappedFile mappedFile = null;\n 18: \n 19:         if (this.allocateMappedFileService != null) {\n 20:             mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,\n 21:                 nextNextFilePath, this.mappedFileSize);\n 22:         } else {\n 23:             try {\n 24:                 mappedFile = new MappedFile(nextFilePath, this.mappedFileSize);\n 25:             } catch (IOException e) {\n 26:                 log.error(\"create mappedFile exception\", e);\n 27:             }\n 28:         }\n 29: \n 30:         if (mappedFile != null) {\n 31:             if (this.mappedFiles.isEmpty()) {\n 32:                 mappedFile.setFirstCreateInQueue(true);\n 33:             }\n 34:             this.mappedFiles.add(mappedFile);\n 35:         }\n 36: \n 37:         return mappedFile;\n 38:     }\n 39: \n 40:     return mappedFileLast;\n 41: }\n```\n\n* 说明 ：获取最后一个 `MappedFile`，若不存在或文件已满，则进行创建。\n* 第 5 至 11 行 ：计算当文件不存在或已满时，新创建文件的 `createOffset`。\n* 第 14 行 ：计算文件名。从此处我们可\n以得知，`MappedFile`的文件命名规则：\n\n    > fileName[n] = fileName[n - 1] + n * mappedFileSize\n    > fileName[0] = startOffset - (startOffset % this.mappedFileSize)\n    \n    目前 `CommitLog` 的 `startOffset` 为 0。\n    此处有个**疑问**，为什么需要 `(startOffset % this.mappedFileSize)`。例如：\n    \n    | startOffset  | mappedFileSize | createOffset |\n    | --- | :-- | :-- |\n    | 5 | 1 | 5 |\n    | 5 | 2 | 4 |\n    | 5 | 3 | 3  |\n    | 5 | 4 | 4 |\n    | 5 | > 5 | 0 |\n    \n    _如果有知道的同学，麻烦提示下。😈_\n    *解答：fileName[0] = startOffset - (startOffset % this.mappedFileSize) 计算出来的是，以 `this.mappedFileSize` 为每个文件大小时，`startOffset` 所在文件的开始`offset`*\n    \n* 第 30 至 35 行 ：设置 `MappedFile`是否是第一个创建的文件。该标识用于 `ConsumeQueue` 对应的 `MappedFile` ，详见 `ConsumeQueue#fillPreBlank`。\n    \n## MappedFile#appendMessage(...)\n\n```Java\n  1: public AppendMessageResult appendMessage(final MessageExtBrokerInner msg, final AppendMessageCallback cb) {\n  2:     assert msg != null;\n  3:     assert cb != null;\n  4: \n  5:     int currentPos = this.wrotePosition.get();\n  6: \n  7:     if (currentPos < this.fileSize) {\n  8:         ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();\n  9:         byteBuffer.position(currentPos);\n 10:         AppendMessageResult result =\n 11:             cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, msg);\n 12:         this.wrotePosition.addAndGet(result.getWroteBytes());\n 13:         this.storeTimestamp = result.getStoreTimestamp();\n 14:         return result;\n 15:     }\n 16: \n 17:     log.error(\"MappedFile.appendMessage return null, wrotePosition: \" + currentPos + \" fileSize: \"\n 18:         + this.fileSize);\n 19:     return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);\n 20: }\n```\n\n* 说明 ：**插入消息**到 `MappedFile`，并返回插入结果。\n* 第 8 行 ：获取需要写入的字节缓冲区。为什么会有 `writeBuffer != null` 的判断后，使用不同的字节缓冲区，见：[FlushCommitLogService](#flushcommitlogservice)。\n* 第 9 至 11 行 ：设置写入 `position`，执行写入，更新 `wrotePosition`(当前写入位置，下次开始写入开始位置)。\n\n## DefaultAppendMessageCallback#doAppend(...)\n\n```Java\n  1: class DefaultAppendMessageCallback implements AppendMessageCallback {\n  2:     // File at the end of the minimum fixed length empty\n  3:     private static final int END_FILE_MIN_BLANK_LENGTH = 4 + 4;\n  4:     /**\n  5:      * 存储在内存中的消息编号字节Buffer\n  6:      */\n  7:     private final ByteBuffer msgIdMemory;\n  8:     /**\n  9:      * Store the message content\n 10:      * 存储在内存中的消息字节Buffer\n 11:      * 当消息传递到{@link #doAppend(long, ByteBuffer, int, MessageExtBrokerInner)}方法时，最终写到该参数\n 12:      */\n 13:     private final ByteBuffer msgStoreItemMemory;\n 14:     /**\n 15:      * The maximum length of the message\n 16:      * 消息最大长度\n 17:      */\n 18:     private final int maxMessageSize;\n 19:     /**\n 20:      * Build Message Key\n 21:      * {@link #topicQueueTable}的key\n 22:      * 计算方式：topic + \"-\" + queueId\n 23:      */\n 24:     private final StringBuilder keyBuilder = new StringBuilder();\n 25:     /**\n 26:      * host字节buffer\n 27:      * 用于重复计算host的字节内容\n 28:      */\n 29:     private final ByteBuffer hostHolder = ByteBuffer.allocate(8);\n 30: \n 31:     DefaultAppendMessageCallback(final int size) {\n 32:         this.msgIdMemory = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);\n 33:         this.msgStoreItemMemory = ByteBuffer.allocate(size + END_FILE_MIN_BLANK_LENGTH);\n 34:         this.maxMessageSize = size;\n 35:     }\n 36: \n 37:     public ByteBuffer getMsgStoreItemMemory() {\n 38:         return msgStoreItemMemory;\n 39:     }\n 40: \n 41:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner) {\n 42:         // STORETIMESTAMP + STOREHOSTADDRESS + OFFSET <br>\n 43: \n 44:         // PHY OFFSET\n 45:         long wroteOffset = fileFromOffset + byteBuffer.position();\n 46: \n 47:         // 计算commitLog里的msgId\n 48:         this.resetByteBuffer(hostHolder, 8);\n 49:         String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);\n 50: \n 51:         // Record ConsumeQueue information 获取队列offset\n 52:         keyBuilder.setLength(0);\n 53:         keyBuilder.append(msgInner.getTopic());\n 54:         keyBuilder.append('-');\n 55:         keyBuilder.append(msgInner.getQueueId());\n 56:         String key = keyBuilder.toString();\n 57:         Long queueOffset = CommitLog.this.topicQueueTable.get(key);\n 58:         if (null == queueOffset) {\n 59:             queueOffset = 0L;\n 60:             CommitLog.this.topicQueueTable.put(key, queueOffset);\n 61:         }\n 62: \n 63:         // Transaction messages that require special handling // TODO 疑问：用途\n 64:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());\n 65:         switch (tranType) {\n 66:             // Prepared and Rollback message is not consumed, will not enter the\n 67:             // consumer queue\n 68:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n 69:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n 70:                 queueOffset = 0L;\n 71:                 break;\n 72:             case MessageSysFlag.TRANSACTION_NOT_TYPE:\n 73:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n 74:             default:\n 75:                 break;\n 76:         }\n 77: \n 78:         // 计算消息长度\n 79:         final byte[] propertiesData =\n 80:             msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);\n 81:         final int propertiesLength = propertiesData == null ? 0 : propertiesData.length;\n 82:         if (propertiesLength > Short.MAX_VALUE) {\n 83:             log.warn(\"putMessage message properties length too long. length={}\", propertiesData.length);\n 84:             return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);\n 85:         }\n 86:         final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);\n 87:         final int topicLength = topicData.length;\n 88:         final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length;\n 89:         final int msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);\n 90:         // Exceeds the maximum message\n 91:         if (msgLen > this.maxMessageSize) {\n 92:             CommitLog.log.warn(\"message size exceeded, msg total size: \" + msgLen + \", msg body size: \" + bodyLength\n 93:                 + \", maxMessageSize: \" + this.maxMessageSize);\n 94:             return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);\n 95:         }\n 96: \n 97:         // Determines whether there is sufficient(足够) free space\n 98:         if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {\n 99:             this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);\n100:             // 1 TOTAL_SIZE\n101:             this.msgStoreItemMemory.putInt(maxBlank);\n102:             // 2 MAGIC_CODE\n103:             this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);\n104:             // 3 The remaining space may be any value\n105:             //\n106: \n107:             // Here the length of the specially set maxBlank\n108:             final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n109:             byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);\n110:             return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),\n111:                 queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n112:         }\n113: \n114:         // Initialization of storage space\n115:         this.resetByteBuffer(msgStoreItemMemory, msgLen);\n116:         // 1 TOTAL_SIZE\n117:         this.msgStoreItemMemory.putInt(msgLen);\n118:         // 2 MAGIC_CODE\n119:         this.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);\n120:         // 3 BODY_CRC\n121:         this.msgStoreItemMemory.putInt(msgInner.getBodyCRC());\n122:         // 4 QUEUE_ID\n123:         this.msgStoreItemMemory.putInt(msgInner.getQueueId());\n124:         // 5 FLAG\n125:         this.msgStoreItemMemory.putInt(msgInner.getFlag());\n126:         // 6 QUEUE_OFFSET\n127:         this.msgStoreItemMemory.putLong(queueOffset);\n128:         // 7 PHYSICAL_OFFSET\n129:         this.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());\n130:         // 8 SYS_FLAG\n131:         this.msgStoreItemMemory.putInt(msgInner.getSysFlag());\n132:         // 9 BORN_TIMESTAMP\n133:         this.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());\n134:         // 10 BORN_HOST\n135:         this.resetByteBuffer(hostHolder, 8);\n136:         this.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));\n137:         // 11 STORE_TIMESTAMP\n138:         this.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());\n139:         // 12 STORE_HOST_ADDRESS\n140:         this.resetByteBuffer(hostHolder, 8);\n141:         this.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));\n142:         //this.msgStoreItemMemory.put(msgInner.getStoreHostBytes());\n143:         // 13 RECONSUME_TIMES\n144:         this.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());\n145:         // 14 Prepared Transaction Offset\n146:         this.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());\n147:         // 15 BODY\n148:         this.msgStoreItemMemory.putInt(bodyLength);\n149:         if (bodyLength > 0)\n150:             this.msgStoreItemMemory.put(msgInner.getBody());\n151:         // 16 TOPIC\n152:         this.msgStoreItemMemory.put((byte) topicLength);\n153:         this.msgStoreItemMemory.put(topicData);\n154:         // 17 PROPERTIES\n155:         this.msgStoreItemMemory.putShort((short) propertiesLength);\n156:         if (propertiesLength > 0)\n157:             this.msgStoreItemMemory.put(propertiesData);\n158: \n159:         final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n160:         // Write messages to the queue buffer\n161:         byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);\n162: \n163:         AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,\n164:             msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n165: \n166:         switch (tranType) {\n167:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n168:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n169:                 break;\n170:             case MessageSysFlag.TRANSACTION_NOT_TYPE:\n171:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n172:                 // The next update ConsumeQueue information 更新队列的offset\n173:                 CommitLog.this.topicQueueTable.put(key, ++queueOffset);\n174:                 break;\n175:             default:\n176:                 break;\n177:         }\n178:         return result;\n179:     }\n180: \n181:     /**\n182:      * 重置字节缓冲区\n183:      *\n184:      * @param byteBuffer 字节缓冲区\n185:      * @param limit 长度\n186:      */\n187:     private void resetByteBuffer(final ByteBuffer byteBuffer, final int limit) {\n188:         byteBuffer.flip();\n189:         byteBuffer.limit(limit);\n190:     }\n191: }\n```\n* 说明 ：插入消息到字节缓冲区。\n* 第 45 行 ：计算物理位置。在 `CommitLog` 的顺序存储位置。\n* 第 47 至 49 行 ：计算 `CommitLog` 里的 `offsetMsgId`。这里一定要和 `msgId` 区分开。\n\n|   |   | 计算方式 | 长度 | |\n| --- | --- | --- | --- |  --- |\n| offsetMsgId | Broker存储时生成 | Hex(storeHostBytes, wroteOffset) | 32 |\n| msgId | Client发送消息时生成 | Hex(进程编号, IP, ClassLoader, startTime, currentTime, 自增序列) | 32 | [《RocketMQ 源码分析 —— Message 基础》](http://www.yunai.me/RocketMQ/message/) |\n\n* 第 51 至 61 行 ：获取队列位置(offset)。\n* 第 78 至 95 行 ：计算消息总长度。\n* 第 98 至 112 行 ：当文件剩余空间不足时，写入 `BLANK` 占位，返回结果。\n* 第 114 至 161 行 ：写入 `MESSAGE` 。\n* 第 173 行 ：更新队列位置(offset)。\n\n## FlushCommitLogService\n\n![FlushCommitLogService类图](http://www.yunai.me/images/RocketMQ/2017_04_23/03.png)\n\n| 线程服务 | 场景 | 插入消息性能 |\n| --- | --- | --- |\n| CommitRealTimeService | 异步刷盘 && 开启内存字节缓冲区 | 第一 |\n| FlushRealTimeService | 异步刷盘 && 关闭内存字节缓冲区 | 第二 |\n| GroupCommitService | 同步刷盘 | 第三 |\n\n### MappedFile#落盘\n\n\n| 方式 |   |  |  |\n| --- | --- | :-- | :-- |\n| 方式一 | 写入内存字节缓冲区(writeBuffer) | 从内存字节缓冲区(write buffer)提交(commit)到文件通道(fileChannel) | 文件通道(fileChannel)flush |\n| 方式二 |  | 写入映射文件字节缓冲区(mappedByteBuffer) | 映射文件字节缓冲区(mappedByteBuffer)flush  |\n\n![MappedFile的position迁移图](http://www.yunai.me/images/RocketMQ/2017_04_23/04.jpeg)\n\n**flush相关代码**\n\n考虑到写入性能，满足 `flushLeastPages * OS_PAGE_SIZE` 才进行 `flush`。\n\n```Java\n  1: /**\n  2:  * flush\n  3:  *\n  4:  * @param flushLeastPages flush最小页数\n  5:  * @return The current flushed position\n  6:  */\n  7: public int flush(final int flushLeastPages) {\n  8:     if (this.isAbleToFlush(flushLeastPages)) {\n  9:         if (this.hold()) {\n 10:             int value = getReadPosition();\n 11: \n 12:             try {\n 13:                 //We only append data to fileChannel or mappedByteBuffer, never both.\n 14:                 if (writeBuffer != null || this.fileChannel.position() != 0) {\n 15:                     this.fileChannel.force(false);\n 16:                 } else {\n 17:                     this.mappedByteBuffer.force();\n 18:                 }\n 19:             } catch (Throwable e) {\n 20:                 log.error(\"Error occurred when force data to disk.\", e);\n 21:             }\n 22: \n 23:             this.flushedPosition.set(value);\n 24:             this.release();\n 25:         } else {\n 26:             log.warn(\"in flush, hold failed, flush offset = \" + this.flushedPosition.get());\n 27:             this.flushedPosition.set(getReadPosition());\n 28:         }\n 29:     }\n 30:     return this.getFlushedPosition();\n 31: }\n 32: \n 33: /**\n 34:  * 是否能够flush。满足如下条件任意条件：\n 35:  * 1. 映射文件已经写满\n 36:  * 2. flushLeastPages > 0 && 未flush部分超过flushLeastPages\n 37:  * 3. flushLeastPages = 0 && 有新写入部分\n 38:  *\n 39:  * @param flushLeastPages flush最小分页\n 40:  * @return 是否能够写入\n 41:  */\n 42: private boolean isAbleToFlush(final int flushLeastPages) {\n 43:     int flush = this.flushedPosition.get();\n 44:     int write = getReadPosition();\n 45: \n 46:     if (this.isFull()) {\n 47:         return true;\n 48:     }\n 49: \n 50:     if (flushLeastPages > 0) {\n 51:         return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) >= flushLeastPages;\n 52:     }\n 53: \n 54:     return write > flush;\n 55: }\n```\n\n**commit相关代码：**\n\n考虑到写入性能，满足 `commitLeastPages * OS_PAGE_SIZE` 才进行 `commit`。\n\n```Java\n  1: /**\n  2:  * commit\n  3:  * 当{@link #writeBuffer}为null时，直接返回{@link #wrotePosition}\n  4:  *\n  5:  * @param commitLeastPages commit最小页数\n  6:  * @return 当前commit位置\n  7:  */\n  8: public int commit(final int commitLeastPages) {\n  9:     if (writeBuffer == null) {\n 10:         //no need to commit data to file channel, so just regard wrotePosition as committedPosition.\n 11:         return this.wrotePosition.get();\n 12:     }\n 13:     if (this.isAbleToCommit(commitLeastPages)) {\n 14:         if (this.hold()) {\n 15:             commit0(commitLeastPages);\n 16:             this.release();\n 17:         } else {\n 18:             log.warn(\"in commit, hold failed, commit offset = \" + this.committedPosition.get());\n 19:         }\n 20:     }\n 21: \n 22:     // All dirty data has been committed to FileChannel. 写到文件尾时，回收writeBuffer。\n 23:     if (writeBuffer != null && this.transientStorePool != null && this.fileSize == this.committedPosition.get()) {\n 24:         this.transientStorePool.returnBuffer(writeBuffer);\n 25:         this.writeBuffer = null;\n 26:     }\n 27: \n 28:     return this.committedPosition.get();\n 29: }\n 30: \n 31: /**\n 32:  * commit实现，将writeBuffer写入fileChannel。\n 33:  * @param commitLeastPages commit最小页数。用不上该参数\n 34:  */\n 35: protected void commit0(final int commitLeastPages) {\n 36:     int writePos = this.wrotePosition.get();\n 37:     int lastCommittedPosition = this.committedPosition.get();\n 38: \n 39:     if (writePos - this.committedPosition.get() > 0) {\n 40:         try {\n 41:             // 设置需要写入的byteBuffer\n 42:             ByteBuffer byteBuffer = writeBuffer.slice();\n 43:             byteBuffer.position(lastCommittedPosition);\n 44:             byteBuffer.limit(writePos);\n 45:             // 写入fileChannel\n 46:             this.fileChannel.position(lastCommittedPosition);\n 47:             this.fileChannel.write(byteBuffer);\n 48:             // 设置position\n 49:             this.committedPosition.set(writePos);\n 50:         } catch (Throwable e) {\n 51:             log.error(\"Error occurred when commit data to FileChannel.\", e);\n 52:         }\n 53:     }\n 54: }\n 55: \n 56: /**\n 57:  * 是否能够commit。满足如下条件任意条件：\n 58:  * 1. 映射文件已经写满\n 59:  * 2. commitLeastPages > 0 && 未commit部分超过commitLeastPages\n 60:  * 3. commitLeastPages = 0 && 有新写入部分\n 61:  *\n 62:  * @param commitLeastPages commit最小分页\n 63:  * @return 是否能够写入\n 64:  */\n 65: protected boolean isAbleToCommit(final int commitLeastPages) {\n 66:     int flush = this.committedPosition.get();\n 67:     int write = this.wrotePosition.get();\n 68: \n 69:     if (this.isFull()) {\n 70:         return true;\n 71:     }\n 72: \n 73:     if (commitLeastPages > 0) {\n 74:         return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) >= commitLeastPages;\n 75:     }\n 76: \n 77:     return write > flush;\n 78: }\n```\n\n### FlushRealTimeService\n\n消息插入成功时，异步刷盘时使用。\n\n```Java\n  1: class FlushRealTimeService extends FlushCommitLogService {\n  2:     /**\n  3:      * 最后flush时间戳\n  4:      */\n  5:     private long lastFlushTimestamp = 0;\n  6:     /**\n  7:      * print计时器。\n  8:      * 满足print次数时，调用{@link #printFlushProgress()}\n  9:      */\n 10:     private long printTimes = 0;\n 11: \n 12:     public void run() {\n 13:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 14: \n 15:         while (!this.isStopped()) {\n 16:             boolean flushCommitLogTimed = CommitLog.this.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();\n 17:             int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();\n 18:             int flushPhysicQueueLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();\n 19:             int flushPhysicQueueThoroughInterval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();\n 20: \n 21:             // Print flush progress\n 22:             // 当时间满足flushPhysicQueueThoroughInterval时，即使写入的数量不足flushPhysicQueueLeastPages，也进行flush\n 23:             boolean printFlushProgress = false;\n 24:             long currentTimeMillis = System.currentTimeMillis();\n 25:             if (currentTimeMillis >= (this.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) {\n 26:                 this.lastFlushTimestamp = currentTimeMillis;\n 27:                 flushPhysicQueueLeastPages = 0;\n 28:                 printFlushProgress = (printTimes++ % 10) == 0;\n 29:             }\n 30: \n 31:             try {\n 32:                 // 等待执行\n 33:                 if (flushCommitLogTimed) {\n 34:                     Thread.sleep(interval);\n 35:                 } else {\n 36:                     this.waitForRunning(interval);\n 37:                 }\n 38: \n 39:                 if (printFlushProgress) {\n 40:                     this.printFlushProgress();\n 41:                 }\n 42: \n 43:                 // flush commitLog\n 44:                 long begin = System.currentTimeMillis();\n 45:                 CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages);\n 46:                 long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();\n 47:                 if (storeTimestamp > 0) {\n 48:                     CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);\n 49:                 }\n 50:                 long past = System.currentTimeMillis() - begin;\n 51:                 if (past > 500) {\n 52:                     log.info(\"Flush data to disk costs {} ms\", past);\n 53:                 }\n 54:             } catch (Throwable e) {\n 55:                 CommitLog.log.warn(this.getServiceName() + \" service has exception. \", e);\n 56:                 this.printFlushProgress();\n 57:             }\n 58:         }\n 59: \n 60:         // Normal shutdown, to ensure that all the flush before exit\n 61:         boolean result = false;\n 62:         for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n 63:             result = CommitLog.this.mappedFileQueue.flush(0);\n 64:             CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n 65:         }\n 66: \n 67:         this.printFlushProgress();\n 68: \n 69:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 70:     }\n 71: \n 72:     @Override\n 73:     public String getServiceName() {\n 74:         return FlushRealTimeService.class.getSimpleName();\n 75:     }\n 76: \n 77:     private void printFlushProgress() {\n 78:         // CommitLog.log.info(\"how much disk fall behind memory, \"\n 79:         // + CommitLog.this.mappedFileQueue.howMuchFallBehind());\n 80:     }\n 81: \n 82:     @Override\n 83:     @SuppressWarnings(\"SpellCheckingInspection\")\n 84:     public long getJointime() {\n 85:         return 1000 * 60 * 5;\n 86:     }\n 87: }\n```\n\n* 说明：实时 `flush `线程服务，调用 `MappedFile#flush` 相关逻辑。\n* 第 23 至 29 行 ：每 `flushPhysicQueueThoroughInterval` 周期，执行一次 `flush` 。因为不是每次循环到都能满足 `flushCommitLogLeastPages` 大小，因此，需要一定周期进行一次强制 `flush` 。当然，不能每次循环都去执行强制 `flush`，这样性能较差。\n* 第 33 行 至 37 行 ：根据 `flushCommitLogTimed` 参数，可以选择每次循环是**固定周期**还是**等待唤醒**。默认配置是后者，所以，每次插入消息完成，会去调用 `commitLogService.wakeup()` 。\n* 第 45 行 ：调用 `MappedFile` 进行 `flush`。\n* 第 61 至 65 行 ：`Broker` 关闭时，强制 `flush`，避免有未刷盘的数据。\n\n### CommitRealTimeService\n\n消息插入成功时，异步刷盘时使用。\n和 `FlushRealTimeService` 类似，性能更好。\n\n```Java\n  1: class CommitRealTimeService extends FlushCommitLogService {\n  2: \n  3:     /**\n  4:      * 最后 commit 时间戳\n  5:      */\n  6:     private long lastCommitTimestamp = 0;\n  7: \n  8:     @Override\n  9:     public String getServiceName() {\n 10:         return CommitRealTimeService.class.getSimpleName();\n 11:     }\n 12: \n 13:     @Override\n 14:     public void run() {\n 15:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 16:         while (!this.isStopped()) {\n 17:             int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();\n 18:             int commitDataLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();\n 19:             int commitDataThoroughInterval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();\n 20: \n 21:             // 当时间满足commitDataThoroughInterval时，即使写入的数量不足commitDataLeastPages，也进行flush\n 22:             long begin = System.currentTimeMillis();\n 23:             if (begin >= (this.lastCommitTimestamp + commitDataThoroughInterval)) {\n 24:                 this.lastCommitTimestamp = begin;\n 25:                 commitDataLeastPages = 0;\n 26:             }\n 27: \n 28:             try {\n 29:                 // commit\n 30:                 boolean result = CommitLog.this.mappedFileQueue.commit(commitDataLeastPages);\n 31:                 long end = System.currentTimeMillis();\n 32:                 if (!result) { // TODO 疑问：未写入成功，为啥要唤醒flushCommitLogService\n 33:                     this.lastCommitTimestamp = end; // result = false means some data committed.\n 34:                     //now wake up flush thread.\n 35:                     flushCommitLogService.wakeup();\n 36:                 }\n 37: \n 38:                 if (end - begin > 500) {\n 39:                     log.info(\"Commit data to file costs {} ms\", end - begin);\n 40:                 }\n 41: \n 42:                 // 等待执行\n 43:                 this.waitForRunning(interval);\n 44:             } catch (Throwable e) {\n 45:                 CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n 46:             }\n 47:         }\n 48: \n 49:         boolean result = false;\n 50:         for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n 51:             result = CommitLog.this.mappedFileQueue.commit(0);\n 52:             CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n 53:         }\n 54:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 55:     }\n 56: }\n```\n\n### GroupCommitService\n\n消息插入成功时，同步刷盘时使用。\n\n```Java\n  1: class GroupCommitService extends FlushCommitLogService {\n  2:     /**\n  3:      * 写入请求队列\n  4:      */\n  5:     private volatile List<GroupCommitRequest> requestsWrite = new ArrayList<>();\n  6:     /**\n  7:      * 读取请求队列\n  8:      */\n  9:     private volatile List<GroupCommitRequest> requestsRead = new ArrayList<>();\n 10: \n 11:     /**\n 12:      * 添加写入请求\n 13:      *\n 14:      * @param request 写入请求\n 15:      */\n 16:     public synchronized void putRequest(final GroupCommitRequest request) {\n 17:         // 添加写入请求\n 18:         synchronized (this.requestsWrite) {\n 19:             this.requestsWrite.add(request);\n 20:         }\n 21:         // 切换读写队列\n 22:         if (hasNotified.compareAndSet(false, true)) {\n 23:             waitPoint.countDown(); // notify\n 24:         }\n 25:     }\n 26: \n 27:     /**\n 28:      * 切换读写队列\n 29:      */\n 30:     private void swapRequests() {\n 31:         List<GroupCommitRequest> tmp = this.requestsWrite;\n 32:         this.requestsWrite = this.requestsRead;\n 33:         this.requestsRead = tmp;\n 34:     }\n 35: \n 36:     private void doCommit() {\n 37:         synchronized (this.requestsRead) {\n 38:             if (!this.requestsRead.isEmpty()) {\n 39:                 for (GroupCommitRequest req : this.requestsRead) {\n 40:                     // There may be a message in the next file, so a maximum of\n 41:                     // two times the flush (可能批量提交的messages，分布在两个MappedFile)\n 42:                     boolean flushOK = false;\n 43:                     for (int i = 0; i < 2 && !flushOK; i++) {\n 44:                         // 是否满足需要flush条件，即请求的offset超过flush的offset\n 45:                         flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() >= req.getNextOffset();\n 46:                         if (!flushOK) {\n 47:                             CommitLog.this.mappedFileQueue.flush(0);\n 48:                         }\n 49:                     }\n 50:                     // 唤醒等待请求\n 51:                     req.wakeupCustomer(flushOK);\n 52:                 }\n 53: \n 54:                 long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();\n 55:                 if (storeTimestamp > 0) {\n 56:                     CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);\n 57:                 }\n 58: \n 59:                 // 清理读取队列\n 60:                 this.requestsRead.clear();\n 61:             } else {\n 62:                 // Because of individual messages is set to not sync flush, it\n 63:                 // will come to this process 不合法的请求，比如message上未设置isWaitStoreMsgOK。\n 64:                 // 走到此处的逻辑，相当于发送一条消息，落盘一条消息，实际无批量提交的效果。\n 65:                 CommitLog.this.mappedFileQueue.flush(0);\n 66:             }\n 67:         }\n 68:     }\n 69: \n 70:     public void run() {\n 71:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 72: \n 73:         while (!this.isStopped()) {\n 74:             try {\n 75:                 this.waitForRunning(10);\n 76:                 this.doCommit();\n 77:             } catch (Exception e) {\n 78:                 CommitLog.log.warn(this.getServiceName() + \" service has exception. \", e);\n 79:             }\n 80:         }\n 81: \n 82:         // Under normal circumstances shutdown, wait for the arrival of the\n 83:         // request, and then flush\n 84:         try {\n 85:             Thread.sleep(10);\n 86:         } catch (InterruptedException e) {\n 87:             CommitLog.log.warn(\"GroupCommitService Exception, \", e);\n 88:         }\n 89: \n 90:         synchronized (this) {\n 91:             this.swapRequests();\n 92:         }\n 93: \n 94:         this.doCommit();\n 95: \n 96:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 97:     }\n 98: \n 99:     /**\n100:      * 每次执行完，切换读写队列\n101:      */\n102:     @Override\n103:     protected void onWaitEnd() {\n104:         this.swapRequests();\n105:     }\n106: \n107:     @Override\n108:     public String getServiceName() {\n109:         return GroupCommitService.class.getSimpleName();\n110:     }\n111: \n112:     @Override\n113:     public long getJointime() {\n114:         return 1000 * 60 * 5;\n115:     }\n116: }\n```\n\n* 说明：批量写入线程服务。\n* 第 16 至 25 行 ：添加写入请求。方法设置了 `sync` 的原因：`this.requestsWrite` 会和 `this.requestsRead` 不断交换，无法保证稳定的同步。\n* 第 27 至 34 行 ：读写队列交换。\n* 第 38 至 60 行 ：循环写入队列，进行 `flush`。\n    * 第 43 行 ：考虑到有可能每次循环的消息写入的消息，可能分布在**两个** `MappedFile`(写第N个消息时，`MappedFile` 已满，创建了一个新的)，所以需要有循环2次。\n    * 第 51 行 ：唤醒等待写入请求线程，通过 `CountDownLatch` 实现。\n* 第 61 至 66 行 ：直接刷盘。此处是由于发送的消息的 `isWaitStoreMsgOK` 未设置成 `TRUE` ，导致未走批量提交。\n* 第 73 至 80 行 ：每 10ms 执行一次批量提交。当然，如果 `wakeup()` 时，则会立即进行一次批量提交。当 `Broker` 设置成同步落盘 && 消息 `isWaitStoreMsgOK=true`，消息需要略大于 10ms 才能发送成功。当然，性能相对异步落盘较差，可靠性更高，需要我们在实际使用时去取舍。 \n\n\n# 结尾\n\n写的第二篇与RocketMQ源码相关的博文，看到有阅读、点赞、收藏甚至订阅，很受鼓舞。\n\n《Message存储》比起《Message发送&接收》从难度上说是更大的，当然也是更有趣的，如果存在理解错误或者表达不清晰，还请大家多多包含。如果可以的话，还请麻烦添加 QQ：7685413 进行指出，避免自己的理解错误，给大家造成困扰。\n\n推荐[《Kafka设计解析（六）- Kafka高性能架构之道》](http://www.jasongj.com/kafka/high_throughput/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)，作者站在的高度比我高的多的多，嗯，按照李小璐的说法：高一个喜马拉雅山。😈认真啃读《Linux内核设计与实现(原书第3版)》，day day up。\n\n再次感谢大家的阅读、点赞、收藏。\n\n下一篇：[《RocketMQ 源码分析 —— Message 拉取与消费》](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/) 起航！\n\n\n","source":"_posts/RocketMQ/2017_04_23_RocketMQ源码分析——Message存储.md","raw":"title: RocketMQ 源码分析 —— Message 存储\ndate: 2017-04-23\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-store\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-store/](http://www.yunai.me/RocketMQ/message-store/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、CommitLog 结构](#)\n- [3、CommitLog 存储消息](#)\n\t- [CommitLog#putMessage(...)](#)\n\t- [MappedFileQueue#getLastMappedFile(...)](#)\n\t- [MappedFile#appendMessage(...)](#)\n\t- [DefaultAppendMessageCallback#doAppend(...)](#)\n\t- [FlushCommitLogService](#)\n\t\t- [MappedFile#落盘](#)\n\t\t- [FlushRealTimeService](#)\n\t\t- [CommitRealTimeService](#)\n\t\t- [GroupCommitService](#)\n- [结尾](#)\n\n# 1、概述\n\n本文接[《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)。\n主要解析 `CommitLog` 存储消息部分。\n\n# 2、CommitLog 结构\n\n`CommitLog`、`MappedFileQueue`、`MappedFile` 的关系如下：\n\n> ![CommitLog、MappedFileQueue、MappedFile的关系](http://www.yunai.me/images/RocketMQ/2017_04_23/02.png)\n`CommitLog` : `MappedFileQueue` : `MappedFile` = 1 : 1 : N。\n\n反应到系统文件如下：\n\n```bash\nYunai-MacdeMacBook-Pro-2:commitlog yunai$ pwd\n/Users/yunai/store/commitlog\nYunai-MacdeMacBook-Pro-2:commitlog yunai$ ls -l\ntotal 10485760\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:27 00000000000000000000\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:29 00000000001073741824\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000002147483648\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:33 00000000003221225472\n-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000004294967296\n```\n\n-------\n\n`CommitLog`、`MappedFileQueue`、`MappedFile` 的定义如下：\n\n* `MappedFile` ：00000000000000000000、00000000001073741824、00000000002147483648等文件。\n* `MappedFileQueue` ：`MappedFile` 所在的文件夹，对 `MappedFile` 进行封装成文件队列，对上层提供可无限使用的文件容量。\n    * 每个 `MappedFile` 统一文件大小。\n    * 文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 `CommitLog` 里默认为 1GB。\n* `CommitLog` ：针对 `MappedFileQueue` 的封装使用。\n\n`CommitLog` 目前存储在 `MappedFile` 有两种内容类型：\n\n1. MESSAGE ：消息。\n2. BLANK ：文件不足以存储消息时的空白占位。\n\n`CommitLog` 存储在 `MappedFile`的结构：\n\n> | MESSAGE[1] | MESSAGE[2]  | ... | MESSAGE[n - 1] | MESSAGE[n] | BLANK |\n> | --- | --- | --- | --- | --- | --- |\n\n`MESSAGE` 在 `CommitLog` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | MsgLen | 消息总长度 | Int | 4 |\n| 2 | MagicCode | MESSAGE_MAGIC_CODE | Int | 4 |\n| 3 | BodyCRC | 消息内容CRC | Int | 4 |\n| 4 | QueueId | 消息队列编号 | Int | 4 |\n| 5 | Flag |  flag | Int  | 4 |\n| 6 | QueueOffset | 消息队列位置 | Long | 8 |\n| 7 | PhysicalOffset | 物理位置。在 `CommitLog` 的顺序存储位置。 | Long | 8 |\n| 8 | SysFlag | MessageSysFlag | Int | 4 |\n| 9 | BornTimestamp | 生成消息时间戳 | Long | 8 |\n| 10 | BornHost  | 生效消息的地址+端口 | Long | 8 |\n| 11 | StoreTimestamp | 存储消息时间戳 | Long | 8 |\n| 12 | StoreHost | 存储消息的地址+端口 | Long | 8 |\n| 13 | ReconsumeTimes | 重新消费消息次数 | Int | 4 |\n| 14 | PreparedTransationOffset |  | Long | 8 |\n| 15 | BodyLength + Body  | 内容长度 + 内容 | Int + Bytes | 4 + bodyLength |\n| 16 | TopicLength + Topic | Topic长度 + Topic | Byte + Bytes | 1 + topicLength |\n| 17 | PropertiesLength + Properties | 拓展字段长度 + 拓展字段 | Short + Bytes | 2 + PropertiesLength |\n\n`BLANK` 在 `CommitLog` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | maxBlank | 空白长度 | Int | 4 |\n| 2 | MagicCode | BLANK_MAGIC_CODE | Int | 4 |\n\n# 3、CommitLog 存储消息\n\n> ![Broker存储发送消息顺序图](http://www.yunai.me/images/RocketMQ/2017_04_23/01.png)\n\n## CommitLog#putMessage(...)\n\n```Java\n  1: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  2:     // Set the storage time\n  3:     msg.setStoreTimestamp(System.currentTimeMillis());\n  4:     // Set the message body BODY CRC (consider the most appropriate setting\n  5:     // on the client)\n  6:     msg.setBodyCRC(UtilAll.crc32(msg.getBody()));\n  7:     // Back to Results\n  8:     AppendMessageResult result = null;\n  9: \n 10:     StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n 11: \n 12:     String topic = msg.getTopic();\n 13:     int queueId = msg.getQueueId();\n 14: \n 15:     // 事务相关 TODO 待读：事务相关\n 16:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n 17:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//\n 18:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n 19:         // Delay Delivery\n 20:         if (msg.getDelayTimeLevel() > 0) {\n 21:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 22:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n 23:             }\n 24: \n 25:             topic = ScheduleMessageService.SCHEDULE_TOPIC;\n 26:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n 27: \n 28:             // Backup real topic, queueId\n 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n 30:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n 31:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n 32: \n 33:             msg.setTopic(topic);\n 34:             msg.setQueueId(queueId);\n 35:         }\n 36:     }\n 37: \n 38:     long eclipseTimeInLock = 0;\n 39: \n 40:     // 获取写入映射文件\n 41:     MappedFile unlockMappedFile = null;\n 42:     MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n 43: \n 44:     // 获取写入锁\n 45:     lockForPutMessage(); //spin...\n 46:     try {\n 47:         long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n 48:         this.beginTimeInLock = beginLockTimestamp;\n 49: \n 50:         // Here settings are stored timestamp, in order to ensure an orderly\n 51:         // global\n 52:         msg.setStoreTimestamp(beginLockTimestamp);\n 53: \n 54:         // 当不存在映射文件时，进行创建\n 55:         if (null == mappedFile || mappedFile.isFull()) {\n 56:             mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n 57:         }\n 58:         if (null == mappedFile) {\n 59:             log.error(\"create maped file1 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n 60:             beginTimeInLock = 0;\n 61:             return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);\n 62:         }\n 63: \n 64:         // 存储消息\n 65:         result = mappedFile.appendMessage(msg, this.appendMessageCallback);\n 66:         switch (result.getStatus()) {\n 67:             case PUT_OK:\n 68:                 break;\n 69:             case END_OF_FILE: // 当文件尾时，获取新的映射文件，并进行插入\n 70:                 unlockMappedFile = mappedFile;\n 71:                 // Create a new file, re-write the message\n 72:                 mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n 73:                 if (null == mappedFile) {\n 74:                     // XXX: warn and notify me\n 75:                     log.error(\"create maped file2 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n 76:                     beginTimeInLock = 0;\n 77:                     return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);\n 78:                 }\n 79:                 result = mappedFile.appendMessage(msg, this.appendMessageCallback);\n 80:                 break;\n 81:             case MESSAGE_SIZE_EXCEEDED:\n 82:             case PROPERTIES_SIZE_EXCEEDED:\n 83:                 beginTimeInLock = 0;\n 84:                 return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);\n 85:             case UNKNOWN_ERROR:\n 86:                 beginTimeInLock = 0;\n 87:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);\n 88:             default:\n 89:                 beginTimeInLock = 0;\n 90:                 return new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);\n 91:         }\n 92: \n 93:         eclipseTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n 94:         beginTimeInLock = 0;\n 95:     } finally {\n 96:         // 释放写入锁\n 97:         releasePutMessageLock();\n 98:     }\n 99: \n100:     if (eclipseTimeInLock > 500) {\n101:         log.warn(\"[NOTIFYME]putMessage in lock cost time(ms)={}, bodyLength={} AppendMessageResult={}\", eclipseTimeInLock, msg.getBody().length, result);\n102:     }\n103: \n104:     // \n105:     if (null != unlockMappedFile && this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n106:         this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n107:     }\n108: \n109:     PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n110: \n111:     // Statistics\n112:     storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();\n113:     storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());\n114: \n115:     // 进行同步||异步 flush||commit\n116:     GroupCommitRequest request = null;\n117:     // Synchronization flush\n118:     if (FlushDiskType.SYNC_FLUSH == this.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) {\n119:         final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;\n120:         if (msg.isWaitStoreMsgOK()) {\n121:             request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n122:             service.putRequest(request);\n123:             boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n124:             if (!flushOK) {\n125:                 log.error(\"do groupcommit, wait for flush failed, topic: \" + msg.getTopic() + \" tags: \" + msg.getTags()\n126:                     + \" client address: \" + msg.getBornHostString());\n127:                 putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);\n128:             }\n129:         } else {\n130:             service.wakeup();\n131:         }\n132:     }\n133:     // Asynchronous flush\n134:     else {\n135:         if (!this.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) {\n136:             flushCommitLogService.wakeup(); // important：唤醒commitLog线程，进行flush\n137:         } else {\n138:             commitLogService.wakeup();\n139:         }\n140:     }\n141: \n142:     // Synchronous write double 如果是同步Master，同步到从节点 // TODO 待读：数据同步\n143:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {\n144:         HAService service = this.defaultMessageStore.getHaService();\n145:         if (msg.isWaitStoreMsgOK()) {\n146:             // Determine whether to wait\n147:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {\n148:                 if (null == request) {\n149:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n150:                 }\n151:                 service.putRequest(request);\n152: \n153:                 service.getWaitNotifyObject().wakeupAll();\n154: \n155:                 boolean flushOK =\n156:                     // TODO\n157:                     request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n158:                 if (!flushOK) {\n159:                     log.error(\"do sync transfer other node, wait return, but failed, topic: \" + msg.getTopic() + \" tags: \"\n160:                         + msg.getTags() + \" client address: \" + msg.getBornHostString());\n161:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);\n162:                 }\n163:             }\n164:             // Slave problem\n165:             else {\n166:                 // Tell the producer, slave not available\n167:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);\n168:             }\n169:         }\n170:     }\n171: \n172:     return putMessageResult;\n173: }\n```\n\n* 说明 ：存储消息，并返回存储结果。\n* 第 2 行 ：设置存储时间等。\n* 第 16 至 36 行 ：事务消息相关，暂未了解。\n* 第 45 & 97 行 ：获取锁与释放锁。\n* 第 52 行 ：再次设置存储时间。目前会有多处地方设置存储时间。\n* 第 55 至 62 行 ：获取 `MappedFile`，若不存在或已满，则进行创建。详细解析见：[MappedFileQueue#getLastMappedFile(...)](#mappedfilequeuegetlastmappedfile)。\n* 第 65 行 ：**插入消息**到 `MappedFile`，解析解析见：[MappedFile#appendMessage(...)](#mappedfileappendmessage)。\n* 第 69 至 80 行 ：`MappedFile` 已满，创建新的，再次**插入消息**。\n* 第 116 至 140 行 ：**消息刷盘**，即持久化到文件。上面**插入消息**实际未存储到硬盘。此处，根据不同的刷盘策略，执行会有不同。详细解析见：[FlushCommitLogService](#flushcommitlogservice)。\n* 第 143 至 173 行 ：`Broker` 主从同步。后面的文章会详细解析😈。\n\n## MappedFileQueue#getLastMappedFile(...)\n\n```Java\n  1: public MappedFile getLastMappedFile(final long startOffset, boolean needCreate) {\n  2:     long createOffset = -1; // 创建文件开始offset。-1时，不创建\n  3:     MappedFile mappedFileLast = getLastMappedFile();\n  4: \n  5:     if (mappedFileLast == null) { // 一个映射文件都不存在\n  6:         createOffset = startOffset - (startOffset % this.mappedFileSize);\n  7:     }\n  8: \n  9:     if (mappedFileLast != null && mappedFileLast.isFull()) { // 最后一个文件已满\n 10:         createOffset = mappedFileLast.getFileFromOffset() + this.mappedFileSize;\n 11:     }\n 12: \n 13:     if (createOffset != -1 && needCreate) { // 创建文件\n 14:         String nextFilePath = this.storePath + File.separator + UtilAll.offset2FileName(createOffset);\n 15:         String nextNextFilePath = this.storePath + File.separator\n 16:             + UtilAll.offset2FileName(createOffset + this.mappedFileSize);\n 17:         MappedFile mappedFile = null;\n 18: \n 19:         if (this.allocateMappedFileService != null) {\n 20:             mappedFile = this.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,\n 21:                 nextNextFilePath, this.mappedFileSize);\n 22:         } else {\n 23:             try {\n 24:                 mappedFile = new MappedFile(nextFilePath, this.mappedFileSize);\n 25:             } catch (IOException e) {\n 26:                 log.error(\"create mappedFile exception\", e);\n 27:             }\n 28:         }\n 29: \n 30:         if (mappedFile != null) {\n 31:             if (this.mappedFiles.isEmpty()) {\n 32:                 mappedFile.setFirstCreateInQueue(true);\n 33:             }\n 34:             this.mappedFiles.add(mappedFile);\n 35:         }\n 36: \n 37:         return mappedFile;\n 38:     }\n 39: \n 40:     return mappedFileLast;\n 41: }\n```\n\n* 说明 ：获取最后一个 `MappedFile`，若不存在或文件已满，则进行创建。\n* 第 5 至 11 行 ：计算当文件不存在或已满时，新创建文件的 `createOffset`。\n* 第 14 行 ：计算文件名。从此处我们可\n以得知，`MappedFile`的文件命名规则：\n\n    > fileName[n] = fileName[n - 1] + n * mappedFileSize\n    > fileName[0] = startOffset - (startOffset % this.mappedFileSize)\n    \n    目前 `CommitLog` 的 `startOffset` 为 0。\n    此处有个**疑问**，为什么需要 `(startOffset % this.mappedFileSize)`。例如：\n    \n    | startOffset  | mappedFileSize | createOffset |\n    | --- | :-- | :-- |\n    | 5 | 1 | 5 |\n    | 5 | 2 | 4 |\n    | 5 | 3 | 3  |\n    | 5 | 4 | 4 |\n    | 5 | > 5 | 0 |\n    \n    _如果有知道的同学，麻烦提示下。😈_\n    *解答：fileName[0] = startOffset - (startOffset % this.mappedFileSize) 计算出来的是，以 `this.mappedFileSize` 为每个文件大小时，`startOffset` 所在文件的开始`offset`*\n    \n* 第 30 至 35 行 ：设置 `MappedFile`是否是第一个创建的文件。该标识用于 `ConsumeQueue` 对应的 `MappedFile` ，详见 `ConsumeQueue#fillPreBlank`。\n    \n## MappedFile#appendMessage(...)\n\n```Java\n  1: public AppendMessageResult appendMessage(final MessageExtBrokerInner msg, final AppendMessageCallback cb) {\n  2:     assert msg != null;\n  3:     assert cb != null;\n  4: \n  5:     int currentPos = this.wrotePosition.get();\n  6: \n  7:     if (currentPos < this.fileSize) {\n  8:         ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();\n  9:         byteBuffer.position(currentPos);\n 10:         AppendMessageResult result =\n 11:             cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, msg);\n 12:         this.wrotePosition.addAndGet(result.getWroteBytes());\n 13:         this.storeTimestamp = result.getStoreTimestamp();\n 14:         return result;\n 15:     }\n 16: \n 17:     log.error(\"MappedFile.appendMessage return null, wrotePosition: \" + currentPos + \" fileSize: \"\n 18:         + this.fileSize);\n 19:     return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);\n 20: }\n```\n\n* 说明 ：**插入消息**到 `MappedFile`，并返回插入结果。\n* 第 8 行 ：获取需要写入的字节缓冲区。为什么会有 `writeBuffer != null` 的判断后，使用不同的字节缓冲区，见：[FlushCommitLogService](#flushcommitlogservice)。\n* 第 9 至 11 行 ：设置写入 `position`，执行写入，更新 `wrotePosition`(当前写入位置，下次开始写入开始位置)。\n\n## DefaultAppendMessageCallback#doAppend(...)\n\n```Java\n  1: class DefaultAppendMessageCallback implements AppendMessageCallback {\n  2:     // File at the end of the minimum fixed length empty\n  3:     private static final int END_FILE_MIN_BLANK_LENGTH = 4 + 4;\n  4:     /**\n  5:      * 存储在内存中的消息编号字节Buffer\n  6:      */\n  7:     private final ByteBuffer msgIdMemory;\n  8:     /**\n  9:      * Store the message content\n 10:      * 存储在内存中的消息字节Buffer\n 11:      * 当消息传递到{@link #doAppend(long, ByteBuffer, int, MessageExtBrokerInner)}方法时，最终写到该参数\n 12:      */\n 13:     private final ByteBuffer msgStoreItemMemory;\n 14:     /**\n 15:      * The maximum length of the message\n 16:      * 消息最大长度\n 17:      */\n 18:     private final int maxMessageSize;\n 19:     /**\n 20:      * Build Message Key\n 21:      * {@link #topicQueueTable}的key\n 22:      * 计算方式：topic + \"-\" + queueId\n 23:      */\n 24:     private final StringBuilder keyBuilder = new StringBuilder();\n 25:     /**\n 26:      * host字节buffer\n 27:      * 用于重复计算host的字节内容\n 28:      */\n 29:     private final ByteBuffer hostHolder = ByteBuffer.allocate(8);\n 30: \n 31:     DefaultAppendMessageCallback(final int size) {\n 32:         this.msgIdMemory = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);\n 33:         this.msgStoreItemMemory = ByteBuffer.allocate(size + END_FILE_MIN_BLANK_LENGTH);\n 34:         this.maxMessageSize = size;\n 35:     }\n 36: \n 37:     public ByteBuffer getMsgStoreItemMemory() {\n 38:         return msgStoreItemMemory;\n 39:     }\n 40: \n 41:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner) {\n 42:         // STORETIMESTAMP + STOREHOSTADDRESS + OFFSET <br>\n 43: \n 44:         // PHY OFFSET\n 45:         long wroteOffset = fileFromOffset + byteBuffer.position();\n 46: \n 47:         // 计算commitLog里的msgId\n 48:         this.resetByteBuffer(hostHolder, 8);\n 49:         String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);\n 50: \n 51:         // Record ConsumeQueue information 获取队列offset\n 52:         keyBuilder.setLength(0);\n 53:         keyBuilder.append(msgInner.getTopic());\n 54:         keyBuilder.append('-');\n 55:         keyBuilder.append(msgInner.getQueueId());\n 56:         String key = keyBuilder.toString();\n 57:         Long queueOffset = CommitLog.this.topicQueueTable.get(key);\n 58:         if (null == queueOffset) {\n 59:             queueOffset = 0L;\n 60:             CommitLog.this.topicQueueTable.put(key, queueOffset);\n 61:         }\n 62: \n 63:         // Transaction messages that require special handling // TODO 疑问：用途\n 64:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());\n 65:         switch (tranType) {\n 66:             // Prepared and Rollback message is not consumed, will not enter the\n 67:             // consumer queue\n 68:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n 69:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n 70:                 queueOffset = 0L;\n 71:                 break;\n 72:             case MessageSysFlag.TRANSACTION_NOT_TYPE:\n 73:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n 74:             default:\n 75:                 break;\n 76:         }\n 77: \n 78:         // 计算消息长度\n 79:         final byte[] propertiesData =\n 80:             msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);\n 81:         final int propertiesLength = propertiesData == null ? 0 : propertiesData.length;\n 82:         if (propertiesLength > Short.MAX_VALUE) {\n 83:             log.warn(\"putMessage message properties length too long. length={}\", propertiesData.length);\n 84:             return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);\n 85:         }\n 86:         final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);\n 87:         final int topicLength = topicData.length;\n 88:         final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length;\n 89:         final int msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);\n 90:         // Exceeds the maximum message\n 91:         if (msgLen > this.maxMessageSize) {\n 92:             CommitLog.log.warn(\"message size exceeded, msg total size: \" + msgLen + \", msg body size: \" + bodyLength\n 93:                 + \", maxMessageSize: \" + this.maxMessageSize);\n 94:             return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);\n 95:         }\n 96: \n 97:         // Determines whether there is sufficient(足够) free space\n 98:         if ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {\n 99:             this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);\n100:             // 1 TOTAL_SIZE\n101:             this.msgStoreItemMemory.putInt(maxBlank);\n102:             // 2 MAGIC_CODE\n103:             this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);\n104:             // 3 The remaining space may be any value\n105:             //\n106: \n107:             // Here the length of the specially set maxBlank\n108:             final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n109:             byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);\n110:             return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),\n111:                 queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n112:         }\n113: \n114:         // Initialization of storage space\n115:         this.resetByteBuffer(msgStoreItemMemory, msgLen);\n116:         // 1 TOTAL_SIZE\n117:         this.msgStoreItemMemory.putInt(msgLen);\n118:         // 2 MAGIC_CODE\n119:         this.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);\n120:         // 3 BODY_CRC\n121:         this.msgStoreItemMemory.putInt(msgInner.getBodyCRC());\n122:         // 4 QUEUE_ID\n123:         this.msgStoreItemMemory.putInt(msgInner.getQueueId());\n124:         // 5 FLAG\n125:         this.msgStoreItemMemory.putInt(msgInner.getFlag());\n126:         // 6 QUEUE_OFFSET\n127:         this.msgStoreItemMemory.putLong(queueOffset);\n128:         // 7 PHYSICAL_OFFSET\n129:         this.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());\n130:         // 8 SYS_FLAG\n131:         this.msgStoreItemMemory.putInt(msgInner.getSysFlag());\n132:         // 9 BORN_TIMESTAMP\n133:         this.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());\n134:         // 10 BORN_HOST\n135:         this.resetByteBuffer(hostHolder, 8);\n136:         this.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));\n137:         // 11 STORE_TIMESTAMP\n138:         this.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());\n139:         // 12 STORE_HOST_ADDRESS\n140:         this.resetByteBuffer(hostHolder, 8);\n141:         this.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));\n142:         //this.msgStoreItemMemory.put(msgInner.getStoreHostBytes());\n143:         // 13 RECONSUME_TIMES\n144:         this.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());\n145:         // 14 Prepared Transaction Offset\n146:         this.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());\n147:         // 15 BODY\n148:         this.msgStoreItemMemory.putInt(bodyLength);\n149:         if (bodyLength > 0)\n150:             this.msgStoreItemMemory.put(msgInner.getBody());\n151:         // 16 TOPIC\n152:         this.msgStoreItemMemory.put((byte) topicLength);\n153:         this.msgStoreItemMemory.put(topicData);\n154:         // 17 PROPERTIES\n155:         this.msgStoreItemMemory.putShort((short) propertiesLength);\n156:         if (propertiesLength > 0)\n157:             this.msgStoreItemMemory.put(propertiesData);\n158: \n159:         final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n160:         // Write messages to the queue buffer\n161:         byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);\n162: \n163:         AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,\n164:             msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n165: \n166:         switch (tranType) {\n167:             case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n168:             case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n169:                 break;\n170:             case MessageSysFlag.TRANSACTION_NOT_TYPE:\n171:             case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n172:                 // The next update ConsumeQueue information 更新队列的offset\n173:                 CommitLog.this.topicQueueTable.put(key, ++queueOffset);\n174:                 break;\n175:             default:\n176:                 break;\n177:         }\n178:         return result;\n179:     }\n180: \n181:     /**\n182:      * 重置字节缓冲区\n183:      *\n184:      * @param byteBuffer 字节缓冲区\n185:      * @param limit 长度\n186:      */\n187:     private void resetByteBuffer(final ByteBuffer byteBuffer, final int limit) {\n188:         byteBuffer.flip();\n189:         byteBuffer.limit(limit);\n190:     }\n191: }\n```\n* 说明 ：插入消息到字节缓冲区。\n* 第 45 行 ：计算物理位置。在 `CommitLog` 的顺序存储位置。\n* 第 47 至 49 行 ：计算 `CommitLog` 里的 `offsetMsgId`。这里一定要和 `msgId` 区分开。\n\n|   |   | 计算方式 | 长度 | |\n| --- | --- | --- | --- |  --- |\n| offsetMsgId | Broker存储时生成 | Hex(storeHostBytes, wroteOffset) | 32 |\n| msgId | Client发送消息时生成 | Hex(进程编号, IP, ClassLoader, startTime, currentTime, 自增序列) | 32 | [《RocketMQ 源码分析 —— Message 基础》](http://www.yunai.me/RocketMQ/message/) |\n\n* 第 51 至 61 行 ：获取队列位置(offset)。\n* 第 78 至 95 行 ：计算消息总长度。\n* 第 98 至 112 行 ：当文件剩余空间不足时，写入 `BLANK` 占位，返回结果。\n* 第 114 至 161 行 ：写入 `MESSAGE` 。\n* 第 173 行 ：更新队列位置(offset)。\n\n## FlushCommitLogService\n\n![FlushCommitLogService类图](http://www.yunai.me/images/RocketMQ/2017_04_23/03.png)\n\n| 线程服务 | 场景 | 插入消息性能 |\n| --- | --- | --- |\n| CommitRealTimeService | 异步刷盘 && 开启内存字节缓冲区 | 第一 |\n| FlushRealTimeService | 异步刷盘 && 关闭内存字节缓冲区 | 第二 |\n| GroupCommitService | 同步刷盘 | 第三 |\n\n### MappedFile#落盘\n\n\n| 方式 |   |  |  |\n| --- | --- | :-- | :-- |\n| 方式一 | 写入内存字节缓冲区(writeBuffer) | 从内存字节缓冲区(write buffer)提交(commit)到文件通道(fileChannel) | 文件通道(fileChannel)flush |\n| 方式二 |  | 写入映射文件字节缓冲区(mappedByteBuffer) | 映射文件字节缓冲区(mappedByteBuffer)flush  |\n\n![MappedFile的position迁移图](http://www.yunai.me/images/RocketMQ/2017_04_23/04.jpeg)\n\n**flush相关代码**\n\n考虑到写入性能，满足 `flushLeastPages * OS_PAGE_SIZE` 才进行 `flush`。\n\n```Java\n  1: /**\n  2:  * flush\n  3:  *\n  4:  * @param flushLeastPages flush最小页数\n  5:  * @return The current flushed position\n  6:  */\n  7: public int flush(final int flushLeastPages) {\n  8:     if (this.isAbleToFlush(flushLeastPages)) {\n  9:         if (this.hold()) {\n 10:             int value = getReadPosition();\n 11: \n 12:             try {\n 13:                 //We only append data to fileChannel or mappedByteBuffer, never both.\n 14:                 if (writeBuffer != null || this.fileChannel.position() != 0) {\n 15:                     this.fileChannel.force(false);\n 16:                 } else {\n 17:                     this.mappedByteBuffer.force();\n 18:                 }\n 19:             } catch (Throwable e) {\n 20:                 log.error(\"Error occurred when force data to disk.\", e);\n 21:             }\n 22: \n 23:             this.flushedPosition.set(value);\n 24:             this.release();\n 25:         } else {\n 26:             log.warn(\"in flush, hold failed, flush offset = \" + this.flushedPosition.get());\n 27:             this.flushedPosition.set(getReadPosition());\n 28:         }\n 29:     }\n 30:     return this.getFlushedPosition();\n 31: }\n 32: \n 33: /**\n 34:  * 是否能够flush。满足如下条件任意条件：\n 35:  * 1. 映射文件已经写满\n 36:  * 2. flushLeastPages > 0 && 未flush部分超过flushLeastPages\n 37:  * 3. flushLeastPages = 0 && 有新写入部分\n 38:  *\n 39:  * @param flushLeastPages flush最小分页\n 40:  * @return 是否能够写入\n 41:  */\n 42: private boolean isAbleToFlush(final int flushLeastPages) {\n 43:     int flush = this.flushedPosition.get();\n 44:     int write = getReadPosition();\n 45: \n 46:     if (this.isFull()) {\n 47:         return true;\n 48:     }\n 49: \n 50:     if (flushLeastPages > 0) {\n 51:         return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) >= flushLeastPages;\n 52:     }\n 53: \n 54:     return write > flush;\n 55: }\n```\n\n**commit相关代码：**\n\n考虑到写入性能，满足 `commitLeastPages * OS_PAGE_SIZE` 才进行 `commit`。\n\n```Java\n  1: /**\n  2:  * commit\n  3:  * 当{@link #writeBuffer}为null时，直接返回{@link #wrotePosition}\n  4:  *\n  5:  * @param commitLeastPages commit最小页数\n  6:  * @return 当前commit位置\n  7:  */\n  8: public int commit(final int commitLeastPages) {\n  9:     if (writeBuffer == null) {\n 10:         //no need to commit data to file channel, so just regard wrotePosition as committedPosition.\n 11:         return this.wrotePosition.get();\n 12:     }\n 13:     if (this.isAbleToCommit(commitLeastPages)) {\n 14:         if (this.hold()) {\n 15:             commit0(commitLeastPages);\n 16:             this.release();\n 17:         } else {\n 18:             log.warn(\"in commit, hold failed, commit offset = \" + this.committedPosition.get());\n 19:         }\n 20:     }\n 21: \n 22:     // All dirty data has been committed to FileChannel. 写到文件尾时，回收writeBuffer。\n 23:     if (writeBuffer != null && this.transientStorePool != null && this.fileSize == this.committedPosition.get()) {\n 24:         this.transientStorePool.returnBuffer(writeBuffer);\n 25:         this.writeBuffer = null;\n 26:     }\n 27: \n 28:     return this.committedPosition.get();\n 29: }\n 30: \n 31: /**\n 32:  * commit实现，将writeBuffer写入fileChannel。\n 33:  * @param commitLeastPages commit最小页数。用不上该参数\n 34:  */\n 35: protected void commit0(final int commitLeastPages) {\n 36:     int writePos = this.wrotePosition.get();\n 37:     int lastCommittedPosition = this.committedPosition.get();\n 38: \n 39:     if (writePos - this.committedPosition.get() > 0) {\n 40:         try {\n 41:             // 设置需要写入的byteBuffer\n 42:             ByteBuffer byteBuffer = writeBuffer.slice();\n 43:             byteBuffer.position(lastCommittedPosition);\n 44:             byteBuffer.limit(writePos);\n 45:             // 写入fileChannel\n 46:             this.fileChannel.position(lastCommittedPosition);\n 47:             this.fileChannel.write(byteBuffer);\n 48:             // 设置position\n 49:             this.committedPosition.set(writePos);\n 50:         } catch (Throwable e) {\n 51:             log.error(\"Error occurred when commit data to FileChannel.\", e);\n 52:         }\n 53:     }\n 54: }\n 55: \n 56: /**\n 57:  * 是否能够commit。满足如下条件任意条件：\n 58:  * 1. 映射文件已经写满\n 59:  * 2. commitLeastPages > 0 && 未commit部分超过commitLeastPages\n 60:  * 3. commitLeastPages = 0 && 有新写入部分\n 61:  *\n 62:  * @param commitLeastPages commit最小分页\n 63:  * @return 是否能够写入\n 64:  */\n 65: protected boolean isAbleToCommit(final int commitLeastPages) {\n 66:     int flush = this.committedPosition.get();\n 67:     int write = this.wrotePosition.get();\n 68: \n 69:     if (this.isFull()) {\n 70:         return true;\n 71:     }\n 72: \n 73:     if (commitLeastPages > 0) {\n 74:         return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) >= commitLeastPages;\n 75:     }\n 76: \n 77:     return write > flush;\n 78: }\n```\n\n### FlushRealTimeService\n\n消息插入成功时，异步刷盘时使用。\n\n```Java\n  1: class FlushRealTimeService extends FlushCommitLogService {\n  2:     /**\n  3:      * 最后flush时间戳\n  4:      */\n  5:     private long lastFlushTimestamp = 0;\n  6:     /**\n  7:      * print计时器。\n  8:      * 满足print次数时，调用{@link #printFlushProgress()}\n  9:      */\n 10:     private long printTimes = 0;\n 11: \n 12:     public void run() {\n 13:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 14: \n 15:         while (!this.isStopped()) {\n 16:             boolean flushCommitLogTimed = CommitLog.this.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();\n 17:             int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();\n 18:             int flushPhysicQueueLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();\n 19:             int flushPhysicQueueThoroughInterval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();\n 20: \n 21:             // Print flush progress\n 22:             // 当时间满足flushPhysicQueueThoroughInterval时，即使写入的数量不足flushPhysicQueueLeastPages，也进行flush\n 23:             boolean printFlushProgress = false;\n 24:             long currentTimeMillis = System.currentTimeMillis();\n 25:             if (currentTimeMillis >= (this.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) {\n 26:                 this.lastFlushTimestamp = currentTimeMillis;\n 27:                 flushPhysicQueueLeastPages = 0;\n 28:                 printFlushProgress = (printTimes++ % 10) == 0;\n 29:             }\n 30: \n 31:             try {\n 32:                 // 等待执行\n 33:                 if (flushCommitLogTimed) {\n 34:                     Thread.sleep(interval);\n 35:                 } else {\n 36:                     this.waitForRunning(interval);\n 37:                 }\n 38: \n 39:                 if (printFlushProgress) {\n 40:                     this.printFlushProgress();\n 41:                 }\n 42: \n 43:                 // flush commitLog\n 44:                 long begin = System.currentTimeMillis();\n 45:                 CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages);\n 46:                 long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();\n 47:                 if (storeTimestamp > 0) {\n 48:                     CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);\n 49:                 }\n 50:                 long past = System.currentTimeMillis() - begin;\n 51:                 if (past > 500) {\n 52:                     log.info(\"Flush data to disk costs {} ms\", past);\n 53:                 }\n 54:             } catch (Throwable e) {\n 55:                 CommitLog.log.warn(this.getServiceName() + \" service has exception. \", e);\n 56:                 this.printFlushProgress();\n 57:             }\n 58:         }\n 59: \n 60:         // Normal shutdown, to ensure that all the flush before exit\n 61:         boolean result = false;\n 62:         for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n 63:             result = CommitLog.this.mappedFileQueue.flush(0);\n 64:             CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n 65:         }\n 66: \n 67:         this.printFlushProgress();\n 68: \n 69:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 70:     }\n 71: \n 72:     @Override\n 73:     public String getServiceName() {\n 74:         return FlushRealTimeService.class.getSimpleName();\n 75:     }\n 76: \n 77:     private void printFlushProgress() {\n 78:         // CommitLog.log.info(\"how much disk fall behind memory, \"\n 79:         // + CommitLog.this.mappedFileQueue.howMuchFallBehind());\n 80:     }\n 81: \n 82:     @Override\n 83:     @SuppressWarnings(\"SpellCheckingInspection\")\n 84:     public long getJointime() {\n 85:         return 1000 * 60 * 5;\n 86:     }\n 87: }\n```\n\n* 说明：实时 `flush `线程服务，调用 `MappedFile#flush` 相关逻辑。\n* 第 23 至 29 行 ：每 `flushPhysicQueueThoroughInterval` 周期，执行一次 `flush` 。因为不是每次循环到都能满足 `flushCommitLogLeastPages` 大小，因此，需要一定周期进行一次强制 `flush` 。当然，不能每次循环都去执行强制 `flush`，这样性能较差。\n* 第 33 行 至 37 行 ：根据 `flushCommitLogTimed` 参数，可以选择每次循环是**固定周期**还是**等待唤醒**。默认配置是后者，所以，每次插入消息完成，会去调用 `commitLogService.wakeup()` 。\n* 第 45 行 ：调用 `MappedFile` 进行 `flush`。\n* 第 61 至 65 行 ：`Broker` 关闭时，强制 `flush`，避免有未刷盘的数据。\n\n### CommitRealTimeService\n\n消息插入成功时，异步刷盘时使用。\n和 `FlushRealTimeService` 类似，性能更好。\n\n```Java\n  1: class CommitRealTimeService extends FlushCommitLogService {\n  2: \n  3:     /**\n  4:      * 最后 commit 时间戳\n  5:      */\n  6:     private long lastCommitTimestamp = 0;\n  7: \n  8:     @Override\n  9:     public String getServiceName() {\n 10:         return CommitRealTimeService.class.getSimpleName();\n 11:     }\n 12: \n 13:     @Override\n 14:     public void run() {\n 15:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 16:         while (!this.isStopped()) {\n 17:             int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();\n 18:             int commitDataLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();\n 19:             int commitDataThoroughInterval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();\n 20: \n 21:             // 当时间满足commitDataThoroughInterval时，即使写入的数量不足commitDataLeastPages，也进行flush\n 22:             long begin = System.currentTimeMillis();\n 23:             if (begin >= (this.lastCommitTimestamp + commitDataThoroughInterval)) {\n 24:                 this.lastCommitTimestamp = begin;\n 25:                 commitDataLeastPages = 0;\n 26:             }\n 27: \n 28:             try {\n 29:                 // commit\n 30:                 boolean result = CommitLog.this.mappedFileQueue.commit(commitDataLeastPages);\n 31:                 long end = System.currentTimeMillis();\n 32:                 if (!result) { // TODO 疑问：未写入成功，为啥要唤醒flushCommitLogService\n 33:                     this.lastCommitTimestamp = end; // result = false means some data committed.\n 34:                     //now wake up flush thread.\n 35:                     flushCommitLogService.wakeup();\n 36:                 }\n 37: \n 38:                 if (end - begin > 500) {\n 39:                     log.info(\"Commit data to file costs {} ms\", end - begin);\n 40:                 }\n 41: \n 42:                 // 等待执行\n 43:                 this.waitForRunning(interval);\n 44:             } catch (Throwable e) {\n 45:                 CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n 46:             }\n 47:         }\n 48: \n 49:         boolean result = false;\n 50:         for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n 51:             result = CommitLog.this.mappedFileQueue.commit(0);\n 52:             CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n 53:         }\n 54:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 55:     }\n 56: }\n```\n\n### GroupCommitService\n\n消息插入成功时，同步刷盘时使用。\n\n```Java\n  1: class GroupCommitService extends FlushCommitLogService {\n  2:     /**\n  3:      * 写入请求队列\n  4:      */\n  5:     private volatile List<GroupCommitRequest> requestsWrite = new ArrayList<>();\n  6:     /**\n  7:      * 读取请求队列\n  8:      */\n  9:     private volatile List<GroupCommitRequest> requestsRead = new ArrayList<>();\n 10: \n 11:     /**\n 12:      * 添加写入请求\n 13:      *\n 14:      * @param request 写入请求\n 15:      */\n 16:     public synchronized void putRequest(final GroupCommitRequest request) {\n 17:         // 添加写入请求\n 18:         synchronized (this.requestsWrite) {\n 19:             this.requestsWrite.add(request);\n 20:         }\n 21:         // 切换读写队列\n 22:         if (hasNotified.compareAndSet(false, true)) {\n 23:             waitPoint.countDown(); // notify\n 24:         }\n 25:     }\n 26: \n 27:     /**\n 28:      * 切换读写队列\n 29:      */\n 30:     private void swapRequests() {\n 31:         List<GroupCommitRequest> tmp = this.requestsWrite;\n 32:         this.requestsWrite = this.requestsRead;\n 33:         this.requestsRead = tmp;\n 34:     }\n 35: \n 36:     private void doCommit() {\n 37:         synchronized (this.requestsRead) {\n 38:             if (!this.requestsRead.isEmpty()) {\n 39:                 for (GroupCommitRequest req : this.requestsRead) {\n 40:                     // There may be a message in the next file, so a maximum of\n 41:                     // two times the flush (可能批量提交的messages，分布在两个MappedFile)\n 42:                     boolean flushOK = false;\n 43:                     for (int i = 0; i < 2 && !flushOK; i++) {\n 44:                         // 是否满足需要flush条件，即请求的offset超过flush的offset\n 45:                         flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() >= req.getNextOffset();\n 46:                         if (!flushOK) {\n 47:                             CommitLog.this.mappedFileQueue.flush(0);\n 48:                         }\n 49:                     }\n 50:                     // 唤醒等待请求\n 51:                     req.wakeupCustomer(flushOK);\n 52:                 }\n 53: \n 54:                 long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();\n 55:                 if (storeTimestamp > 0) {\n 56:                     CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);\n 57:                 }\n 58: \n 59:                 // 清理读取队列\n 60:                 this.requestsRead.clear();\n 61:             } else {\n 62:                 // Because of individual messages is set to not sync flush, it\n 63:                 // will come to this process 不合法的请求，比如message上未设置isWaitStoreMsgOK。\n 64:                 // 走到此处的逻辑，相当于发送一条消息，落盘一条消息，实际无批量提交的效果。\n 65:                 CommitLog.this.mappedFileQueue.flush(0);\n 66:             }\n 67:         }\n 68:     }\n 69: \n 70:     public void run() {\n 71:         CommitLog.log.info(this.getServiceName() + \" service started\");\n 72: \n 73:         while (!this.isStopped()) {\n 74:             try {\n 75:                 this.waitForRunning(10);\n 76:                 this.doCommit();\n 77:             } catch (Exception e) {\n 78:                 CommitLog.log.warn(this.getServiceName() + \" service has exception. \", e);\n 79:             }\n 80:         }\n 81: \n 82:         // Under normal circumstances shutdown, wait for the arrival of the\n 83:         // request, and then flush\n 84:         try {\n 85:             Thread.sleep(10);\n 86:         } catch (InterruptedException e) {\n 87:             CommitLog.log.warn(\"GroupCommitService Exception, \", e);\n 88:         }\n 89: \n 90:         synchronized (this) {\n 91:             this.swapRequests();\n 92:         }\n 93: \n 94:         this.doCommit();\n 95: \n 96:         CommitLog.log.info(this.getServiceName() + \" service end\");\n 97:     }\n 98: \n 99:     /**\n100:      * 每次执行完，切换读写队列\n101:      */\n102:     @Override\n103:     protected void onWaitEnd() {\n104:         this.swapRequests();\n105:     }\n106: \n107:     @Override\n108:     public String getServiceName() {\n109:         return GroupCommitService.class.getSimpleName();\n110:     }\n111: \n112:     @Override\n113:     public long getJointime() {\n114:         return 1000 * 60 * 5;\n115:     }\n116: }\n```\n\n* 说明：批量写入线程服务。\n* 第 16 至 25 行 ：添加写入请求。方法设置了 `sync` 的原因：`this.requestsWrite` 会和 `this.requestsRead` 不断交换，无法保证稳定的同步。\n* 第 27 至 34 行 ：读写队列交换。\n* 第 38 至 60 行 ：循环写入队列，进行 `flush`。\n    * 第 43 行 ：考虑到有可能每次循环的消息写入的消息，可能分布在**两个** `MappedFile`(写第N个消息时，`MappedFile` 已满，创建了一个新的)，所以需要有循环2次。\n    * 第 51 行 ：唤醒等待写入请求线程，通过 `CountDownLatch` 实现。\n* 第 61 至 66 行 ：直接刷盘。此处是由于发送的消息的 `isWaitStoreMsgOK` 未设置成 `TRUE` ，导致未走批量提交。\n* 第 73 至 80 行 ：每 10ms 执行一次批量提交。当然，如果 `wakeup()` 时，则会立即进行一次批量提交。当 `Broker` 设置成同步落盘 && 消息 `isWaitStoreMsgOK=true`，消息需要略大于 10ms 才能发送成功。当然，性能相对异步落盘较差，可靠性更高，需要我们在实际使用时去取舍。 \n\n\n# 结尾\n\n写的第二篇与RocketMQ源码相关的博文，看到有阅读、点赞、收藏甚至订阅，很受鼓舞。\n\n《Message存储》比起《Message发送&接收》从难度上说是更大的，当然也是更有趣的，如果存在理解错误或者表达不清晰，还请大家多多包含。如果可以的话，还请麻烦添加 QQ：7685413 进行指出，避免自己的理解错误，给大家造成困扰。\n\n推荐[《Kafka设计解析（六）- Kafka高性能架构之道》](http://www.jasongj.com/kafka/high_throughput/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)，作者站在的高度比我高的多的多，嗯，按照李小璐的说法：高一个喜马拉雅山。😈认真啃读《Linux内核设计与实现(原书第3版)》，day day up。\n\n再次感谢大家的阅读、点赞、收藏。\n\n下一篇：[《RocketMQ 源码分析 —— Message 拉取与消费》](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/) 起航！\n\n\n","slug":"RocketMQ/message-store","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzaf000sag5dg5n0cxuu","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-store/\">http://www.yunai.me/RocketMQ/message-store/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、CommitLog 结构</a></li>\n<li><a href=\"#\">3、CommitLog 存储消息</a><ul>\n<li><a href=\"#\">CommitLog#putMessage(…)</a></li>\n<li><a href=\"#\">MappedFileQueue#getLastMappedFile(…)</a></li>\n<li><a href=\"#\">MappedFile#appendMessage(…)</a></li>\n<li><a href=\"#\">DefaultAppendMessageCallback#doAppend(…)</a></li>\n<li><a href=\"#\">FlushCommitLogService</a><ul>\n<li><a href=\"#\">MappedFile#落盘</a></li>\n<li><a href=\"#\">FlushRealTimeService</a></li>\n<li><a href=\"#\">CommitRealTimeService</a></li>\n<li><a href=\"#\">GroupCommitService</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本文接<a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a>。<br>主要解析 <code>CommitLog</code> 存储消息部分。</p>\n<h1 id=\"2、CommitLog-结构\"><a href=\"#2、CommitLog-结构\" class=\"headerlink\" title=\"2、CommitLog 结构\"></a>2、CommitLog 结构</h1><p><code>CommitLog</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的关系如下：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/02.png\" alt=\"CommitLog、MappedFileQueue、MappedFile的关系\"><br><code>CommitLog</code> : <code>MappedFileQueue</code> : <code>MappedFile</code> = 1 : 1 : N。</p>\n</blockquote>\n<p>反应到系统文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:commitlog yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/commitlog</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:commitlog yunai$ ls -l</div><div class=\"line\">total 10485760</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:27 00000000000000000000</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:29 00000000001073741824</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000002147483648</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:33 00000000003221225472</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000004294967296</div></pre></td></tr></table></figure>\n<hr>\n<p><code>CommitLog</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的定义如下：</p>\n<ul>\n<li><code>MappedFile</code> ：00000000000000000000、00000000001073741824、00000000002147483648等文件。</li>\n<li><code>MappedFileQueue</code> ：<code>MappedFile</code> 所在的文件夹，对 <code>MappedFile</code> 进行封装成文件队列，对上层提供可无限使用的文件容量。<ul>\n<li>每个 <code>MappedFile</code> 统一文件大小。</li>\n<li>文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 <code>CommitLog</code> 里默认为 1GB。</li>\n</ul>\n</li>\n<li><code>CommitLog</code> ：针对 <code>MappedFileQueue</code> 的封装使用。</li>\n</ul>\n<p><code>CommitLog</code> 目前存储在 <code>MappedFile</code> 有两种内容类型：</p>\n<ol>\n<li>MESSAGE ：消息。</li>\n<li>BLANK ：文件不足以存储消息时的空白占位。</li>\n</ol>\n<p><code>CommitLog</code> 存储在 <code>MappedFile</code>的结构：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>MESSAGE[1]</th>\n<th>MESSAGE[2]</th>\n<th>…</th>\n<th>MESSAGE[n - 1]</th>\n<th>MESSAGE[n]</th>\n<th>BLANK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><code>MESSAGE</code> 在 <code>CommitLog</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">MsgLen</td>\n<td style=\"text-align:left\">消息总长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">MagicCode</td>\n<td style=\"text-align:left\">MESSAGE_MAGIC_CODE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">BodyCRC</td>\n<td style=\"text-align:left\">消息内容CRC</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">QueueId</td>\n<td style=\"text-align:left\">消息队列编号</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">Flag</td>\n<td style=\"text-align:left\">flag</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">QueueOffset</td>\n<td style=\"text-align:left\">消息队列位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">PhysicalOffset</td>\n<td style=\"text-align:left\">物理位置。在 <code>CommitLog</code> 的顺序存储位置。</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">SysFlag</td>\n<td style=\"text-align:left\">MessageSysFlag</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">BornTimestamp</td>\n<td style=\"text-align:left\">生成消息时间戳</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">BornHost</td>\n<td style=\"text-align:left\">生效消息的地址+端口</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">StoreTimestamp</td>\n<td style=\"text-align:left\">存储消息时间戳</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">StoreHost</td>\n<td style=\"text-align:left\">存储消息的地址+端口</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ReconsumeTimes</td>\n<td style=\"text-align:left\">重新消费消息次数</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">PreparedTransationOffset</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">BodyLength + Body</td>\n<td style=\"text-align:left\">内容长度 + 内容</td>\n<td style=\"text-align:left\">Int + Bytes</td>\n<td style=\"text-align:left\">4 + bodyLength</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">TopicLength + Topic</td>\n<td style=\"text-align:left\">Topic长度 + Topic</td>\n<td style=\"text-align:left\">Byte + Bytes</td>\n<td style=\"text-align:left\">1 + topicLength</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">17</td>\n<td style=\"text-align:left\">PropertiesLength + Properties</td>\n<td style=\"text-align:left\">拓展字段长度 + 拓展字段</td>\n<td style=\"text-align:left\">Short + Bytes</td>\n<td style=\"text-align:left\">2 + PropertiesLength</td>\n</tr>\n</tbody>\n</table>\n<p><code>BLANK</code> 在 <code>CommitLog</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">maxBlank</td>\n<td style=\"text-align:left\">空白长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">MagicCode</td>\n<td style=\"text-align:left\">BLANK_MAGIC_CODE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3、CommitLog-存储消息\"><a href=\"#3、CommitLog-存储消息\" class=\"headerlink\" title=\"3、CommitLog 存储消息\"></a>3、CommitLog 存储消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/01.png\" alt=\"Broker存储发送消息顺序图\"></p>\n</blockquote>\n<h2 id=\"CommitLog-putMessage-…\"><a href=\"#CommitLog-putMessage-…\" class=\"headerlink\" title=\"CommitLog#putMessage(…)\"></a>CommitLog#putMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">// Set the storage time</span></div><div class=\"line\">  <span class=\"number\">3</span>:     msg.setStoreTimestamp(System.currentTimeMillis());</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">// Set the message body BODY CRC (consider the most appropriate setting</span></div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"comment\">// on the client)</span></div><div class=\"line\">  <span class=\"number\">6</span>:     msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">// Back to Results</span></div><div class=\"line\">  <span class=\"number\">8</span>:     AppendMessageResult result = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:     StoreStatsService storeStatsService = <span class=\"keyword\">this</span>.defaultMessageStore.getStoreStatsService();</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:     String topic = msg.getTopic();</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">int</span> queueId = msg.getQueueId();</div><div class=\"line\"> <span class=\"number\">14</span>: </div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"comment\">// 事务相关 TODO 待读：事务相关</span></div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">18</span>:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"comment\">// Delay Delivery</span></div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:                 msg.setDelayTimeLevel(<span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</div><div class=\"line\"> <span class=\"number\">23</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:             topic = ScheduleMessageService.SCHEDULE_TOPIC;</div><div class=\"line\"> <span class=\"number\">26</span>:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</div><div class=\"line\"> <span class=\"number\">27</span>: </div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"comment\">// Backup real topic, queueId</span></div><div class=\"line\"> <span class=\"number\">29</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</div><div class=\"line\"> <span class=\"number\">30</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</div><div class=\"line\"> <span class=\"number\">31</span>:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"> <span class=\"number\">32</span>: </div><div class=\"line\"> <span class=\"number\">33</span>:             msg.setTopic(topic);</div><div class=\"line\"> <span class=\"number\">34</span>:             msg.setQueueId(queueId);</div><div class=\"line\"> <span class=\"number\">35</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">36</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">37</span>: </div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">long</span> eclipseTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"comment\">// 获取写入映射文件</span></div><div class=\"line\"> <span class=\"number\">41</span>:     MappedFile unlockMappedFile = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:     MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile();</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:     <span class=\"comment\">// 获取写入锁</span></div><div class=\"line\"> <span class=\"number\">45</span>:     lockForPutMessage(); <span class=\"comment\">//spin...</span></div><div class=\"line\"> <span class=\"number\">46</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">long</span> beginLockTimestamp = <span class=\"keyword\">this</span>.defaultMessageStore.getSystemClock().now();</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.beginTimeInLock = beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:         <span class=\"comment\">// Here settings are stored timestamp, in order to ensure an orderly</span></div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"comment\">// global</span></div><div class=\"line\"> <span class=\"number\">52</span>:         msg.setStoreTimestamp(beginLockTimestamp);</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:         <span class=\"comment\">// 当不存在映射文件时，进行创建</span></div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile || mappedFile.isFull()) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:             mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>); <span class=\"comment\">// Mark: NewFile may be cause noise</span></div><div class=\"line\"> <span class=\"number\">57</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:             log.error(<span class=\"string\">\"create maped file1 error, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" clientAddr: \"</span> + msg.getBornHostString());</div><div class=\"line\"> <span class=\"number\">60</span>:             beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">62</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:         <span class=\"comment\">// 存储消息</span></div><div class=\"line\"> <span class=\"number\">65</span>:         result = mappedFile.appendMessage(msg, <span class=\"keyword\">this</span>.appendMessageCallback);</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">switch</span> (result.getStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">case</span> END_OF_FILE: <span class=\"comment\">// 当文件尾时，获取新的映射文件，并进行插入</span></div><div class=\"line\"> <span class=\"number\">70</span>:                 unlockMappedFile = mappedFile;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"comment\">// Create a new file, re-write the message</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">75</span>:                     log.error(<span class=\"string\">\"create maped file2 error, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" clientAddr: \"</span> + msg.getBornHostString());</div><div class=\"line\"> <span class=\"number\">76</span>:                     beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</div><div class=\"line\"> <span class=\"number\">78</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:                 result = mappedFile.appendMessage(msg, <span class=\"keyword\">this</span>.appendMessageCallback);</div><div class=\"line\"> <span class=\"number\">80</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">81</span>:             <span class=\"keyword\">case</span> MESSAGE_SIZE_EXCEEDED:</div><div class=\"line\"> <span class=\"number\">82</span>:             <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"> <span class=\"number\">83</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">84</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</div><div class=\"line\"> <span class=\"number\">85</span>:             <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"> <span class=\"number\">86</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">87</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</div><div class=\"line\"> <span class=\"number\">88</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">89</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</div><div class=\"line\"> <span class=\"number\">91</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:         eclipseTimeInLock = <span class=\"keyword\">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">94</span>:         beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">95</span>:     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"comment\">// 释放写入锁</span></div><div class=\"line\"> <span class=\"number\">97</span>:         releasePutMessageLock();</div><div class=\"line\"> <span class=\"number\">98</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">if</span> (eclipseTimeInLock &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:         log.warn(<span class=\"string\">\"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;\"</span>, eclipseTimeInLock, msg.getBody().length, result);</div><div class=\"line\"><span class=\"number\">102</span>:     &#125;</div><div class=\"line\"><span class=\"number\">103</span>: </div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"comment\">// </span></div><div class=\"line\"><span class=\"number\">105</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != unlockMappedFile &amp;&amp; <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</div><div class=\"line\"><span class=\"number\">107</span>:     &#125;</div><div class=\"line\"><span class=\"number\">108</span>: </div><div class=\"line\"><span class=\"number\">109</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:     <span class=\"comment\">// Statistics</span></div><div class=\"line\"><span class=\"number\">112</span>:     storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</div><div class=\"line\"><span class=\"number\">113</span>:     storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"comment\">// 进行同步||异步 flush||commit</span></div><div class=\"line\"><span class=\"number\">116</span>:     GroupCommitRequest request = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">117</span>:     <span class=\"comment\">// Synchronization flush</span></div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">if</span> (FlushDiskType.SYNC_FLUSH == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">final</span> GroupCommitService service = (GroupCommitService) <span class=\"keyword\">this</span>.flushCommitLogService;</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"><span class=\"number\">121</span>:             request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">122</span>:             service.putRequest(request);</div><div class=\"line\"><span class=\"number\">123</span>:             <span class=\"keyword\">boolean</span> flushOK = request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">125</span>:                 log.error(<span class=\"string\">\"do groupcommit, wait for flush failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span> + msg.getTags()</div><div class=\"line\"><span class=\"number\">126</span>:                     + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">127</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             service.wakeup();</div><div class=\"line\"><span class=\"number\">131</span>:         &#125;</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"comment\">// Asynchronous flush</span></div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:             flushCommitLogService.wakeup(); <span class=\"comment\">// important：唤醒commitLog线程，进行flush</span></div><div class=\"line\"><span class=\"number\">137</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">138</span>:             commitLogService.wakeup();</div><div class=\"line\"><span class=\"number\">139</span>:         &#125;</div><div class=\"line\"><span class=\"number\">140</span>:     &#125;</div><div class=\"line\"><span class=\"number\">141</span>: </div><div class=\"line\"><span class=\"number\">142</span>:     <span class=\"comment\">// Synchronous write double 如果是同步Master，同步到从节点 // TODO 待读：数据同步</span></div><div class=\"line\"><span class=\"number\">143</span>:     <span class=\"keyword\">if</span> (BrokerRole.SYNC_MASTER == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"><span class=\"number\">144</span>:         HAService service = <span class=\"keyword\">this</span>.defaultMessageStore.getHaService();</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"comment\">// Determine whether to wait</span></div><div class=\"line\"><span class=\"number\">147</span>:             <span class=\"keyword\">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == request) &#123;</div><div class=\"line\"><span class=\"number\">149</span>:                     request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">150</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">151</span>:                 service.putRequest(request);</div><div class=\"line\"><span class=\"number\">152</span>: </div><div class=\"line\"><span class=\"number\">153</span>:                 service.getWaitNotifyObject().wakeupAll();</div><div class=\"line\"><span class=\"number\">154</span>: </div><div class=\"line\"><span class=\"number\">155</span>:                 <span class=\"keyword\">boolean</span> flushOK =</div><div class=\"line\"><span class=\"number\">156</span>:                     <span class=\"comment\">// TODO</span></div><div class=\"line\"><span class=\"number\">157</span>:                     request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">158</span>:                 <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">159</span>:                     log.error(<span class=\"string\">\"do sync transfer other node, wait return, but failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span></div><div class=\"line\"><span class=\"number\">160</span>:                         + msg.getTags() + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">161</span>:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">162</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">163</span>:             &#125;</div><div class=\"line\"><span class=\"number\">164</span>:             <span class=\"comment\">// Slave problem</span></div><div class=\"line\"><span class=\"number\">165</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">166</span>:                 <span class=\"comment\">// Tell the producer, slave not available</span></div><div class=\"line\"><span class=\"number\">167</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">168</span>:             &#125;</div><div class=\"line\"><span class=\"number\">169</span>:         &#125;</div><div class=\"line\"><span class=\"number\">170</span>:     &#125;</div><div class=\"line\"><span class=\"number\">171</span>: </div><div class=\"line\"><span class=\"number\">172</span>:     <span class=\"keyword\">return</span> putMessageResult;</div><div class=\"line\"><span class=\"number\">173</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：存储消息，并返回存储结果。</li>\n<li>第 2 行 ：设置存储时间等。</li>\n<li>第 16 至 36 行 ：事务消息相关，暂未了解。</li>\n<li>第 45 &amp; 97 行 ：获取锁与释放锁。</li>\n<li>第 52 行 ：再次设置存储时间。目前会有多处地方设置存储时间。</li>\n<li>第 55 至 62 行 ：获取 <code>MappedFile</code>，若不存在或已满，则进行创建。详细解析见：<a href=\"#mappedfilequeuegetlastmappedfile\">MappedFileQueue#getLastMappedFile(…)</a>。</li>\n<li>第 65 行 ：<strong>插入消息</strong>到 <code>MappedFile</code>，解析解析见：<a href=\"#mappedfileappendmessage\">MappedFile#appendMessage(…)</a>。</li>\n<li>第 69 至 80 行 ：<code>MappedFile</code> 已满，创建新的，再次<strong>插入消息</strong>。</li>\n<li>第 116 至 140 行 ：<strong>消息刷盘</strong>，即持久化到文件。上面<strong>插入消息</strong>实际未存储到硬盘。此处，根据不同的刷盘策略，执行会有不同。详细解析见：<a href=\"#flushcommitlogservice\">FlushCommitLogService</a>。</li>\n<li>第 143 至 173 行 ：<code>Broker</code> 主从同步。后面的文章会详细解析😈。</li>\n</ul>\n<h2 id=\"MappedFileQueue-getLastMappedFile-…\"><a href=\"#MappedFileQueue-getLastMappedFile-…\" class=\"headerlink\" title=\"MappedFileQueue#getLastMappedFile(…)\"></a>MappedFileQueue#getLastMappedFile(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> MappedFile <span class=\"title\">getLastMappedFile</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startOffset, <span class=\"keyword\">boolean</span> needCreate)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">long</span> createOffset = -<span class=\"number\">1</span>; <span class=\"comment\">// 创建文件开始offset。-1时，不创建</span></div><div class=\"line\"> <span class=\"number\">3</span>:     MappedFile mappedFileLast = getLastMappedFile();</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (mappedFileLast == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 一个映射文件都不存在</span></div><div class=\"line\"> <span class=\"number\">6</span>:         createOffset = startOffset - (startOffset % <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"> <span class=\"number\">7</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (mappedFileLast != <span class=\"keyword\">null</span> &amp;&amp; mappedFileLast.isFull()) &#123; <span class=\"comment\">// 最后一个文件已满</span></div><div class=\"line\"><span class=\"number\">10</span>:         createOffset = mappedFileLast.getFileFromOffset() + <span class=\"keyword\">this</span>.mappedFileSize;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (createOffset != -<span class=\"number\">1</span> &amp;&amp; needCreate) &#123; <span class=\"comment\">// 创建文件</span></div><div class=\"line\"><span class=\"number\">14</span>:         String nextFilePath = <span class=\"keyword\">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</div><div class=\"line\"><span class=\"number\">15</span>:         String nextNextFilePath = <span class=\"keyword\">this</span>.storePath + File.separator</div><div class=\"line\"><span class=\"number\">16</span>:             + UtilAll.offset2FileName(createOffset + <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">17</span>:         MappedFile mappedFile = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.allocateMappedFileService != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             mappedFile = <span class=\"keyword\">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</div><div class=\"line\"><span class=\"number\">21</span>:                 nextNextFilePath, <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">22</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 mappedFile = <span class=\"keyword\">new</span> MappedFile(nextFilePath, <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 log.error(<span class=\"string\">\"create mappedFile exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mappedFiles.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 mappedFile.setFirstCreateInQueue(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.mappedFiles.add(mappedFile);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> mappedFile;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"keyword\">return</span> mappedFileLast;</div><div class=\"line\"><span class=\"number\">41</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获取最后一个 <code>MappedFile</code>，若不存在或文件已满，则进行创建。</li>\n<li>第 5 至 11 行 ：计算当文件不存在或已满时，新创建文件的 <code>createOffset</code>。</li>\n<li><p>第 14 行 ：计算文件名。从此处我们可<br>以得知，<code>MappedFile</code>的文件命名规则：</p>\n<blockquote>\n<p>fileName[n] = fileName[n - 1] + n * mappedFileSize<br>fileName[0] = startOffset - (startOffset % this.mappedFileSize)</p>\n</blockquote>\n<p>  目前 <code>CommitLog</code> 的 <code>startOffset</code> 为 0。<br>  此处有个<strong>疑问</strong>，为什么需要 <code>(startOffset % this.mappedFileSize)</code>。例如：</p>\n<p>  | startOffset  | mappedFileSize | createOffset |<br>  | — | :– | :– |<br>  | 5 | 1 | 5 |<br>  | 5 | 2 | 4 |<br>  | 5 | 3 | 3  |<br>  | 5 | 4 | 4 |<br>  | 5 | &gt; 5 | 0 |</p>\n<p>  <em>如果有知道的同学，麻烦提示下。😈</em><br>  <em>解答：fileName[0] = startOffset - (startOffset % this.mappedFileSize) 计算出来的是，以 <code>this.mappedFileSize</code> 为每个文件大小时，<code>startOffset</code> 所在文件的开始<code>offset</code></em></p>\n</li>\n<li><p>第 30 至 35 行 ：设置 <code>MappedFile</code>是否是第一个创建的文件。该标识用于 <code>ConsumeQueue</code> 对应的 <code>MappedFile</code> ，详见 <code>ConsumeQueue#fillPreBlank</code>。</p>\n</li>\n</ul>\n<h2 id=\"MappedFile-appendMessage-…\"><a href=\"#MappedFile-appendMessage-…\" class=\"headerlink\" title=\"MappedFile#appendMessage(…)\"></a>MappedFile#appendMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">appendMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg, <span class=\"keyword\">final</span> AppendMessageCallback cb)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">assert</span> msg != <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">assert</span> cb != <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">int</span> currentPos = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (currentPos &lt; <span class=\"keyword\">this</span>.fileSize) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         ByteBuffer byteBuffer = writeBuffer != <span class=\"keyword\">null</span> ? writeBuffer.slice() : <span class=\"keyword\">this</span>.mappedByteBuffer.slice();</div><div class=\"line\"> <span class=\"number\">9</span>:         byteBuffer.position(currentPos);</div><div class=\"line\"><span class=\"number\">10</span>:         AppendMessageResult result =</div><div class=\"line\"><span class=\"number\">11</span>:             cb.doAppend(<span class=\"keyword\">this</span>.getFileFromOffset(), byteBuffer, <span class=\"keyword\">this</span>.fileSize - currentPos, msg);</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.storeTimestamp = result.getStoreTimestamp();</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">15</span>:     &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:     log.error(<span class=\"string\">\"MappedFile.appendMessage return null, wrotePosition: \"</span> + currentPos + <span class=\"string\">\" fileSize: \"</span></div><div class=\"line\"><span class=\"number\">18</span>:         + <span class=\"keyword\">this</span>.fileSize);</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</div><div class=\"line\"><span class=\"number\">20</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>插入消息</strong>到 <code>MappedFile</code>，并返回插入结果。</li>\n<li>第 8 行 ：获取需要写入的字节缓冲区。为什么会有 <code>writeBuffer != null</code> 的判断后，使用不同的字节缓冲区，见：<a href=\"#flushcommitlogservice\">FlushCommitLogService</a>。</li>\n<li>第 9 至 11 行 ：设置写入 <code>position</code>，执行写入，更新 <code>wrotePosition</code>(当前写入位置，下次开始写入开始位置)。</li>\n</ul>\n<h2 id=\"DefaultAppendMessageCallback-doAppend-…\"><a href=\"#DefaultAppendMessageCallback-doAppend-…\" class=\"headerlink\" title=\"DefaultAppendMessageCallback#doAppend(…)\"></a>DefaultAppendMessageCallback#doAppend(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAppendMessageCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AppendMessageCallback</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">// File at the end of the minimum fixed length empty</span></div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> END_FILE_MIN_BLANK_LENGTH = <span class=\"number\">4</span> + <span class=\"number\">4</span>;</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  5:      * 存储在内存中的消息编号字节Buffer</div><div class=\"line\">  6:      */</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer msgIdMemory;</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  9:      * Store the message content</div><div class=\"line\"> 10:      * 存储在内存中的消息字节Buffer</div><div class=\"line\"> 11:      * 当消息传递到&#123;<span class=\"doctag\">@link</span> #doAppend(long, ByteBuffer, int, MessageExtBrokerInner)&#125;方法时，最终写到该参数</div><div class=\"line\"> 12:      */</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer msgStoreItemMemory;</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 15:      * The maximum length of the message</div><div class=\"line\"> 16:      * 消息最大长度</div><div class=\"line\"> 17:      */</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMessageSize;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 20:      * Build Message Key</div><div class=\"line\"> 21:      * &#123;<span class=\"doctag\">@link</span> #topicQueueTable&#125;的key</div><div class=\"line\"> 22:      * 计算方式：topic + \"-\" + queueId</div><div class=\"line\"> 23:      */</div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringBuilder keyBuilder = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 26:      * host字节buffer</div><div class=\"line\"> 27:      * 用于重复计算host的字节内容</div><div class=\"line\"> 28:      */</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer hostHolder = ByteBuffer.allocate(<span class=\"number\">8</span>);</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:     DefaultAppendMessageCallback(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">this</span>.msgIdMemory = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory = ByteBuffer.allocate(size + END_FILE_MIN_BLANK_LENGTH);</div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">this</span>.maxMessageSize = size;</div><div class=\"line\"> <span class=\"number\">35</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">getMsgStoreItemMemory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">38</span>:         <span class=\"keyword\">return</span> msgStoreItemMemory;</div><div class=\"line\"> <span class=\"number\">39</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:     <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">doAppend</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> fileFromOffset, <span class=\"keyword\">final</span> ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxBlank, <span class=\"keyword\">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"comment\">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:         <span class=\"comment\">// PHY OFFSET</span></div><div class=\"line\"> <span class=\"number\">45</span>:         <span class=\"keyword\">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"comment\">// 计算commitLog里的msgId</span></div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"> <span class=\"number\">49</span>:         String msgId = MessageDecoder.createMessageId(<span class=\"keyword\">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</div><div class=\"line\"> <span class=\"number\">50</span>: </div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"comment\">// Record ConsumeQueue information 获取队列offset</span></div><div class=\"line\"> <span class=\"number\">52</span>:         keyBuilder.setLength(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">53</span>:         keyBuilder.append(msgInner.getTopic());</div><div class=\"line\"> <span class=\"number\">54</span>:         keyBuilder.append(<span class=\"string\">'-'</span>);</div><div class=\"line\"> <span class=\"number\">55</span>:         keyBuilder.append(msgInner.getQueueId());</div><div class=\"line\"> <span class=\"number\">56</span>:         String key = keyBuilder.toString();</div><div class=\"line\"> <span class=\"number\">57</span>:         Long queueOffset = CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.get(key);</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == queueOffset) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:             queueOffset = <span class=\"number\">0L</span>;</div><div class=\"line\"> <span class=\"number\">60</span>:             CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, queueOffset);</div><div class=\"line\"> <span class=\"number\">61</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"comment\">// Transaction messages that require special handling // TODO 疑问：用途</span></div><div class=\"line\"> <span class=\"number\">64</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</div><div class=\"line\"> <span class=\"number\">65</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"comment\">// Prepared and Rollback message is not consumed, will not enter the</span></div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"comment\">// consumer queue</span></div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"> <span class=\"number\">70</span>:                 queueOffset = <span class=\"number\">0L</span>;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">72</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"> <span class=\"number\">73</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">76</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">77</span>: </div><div class=\"line\"> <span class=\"number\">78</span>:         <span class=\"comment\">// 计算消息长度</span></div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] propertiesData =</div><div class=\"line\"> <span class=\"number\">80</span>:             msgInner.getPropertiesString() == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class=\"line\"> <span class=\"number\">81</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> propertiesLength = propertiesData == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : propertiesData.length;</div><div class=\"line\"> <span class=\"number\">82</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:             log.warn(<span class=\"string\">\"putMessage message properties length too long. length=&#123;&#125;\"</span>, propertiesData.length);</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> topicLength = topicData.length;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bodyLength = msgInner.getBody() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : msgInner.getBody().length;</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"comment\">// Exceeds the maximum message</span></div><div class=\"line\"> <span class=\"number\">91</span>:         <span class=\"keyword\">if</span> (msgLen &gt; <span class=\"keyword\">this</span>.maxMessageSize) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:             CommitLog.log.warn(<span class=\"string\">\"message size exceeded, msg total size: \"</span> + msgLen + <span class=\"string\">\", msg body size: \"</span> + bodyLength</div><div class=\"line\"> <span class=\"number\">93</span>:                 + <span class=\"string\">\", maxMessageSize: \"</span> + <span class=\"keyword\">this</span>.maxMessageSize);</div><div class=\"line\"> <span class=\"number\">94</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</div><div class=\"line\"> <span class=\"number\">95</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:         <span class=\"comment\">// Determines whether there is sufficient(足够) free space</span></div><div class=\"line\"> <span class=\"number\">98</span>:         <span class=\"keyword\">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:             <span class=\"keyword\">this</span>.resetByteBuffer(<span class=\"keyword\">this</span>.msgStoreItemMemory, maxBlank);</div><div class=\"line\"><span class=\"number\">100</span>:             <span class=\"comment\">// 1 TOTAL_SIZE</span></div><div class=\"line\"><span class=\"number\">101</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(maxBlank);</div><div class=\"line\"><span class=\"number\">102</span>:             <span class=\"comment\">// 2 MAGIC_CODE</span></div><div class=\"line\"><span class=\"number\">103</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</div><div class=\"line\"><span class=\"number\">104</span>:             <span class=\"comment\">// 3 The remaining space may be any value</span></div><div class=\"line\"><span class=\"number\">105</span>:             <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:             <span class=\"comment\">// Here the length of the specially set maxBlank</span></div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now();</div><div class=\"line\"><span class=\"number\">109</span>:             byteBuffer.put(<span class=\"keyword\">this</span>.msgStoreItemMemory.array(), <span class=\"number\">0</span>, maxBlank);</div><div class=\"line\"><span class=\"number\">110</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</div><div class=\"line\"><span class=\"number\">111</span>:                 queueOffset, CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now() - beginTimeMills);</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"comment\">// Initialization of storage space</span></div><div class=\"line\"><span class=\"number\">115</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</div><div class=\"line\"><span class=\"number\">116</span>:         <span class=\"comment\">// 1 TOTAL_SIZE</span></div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgLen);</div><div class=\"line\"><span class=\"number\">118</span>:         <span class=\"comment\">// 2 MAGIC_CODE</span></div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"comment\">// 3 BODY_CRC</span></div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"comment\">// 4 QUEUE_ID</span></div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</div><div class=\"line\"><span class=\"number\">124</span>:         <span class=\"comment\">// 5 FLAG</span></div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</div><div class=\"line\"><span class=\"number\">126</span>:         <span class=\"comment\">// 6 QUEUE_OFFSET</span></div><div class=\"line\"><span class=\"number\">127</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(queueOffset);</div><div class=\"line\"><span class=\"number\">128</span>:         <span class=\"comment\">// 7 PHYSICAL_OFFSET</span></div><div class=\"line\"><span class=\"number\">129</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</div><div class=\"line\"><span class=\"number\">130</span>:         <span class=\"comment\">// 8 SYS_FLAG</span></div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</div><div class=\"line\"><span class=\"number\">132</span>:         <span class=\"comment\">// 9 BORN_TIMESTAMP</span></div><div class=\"line\"><span class=\"number\">133</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">134</span>:         <span class=\"comment\">// 10 BORN_HOST</span></div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));</div><div class=\"line\"><span class=\"number\">137</span>:         <span class=\"comment\">// 11 STORE_TIMESTAMP</span></div><div class=\"line\"><span class=\"number\">138</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"comment\">// 12 STORE_HOST_ADDRESS</span></div><div class=\"line\"><span class=\"number\">140</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));</div><div class=\"line\"><span class=\"number\">142</span>:         <span class=\"comment\">//this.msgStoreItemMemory.put(msgInner.getStoreHostBytes());</span></div><div class=\"line\"><span class=\"number\">143</span>:         <span class=\"comment\">// 13 RECONSUME_TIMES</span></div><div class=\"line\"><span class=\"number\">144</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"comment\">// 14 Prepared Transaction Offset</span></div><div class=\"line\"><span class=\"number\">146</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"comment\">// 15 BODY</span></div><div class=\"line\"><span class=\"number\">148</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(bodyLength);</div><div class=\"line\"><span class=\"number\">149</span>:         <span class=\"keyword\">if</span> (bodyLength &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">150</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getBody());</div><div class=\"line\"><span class=\"number\">151</span>:         <span class=\"comment\">// 16 TOPIC</span></div><div class=\"line\"><span class=\"number\">152</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put((<span class=\"keyword\">byte</span>) topicLength);</div><div class=\"line\"><span class=\"number\">153</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(topicData);</div><div class=\"line\"><span class=\"number\">154</span>:         <span class=\"comment\">// 17 PROPERTIES</span></div><div class=\"line\"><span class=\"number\">155</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putShort((<span class=\"keyword\">short</span>) propertiesLength);</div><div class=\"line\"><span class=\"number\">156</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">157</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.put(propertiesData);</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now();</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"comment\">// Write messages to the queue buffer</span></div><div class=\"line\"><span class=\"number\">161</span>:         byteBuffer.put(<span class=\"keyword\">this</span>.msgStoreItemMemory.array(), <span class=\"number\">0</span>, msgLen);</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:         AppendMessageResult result = <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</div><div class=\"line\"><span class=\"number\">164</span>:             msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now() - beginTimeMills);</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">167</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"><span class=\"number\">168</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"><span class=\"number\">169</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">170</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"><span class=\"number\">171</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"><span class=\"number\">172</span>:                 <span class=\"comment\">// The next update ConsumeQueue information 更新队列的offset</span></div><div class=\"line\"><span class=\"number\">173</span>:                 CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, ++queueOffset);</div><div class=\"line\"><span class=\"number\">174</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">175</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">176</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">177</span>:         &#125;</div><div class=\"line\"><span class=\"number\">178</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">179</span>:     &#125;</div><div class=\"line\"><span class=\"number\">180</span>: </div><div class=\"line\"><span class=\"number\">181</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">182:      * 重置字节缓冲区</div><div class=\"line\">183:      *</div><div class=\"line\">184:      * <span class=\"doctag\">@param</span> byteBuffer 字节缓冲区</div><div class=\"line\">185:      * <span class=\"doctag\">@param</span> limit 长度</div><div class=\"line\">186:      */</div><div class=\"line\"><span class=\"number\">187</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resetByteBuffer</span><span class=\"params\">(<span class=\"keyword\">final</span> ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> limit)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">188</span>:         byteBuffer.flip();</div><div class=\"line\"><span class=\"number\">189</span>:         byteBuffer.limit(limit);</div><div class=\"line\"><span class=\"number\">190</span>:     &#125;</div><div class=\"line\"><span class=\"number\">191</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：插入消息到字节缓冲区。</li>\n<li>第 45 行 ：计算物理位置。在 <code>CommitLog</code> 的顺序存储位置。</li>\n<li>第 47 至 49 行 ：计算 <code>CommitLog</code> 里的 <code>offsetMsgId</code>。这里一定要和 <code>msgId</code> 区分开。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th>计算方式</th>\n<th>长度</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>offsetMsgId</td>\n<td>Broker存储时生成</td>\n<td>Hex(storeHostBytes, wroteOffset)</td>\n<td>32</td>\n</tr>\n<tr>\n<td>msgId</td>\n<td>Client发送消息时生成</td>\n<td>Hex(进程编号, IP, ClassLoader, startTime, currentTime, 自增序列)</td>\n<td>32</td>\n<td><a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message 基础》</a></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第 51 至 61 行 ：获取队列位置(offset)。</li>\n<li>第 78 至 95 行 ：计算消息总长度。</li>\n<li>第 98 至 112 行 ：当文件剩余空间不足时，写入 <code>BLANK</code> 占位，返回结果。</li>\n<li>第 114 至 161 行 ：写入 <code>MESSAGE</code> 。</li>\n<li>第 173 行 ：更新队列位置(offset)。</li>\n</ul>\n<h2 id=\"FlushCommitLogService\"><a href=\"#FlushCommitLogService\" class=\"headerlink\" title=\"FlushCommitLogService\"></a>FlushCommitLogService</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/03.png\" alt=\"FlushCommitLogService类图\"></p>\n<table>\n<thead>\n<tr>\n<th>线程服务</th>\n<th>场景</th>\n<th>插入消息性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CommitRealTimeService</td>\n<td>异步刷盘 &amp;&amp; 开启内存字节缓冲区</td>\n<td>第一</td>\n</tr>\n<tr>\n<td>FlushRealTimeService</td>\n<td>异步刷盘 &amp;&amp; 关闭内存字节缓冲区</td>\n<td>第二</td>\n</tr>\n<tr>\n<td>GroupCommitService</td>\n<td>同步刷盘</td>\n<td>第三</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"MappedFile-落盘\"><a href=\"#MappedFile-落盘\" class=\"headerlink\" title=\"MappedFile#落盘\"></a>MappedFile#落盘</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方式一</td>\n<td>写入内存字节缓冲区(writeBuffer)</td>\n<td style=\"text-align:left\">从内存字节缓冲区(write buffer)提交(commit)到文件通道(fileChannel)</td>\n<td style=\"text-align:left\">文件通道(fileChannel)flush</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td></td>\n<td style=\"text-align:left\">写入映射文件字节缓冲区(mappedByteBuffer)</td>\n<td style=\"text-align:left\">映射文件字节缓冲区(mappedByteBuffer)flush</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/04.jpeg\" alt=\"MappedFile的position迁移图\"></p>\n<p><strong>flush相关代码</strong></p>\n<p>考虑到写入性能，满足 <code>flushLeastPages * OS_PAGE_SIZE</code> 才进行 <code>flush</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * flush</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> flushLeastPages flush最小页数</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> The current flushed position</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">flush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAbleToFlush(flushLeastPages)) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hold()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">int</span> value = getReadPosition();</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"comment\">//We only append data to fileChannel or mappedByteBuffer, never both.</span></div><div class=\"line\"><span class=\"number\">14</span>:                 <span class=\"keyword\">if</span> (writeBuffer != <span class=\"keyword\">null</span> || <span class=\"keyword\">this</span>.fileChannel.position() != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                     <span class=\"keyword\">this</span>.fileChannel.force(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">16</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     <span class=\"keyword\">this</span>.mappedByteBuffer.force();</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">19</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                 log.error(<span class=\"string\">\"Error occurred when force data to disk.\"</span>, e);</div><div class=\"line\"><span class=\"number\">21</span>:             &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">this</span>.flushedPosition.set(value);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.release();</div><div class=\"line\"><span class=\"number\">25</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:             log.warn(<span class=\"string\">\"in flush, hold failed, flush offset = \"</span> + <span class=\"keyword\">this</span>.flushedPosition.get());</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">this</span>.flushedPosition.set(getReadPosition());</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getFlushedPosition();</div><div class=\"line\"><span class=\"number\">31</span>: &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>: <span class=\"comment\">/**</span></div><div class=\"line\">34:  * 是否能够flush。满足如下条件任意条件：</div><div class=\"line\">35:  * 1. 映射文件已经写满</div><div class=\"line\">36:  * 2. flushLeastPages &gt; 0 &amp;&amp; 未flush部分超过flushLeastPages</div><div class=\"line\">37:  * 3. flushLeastPages = 0 &amp;&amp; 有新写入部分</div><div class=\"line\">38:  *</div><div class=\"line\">39:  * <span class=\"doctag\">@param</span> flushLeastPages flush最小分页</div><div class=\"line\">40:  * <span class=\"doctag\">@return</span> 是否能够写入</div><div class=\"line\">41:  */</div><div class=\"line\"><span class=\"number\">42</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAbleToFlush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"keyword\">int</span> flush = <span class=\"keyword\">this</span>.flushedPosition.get();</div><div class=\"line\"><span class=\"number\">44</span>:     <span class=\"keyword\">int</span> write = getReadPosition();</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isFull()) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">48</span>:     &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"keyword\">if</span> (flushLeastPages &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:     <span class=\"keyword\">return</span> write &gt; flush;</div><div class=\"line\"><span class=\"number\">55</span>: &#125;</div></pre></td></tr></table></figure>\n<p><strong>commit相关代码：</strong></p>\n<p>考虑到写入性能，满足 <code>commitLeastPages * OS_PAGE_SIZE</code> 才进行 <code>commit</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * commit</div><div class=\"line\"> 3:  * 当&#123;<span class=\"doctag\">@link</span> #writeBuffer&#125;为null时，直接返回&#123;<span class=\"doctag\">@link</span> #wrotePosition&#125;</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小页数</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 当前commit位置</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commit</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (writeBuffer == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAbleToCommit(commitLeastPages)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hold()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             commit0(commitLeastPages);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">this</span>.release();</div><div class=\"line\"><span class=\"number\">17</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:             log.warn(<span class=\"string\">\"in commit, hold failed, commit offset = \"</span> + <span class=\"keyword\">this</span>.committedPosition.get());</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">// All dirty data has been committed to FileChannel. 写到文件尾时，回收writeBuffer。</span></div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">if</span> (writeBuffer != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.transientStorePool != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.fileSize == <span class=\"keyword\">this</span>.committedPosition.get()) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">this</span>.transientStorePool.returnBuffer(writeBuffer);</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">this</span>.writeBuffer = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">29</span>: &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"comment\">/**</span></div><div class=\"line\">32:  * commit实现，将writeBuffer写入fileChannel。</div><div class=\"line\">33:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小页数。用不上该参数</div><div class=\"line\">34:  */</div><div class=\"line\"><span class=\"number\">35</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">commit0</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">int</span> writePos = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"keyword\">int</span> lastCommittedPosition = <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">if</span> (writePos - <span class=\"keyword\">this</span>.committedPosition.get() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"comment\">// 设置需要写入的byteBuffer</span></div><div class=\"line\"><span class=\"number\">42</span>:             ByteBuffer byteBuffer = writeBuffer.slice();</div><div class=\"line\"><span class=\"number\">43</span>:             byteBuffer.position(lastCommittedPosition);</div><div class=\"line\"><span class=\"number\">44</span>:             byteBuffer.limit(writePos);</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"comment\">// 写入fileChannel</span></div><div class=\"line\"><span class=\"number\">46</span>:             <span class=\"keyword\">this</span>.fileChannel.position(lastCommittedPosition);</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">this</span>.fileChannel.write(byteBuffer);</div><div class=\"line\"><span class=\"number\">48</span>:             <span class=\"comment\">// 设置position</span></div><div class=\"line\"><span class=\"number\">49</span>:             <span class=\"keyword\">this</span>.committedPosition.set(writePos);</div><div class=\"line\"><span class=\"number\">50</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:             log.error(<span class=\"string\">\"Error occurred when commit data to FileChannel.\"</span>, e);</div><div class=\"line\"><span class=\"number\">52</span>:         &#125;</div><div class=\"line\"><span class=\"number\">53</span>:     &#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>: <span class=\"comment\">/**</span></div><div class=\"line\">57:  * 是否能够commit。满足如下条件任意条件：</div><div class=\"line\">58:  * 1. 映射文件已经写满</div><div class=\"line\">59:  * 2. commitLeastPages &gt; 0 &amp;&amp; 未commit部分超过commitLeastPages</div><div class=\"line\">60:  * 3. commitLeastPages = 0 &amp;&amp; 有新写入部分</div><div class=\"line\">61:  *</div><div class=\"line\">62:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小分页</div><div class=\"line\">63:  * <span class=\"doctag\">@return</span> 是否能够写入</div><div class=\"line\">64:  */</div><div class=\"line\"><span class=\"number\">65</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAbleToCommit</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"keyword\">int</span> flush = <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"keyword\">int</span> write = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">68</span>: </div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isFull()) &#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125;</div><div class=\"line\"><span class=\"number\">72</span>: </div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"keyword\">if</span> (commitLeastPages &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> write &gt; flush;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"FlushRealTimeService\"><a href=\"#FlushRealTimeService\" class=\"headerlink\" title=\"FlushRealTimeService\"></a>FlushRealTimeService</h3><p>消息插入成功时，异步刷盘时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlushRealTimeService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 最后flush时间戳</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastFlushTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 7:      * print计时器。</div><div class=\"line\"> 8:      * 满足print次数时，调用&#123;<span class=\"doctag\">@link</span> #printFlushProgress()&#125;</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> printTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">boolean</span> flushCommitLogTimed = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">int</span> interval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">int</span> flushPhysicQueueLeastPages = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> flushPhysicQueueThoroughInterval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// Print flush progress</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"comment\">// 当时间满足flushPhysicQueueThoroughInterval时，即使写入的数量不足flushPhysicQueueLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">boolean</span> printFlushProgress = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"keyword\">if</span> (currentTimeMillis &gt;= (<span class=\"keyword\">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 <span class=\"keyword\">this</span>.lastFlushTimestamp = currentTimeMillis;</div><div class=\"line\"><span class=\"number\">27</span>:                 flushPhysicQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">28</span>:                 printFlushProgress = (printTimes++ % <span class=\"number\">10</span>) == <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">29</span>:             &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"comment\">// 等待执行</span></div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">if</span> (flushCommitLogTimed) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:                     Thread.sleep(interval);</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (printFlushProgress) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                     <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"comment\">// flush commitLog</span></div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">45</span>:                 CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">long</span> storeTimestamp = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">if</span> (storeTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                     CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div><div class=\"line\"><span class=\"number\">49</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">long</span> past = System.currentTimeMillis() - begin;</div><div class=\"line\"><span class=\"number\">51</span>:                 <span class=\"keyword\">if</span> (past &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                     log.info(<span class=\"string\">\"Flush data to disk costs &#123;&#125; ms\"</span>, past);</div><div class=\"line\"><span class=\"number\">53</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">54</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                 CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">57</span>:             &#125;</div><div class=\"line\"><span class=\"number\">58</span>:         &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:         <span class=\"comment\">// Normal shutdown, to ensure that all the flush before exit</span></div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:             result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">64</span>:             CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service shutdown, retry \"</span> + (i + <span class=\"number\">1</span>) + <span class=\"string\">\" times \"</span> + (result ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Not OK\"</span>));</div><div class=\"line\"><span class=\"number\">65</span>:         &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:         <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">68</span>: </div><div class=\"line\"><span class=\"number\">69</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">70</span>:     &#125;</div><div class=\"line\"><span class=\"number\">71</span>: </div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> FlushRealTimeService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printFlushProgress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">78</span>:         <span class=\"comment\">// CommitLog.log.info(\"how much disk fall behind memory, \"</span></div><div class=\"line\"><span class=\"number\">79</span>:         <span class=\"comment\">// + CommitLog.this.mappedFileQueue.howMuchFallBehind());</span></div><div class=\"line\"><span class=\"number\">80</span>:     &#125;</div><div class=\"line\"><span class=\"number\">81</span>: </div><div class=\"line\"><span class=\"number\">82</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">83</span>:     <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"SpellCheckingInspection\"</span>)</div><div class=\"line\"><span class=\"number\">84</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">85</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"number\">86</span>:     &#125;</div><div class=\"line\"><span class=\"number\">87</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：实时 <code>flush</code>线程服务，调用 <code>MappedFile#flush</code> 相关逻辑。</li>\n<li>第 23 至 29 行 ：每 <code>flushPhysicQueueThoroughInterval</code> 周期，执行一次 <code>flush</code> 。因为不是每次循环到都能满足 <code>flushCommitLogLeastPages</code> 大小，因此，需要一定周期进行一次强制 <code>flush</code> 。当然，不能每次循环都去执行强制 <code>flush</code>，这样性能较差。</li>\n<li>第 33 行 至 37 行 ：根据 <code>flushCommitLogTimed</code> 参数，可以选择每次循环是<strong>固定周期</strong>还是<strong>等待唤醒</strong>。默认配置是后者，所以，每次插入消息完成，会去调用 <code>commitLogService.wakeup()</code> 。</li>\n<li>第 45 行 ：调用 <code>MappedFile</code> 进行 <code>flush</code>。</li>\n<li>第 61 至 65 行 ：<code>Broker</code> 关闭时，强制 <code>flush</code>，避免有未刷盘的数据。</li>\n</ul>\n<h3 id=\"CommitRealTimeService\"><a href=\"#CommitRealTimeService\" class=\"headerlink\" title=\"CommitRealTimeService\"></a>CommitRealTimeService</h3><p>消息插入成功时，异步刷盘时使用。<br>和 <code>FlushRealTimeService</code> 类似，性能更好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommitRealTimeService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 最后 commit 时间戳</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastCommitTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">return</span> CommitRealTimeService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">15</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">int</span> interval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">int</span> commitDataLeastPages = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> commitDataThoroughInterval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 当时间满足commitDataThoroughInterval时，即使写入的数量不足commitDataLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (begin &gt;= (<span class=\"keyword\">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"keyword\">this</span>.lastCommitTimestamp = begin;</div><div class=\"line\"><span class=\"number\">25</span>:                 commitDataLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">26</span>:             &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"comment\">// commit</span></div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">boolean</span> result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.commit(commitDataLeastPages);</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">long</span> end = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">if</span> (!result) &#123; <span class=\"comment\">// TODO 疑问：未写入成功，为啥要唤醒flushCommitLogService</span></div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">this</span>.lastCommitTimestamp = end; <span class=\"comment\">// result = false means some data committed.</span></div><div class=\"line\"><span class=\"number\">34</span>:                     <span class=\"comment\">//now wake up flush thread.</span></div><div class=\"line\"><span class=\"number\">35</span>:                     flushCommitLogService.wakeup();</div><div class=\"line\"><span class=\"number\">36</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">if</span> (end - begin &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                     log.info(<span class=\"string\">\"Commit data to file costs &#123;&#125; ms\"</span>, end - begin);</div><div class=\"line\"><span class=\"number\">40</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"comment\">// 等待执行</span></div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">44</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:                 CommitLog.log.error(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">46</span>:             &#125;</div><div class=\"line\"><span class=\"number\">47</span>:         &#125;</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">50</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:             result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.commit(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">52</span>:             CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service shutdown, retry \"</span> + (i + <span class=\"number\">1</span>) + <span class=\"string\">\" times \"</span> + (result ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Not OK\"</span>));</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">55</span>:     &#125;</div><div class=\"line\"><span class=\"number\">56</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GroupCommitService\"><a href=\"#GroupCommitService\" class=\"headerlink\" title=\"GroupCommitService\"></a>GroupCommitService</h3><p>消息插入成功时，同步刷盘时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroupCommitService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  3:      * 写入请求队列</div><div class=\"line\">  4:      */</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;GroupCommitRequest&gt; requestsWrite = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  7:      * 读取请求队列</div><div class=\"line\">  8:      */</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;GroupCommitRequest&gt; requestsRead = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 添加写入请求</div><div class=\"line\"> 13:      *</div><div class=\"line\"> 14:      * <span class=\"doctag\">@param</span> request 写入请求</div><div class=\"line\"> 15:      */</div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">putRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> GroupCommitRequest request)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"comment\">// 添加写入请求</span></div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsWrite) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.requestsWrite.add(request);</div><div class=\"line\"> <span class=\"number\">20</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"comment\">// 切换读写队列</span></div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (hasNotified.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             waitPoint.countDown(); <span class=\"comment\">// notify</span></div><div class=\"line\"> <span class=\"number\">24</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">25</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 28:      * 切换读写队列</div><div class=\"line\"> 29:      */</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swapRequests</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">31</span>:         List&lt;GroupCommitRequest&gt; tmp = <span class=\"keyword\">this</span>.requestsWrite;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">this</span>.requestsWrite = <span class=\"keyword\">this</span>.requestsRead;</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.requestsRead = tmp;</div><div class=\"line\"> <span class=\"number\">34</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">35</span>: </div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doCommit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">37</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:             <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"keyword\">for</span> (GroupCommitRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"comment\">// There may be a message in the next file, so a maximum of</span></div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"comment\">// two times the flush (可能批量提交的messages，分布在两个MappedFile)</span></div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">boolean</span> flushOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">43</span>:                     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> &amp;&amp; !flushOK; i++) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:                         <span class=\"comment\">// 是否满足需要flush条件，即请求的offset超过flush的offset</span></div><div class=\"line\"> <span class=\"number\">45</span>:                         flushOK = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</div><div class=\"line\"> <span class=\"number\">46</span>:                         <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:                             CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">48</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">50</span>:                     <span class=\"comment\">// 唤醒等待请求</span></div><div class=\"line\"> <span class=\"number\">51</span>:                     req.wakeupCustomer(flushOK);</div><div class=\"line\"> <span class=\"number\">52</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:                 <span class=\"keyword\">long</span> storeTimestamp = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">if</span> (storeTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>: </div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"comment\">// 清理读取队列</span></div><div class=\"line\"> <span class=\"number\">60</span>:                 <span class=\"keyword\">this</span>.requestsRead.clear();</div><div class=\"line\"> <span class=\"number\">61</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">62</span>:                 <span class=\"comment\">// Because of individual messages is set to not sync flush, it</span></div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"comment\">// will come to this process 不合法的请求，比如message上未设置isWaitStoreMsgOK。</span></div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"comment\">// 走到此处的逻辑，相当于发送一条消息，落盘一条消息，实际无批量提交的效果。</span></div><div class=\"line\"> <span class=\"number\">65</span>:                 CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">66</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">67</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">71</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">76</span>:                 <span class=\"keyword\">this</span>.doCommit();</div><div class=\"line\"> <span class=\"number\">77</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                 CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"> <span class=\"number\">79</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">80</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:         <span class=\"comment\">// Under normal circumstances shutdown, wait for the arrival of the</span></div><div class=\"line\"> <span class=\"number\">83</span>:         <span class=\"comment\">// request, and then flush</span></div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">85</span>:             Thread.sleep(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">86</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:             CommitLog.log.warn(<span class=\"string\">\"GroupCommitService Exception, \"</span>, e);</div><div class=\"line\"> <span class=\"number\">88</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">this</span>.swapRequests();</div><div class=\"line\"> <span class=\"number\">92</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">93</span>: </div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"keyword\">this</span>.doCommit();</div><div class=\"line\"> <span class=\"number\">95</span>: </div><div class=\"line\"> <span class=\"number\">96</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"> <span class=\"number\">97</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">100:      * 每次执行完，切换读写队列</div><div class=\"line\">101:      */</div><div class=\"line\"><span class=\"number\">102</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onWaitEnd</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">104</span>:         <span class=\"keyword\">this</span>.swapRequests();</div><div class=\"line\"><span class=\"number\">105</span>:     &#125;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"keyword\">return</span> GroupCommitService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">110</span>:     &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"number\">115</span>:     &#125;</div><div class=\"line\"><span class=\"number\">116</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：批量写入线程服务。</li>\n<li>第 16 至 25 行 ：添加写入请求。方法设置了 <code>sync</code> 的原因：<code>this.requestsWrite</code> 会和 <code>this.requestsRead</code> 不断交换，无法保证稳定的同步。</li>\n<li>第 27 至 34 行 ：读写队列交换。</li>\n<li>第 38 至 60 行 ：循环写入队列，进行 <code>flush</code>。<ul>\n<li>第 43 行 ：考虑到有可能每次循环的消息写入的消息，可能分布在<strong>两个</strong> <code>MappedFile</code>(写第N个消息时，<code>MappedFile</code> 已满，创建了一个新的)，所以需要有循环2次。</li>\n<li>第 51 行 ：唤醒等待写入请求线程，通过 <code>CountDownLatch</code> 实现。</li>\n</ul>\n</li>\n<li>第 61 至 66 行 ：直接刷盘。此处是由于发送的消息的 <code>isWaitStoreMsgOK</code> 未设置成 <code>TRUE</code> ，导致未走批量提交。</li>\n<li>第 73 至 80 行 ：每 10ms 执行一次批量提交。当然，如果 <code>wakeup()</code> 时，则会立即进行一次批量提交。当 <code>Broker</code> 设置成同步落盘 &amp;&amp; 消息 <code>isWaitStoreMsgOK=true</code>，消息需要略大于 10ms 才能发送成功。当然，性能相对异步落盘较差，可靠性更高，需要我们在实际使用时去取舍。 </li>\n</ul>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>写的第二篇与RocketMQ源码相关的博文，看到有阅读、点赞、收藏甚至订阅，很受鼓舞。</p>\n<p>《Message存储》比起《Message发送&amp;接收》从难度上说是更大的，当然也是更有趣的，如果存在理解错误或者表达不清晰，还请大家多多包含。如果可以的话，还请麻烦添加 QQ：7685413 进行指出，避免自己的理解错误，给大家造成困扰。</p>\n<p>推荐<a href=\"http://www.jasongj.com/kafka/high_throughput/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《Kafka设计解析（六）- Kafka高性能架构之道》</a>，作者站在的高度比我高的多的多，嗯，按照李小璐的说法：高一个喜马拉雅山。😈认真啃读《Linux内核设计与实现(原书第3版)》，day day up。</p>\n<p>再次感谢大家的阅读、点赞、收藏。</p>\n<p>下一篇：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">《RocketMQ 源码分析 —— Message 拉取与消费》</a> 起航！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-store/\">http://www.yunai.me/RocketMQ/message-store/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、CommitLog 结构</a></li>\n<li><a href=\"#\">3、CommitLog 存储消息</a><ul>\n<li><a href=\"#\">CommitLog#putMessage(…)</a></li>\n<li><a href=\"#\">MappedFileQueue#getLastMappedFile(…)</a></li>\n<li><a href=\"#\">MappedFile#appendMessage(…)</a></li>\n<li><a href=\"#\">DefaultAppendMessageCallback#doAppend(…)</a></li>\n<li><a href=\"#\">FlushCommitLogService</a><ul>\n<li><a href=\"#\">MappedFile#落盘</a></li>\n<li><a href=\"#\">FlushRealTimeService</a></li>\n<li><a href=\"#\">CommitRealTimeService</a></li>\n<li><a href=\"#\">GroupCommitService</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本文接<a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a>。<br>主要解析 <code>CommitLog</code> 存储消息部分。</p>\n<h1 id=\"2、CommitLog-结构\"><a href=\"#2、CommitLog-结构\" class=\"headerlink\" title=\"2、CommitLog 结构\"></a>2、CommitLog 结构</h1><p><code>CommitLog</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的关系如下：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/02.png\" alt=\"CommitLog、MappedFileQueue、MappedFile的关系\"><br><code>CommitLog</code> : <code>MappedFileQueue</code> : <code>MappedFile</code> = 1 : 1 : N。</p>\n</blockquote>\n<p>反应到系统文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:commitlog yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/commitlog</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:commitlog yunai$ ls -l</div><div class=\"line\">total 10485760</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:27 00000000000000000000</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:29 00000000001073741824</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000002147483648</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:33 00000000003221225472</div><div class=\"line\">-rw-r--r--  1 yunai  staff  1073741824  4 21 16:32 00000000004294967296</div></pre></td></tr></table></figure>\n<hr>\n<p><code>CommitLog</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的定义如下：</p>\n<ul>\n<li><code>MappedFile</code> ：00000000000000000000、00000000001073741824、00000000002147483648等文件。</li>\n<li><code>MappedFileQueue</code> ：<code>MappedFile</code> 所在的文件夹，对 <code>MappedFile</code> 进行封装成文件队列，对上层提供可无限使用的文件容量。<ul>\n<li>每个 <code>MappedFile</code> 统一文件大小。</li>\n<li>文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 <code>CommitLog</code> 里默认为 1GB。</li>\n</ul>\n</li>\n<li><code>CommitLog</code> ：针对 <code>MappedFileQueue</code> 的封装使用。</li>\n</ul>\n<p><code>CommitLog</code> 目前存储在 <code>MappedFile</code> 有两种内容类型：</p>\n<ol>\n<li>MESSAGE ：消息。</li>\n<li>BLANK ：文件不足以存储消息时的空白占位。</li>\n</ol>\n<p><code>CommitLog</code> 存储在 <code>MappedFile</code>的结构：</p>\n<blockquote>\n<table>\n<thead>\n<tr>\n<th>MESSAGE[1]</th>\n<th>MESSAGE[2]</th>\n<th>…</th>\n<th>MESSAGE[n - 1]</th>\n<th>MESSAGE[n]</th>\n<th>BLANK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><code>MESSAGE</code> 在 <code>CommitLog</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">MsgLen</td>\n<td style=\"text-align:left\">消息总长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">MagicCode</td>\n<td style=\"text-align:left\">MESSAGE_MAGIC_CODE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">BodyCRC</td>\n<td style=\"text-align:left\">消息内容CRC</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">QueueId</td>\n<td style=\"text-align:left\">消息队列编号</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">Flag</td>\n<td style=\"text-align:left\">flag</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">QueueOffset</td>\n<td style=\"text-align:left\">消息队列位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">PhysicalOffset</td>\n<td style=\"text-align:left\">物理位置。在 <code>CommitLog</code> 的顺序存储位置。</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">SysFlag</td>\n<td style=\"text-align:left\">MessageSysFlag</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">BornTimestamp</td>\n<td style=\"text-align:left\">生成消息时间戳</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">BornHost</td>\n<td style=\"text-align:left\">生效消息的地址+端口</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">StoreTimestamp</td>\n<td style=\"text-align:left\">存储消息时间戳</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">StoreHost</td>\n<td style=\"text-align:left\">存储消息的地址+端口</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ReconsumeTimes</td>\n<td style=\"text-align:left\">重新消费消息次数</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">PreparedTransationOffset</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">BodyLength + Body</td>\n<td style=\"text-align:left\">内容长度 + 内容</td>\n<td style=\"text-align:left\">Int + Bytes</td>\n<td style=\"text-align:left\">4 + bodyLength</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">TopicLength + Topic</td>\n<td style=\"text-align:left\">Topic长度 + Topic</td>\n<td style=\"text-align:left\">Byte + Bytes</td>\n<td style=\"text-align:left\">1 + topicLength</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">17</td>\n<td style=\"text-align:left\">PropertiesLength + Properties</td>\n<td style=\"text-align:left\">拓展字段长度 + 拓展字段</td>\n<td style=\"text-align:left\">Short + Bytes</td>\n<td style=\"text-align:left\">2 + PropertiesLength</td>\n</tr>\n</tbody>\n</table>\n<p><code>BLANK</code> 在 <code>CommitLog</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">maxBlank</td>\n<td style=\"text-align:left\">空白长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">MagicCode</td>\n<td style=\"text-align:left\">BLANK_MAGIC_CODE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3、CommitLog-存储消息\"><a href=\"#3、CommitLog-存储消息\" class=\"headerlink\" title=\"3、CommitLog 存储消息\"></a>3、CommitLog 存储消息</h1><blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/01.png\" alt=\"Broker存储发送消息顺序图\"></p>\n</blockquote>\n<h2 id=\"CommitLog-putMessage-…\"><a href=\"#CommitLog-putMessage-…\" class=\"headerlink\" title=\"CommitLog#putMessage(…)\"></a>CommitLog#putMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">// Set the storage time</span></div><div class=\"line\">  <span class=\"number\">3</span>:     msg.setStoreTimestamp(System.currentTimeMillis());</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">// Set the message body BODY CRC (consider the most appropriate setting</span></div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"comment\">// on the client)</span></div><div class=\"line\">  <span class=\"number\">6</span>:     msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">// Back to Results</span></div><div class=\"line\">  <span class=\"number\">8</span>:     AppendMessageResult result = <span class=\"keyword\">null</span>;</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:     StoreStatsService storeStatsService = <span class=\"keyword\">this</span>.defaultMessageStore.getStoreStatsService();</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:     String topic = msg.getTopic();</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">int</span> queueId = msg.getQueueId();</div><div class=\"line\"> <span class=\"number\">14</span>: </div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"comment\">// 事务相关 TODO 待读：事务相关</span></div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">18</span>:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"comment\">// Delay Delivery</span></div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:                 msg.setDelayTimeLevel(<span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</div><div class=\"line\"> <span class=\"number\">23</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:             topic = ScheduleMessageService.SCHEDULE_TOPIC;</div><div class=\"line\"> <span class=\"number\">26</span>:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</div><div class=\"line\"> <span class=\"number\">27</span>: </div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"comment\">// Backup real topic, queueId</span></div><div class=\"line\"> <span class=\"number\">29</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</div><div class=\"line\"> <span class=\"number\">30</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</div><div class=\"line\"> <span class=\"number\">31</span>:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"> <span class=\"number\">32</span>: </div><div class=\"line\"> <span class=\"number\">33</span>:             msg.setTopic(topic);</div><div class=\"line\"> <span class=\"number\">34</span>:             msg.setQueueId(queueId);</div><div class=\"line\"> <span class=\"number\">35</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">36</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">37</span>: </div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">long</span> eclipseTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"comment\">// 获取写入映射文件</span></div><div class=\"line\"> <span class=\"number\">41</span>:     MappedFile unlockMappedFile = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:     MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile();</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:     <span class=\"comment\">// 获取写入锁</span></div><div class=\"line\"> <span class=\"number\">45</span>:     lockForPutMessage(); <span class=\"comment\">//spin...</span></div><div class=\"line\"> <span class=\"number\">46</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">long</span> beginLockTimestamp = <span class=\"keyword\">this</span>.defaultMessageStore.getSystemClock().now();</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.beginTimeInLock = beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:         <span class=\"comment\">// Here settings are stored timestamp, in order to ensure an orderly</span></div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"comment\">// global</span></div><div class=\"line\"> <span class=\"number\">52</span>:         msg.setStoreTimestamp(beginLockTimestamp);</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:         <span class=\"comment\">// 当不存在映射文件时，进行创建</span></div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile || mappedFile.isFull()) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:             mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>); <span class=\"comment\">// Mark: NewFile may be cause noise</span></div><div class=\"line\"> <span class=\"number\">57</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:             log.error(<span class=\"string\">\"create maped file1 error, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" clientAddr: \"</span> + msg.getBornHostString());</div><div class=\"line\"> <span class=\"number\">60</span>:             beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">62</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:         <span class=\"comment\">// 存储消息</span></div><div class=\"line\"> <span class=\"number\">65</span>:         result = mappedFile.appendMessage(msg, <span class=\"keyword\">this</span>.appendMessageCallback);</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">switch</span> (result.getStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">case</span> END_OF_FILE: <span class=\"comment\">// 当文件尾时，获取新的映射文件，并进行插入</span></div><div class=\"line\"> <span class=\"number\">70</span>:                 unlockMappedFile = mappedFile;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"comment\">// Create a new file, re-write the message</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mappedFile) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">75</span>:                     log.error(<span class=\"string\">\"create maped file2 error, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" clientAddr: \"</span> + msg.getBornHostString());</div><div class=\"line\"> <span class=\"number\">76</span>:                     beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</div><div class=\"line\"> <span class=\"number\">78</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:                 result = mappedFile.appendMessage(msg, <span class=\"keyword\">this</span>.appendMessageCallback);</div><div class=\"line\"> <span class=\"number\">80</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">81</span>:             <span class=\"keyword\">case</span> MESSAGE_SIZE_EXCEEDED:</div><div class=\"line\"> <span class=\"number\">82</span>:             <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"> <span class=\"number\">83</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">84</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</div><div class=\"line\"> <span class=\"number\">85</span>:             <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"> <span class=\"number\">86</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">87</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</div><div class=\"line\"> <span class=\"number\">88</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">89</span>:                 beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</div><div class=\"line\"> <span class=\"number\">91</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:         eclipseTimeInLock = <span class=\"keyword\">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">94</span>:         beginTimeInLock = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">95</span>:     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"comment\">// 释放写入锁</span></div><div class=\"line\"> <span class=\"number\">97</span>:         releasePutMessageLock();</div><div class=\"line\"> <span class=\"number\">98</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">if</span> (eclipseTimeInLock &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:         log.warn(<span class=\"string\">\"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;\"</span>, eclipseTimeInLock, msg.getBody().length, result);</div><div class=\"line\"><span class=\"number\">102</span>:     &#125;</div><div class=\"line\"><span class=\"number\">103</span>: </div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"comment\">// </span></div><div class=\"line\"><span class=\"number\">105</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != unlockMappedFile &amp;&amp; <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</div><div class=\"line\"><span class=\"number\">107</span>:     &#125;</div><div class=\"line\"><span class=\"number\">108</span>: </div><div class=\"line\"><span class=\"number\">109</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:     <span class=\"comment\">// Statistics</span></div><div class=\"line\"><span class=\"number\">112</span>:     storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</div><div class=\"line\"><span class=\"number\">113</span>:     storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"comment\">// 进行同步||异步 flush||commit</span></div><div class=\"line\"><span class=\"number\">116</span>:     GroupCommitRequest request = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">117</span>:     <span class=\"comment\">// Synchronization flush</span></div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">if</span> (FlushDiskType.SYNC_FLUSH == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">final</span> GroupCommitService service = (GroupCommitService) <span class=\"keyword\">this</span>.flushCommitLogService;</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"><span class=\"number\">121</span>:             request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">122</span>:             service.putRequest(request);</div><div class=\"line\"><span class=\"number\">123</span>:             <span class=\"keyword\">boolean</span> flushOK = request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">125</span>:                 log.error(<span class=\"string\">\"do groupcommit, wait for flush failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span> + msg.getTags()</div><div class=\"line\"><span class=\"number\">126</span>:                     + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">127</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             service.wakeup();</div><div class=\"line\"><span class=\"number\">131</span>:         &#125;</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"comment\">// Asynchronous flush</span></div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:             flushCommitLogService.wakeup(); <span class=\"comment\">// important：唤醒commitLog线程，进行flush</span></div><div class=\"line\"><span class=\"number\">137</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">138</span>:             commitLogService.wakeup();</div><div class=\"line\"><span class=\"number\">139</span>:         &#125;</div><div class=\"line\"><span class=\"number\">140</span>:     &#125;</div><div class=\"line\"><span class=\"number\">141</span>: </div><div class=\"line\"><span class=\"number\">142</span>:     <span class=\"comment\">// Synchronous write double 如果是同步Master，同步到从节点 // TODO 待读：数据同步</span></div><div class=\"line\"><span class=\"number\">143</span>:     <span class=\"keyword\">if</span> (BrokerRole.SYNC_MASTER == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"><span class=\"number\">144</span>:         HAService service = <span class=\"keyword\">this</span>.defaultMessageStore.getHaService();</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"comment\">// Determine whether to wait</span></div><div class=\"line\"><span class=\"number\">147</span>:             <span class=\"keyword\">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == request) &#123;</div><div class=\"line\"><span class=\"number\">149</span>:                     request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">150</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">151</span>:                 service.putRequest(request);</div><div class=\"line\"><span class=\"number\">152</span>: </div><div class=\"line\"><span class=\"number\">153</span>:                 service.getWaitNotifyObject().wakeupAll();</div><div class=\"line\"><span class=\"number\">154</span>: </div><div class=\"line\"><span class=\"number\">155</span>:                 <span class=\"keyword\">boolean</span> flushOK =</div><div class=\"line\"><span class=\"number\">156</span>:                     <span class=\"comment\">// TODO</span></div><div class=\"line\"><span class=\"number\">157</span>:                     request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">158</span>:                 <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">159</span>:                     log.error(<span class=\"string\">\"do sync transfer other node, wait return, but failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span></div><div class=\"line\"><span class=\"number\">160</span>:                         + msg.getTags() + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">161</span>:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">162</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">163</span>:             &#125;</div><div class=\"line\"><span class=\"number\">164</span>:             <span class=\"comment\">// Slave problem</span></div><div class=\"line\"><span class=\"number\">165</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">166</span>:                 <span class=\"comment\">// Tell the producer, slave not available</span></div><div class=\"line\"><span class=\"number\">167</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">168</span>:             &#125;</div><div class=\"line\"><span class=\"number\">169</span>:         &#125;</div><div class=\"line\"><span class=\"number\">170</span>:     &#125;</div><div class=\"line\"><span class=\"number\">171</span>: </div><div class=\"line\"><span class=\"number\">172</span>:     <span class=\"keyword\">return</span> putMessageResult;</div><div class=\"line\"><span class=\"number\">173</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：存储消息，并返回存储结果。</li>\n<li>第 2 行 ：设置存储时间等。</li>\n<li>第 16 至 36 行 ：事务消息相关，暂未了解。</li>\n<li>第 45 &amp; 97 行 ：获取锁与释放锁。</li>\n<li>第 52 行 ：再次设置存储时间。目前会有多处地方设置存储时间。</li>\n<li>第 55 至 62 行 ：获取 <code>MappedFile</code>，若不存在或已满，则进行创建。详细解析见：<a href=\"#mappedfilequeuegetlastmappedfile\">MappedFileQueue#getLastMappedFile(…)</a>。</li>\n<li>第 65 行 ：<strong>插入消息</strong>到 <code>MappedFile</code>，解析解析见：<a href=\"#mappedfileappendmessage\">MappedFile#appendMessage(…)</a>。</li>\n<li>第 69 至 80 行 ：<code>MappedFile</code> 已满，创建新的，再次<strong>插入消息</strong>。</li>\n<li>第 116 至 140 行 ：<strong>消息刷盘</strong>，即持久化到文件。上面<strong>插入消息</strong>实际未存储到硬盘。此处，根据不同的刷盘策略，执行会有不同。详细解析见：<a href=\"#flushcommitlogservice\">FlushCommitLogService</a>。</li>\n<li>第 143 至 173 行 ：<code>Broker</code> 主从同步。后面的文章会详细解析😈。</li>\n</ul>\n<h2 id=\"MappedFileQueue-getLastMappedFile-…\"><a href=\"#MappedFileQueue-getLastMappedFile-…\" class=\"headerlink\" title=\"MappedFileQueue#getLastMappedFile(…)\"></a>MappedFileQueue#getLastMappedFile(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> MappedFile <span class=\"title\">getLastMappedFile</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startOffset, <span class=\"keyword\">boolean</span> needCreate)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">long</span> createOffset = -<span class=\"number\">1</span>; <span class=\"comment\">// 创建文件开始offset。-1时，不创建</span></div><div class=\"line\"> <span class=\"number\">3</span>:     MappedFile mappedFileLast = getLastMappedFile();</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (mappedFileLast == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 一个映射文件都不存在</span></div><div class=\"line\"> <span class=\"number\">6</span>:         createOffset = startOffset - (startOffset % <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"> <span class=\"number\">7</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (mappedFileLast != <span class=\"keyword\">null</span> &amp;&amp; mappedFileLast.isFull()) &#123; <span class=\"comment\">// 最后一个文件已满</span></div><div class=\"line\"><span class=\"number\">10</span>:         createOffset = mappedFileLast.getFileFromOffset() + <span class=\"keyword\">this</span>.mappedFileSize;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (createOffset != -<span class=\"number\">1</span> &amp;&amp; needCreate) &#123; <span class=\"comment\">// 创建文件</span></div><div class=\"line\"><span class=\"number\">14</span>:         String nextFilePath = <span class=\"keyword\">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</div><div class=\"line\"><span class=\"number\">15</span>:         String nextNextFilePath = <span class=\"keyword\">this</span>.storePath + File.separator</div><div class=\"line\"><span class=\"number\">16</span>:             + UtilAll.offset2FileName(createOffset + <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">17</span>:         MappedFile mappedFile = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.allocateMappedFileService != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             mappedFile = <span class=\"keyword\">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</div><div class=\"line\"><span class=\"number\">21</span>:                 nextNextFilePath, <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">22</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 mappedFile = <span class=\"keyword\">new</span> MappedFile(nextFilePath, <span class=\"keyword\">this</span>.mappedFileSize);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 log.error(<span class=\"string\">\"create mappedFile exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mappedFiles.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 mappedFile.setFirstCreateInQueue(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.mappedFiles.add(mappedFile);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> mappedFile;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"keyword\">return</span> mappedFileLast;</div><div class=\"line\"><span class=\"number\">41</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获取最后一个 <code>MappedFile</code>，若不存在或文件已满，则进行创建。</li>\n<li>第 5 至 11 行 ：计算当文件不存在或已满时，新创建文件的 <code>createOffset</code>。</li>\n<li><p>第 14 行 ：计算文件名。从此处我们可<br>以得知，<code>MappedFile</code>的文件命名规则：</p>\n<blockquote>\n<p>fileName[n] = fileName[n - 1] + n * mappedFileSize<br>fileName[0] = startOffset - (startOffset % this.mappedFileSize)</p>\n</blockquote>\n<p>  目前 <code>CommitLog</code> 的 <code>startOffset</code> 为 0。<br>  此处有个<strong>疑问</strong>，为什么需要 <code>(startOffset % this.mappedFileSize)</code>。例如：</p>\n<p>  | startOffset  | mappedFileSize | createOffset |<br>  | — | :– | :– |<br>  | 5 | 1 | 5 |<br>  | 5 | 2 | 4 |<br>  | 5 | 3 | 3  |<br>  | 5 | 4 | 4 |<br>  | 5 | &gt; 5 | 0 |</p>\n<p>  <em>如果有知道的同学，麻烦提示下。😈</em><br>  <em>解答：fileName[0] = startOffset - (startOffset % this.mappedFileSize) 计算出来的是，以 <code>this.mappedFileSize</code> 为每个文件大小时，<code>startOffset</code> 所在文件的开始<code>offset</code></em></p>\n</li>\n<li><p>第 30 至 35 行 ：设置 <code>MappedFile</code>是否是第一个创建的文件。该标识用于 <code>ConsumeQueue</code> 对应的 <code>MappedFile</code> ，详见 <code>ConsumeQueue#fillPreBlank</code>。</p>\n</li>\n</ul>\n<h2 id=\"MappedFile-appendMessage-…\"><a href=\"#MappedFile-appendMessage-…\" class=\"headerlink\" title=\"MappedFile#appendMessage(…)\"></a>MappedFile#appendMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">appendMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg, <span class=\"keyword\">final</span> AppendMessageCallback cb)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">assert</span> msg != <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">assert</span> cb != <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">int</span> currentPos = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (currentPos &lt; <span class=\"keyword\">this</span>.fileSize) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         ByteBuffer byteBuffer = writeBuffer != <span class=\"keyword\">null</span> ? writeBuffer.slice() : <span class=\"keyword\">this</span>.mappedByteBuffer.slice();</div><div class=\"line\"> <span class=\"number\">9</span>:         byteBuffer.position(currentPos);</div><div class=\"line\"><span class=\"number\">10</span>:         AppendMessageResult result =</div><div class=\"line\"><span class=\"number\">11</span>:             cb.doAppend(<span class=\"keyword\">this</span>.getFileFromOffset(), byteBuffer, <span class=\"keyword\">this</span>.fileSize - currentPos, msg);</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.storeTimestamp = result.getStoreTimestamp();</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">15</span>:     &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:     log.error(<span class=\"string\">\"MappedFile.appendMessage return null, wrotePosition: \"</span> + currentPos + <span class=\"string\">\" fileSize: \"</span></div><div class=\"line\"><span class=\"number\">18</span>:         + <span class=\"keyword\">this</span>.fileSize);</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</div><div class=\"line\"><span class=\"number\">20</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>插入消息</strong>到 <code>MappedFile</code>，并返回插入结果。</li>\n<li>第 8 行 ：获取需要写入的字节缓冲区。为什么会有 <code>writeBuffer != null</code> 的判断后，使用不同的字节缓冲区，见：<a href=\"#flushcommitlogservice\">FlushCommitLogService</a>。</li>\n<li>第 9 至 11 行 ：设置写入 <code>position</code>，执行写入，更新 <code>wrotePosition</code>(当前写入位置，下次开始写入开始位置)。</li>\n</ul>\n<h2 id=\"DefaultAppendMessageCallback-doAppend-…\"><a href=\"#DefaultAppendMessageCallback-doAppend-…\" class=\"headerlink\" title=\"DefaultAppendMessageCallback#doAppend(…)\"></a>DefaultAppendMessageCallback#doAppend(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAppendMessageCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AppendMessageCallback</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">// File at the end of the minimum fixed length empty</span></div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> END_FILE_MIN_BLANK_LENGTH = <span class=\"number\">4</span> + <span class=\"number\">4</span>;</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  5:      * 存储在内存中的消息编号字节Buffer</div><div class=\"line\">  6:      */</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer msgIdMemory;</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  9:      * Store the message content</div><div class=\"line\"> 10:      * 存储在内存中的消息字节Buffer</div><div class=\"line\"> 11:      * 当消息传递到&#123;<span class=\"doctag\">@link</span> #doAppend(long, ByteBuffer, int, MessageExtBrokerInner)&#125;方法时，最终写到该参数</div><div class=\"line\"> 12:      */</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer msgStoreItemMemory;</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 15:      * The maximum length of the message</div><div class=\"line\"> 16:      * 消息最大长度</div><div class=\"line\"> 17:      */</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMessageSize;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 20:      * Build Message Key</div><div class=\"line\"> 21:      * &#123;<span class=\"doctag\">@link</span> #topicQueueTable&#125;的key</div><div class=\"line\"> 22:      * 计算方式：topic + \"-\" + queueId</div><div class=\"line\"> 23:      */</div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StringBuilder keyBuilder = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 26:      * host字节buffer</div><div class=\"line\"> 27:      * 用于重复计算host的字节内容</div><div class=\"line\"> 28:      */</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ByteBuffer hostHolder = ByteBuffer.allocate(<span class=\"number\">8</span>);</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:     DefaultAppendMessageCallback(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">this</span>.msgIdMemory = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory = ByteBuffer.allocate(size + END_FILE_MIN_BLANK_LENGTH);</div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">this</span>.maxMessageSize = size;</div><div class=\"line\"> <span class=\"number\">35</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">getMsgStoreItemMemory</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">38</span>:         <span class=\"keyword\">return</span> msgStoreItemMemory;</div><div class=\"line\"> <span class=\"number\">39</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:     <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">doAppend</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> fileFromOffset, <span class=\"keyword\">final</span> ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxBlank, <span class=\"keyword\">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"comment\">// STORETIMESTAMP + STOREHOSTADDRESS + OFFSET &lt;br&gt;</span></div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:         <span class=\"comment\">// PHY OFFSET</span></div><div class=\"line\"> <span class=\"number\">45</span>:         <span class=\"keyword\">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"comment\">// 计算commitLog里的msgId</span></div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"> <span class=\"number\">49</span>:         String msgId = MessageDecoder.createMessageId(<span class=\"keyword\">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</div><div class=\"line\"> <span class=\"number\">50</span>: </div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"comment\">// Record ConsumeQueue information 获取队列offset</span></div><div class=\"line\"> <span class=\"number\">52</span>:         keyBuilder.setLength(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">53</span>:         keyBuilder.append(msgInner.getTopic());</div><div class=\"line\"> <span class=\"number\">54</span>:         keyBuilder.append(<span class=\"string\">'-'</span>);</div><div class=\"line\"> <span class=\"number\">55</span>:         keyBuilder.append(msgInner.getQueueId());</div><div class=\"line\"> <span class=\"number\">56</span>:         String key = keyBuilder.toString();</div><div class=\"line\"> <span class=\"number\">57</span>:         Long queueOffset = CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.get(key);</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == queueOffset) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:             queueOffset = <span class=\"number\">0L</span>;</div><div class=\"line\"> <span class=\"number\">60</span>:             CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, queueOffset);</div><div class=\"line\"> <span class=\"number\">61</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"comment\">// Transaction messages that require special handling // TODO 疑问：用途</span></div><div class=\"line\"> <span class=\"number\">64</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</div><div class=\"line\"> <span class=\"number\">65</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"comment\">// Prepared and Rollback message is not consumed, will not enter the</span></div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"comment\">// consumer queue</span></div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"> <span class=\"number\">70</span>:                 queueOffset = <span class=\"number\">0L</span>;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">72</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"> <span class=\"number\">73</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">76</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">77</span>: </div><div class=\"line\"> <span class=\"number\">78</span>:         <span class=\"comment\">// 计算消息长度</span></div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] propertiesData =</div><div class=\"line\"> <span class=\"number\">80</span>:             msgInner.getPropertiesString() == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class=\"line\"> <span class=\"number\">81</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> propertiesLength = propertiesData == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : propertiesData.length;</div><div class=\"line\"> <span class=\"number\">82</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:             log.warn(<span class=\"string\">\"putMessage message properties length too long. length=&#123;&#125;\"</span>, propertiesData.length);</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> topicLength = topicData.length;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bodyLength = msgInner.getBody() == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : msgInner.getBody().length;</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"comment\">// Exceeds the maximum message</span></div><div class=\"line\"> <span class=\"number\">91</span>:         <span class=\"keyword\">if</span> (msgLen &gt; <span class=\"keyword\">this</span>.maxMessageSize) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:             CommitLog.log.warn(<span class=\"string\">\"message size exceeded, msg total size: \"</span> + msgLen + <span class=\"string\">\", msg body size: \"</span> + bodyLength</div><div class=\"line\"> <span class=\"number\">93</span>:                 + <span class=\"string\">\", maxMessageSize: \"</span> + <span class=\"keyword\">this</span>.maxMessageSize);</div><div class=\"line\"> <span class=\"number\">94</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</div><div class=\"line\"> <span class=\"number\">95</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:         <span class=\"comment\">// Determines whether there is sufficient(足够) free space</span></div><div class=\"line\"> <span class=\"number\">98</span>:         <span class=\"keyword\">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:             <span class=\"keyword\">this</span>.resetByteBuffer(<span class=\"keyword\">this</span>.msgStoreItemMemory, maxBlank);</div><div class=\"line\"><span class=\"number\">100</span>:             <span class=\"comment\">// 1 TOTAL_SIZE</span></div><div class=\"line\"><span class=\"number\">101</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(maxBlank);</div><div class=\"line\"><span class=\"number\">102</span>:             <span class=\"comment\">// 2 MAGIC_CODE</span></div><div class=\"line\"><span class=\"number\">103</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</div><div class=\"line\"><span class=\"number\">104</span>:             <span class=\"comment\">// 3 The remaining space may be any value</span></div><div class=\"line\"><span class=\"number\">105</span>:             <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:             <span class=\"comment\">// Here the length of the specially set maxBlank</span></div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now();</div><div class=\"line\"><span class=\"number\">109</span>:             byteBuffer.put(<span class=\"keyword\">this</span>.msgStoreItemMemory.array(), <span class=\"number\">0</span>, maxBlank);</div><div class=\"line\"><span class=\"number\">110</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</div><div class=\"line\"><span class=\"number\">111</span>:                 queueOffset, CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now() - beginTimeMills);</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"comment\">// Initialization of storage space</span></div><div class=\"line\"><span class=\"number\">115</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</div><div class=\"line\"><span class=\"number\">116</span>:         <span class=\"comment\">// 1 TOTAL_SIZE</span></div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgLen);</div><div class=\"line\"><span class=\"number\">118</span>:         <span class=\"comment\">// 2 MAGIC_CODE</span></div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"comment\">// 3 BODY_CRC</span></div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"comment\">// 4 QUEUE_ID</span></div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</div><div class=\"line\"><span class=\"number\">124</span>:         <span class=\"comment\">// 5 FLAG</span></div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</div><div class=\"line\"><span class=\"number\">126</span>:         <span class=\"comment\">// 6 QUEUE_OFFSET</span></div><div class=\"line\"><span class=\"number\">127</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(queueOffset);</div><div class=\"line\"><span class=\"number\">128</span>:         <span class=\"comment\">// 7 PHYSICAL_OFFSET</span></div><div class=\"line\"><span class=\"number\">129</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</div><div class=\"line\"><span class=\"number\">130</span>:         <span class=\"comment\">// 8 SYS_FLAG</span></div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</div><div class=\"line\"><span class=\"number\">132</span>:         <span class=\"comment\">// 9 BORN_TIMESTAMP</span></div><div class=\"line\"><span class=\"number\">133</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">134</span>:         <span class=\"comment\">// 10 BORN_HOST</span></div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">136</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(hostHolder));</div><div class=\"line\"><span class=\"number\">137</span>:         <span class=\"comment\">// 11 STORE_TIMESTAMP</span></div><div class=\"line\"><span class=\"number\">138</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"comment\">// 12 STORE_HOST_ADDRESS</span></div><div class=\"line\"><span class=\"number\">140</span>:         <span class=\"keyword\">this</span>.resetByteBuffer(hostHolder, <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(hostHolder));</div><div class=\"line\"><span class=\"number\">142</span>:         <span class=\"comment\">//this.msgStoreItemMemory.put(msgInner.getStoreHostBytes());</span></div><div class=\"line\"><span class=\"number\">143</span>:         <span class=\"comment\">// 13 RECONSUME_TIMES</span></div><div class=\"line\"><span class=\"number\">144</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"comment\">// 14 Prepared Transaction Offset</span></div><div class=\"line\"><span class=\"number\">146</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"comment\">// 15 BODY</span></div><div class=\"line\"><span class=\"number\">148</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putInt(bodyLength);</div><div class=\"line\"><span class=\"number\">149</span>:         <span class=\"keyword\">if</span> (bodyLength &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">150</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.put(msgInner.getBody());</div><div class=\"line\"><span class=\"number\">151</span>:         <span class=\"comment\">// 16 TOPIC</span></div><div class=\"line\"><span class=\"number\">152</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put((<span class=\"keyword\">byte</span>) topicLength);</div><div class=\"line\"><span class=\"number\">153</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.put(topicData);</div><div class=\"line\"><span class=\"number\">154</span>:         <span class=\"comment\">// 17 PROPERTIES</span></div><div class=\"line\"><span class=\"number\">155</span>:         <span class=\"keyword\">this</span>.msgStoreItemMemory.putShort((<span class=\"keyword\">short</span>) propertiesLength);</div><div class=\"line\"><span class=\"number\">156</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"number\">157</span>:             <span class=\"keyword\">this</span>.msgStoreItemMemory.put(propertiesData);</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now();</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"comment\">// Write messages to the queue buffer</span></div><div class=\"line\"><span class=\"number\">161</span>:         byteBuffer.put(<span class=\"keyword\">this</span>.msgStoreItemMemory.array(), <span class=\"number\">0</span>, msgLen);</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:         AppendMessageResult result = <span class=\"keyword\">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</div><div class=\"line\"><span class=\"number\">164</span>:             msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.now() - beginTimeMills);</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">167</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"><span class=\"number\">168</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"><span class=\"number\">169</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">170</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"><span class=\"number\">171</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"><span class=\"number\">172</span>:                 <span class=\"comment\">// The next update ConsumeQueue information 更新队列的offset</span></div><div class=\"line\"><span class=\"number\">173</span>:                 CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, ++queueOffset);</div><div class=\"line\"><span class=\"number\">174</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">175</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">176</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">177</span>:         &#125;</div><div class=\"line\"><span class=\"number\">178</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">179</span>:     &#125;</div><div class=\"line\"><span class=\"number\">180</span>: </div><div class=\"line\"><span class=\"number\">181</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">182:      * 重置字节缓冲区</div><div class=\"line\">183:      *</div><div class=\"line\">184:      * <span class=\"doctag\">@param</span> byteBuffer 字节缓冲区</div><div class=\"line\">185:      * <span class=\"doctag\">@param</span> limit 长度</div><div class=\"line\">186:      */</div><div class=\"line\"><span class=\"number\">187</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resetByteBuffer</span><span class=\"params\">(<span class=\"keyword\">final</span> ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> limit)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">188</span>:         byteBuffer.flip();</div><div class=\"line\"><span class=\"number\">189</span>:         byteBuffer.limit(limit);</div><div class=\"line\"><span class=\"number\">190</span>:     &#125;</div><div class=\"line\"><span class=\"number\">191</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：插入消息到字节缓冲区。</li>\n<li>第 45 行 ：计算物理位置。在 <code>CommitLog</code> 的顺序存储位置。</li>\n<li>第 47 至 49 行 ：计算 <code>CommitLog</code> 里的 <code>offsetMsgId</code>。这里一定要和 <code>msgId</code> 区分开。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th>计算方式</th>\n<th>长度</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>offsetMsgId</td>\n<td>Broker存储时生成</td>\n<td>Hex(storeHostBytes, wroteOffset)</td>\n<td>32</td>\n</tr>\n<tr>\n<td>msgId</td>\n<td>Client发送消息时生成</td>\n<td>Hex(进程编号, IP, ClassLoader, startTime, currentTime, 自增序列)</td>\n<td>32</td>\n<td><a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message 基础》</a></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>第 51 至 61 行 ：获取队列位置(offset)。</li>\n<li>第 78 至 95 行 ：计算消息总长度。</li>\n<li>第 98 至 112 行 ：当文件剩余空间不足时，写入 <code>BLANK</code> 占位，返回结果。</li>\n<li>第 114 至 161 行 ：写入 <code>MESSAGE</code> 。</li>\n<li>第 173 行 ：更新队列位置(offset)。</li>\n</ul>\n<h2 id=\"FlushCommitLogService\"><a href=\"#FlushCommitLogService\" class=\"headerlink\" title=\"FlushCommitLogService\"></a>FlushCommitLogService</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/03.png\" alt=\"FlushCommitLogService类图\"></p>\n<table>\n<thead>\n<tr>\n<th>线程服务</th>\n<th>场景</th>\n<th>插入消息性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CommitRealTimeService</td>\n<td>异步刷盘 &amp;&amp; 开启内存字节缓冲区</td>\n<td>第一</td>\n</tr>\n<tr>\n<td>FlushRealTimeService</td>\n<td>异步刷盘 &amp;&amp; 关闭内存字节缓冲区</td>\n<td>第二</td>\n</tr>\n<tr>\n<td>GroupCommitService</td>\n<td>同步刷盘</td>\n<td>第三</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"MappedFile-落盘\"><a href=\"#MappedFile-落盘\" class=\"headerlink\" title=\"MappedFile#落盘\"></a>MappedFile#落盘</h3><table>\n<thead>\n<tr>\n<th>方式</th>\n<th></th>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方式一</td>\n<td>写入内存字节缓冲区(writeBuffer)</td>\n<td style=\"text-align:left\">从内存字节缓冲区(write buffer)提交(commit)到文件通道(fileChannel)</td>\n<td style=\"text-align:left\">文件通道(fileChannel)flush</td>\n</tr>\n<tr>\n<td>方式二</td>\n<td></td>\n<td style=\"text-align:left\">写入映射文件字节缓冲区(mappedByteBuffer)</td>\n<td style=\"text-align:left\">映射文件字节缓冲区(mappedByteBuffer)flush</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_04_23/04.jpeg\" alt=\"MappedFile的position迁移图\"></p>\n<p><strong>flush相关代码</strong></p>\n<p>考虑到写入性能，满足 <code>flushLeastPages * OS_PAGE_SIZE</code> 才进行 <code>flush</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * flush</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> flushLeastPages flush最小页数</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> The current flushed position</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">flush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAbleToFlush(flushLeastPages)) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hold()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">int</span> value = getReadPosition();</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"comment\">//We only append data to fileChannel or mappedByteBuffer, never both.</span></div><div class=\"line\"><span class=\"number\">14</span>:                 <span class=\"keyword\">if</span> (writeBuffer != <span class=\"keyword\">null</span> || <span class=\"keyword\">this</span>.fileChannel.position() != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                     <span class=\"keyword\">this</span>.fileChannel.force(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">16</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     <span class=\"keyword\">this</span>.mappedByteBuffer.force();</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">19</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                 log.error(<span class=\"string\">\"Error occurred when force data to disk.\"</span>, e);</div><div class=\"line\"><span class=\"number\">21</span>:             &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">this</span>.flushedPosition.set(value);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.release();</div><div class=\"line\"><span class=\"number\">25</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:             log.warn(<span class=\"string\">\"in flush, hold failed, flush offset = \"</span> + <span class=\"keyword\">this</span>.flushedPosition.get());</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">this</span>.flushedPosition.set(getReadPosition());</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getFlushedPosition();</div><div class=\"line\"><span class=\"number\">31</span>: &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>: <span class=\"comment\">/**</span></div><div class=\"line\">34:  * 是否能够flush。满足如下条件任意条件：</div><div class=\"line\">35:  * 1. 映射文件已经写满</div><div class=\"line\">36:  * 2. flushLeastPages &gt; 0 &amp;&amp; 未flush部分超过flushLeastPages</div><div class=\"line\">37:  * 3. flushLeastPages = 0 &amp;&amp; 有新写入部分</div><div class=\"line\">38:  *</div><div class=\"line\">39:  * <span class=\"doctag\">@param</span> flushLeastPages flush最小分页</div><div class=\"line\">40:  * <span class=\"doctag\">@return</span> 是否能够写入</div><div class=\"line\">41:  */</div><div class=\"line\"><span class=\"number\">42</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAbleToFlush</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> flushLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"keyword\">int</span> flush = <span class=\"keyword\">this</span>.flushedPosition.get();</div><div class=\"line\"><span class=\"number\">44</span>:     <span class=\"keyword\">int</span> write = getReadPosition();</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isFull()) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">48</span>:     &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"keyword\">if</span> (flushLeastPages &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:     <span class=\"keyword\">return</span> write &gt; flush;</div><div class=\"line\"><span class=\"number\">55</span>: &#125;</div></pre></td></tr></table></figure>\n<p><strong>commit相关代码：</strong></p>\n<p>考虑到写入性能，满足 <code>commitLeastPages * OS_PAGE_SIZE</code> 才进行 <code>commit</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * commit</div><div class=\"line\"> 3:  * 当&#123;<span class=\"doctag\">@link</span> #writeBuffer&#125;为null时，直接返回&#123;<span class=\"doctag\">@link</span> #wrotePosition&#125;</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小页数</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 当前commit位置</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">commit</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (writeBuffer == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isAbleToCommit(commitLeastPages)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hold()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             commit0(commitLeastPages);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">this</span>.release();</div><div class=\"line\"><span class=\"number\">17</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:             log.warn(<span class=\"string\">\"in commit, hold failed, commit offset = \"</span> + <span class=\"keyword\">this</span>.committedPosition.get());</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">// All dirty data has been committed to FileChannel. 写到文件尾时，回收writeBuffer。</span></div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">if</span> (writeBuffer != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.transientStorePool != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.fileSize == <span class=\"keyword\">this</span>.committedPosition.get()) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">this</span>.transientStorePool.returnBuffer(writeBuffer);</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">this</span>.writeBuffer = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">29</span>: &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>: <span class=\"comment\">/**</span></div><div class=\"line\">32:  * commit实现，将writeBuffer写入fileChannel。</div><div class=\"line\">33:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小页数。用不上该参数</div><div class=\"line\">34:  */</div><div class=\"line\"><span class=\"number\">35</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">commit0</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">int</span> writePos = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"keyword\">int</span> lastCommittedPosition = <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">if</span> (writePos - <span class=\"keyword\">this</span>.committedPosition.get() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"comment\">// 设置需要写入的byteBuffer</span></div><div class=\"line\"><span class=\"number\">42</span>:             ByteBuffer byteBuffer = writeBuffer.slice();</div><div class=\"line\"><span class=\"number\">43</span>:             byteBuffer.position(lastCommittedPosition);</div><div class=\"line\"><span class=\"number\">44</span>:             byteBuffer.limit(writePos);</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"comment\">// 写入fileChannel</span></div><div class=\"line\"><span class=\"number\">46</span>:             <span class=\"keyword\">this</span>.fileChannel.position(lastCommittedPosition);</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">this</span>.fileChannel.write(byteBuffer);</div><div class=\"line\"><span class=\"number\">48</span>:             <span class=\"comment\">// 设置position</span></div><div class=\"line\"><span class=\"number\">49</span>:             <span class=\"keyword\">this</span>.committedPosition.set(writePos);</div><div class=\"line\"><span class=\"number\">50</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:             log.error(<span class=\"string\">\"Error occurred when commit data to FileChannel.\"</span>, e);</div><div class=\"line\"><span class=\"number\">52</span>:         &#125;</div><div class=\"line\"><span class=\"number\">53</span>:     &#125;</div><div class=\"line\"><span class=\"number\">54</span>: &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>: <span class=\"comment\">/**</span></div><div class=\"line\">57:  * 是否能够commit。满足如下条件任意条件：</div><div class=\"line\">58:  * 1. 映射文件已经写满</div><div class=\"line\">59:  * 2. commitLeastPages &gt; 0 &amp;&amp; 未commit部分超过commitLeastPages</div><div class=\"line\">60:  * 3. commitLeastPages = 0 &amp;&amp; 有新写入部分</div><div class=\"line\">61:  *</div><div class=\"line\">62:  * <span class=\"doctag\">@param</span> commitLeastPages commit最小分页</div><div class=\"line\">63:  * <span class=\"doctag\">@return</span> 是否能够写入</div><div class=\"line\">64:  */</div><div class=\"line\"><span class=\"number\">65</span>: <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAbleToCommit</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> commitLeastPages)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"keyword\">int</span> flush = <span class=\"keyword\">this</span>.committedPosition.get();</div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"keyword\">int</span> write = <span class=\"keyword\">this</span>.wrotePosition.get();</div><div class=\"line\"><span class=\"number\">68</span>: </div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isFull()) &#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125;</div><div class=\"line\"><span class=\"number\">72</span>: </div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"keyword\">if</span> (commitLeastPages &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> write &gt; flush;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"FlushRealTimeService\"><a href=\"#FlushRealTimeService\" class=\"headerlink\" title=\"FlushRealTimeService\"></a>FlushRealTimeService</h3><p>消息插入成功时，异步刷盘时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlushRealTimeService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 最后flush时间戳</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastFlushTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 7:      * print计时器。</div><div class=\"line\"> 8:      * 满足print次数时，调用&#123;<span class=\"doctag\">@link</span> #printFlushProgress()&#125;</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> printTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">boolean</span> flushCommitLogTimed = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">int</span> interval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">int</span> flushPhysicQueueLeastPages = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> flushPhysicQueueThoroughInterval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// Print flush progress</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"comment\">// 当时间满足flushPhysicQueueThoroughInterval时，即使写入的数量不足flushPhysicQueueLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">boolean</span> printFlushProgress = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"keyword\">if</span> (currentTimeMillis &gt;= (<span class=\"keyword\">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 <span class=\"keyword\">this</span>.lastFlushTimestamp = currentTimeMillis;</div><div class=\"line\"><span class=\"number\">27</span>:                 flushPhysicQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">28</span>:                 printFlushProgress = (printTimes++ % <span class=\"number\">10</span>) == <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">29</span>:             &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"comment\">// 等待执行</span></div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">if</span> (flushCommitLogTimed) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:                     Thread.sleep(interval);</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (printFlushProgress) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                     <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"comment\">// flush commitLog</span></div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">45</span>:                 CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">long</span> storeTimestamp = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">if</span> (storeTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                     CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div><div class=\"line\"><span class=\"number\">49</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">long</span> past = System.currentTimeMillis() - begin;</div><div class=\"line\"><span class=\"number\">51</span>:                 <span class=\"keyword\">if</span> (past &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                     log.info(<span class=\"string\">\"Flush data to disk costs &#123;&#125; ms\"</span>, past);</div><div class=\"line\"><span class=\"number\">53</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">54</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                 CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">57</span>:             &#125;</div><div class=\"line\"><span class=\"number\">58</span>:         &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:         <span class=\"comment\">// Normal shutdown, to ensure that all the flush before exit</span></div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:             result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">64</span>:             CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service shutdown, retry \"</span> + (i + <span class=\"number\">1</span>) + <span class=\"string\">\" times \"</span> + (result ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Not OK\"</span>));</div><div class=\"line\"><span class=\"number\">65</span>:         &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:         <span class=\"keyword\">this</span>.printFlushProgress();</div><div class=\"line\"><span class=\"number\">68</span>: </div><div class=\"line\"><span class=\"number\">69</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">70</span>:     &#125;</div><div class=\"line\"><span class=\"number\">71</span>: </div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> FlushRealTimeService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printFlushProgress</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">78</span>:         <span class=\"comment\">// CommitLog.log.info(\"how much disk fall behind memory, \"</span></div><div class=\"line\"><span class=\"number\">79</span>:         <span class=\"comment\">// + CommitLog.this.mappedFileQueue.howMuchFallBehind());</span></div><div class=\"line\"><span class=\"number\">80</span>:     &#125;</div><div class=\"line\"><span class=\"number\">81</span>: </div><div class=\"line\"><span class=\"number\">82</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">83</span>:     <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"SpellCheckingInspection\"</span>)</div><div class=\"line\"><span class=\"number\">84</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">85</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"number\">86</span>:     &#125;</div><div class=\"line\"><span class=\"number\">87</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：实时 <code>flush</code>线程服务，调用 <code>MappedFile#flush</code> 相关逻辑。</li>\n<li>第 23 至 29 行 ：每 <code>flushPhysicQueueThoroughInterval</code> 周期，执行一次 <code>flush</code> 。因为不是每次循环到都能满足 <code>flushCommitLogLeastPages</code> 大小，因此，需要一定周期进行一次强制 <code>flush</code> 。当然，不能每次循环都去执行强制 <code>flush</code>，这样性能较差。</li>\n<li>第 33 行 至 37 行 ：根据 <code>flushCommitLogTimed</code> 参数，可以选择每次循环是<strong>固定周期</strong>还是<strong>等待唤醒</strong>。默认配置是后者，所以，每次插入消息完成，会去调用 <code>commitLogService.wakeup()</code> 。</li>\n<li>第 45 行 ：调用 <code>MappedFile</code> 进行 <code>flush</code>。</li>\n<li>第 61 至 65 行 ：<code>Broker</code> 关闭时，强制 <code>flush</code>，避免有未刷盘的数据。</li>\n</ul>\n<h3 id=\"CommitRealTimeService\"><a href=\"#CommitRealTimeService\" class=\"headerlink\" title=\"CommitRealTimeService\"></a>CommitRealTimeService</h3><p>消息插入成功时，异步刷盘时使用。<br>和 <code>FlushRealTimeService</code> 类似，性能更好。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommitRealTimeService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 最后 commit 时间戳</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastCommitTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">return</span> CommitRealTimeService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">15</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">int</span> interval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">int</span> commitDataLeastPages = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> commitDataThoroughInterval = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 当时间满足commitDataThoroughInterval时，即使写入的数量不足commitDataLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">long</span> begin = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">if</span> (begin &gt;= (<span class=\"keyword\">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"keyword\">this</span>.lastCommitTimestamp = begin;</div><div class=\"line\"><span class=\"number\">25</span>:                 commitDataLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">26</span>:             &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"comment\">// commit</span></div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">boolean</span> result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.commit(commitDataLeastPages);</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">long</span> end = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">if</span> (!result) &#123; <span class=\"comment\">// TODO 疑问：未写入成功，为啥要唤醒flushCommitLogService</span></div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">this</span>.lastCommitTimestamp = end; <span class=\"comment\">// result = false means some data committed.</span></div><div class=\"line\"><span class=\"number\">34</span>:                     <span class=\"comment\">//now wake up flush thread.</span></div><div class=\"line\"><span class=\"number\">35</span>:                     flushCommitLogService.wakeup();</div><div class=\"line\"><span class=\"number\">36</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">if</span> (end - begin &gt; <span class=\"number\">500</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                     log.info(<span class=\"string\">\"Commit data to file costs &#123;&#125; ms\"</span>, end - begin);</div><div class=\"line\"><span class=\"number\">40</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"comment\">// 等待执行</span></div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">44</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:                 CommitLog.log.error(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">46</span>:             &#125;</div><div class=\"line\"><span class=\"number\">47</span>:         &#125;</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">50</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:             result = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.commit(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">52</span>:             CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service shutdown, retry \"</span> + (i + <span class=\"number\">1</span>) + <span class=\"string\">\" times \"</span> + (result ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Not OK\"</span>));</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">55</span>:     &#125;</div><div class=\"line\"><span class=\"number\">56</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"GroupCommitService\"><a href=\"#GroupCommitService\" class=\"headerlink\" title=\"GroupCommitService\"></a>GroupCommitService</h3><p>消息插入成功时，同步刷盘时使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroupCommitService</span> <span class=\"keyword\">extends</span> <span class=\"title\">FlushCommitLogService</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  3:      * 写入请求队列</div><div class=\"line\">  4:      */</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;GroupCommitRequest&gt; requestsWrite = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  7:      * 读取请求队列</div><div class=\"line\">  8:      */</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> List&lt;GroupCommitRequest&gt; requestsRead = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 添加写入请求</div><div class=\"line\"> 13:      *</div><div class=\"line\"> 14:      * <span class=\"doctag\">@param</span> request 写入请求</div><div class=\"line\"> 15:      */</div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">putRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> GroupCommitRequest request)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"comment\">// 添加写入请求</span></div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsWrite) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.requestsWrite.add(request);</div><div class=\"line\"> <span class=\"number\">20</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"comment\">// 切换读写队列</span></div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (hasNotified.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>)) &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             waitPoint.countDown(); <span class=\"comment\">// notify</span></div><div class=\"line\"> <span class=\"number\">24</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">25</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 28:      * 切换读写队列</div><div class=\"line\"> 29:      */</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">swapRequests</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">31</span>:         List&lt;GroupCommitRequest&gt; tmp = <span class=\"keyword\">this</span>.requestsWrite;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">this</span>.requestsWrite = <span class=\"keyword\">this</span>.requestsRead;</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.requestsRead = tmp;</div><div class=\"line\"> <span class=\"number\">34</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">35</span>: </div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doCommit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">37</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:             <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"keyword\">for</span> (GroupCommitRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"comment\">// There may be a message in the next file, so a maximum of</span></div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"comment\">// two times the flush (可能批量提交的messages，分布在两个MappedFile)</span></div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">boolean</span> flushOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">43</span>:                     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span> &amp;&amp; !flushOK; i++) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:                         <span class=\"comment\">// 是否满足需要flush条件，即请求的offset超过flush的offset</span></div><div class=\"line\"> <span class=\"number\">45</span>:                         flushOK = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</div><div class=\"line\"> <span class=\"number\">46</span>:                         <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:                             CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">48</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">50</span>:                     <span class=\"comment\">// 唤醒等待请求</span></div><div class=\"line\"> <span class=\"number\">51</span>:                     req.wakeupCustomer(flushOK);</div><div class=\"line\"> <span class=\"number\">52</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:                 <span class=\"keyword\">long</span> storeTimestamp = CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.getStoreTimestamp();</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">if</span> (storeTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>: </div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"comment\">// 清理读取队列</span></div><div class=\"line\"> <span class=\"number\">60</span>:                 <span class=\"keyword\">this</span>.requestsRead.clear();</div><div class=\"line\"> <span class=\"number\">61</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">62</span>:                 <span class=\"comment\">// Because of individual messages is set to not sync flush, it</span></div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"comment\">// will come to this process 不合法的请求，比如message上未设置isWaitStoreMsgOK。</span></div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"comment\">// 走到此处的逻辑，相当于发送一条消息，落盘一条消息，实际无批量提交的效果。</span></div><div class=\"line\"> <span class=\"number\">65</span>:                 CommitLog.<span class=\"keyword\">this</span>.mappedFileQueue.flush(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">66</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">67</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">71</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">76</span>:                 <span class=\"keyword\">this</span>.doCommit();</div><div class=\"line\"> <span class=\"number\">77</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                 CommitLog.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"> <span class=\"number\">79</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">80</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:         <span class=\"comment\">// Under normal circumstances shutdown, wait for the arrival of the</span></div><div class=\"line\"> <span class=\"number\">83</span>:         <span class=\"comment\">// request, and then flush</span></div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">85</span>:             Thread.sleep(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">86</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:             CommitLog.log.warn(<span class=\"string\">\"GroupCommitService Exception, \"</span>, e);</div><div class=\"line\"> <span class=\"number\">88</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">this</span>.swapRequests();</div><div class=\"line\"> <span class=\"number\">92</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">93</span>: </div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"keyword\">this</span>.doCommit();</div><div class=\"line\"> <span class=\"number\">95</span>: </div><div class=\"line\"> <span class=\"number\">96</span>:         CommitLog.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"> <span class=\"number\">97</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">100:      * 每次执行完，切换读写队列</div><div class=\"line\">101:      */</div><div class=\"line\"><span class=\"number\">102</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onWaitEnd</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">104</span>:         <span class=\"keyword\">this</span>.swapRequests();</div><div class=\"line\"><span class=\"number\">105</span>:     &#125;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"keyword\">return</span> GroupCommitService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">110</span>:     &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"number\">115</span>:     &#125;</div><div class=\"line\"><span class=\"number\">116</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：批量写入线程服务。</li>\n<li>第 16 至 25 行 ：添加写入请求。方法设置了 <code>sync</code> 的原因：<code>this.requestsWrite</code> 会和 <code>this.requestsRead</code> 不断交换，无法保证稳定的同步。</li>\n<li>第 27 至 34 行 ：读写队列交换。</li>\n<li>第 38 至 60 行 ：循环写入队列，进行 <code>flush</code>。<ul>\n<li>第 43 行 ：考虑到有可能每次循环的消息写入的消息，可能分布在<strong>两个</strong> <code>MappedFile</code>(写第N个消息时，<code>MappedFile</code> 已满，创建了一个新的)，所以需要有循环2次。</li>\n<li>第 51 行 ：唤醒等待写入请求线程，通过 <code>CountDownLatch</code> 实现。</li>\n</ul>\n</li>\n<li>第 61 至 66 行 ：直接刷盘。此处是由于发送的消息的 <code>isWaitStoreMsgOK</code> 未设置成 <code>TRUE</code> ，导致未走批量提交。</li>\n<li>第 73 至 80 行 ：每 10ms 执行一次批量提交。当然，如果 <code>wakeup()</code> 时，则会立即进行一次批量提交。当 <code>Broker</code> 设置成同步落盘 &amp;&amp; 消息 <code>isWaitStoreMsgOK=true</code>，消息需要略大于 10ms 才能发送成功。当然，性能相对异步落盘较差，可靠性更高，需要我们在实际使用时去取舍。 </li>\n</ul>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>写的第二篇与RocketMQ源码相关的博文，看到有阅读、点赞、收藏甚至订阅，很受鼓舞。</p>\n<p>《Message存储》比起《Message发送&amp;接收》从难度上说是更大的，当然也是更有趣的，如果存在理解错误或者表达不清晰，还请大家多多包含。如果可以的话，还请麻烦添加 QQ：7685413 进行指出，避免自己的理解错误，给大家造成困扰。</p>\n<p>推荐<a href=\"http://www.jasongj.com/kafka/high_throughput/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《Kafka设计解析（六）- Kafka高性能架构之道》</a>，作者站在的高度比我高的多的多，嗯，按照李小璐的说法：高一个喜马拉雅山。😈认真啃读《Linux内核设计与实现(原书第3版)》，day day up。</p>\n<p>再次感谢大家的阅读、点赞、收藏。</p>\n<p>下一篇：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">《RocketMQ 源码分析 —— Message 拉取与消费》</a> 起航！</p>\n"},{"title":"RocketMQ 源码分析 —— Message 顺序发送与消费","date":"2017-05-12T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-send-and-consume-orderly](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Producer 顺序发送](#)\n- [3. Consumer 顺序消费](#)\n\t- [3.1 获得(锁定)消息队列](#)\n\t- [3.2 移除消息队列](#)\n\t- [3.3 消费消息队列](#)\n\t\t- [3.1.1 消费消息](#)\n\t\t- [3.1.2 处理消费结果](#)\n\t\t- [3.13 消息处理队列核心方法](#)\n\n# 1. 概述\n\n**建议**前置阅读内容：\n\n* [《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)\n* [《RocketMQ 源码分析 —— Message 拉取与消费（下）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)\n\n当然对 `Message` 发送与消费已经有一定了解的同学，可以选择跳过。\n\n-------\n\n`RocketMQ` 提供了两种顺序级别：\n\n* 普通顺序消息 ：`Producer` 将相关联的消息发送到相同的消息队列。\n* 完全严格顺序 ：在 `普通顺序消息` 的基础上，`Consumer` 严格顺序消费。\n\n绝大部分场景下只需要用到**普通顺序消息**。  \n例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，**不会产生系统逻辑上BUG**。另外，`普通顺序消息`性能能更加好。  \n那么什么时候使用使用**完全严格顺序**？如下是来自官方文档的说明：\n> 目前已知的应用只有数据库 `binlog` 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息\n\n-------\n\n😈上代码！！！\n\n# 2. `Producer` 顺序发送\n\n官方发送顺序消息的**例子**：\n\n```Java\n  1: package org.apache.rocketmq.example.ordermessage;\n  2: \n  3: import java.io.UnsupportedEncodingException;\n  4: import java.util.List;\n  5: import org.apache.rocketmq.client.exception.MQBrokerException;\n  6: import org.apache.rocketmq.client.exception.MQClientException;\n  7: import org.apache.rocketmq.client.producer.DefaultMQProducer;\n  8: import org.apache.rocketmq.client.producer.MQProducer;\n  9: import org.apache.rocketmq.client.producer.MessageQueueSelector;\n 10: import org.apache.rocketmq.client.producer.SendResult;\n 11: import org.apache.rocketmq.common.message.Message;\n 12: import org.apache.rocketmq.common.message.MessageQueue;\n 13: import org.apache.rocketmq.remoting.common.RemotingHelper;\n 14: import org.apache.rocketmq.remoting.exception.RemotingException;\n 15: \n 16: public class Producer {\n 17:     public static void main(String[] args) throws UnsupportedEncodingException {\n 18:         try {\n 19:             MQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n 20:             producer.start();\n 21: \n 22:             String[] tags = new String[] {\"TagA\", \"TagB\", \"TagC\", \"TagD\", \"TagE\"};\n 23:             for (int i = 0; i < 100; i++) {\n 24:                 int orderId = i % 10;\n 25:                 Message msg =\n 26:                     new Message(\"TopicTestjjj\", tags[i % tags.length], \"KEY\" + i,\n 27:                         (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET));\n 28:                 SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n 29:                     @Override\n 30:                     public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n 31:                         Integer id = (Integer) arg;\n 32:                         int index = id % mqs.size();\n 33:                         return mqs.get(index);\n 34:                     }\n 35:                 }, orderId);\n 36: \n 37:                 System.out.printf(\"%s%n\", sendResult);\n 38:             }\n 39: \n 40:             producer.shutdown();\n 41:         } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n 42:             e.printStackTrace();\n 43:         }\n 44:     }\n 45: }\n```\n\n* 第 28 至 35 行 ：实现了根据 `id % mqs.size()` 来进行消息队列的选择。当前例子，**我们传递 `orderId` 作为参数，那么相同的 `orderId` 能够进入相同的消息队列**。\n\n-------\n\n`MessageQueueSelector` 接口的**源码**：\n\n```Java\n  1: public interface MessageQueueSelector {\n  2: \n  3:     /**\n  4:      * 选择消息队列\n  5:      *\n  6:      * @param mqs 消息队列\n  7:      * @param msg 消息\n  8:      * @param arg 参数\n  9:      * @return 消息队列\n 10:      */\n 11:     MessageQueue select(final List<MessageQueue> mqs, final Message msg, final Object arg);\n 12: }\n```\n-------\n\n`Producer` 选择队列发送消息方法的**源码**：\n\n```Java\n 16: private SendResult sendSelectImpl(//\n 17:     Message msg, //\n 18:     MessageQueueSelector selector, //\n 19:     Object arg, //\n 20:     final CommunicationMode communicationMode, //\n 21:     final SendCallback sendCallback, final long timeout//\n 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 23:     this.makeSureStateOK();\n 24:     Validators.checkMessage(msg, this.defaultMQProducer);\n 25: \n 26:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 27:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 28:         MessageQueue mq = null;\n 29:         try {\n 30:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);\n 31:         } catch (Throwable e) {\n 32:             throw new MQClientException(\"select message queue throwed exception.\", e);\n 33:         }\n 34: \n 35:         if (mq != null) {\n 36:             return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout);\n 37:         } else {\n 38:             throw new MQClientException(\"select message queue return null.\", null);\n 39:         }\n 40:     }\n 41: \n 42:     throw new MQClientException(\"No route info for this topic, \" + msg.getTopic(), null);\n 43: }\n```\n\n* 第 30 行 ：选择消息队列。\n* 第 36 行 ：发送消息。\n\n# 3. `Consumer` 严格顺序消费\n\n`Consumer` 在严格顺序消费时，通过 **三** 把锁保证严格顺序消费。\n\n* `Broker` 消息队列锁（**分布式锁**） ：\n    * 集群模式下，`Consumer` 从 `Broker` 获得该锁后，才能进行消息拉取、消费。\n    * 广播模式下，`Consumer` 无需该锁。\n* `Consumer` 消息队列锁（**本地锁**） ：`Consumer` 获得该锁才能操作消息队列。\n* `Consumer` 消息处理队列消费锁（**本地锁**） ：`Consumer` 获得该锁才能消费消息队列。\n\n**可能同学有疑问，为什么有 `Consumer` 消息队列锁还需要有 `Consumer` 消息队列消费锁呢**？😈让我们带着疑问继续往下看。\n\n-------\n\n## 3.1 获得(锁定)消息队列\n\n**集群模式**下，`Consumer` 更新属于自己的消息队列时，会向 `Broker` 锁定该消息队列（*广播模式下不需要*）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RebalanceImpl.java】\n  2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) {\n  3: // ..... 此处省略部分代码 \n  4:     // 增加 不在processQueueTable && 存在于mqSet 里的消息队列。\n  5:     List<PullRequest> pullRequestList = new ArrayList<>(); // 拉消息请求数组\n  6:     for (MessageQueue mq : mqSet) {\n  7:         if (!this.processQueueTable.containsKey(mq)) {\n  8:             if (isOrder && !this.lock(mq)) { // 顺序消息锁定消息队列\n  9:                 log.warn(\"doRebalance, {}, add a new mq failed, {}, because lock failed\", consumerGroup, mq);\n 10:                 continue;\n 11:             }\n 12: \n 13:             this.removeDirtyOffset(mq);\n 14:             ProcessQueue pq = new ProcessQueue();\n 15:             long nextOffset = this.computePullFromWhere(mq);\n 16:             if (nextOffset >= 0) {\n 17:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);\n 18:                 if (pre != null) {\n 19:                     log.info(\"doRebalance, {}, mq already exists, {}\", consumerGroup, mq);\n 20:                 } else {\n 21:                     log.info(\"doRebalance, {}, add a new mq, {}\", consumerGroup, mq);\n 22:                     PullRequest pullRequest = new PullRequest();\n 23:                     pullRequest.setConsumerGroup(consumerGroup);\n 24:                     pullRequest.setNextOffset(nextOffset);\n 25:                     pullRequest.setMessageQueue(mq);\n 26:                     pullRequest.setProcessQueue(pq);\n 27:                     pullRequestList.add(pullRequest);\n 28:                     changed = true;\n 29:                 }\n 30:             } else {\n 31:                 log.warn(\"doRebalance, {}, add new mq failed, {}\", consumerGroup, mq);\n 32:             }\n 33:         }\n 34:     }\n 35: \n 36: // ..... 此处省略部分代码 \n 37: }\n 38: \n 39: // ⬇️⬇️⬇️【RebalanceImpl.java】\n 40: /**\n 41:  * 请求Broker获得指定消息队列的分布式锁\n 42:  *\n 43:  * @param mq 队列\n 44:  * @return 是否成功\n 45:  */\n 46: public boolean lock(final MessageQueue mq) {\n 47:     FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);\n 48:     if (findBrokerResult != null) {\n 49:         LockBatchRequestBody requestBody = new LockBatchRequestBody();\n 50:         requestBody.setConsumerGroup(this.consumerGroup);\n 51:         requestBody.setClientId(this.mQClientFactory.getClientId());\n 52:         requestBody.getMqSet().add(mq);\n 53: \n 54:         try {\n 55:             // 请求Broker获得指定消息队列的分布式锁\n 56:             Set<MessageQueue> lockedMq =\n 57:                 this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);\n 58: \n 59:             // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。\n 60:             for (MessageQueue mmqq : lockedMq) {\n 61:                 ProcessQueue processQueue = this.processQueueTable.get(mmqq);\n 62:                 if (processQueue != null) {\n 63:                     processQueue.setLocked(true);\n 64:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());\n 65:                 }\n 66:             }\n 67: \n 68:             boolean lockOK = lockedMq.contains(mq);\n 69:             log.info(\"the message queue lock {}, {} {}\",\n 70:                 lockOK ? \"OK\" : \"Failed\",\n 71:                 this.consumerGroup,\n 72:                 mq);\n 73:             return lockOK;\n 74:         } catch (Exception e) {\n 75:             log.error(\"lockBatchMQ exception, \" + mq, e);\n 76:         }\n 77:     }\n 78: \n 79:     return false;\n 80: }\n```\n\n* ⬆️⬆️⬆️\n* 第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。\n\n-------\n\n`Broker` 消息队列锁会过期，默认配置 30s。因此，`Consumer` 需要不断向 `Broker` 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: public void start() {\n  3:     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) {\n  4:         this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  5:             @Override\n  6:             public void run() {\n  7:                 ConsumeMessageOrderlyService.this.lockMQPeriodically();\n  8:             }\n  9:         }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);\n 10:     }\n 11: }\n```\n\n## 3.2 移除消息队列\n\n集群模式下，`Consumer` 移除自己的消息队列时，会向 `Broker` 解锁该消息队列（广播模式下不需要）。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RebalancePushImpl.java】\n  2: /**\n  3:  * 移除不需要的队列相关的信息\n  4:  * 1. 持久化消费进度，并移除之\n  5:  * 2. 顺序消费&集群模式，解锁对该队列的锁定\n  6:  *\n  7:  * @param mq 消息队列\n  8:  * @param pq 消息处理队列\n  9:  * @return 是否移除成功\n 10:  */\n 11: @Override\n 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n 13:     // 同步队列的消费进度，并移除之。\n 14:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);\n 15:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);\n 16:     // 集群模式下，顺序消费移除时，解锁对队列的锁定\n 17:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()\n 18:         && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {\n 19:         try {\n 20:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {\n 21:                 try {\n 22:                     return this.unlockDelay(mq, pq);\n 23:                 } finally {\n 24:                     pq.getLockConsume().unlock();\n 25:                 }\n 26:             } else {\n 27:                 log.warn(\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\", //\n 28:                     mq, //\n 29:                     pq.getTryUnlockTimes());\n 30: \n 31:                 pq.incTryUnlockTimes();\n 32:             }\n 33:         } catch (Exception e) {\n 34:             log.error(\"removeUnnecessaryMessageQueue Exception\", e);\n 35:         }\n 36: \n 37:         return false;\n 38:     }\n 39:     return true;\n 40: }\n 41: \n 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】\n 43: /**\n 44:  * 延迟解锁 Broker 消息队列锁\n 45:  * 当消息处理队列不存在消息，则直接解锁\n 46:  *\n 47:  * @param mq 消息队列\n 48:  * @param pq 消息处理队列\n 49:  * @return 是否解锁成功\n 50:  */\n 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {\n 52:     if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除\n 53:         log.info(\"[{}]unlockDelay, begin {} \", mq.hashCode(), mq);\n 54:         this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {\n 55:             @Override\n 56:             public void run() {\n 57:                 log.info(\"[{}]unlockDelay, execute at once {}\", mq.hashCode(), mq);\n 58:                 RebalancePushImpl.this.unlock(mq, true);\n 59:             }\n 60:         }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);\n 61:     } else {\n 62:         this.unlock(mq, true);\n 63:     }\n 64:     return true;\n 65: }\n```\n\n* ⬆️⬆️⬆️\n* 第 20 至 32 行 ：获取**消息队列消费锁**，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的  `Consumer` 和当前 `Consumer` 同时消费该消息队列，导致消息无法严格顺序消费。\n* 第 51 至 64 行 ：解锁 `Broker` 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 `Broker` 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。\n\n## 3.3 消费消息队列\n\n😏本节会类比**并发消费消费队列**，建议对照 [PushConsumer并发消费消息](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/#6、PushConsumer-消费消息) 一起理解。\n\n### 3.1.1 消费消息\n\n![顺序消费活动图-消费消息](http://www.yunai.me/images/RocketMQ/2017_05_13/01.png)\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: class ConsumeRequest implements Runnable {\n  3: \n  4:     /**\n  5:      * 消息处理队列\n  6:      */\n  7:     private final ProcessQueue processQueue;\n  8:     /**\n  9:      * 消息队列\n 10:      */\n 11:     private final MessageQueue messageQueue;\n 12: \n 13:     @Override\n 14:     public void run() {\n 15:         if (this.processQueue.isDropped()) {\n 16:             log.warn(\"run, the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n 17:             return;\n 18:         }\n 19: \n 20:         // 获得 Consumer 消息队列锁\n 21:         final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);\n 22:         synchronized (objLock) {\n 23:             // (广播模式) 或者 (集群模式 && Broker消息队列锁有效)\n 24:             if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 25:                 || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n 26:                 final long beginTime = System.currentTimeMillis();\n 27:                 // 循环\n 28:                 for (boolean continueConsume = true; continueConsume; ) {\n 29:                     if (this.processQueue.isDropped()) {\n 30:                         log.warn(\"the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n 31:                         break;\n 32:                     }\n 33: \n 34:                     // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求\n 35:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 36:                         && !this.processQueue.isLocked()) {\n 37:                         log.warn(\"the message queue not locked, so consume later, {}\", this.messageQueue);\n 38:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);\n 39:                         break;\n 40:                     }\n 41:                     // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求\n 42:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 43:                         && this.processQueue.isLockExpired()) {\n 44:                         log.warn(\"the message queue lock expired, so consume later, {}\", this.messageQueue);\n 45:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);\n 46:                         break;\n 47:                     }\n 48: \n 49:                     // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。\n 50:                     long interval = System.currentTimeMillis() - beginTime;\n 51:                     if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n 52:                         ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);\n 53:                         break;\n 54:                     }\n 55: \n 56:                     // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。\n 57:                     final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n 58:                     List<MessageExt> msgs = this.processQueue.takeMessags(consumeBatchSize);\n 59:                     if (!msgs.isEmpty()) {\n 60:                         final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);\n 61: \n 62:                         ConsumeOrderlyStatus status = null;\n 63: \n 64:                         // ....省略代码：Hook：before\n 65: \n 66:                         // 执行消费\n 67:                         long beginTimestamp = System.currentTimeMillis();\n 68:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;\n 69:                         boolean hasException = false;\n 70:                         try {\n 71:                             this.processQueue.getLockConsume().lock(); // 锁定队列消费锁\n 72: \n 73:                             if (this.processQueue.isDropped()) {\n 74:                                 log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",\n 75:                                     this.messageQueue);\n 76:                                 break;\n 77:                             }\n 78: \n 79:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);\n 80:                         } catch (Throwable e) {\n 81:                             log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\", //\n 82:                                 RemotingHelper.exceptionSimpleDesc(e), //\n 83:                                 ConsumeMessageOrderlyService.this.consumerGroup, //\n 84:                                 msgs, //\n 85:                                 messageQueue);\n 86:                             hasException = true;\n 87:                         } finally {\n 88:                             this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁\n 89:                         }\n 90: \n 91:                         // ....省略代码：解析消费结果状态\n 92: \n 93:                         // ....省略代码：Hook：after\n 94: \n 95:                         ConsumeMessageOrderlyService.this.getConsumerStatsManager()\n 96:                             .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);\n 97: \n 98:                         // 处理消费结果\n 99:                         continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);\n100:                     } else {\n101:                         continueConsume = false;\n102:                     }\n103:                 }\n104:             } else {\n105:                 if (this.processQueue.isDropped()) {\n106:                     log.warn(\"the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n107:                     return;\n108:                 }\n109: \n110:                 ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);\n111:             }\n112:         }\n113:     }\n114: \n115: }\n```\n\n* ⬆️⬆️⬆️\n* 第 20 行 ：获得 `Consumer` 消息队列锁。\n* 第 58 行 ：从消息处理队列顺序获得消息。**和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。**\n* 第 71 行 ：获得 `Consumer` 消息处理队列消费锁。相比【`Consumer`消息队列锁】，其粒度较小。这就是上文提到的❓**为什么有`Consumer`消息队列锁还需要有 Consumer 消息队列消费锁呢**的原因。\n* 第 79 行 ：**执行消费**。\n* 第 99 行 ：处理消费结果。\n\n### 3.1.2 处理消费结果\n\n顺序消费消息结果 (`ConsumeOrderlyStatus`) 有四种情况：\n\n* `SUCCESS` ：消费成功**但不提交**。\n* `ROLLBACK` ：消费失败，消费回滚。\n* `COMMIT` ：消费成功提交并且提交。\n* `SUSPEND_CURRENT_QUEUE_A_MOMENT` ：消费失败，挂起消费队列一会会，稍后继续消费。\n\n考虑到 `ROLLBACK` 、`COMMIT` 暂时只使用在 `MySQL binlog` 场景，官方将这两状态标记为 `@Deprecated`。当然，相应的实现逻辑依然保留。\n\n在**并发消费**场景时，如果消费失败，`Consumer` 会将消费失败消息发回到 `Broker` 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。\n\n但是在**完全严格顺序消费**消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 \n\n不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，`Consumer` 会将消费失败超过上限的消息发回到 `Broker` 死信队列。\n\n让我们来看看代码：\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: /**\n  3:  * 处理消费结果，并返回是否继续消费\n  4:  *\n  5:  * @param msgs 消息\n  6:  * @param status 消费结果状态\n  7:  * @param context 消费Context\n  8:  * @param consumeRequest 消费请求\n  9:  * @return 是否继续消费\n 10:  */\n 11: public boolean processConsumeResult(//\n 12:     final List<MessageExt> msgs, //\n 13:     final ConsumeOrderlyStatus status, //\n 14:     final ConsumeOrderlyContext context, //\n 15:     final ConsumeRequest consumeRequest//\n 16: ) {\n 17:     boolean continueConsume = true;\n 18:     long commitOffset = -1L;\n 19:     if (context.isAutoCommit()) {\n 20:         switch (status) {\n 21:             case COMMIT:\n 22:             case ROLLBACK:\n 23:                 log.warn(\"the message queue consume result is illegal, we think you want to ack these message {}\", consumeRequest.getMessageQueue());\n 24:             case SUCCESS:\n 25:                 // 提交消息已消费成功到消息处理队列\n 26:                 commitOffset = consumeRequest.getProcessQueue().commit();\n 27:                 // 统计\n 28:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 29:                 break;\n 30:             case SUSPEND_CURRENT_QUEUE_A_MOMENT:\n 31:                 // 统计\n 32:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 33:                 if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms\n 34:                     // 设置消息重新消费\n 35:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);\n 36:                     // 提交延迟消费请求\n 37:                     this.submitConsumeRequestLater(//\n 38:                         consumeRequest.getProcessQueue(), //\n 39:                         consumeRequest.getMessageQueue(), //\n 40:                         context.getSuspendCurrentQueueTimeMillis());\n 41:                     continueConsume = false;\n 42:                 } else {\n 43:                     commitOffset = consumeRequest.getProcessQueue().commit();\n 44:                 }\n 45:                 break;\n 46:             default:\n 47:                 break;\n 48:         }\n 49:     } else {\n 50:         switch (status) {\n 51:             case SUCCESS:\n 52:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 53:                 break;\n 54:             case COMMIT:\n 55:                 // 提交消息已消费成功到消息处理队列\n 56:                 commitOffset = consumeRequest.getProcessQueue().commit();\n 57:                 break;\n 58:             case ROLLBACK:\n 59:                 // 设置消息重新消费\n 60:                 consumeRequest.getProcessQueue().rollback();\n 61:                 this.submitConsumeRequestLater(//\n 62:                     consumeRequest.getProcessQueue(), //\n 63:                     consumeRequest.getMessageQueue(), //\n 64:                     context.getSuspendCurrentQueueTimeMillis());\n 65:                 continueConsume = false;\n 66:                 break;\n 67:             case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms\n 68:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 69:                 if (checkReconsumeTimes(msgs)) {\n 70:                     // 设置消息重新消费\n 71:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);\n 72:                     // 提交延迟消费请求\n 73:                     this.submitConsumeRequestLater(//\n 74:                         consumeRequest.getProcessQueue(), //\n 75:                         consumeRequest.getMessageQueue(), //\n 76:                         context.getSuspendCurrentQueueTimeMillis());\n 77:                     continueConsume = false;\n 78:                 }\n 79:                 break;\n 80:             default:\n 81:                 break;\n 82:         }\n 83:     }\n 84: \n 85:     // 消息处理队列未dropped，提交有效消费进度\n 86:     if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {\n 87:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);\n 88:     }\n 89: \n 90:     return continueConsume;\n 91: }\n 92: \n 93: private int getMaxReconsumeTimes() {\n 94:     // default reconsume times: Integer.MAX_VALUE\n 95:     if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {\n 96:         return Integer.MAX_VALUE;\n 97:     } else {\n 98:         return this.defaultMQPushConsumer.getMaxReconsumeTimes();\n 99:     }\n100: }\n101: \n102: /**\n103:  * 计算是否要暂停消费\n104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功\n105:  *\n106:  * @param msgs 消息\n107:  * @return 是否要暂停\n108:  */\n109: private boolean checkReconsumeTimes(List<MessageExt> msgs) {\n110:     boolean suspend = false;\n111:     if (msgs != null && !msgs.isEmpty()) {\n112:         for (MessageExt msg : msgs) {\n113:             if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {\n114:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));\n115:                 if (!sendMessageBack(msg)) { // 发回失败，中断\n116:                     suspend = true;\n117:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n118:                 }\n119:             } else {\n120:                 suspend = true;\n121:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n122:             }\n123:         }\n124:     }\n125:     return suspend;\n126: }\n127: \n128: /**\n129:  * 发回消息。\n130:  * 消息发回broker后，对应的消息队列是死信队列。\n131:  *\n132:  * @param msg 消息\n133:  * @return 是否发送成功\n134:  */\n135: public boolean sendMessageBack(final MessageExt msg) {\n136:     try {\n137:         // max reconsume times exceeded then send to dead letter queue.\n138:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());\n139:         String originMsgId = MessageAccessor.getOriginMessageId(msg);\n140:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);\n141:         newMsg.setFlag(msg.getFlag());\n142:         MessageAccessor.setProperties(newMsg, msg.getProperties());\n143:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());\n144:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));\n145:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));\n146:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());\n147: \n148:         this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);\n149:         return true;\n150:     } catch (Exception e) {\n151:         log.error(\"sendMessageBack exception, group: \" + this.consumerGroup + \" msg: \" + msg.toString(), e);\n152:     }\n153: \n154:     return false;\n155: }\n```\n\n* ⬆️⬆️⬆️\n* 第 21 至 29 行 ：消费成功。在自动提交进度( `AutoCommit` )的情况下，`COMMIT`、`ROLLBACK`、`SUCCESS` 逻辑**已经统一**。\n* 第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 `Broker` 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。\n* 第 85 至 88 行 ：提交消费进度。\n\n### 3.13 消息处理队列核心方法\n\n😈涉及到的四个核心方法的源码：\n\n```Java\n  1: // ⬇️⬇️⬇️【ProcessQueue.java】\n  2: /**\n  3:  * 消息映射\n  4:  * key：消息队列位置\n  5:  */\n  6: private final TreeMap<Long, MessageExt> msgTreeMap = new TreeMap<>();    /**\n  7:  * 消息映射临时存储（消费中的消息）\n  8:  */\n  9: private final TreeMap<Long, MessageExt> msgTreeMapTemp = new TreeMap<>();\n 10: \n 11: /**\n 12:  * 回滚消费中的消息\n 13:  * 逻辑类似于{@link #makeMessageToCosumeAgain(List)}\n 14:  */\n 15: public void rollback() {\n 16:     try {\n 17:         this.lockTreeMap.writeLock().lockInterruptibly();\n 18:         try {\n 19:             this.msgTreeMap.putAll(this.msgTreeMapTemp);\n 20:             this.msgTreeMapTemp.clear();\n 21:         } finally {\n 22:             this.lockTreeMap.writeLock().unlock();\n 23:         }\n 24:     } catch (InterruptedException e) {\n 25:         log.error(\"rollback exception\", e);\n 26:     }\n 27: }\n 28: \n 29: /**\n 30:  * 提交消费中的消息已消费成功，返回消费进度\n 31:  *\n 32:  * @return 消费进度\n 33:  */\n 34: public long commit() {\n 35:     try {\n 36:         this.lockTreeMap.writeLock().lockInterruptibly();\n 37:         try {\n 38:             // 消费进度\n 39:             Long offset = this.msgTreeMapTemp.lastKey();\n 40: \n 41:             //\n 42:             msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));\n 43: \n 44:             //\n 45:             this.msgTreeMapTemp.clear();\n 46: \n 47:             // 返回消费进度\n 48:             if (offset != null) {\n 49:                 return offset + 1;\n 50:             }\n 51:         } finally {\n 52:             this.lockTreeMap.writeLock().unlock();\n 53:         }\n 54:     } catch (InterruptedException e) {\n 55:         log.error(\"commit exception\", e);\n 56:     }\n 57: \n 58:     return -1;\n 59: }\n 60: \n 61: /**\n 62:  * 指定消息重新消费\n 63:  * 逻辑类似于{@link #rollback()}\n 64:  *\n 65:  * @param msgs 消息\n 66:  */\n 67: public void makeMessageToCosumeAgain(List<MessageExt> msgs) {\n 68:     try {\n 69:         this.lockTreeMap.writeLock().lockInterruptibly();\n 70:         try {\n 71:             for (MessageExt msg : msgs) {\n 72:                 this.msgTreeMapTemp.remove(msg.getQueueOffset());\n 73:                 this.msgTreeMap.put(msg.getQueueOffset(), msg);\n 74:             }\n 75:         } finally {\n 76:             this.lockTreeMap.writeLock().unlock();\n 77:         }\n 78:     } catch (InterruptedException e) {\n 79:         log.error(\"makeMessageToCosumeAgain exception\", e);\n 80:     }\n 81: }\n 82: \n 83: /**\n 84:  * 获得持有消息前N条\n 85:  *\n 86:  * @param batchSize 条数\n 87:  * @return 消息\n 88:  */\n 89: public List<MessageExt> takeMessags(final int batchSize) {\n 90:     List<MessageExt> result = new ArrayList<>(batchSize);\n 91:     final long now = System.currentTimeMillis();\n 92:     try {\n 93:         this.lockTreeMap.writeLock().lockInterruptibly();\n 94:         this.lastConsumeTimestamp = now;\n 95:         try {\n 96:             if (!this.msgTreeMap.isEmpty()) {\n 97:                 for (int i = 0; i < batchSize; i++) {\n 98:                     Map.Entry<Long, MessageExt> entry = this.msgTreeMap.pollFirstEntry();\n 99:                     if (entry != null) {\n100:                         result.add(entry.getValue());\n101:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());\n102:                     } else {\n103:                         break;\n104:                     }\n105:                 }\n106:             }\n107: \n108:             if (result.isEmpty()) {\n109:                 consuming = false;\n110:             }\n111:         } finally {\n112:             this.lockTreeMap.writeLock().unlock();\n113:         }\n114:     } catch (InterruptedException e) {\n115:         log.error(\"take Messages exception\", e);\n116:     }\n117: \n118:     return result;\n119: }\n```\n\n\n","source":"_posts/RocketMQ/2017_05_13_RocketMQ源码分析——Message顺序发送与消费.md","raw":"title: RocketMQ 源码分析 —— Message 顺序发送与消费\ndate: 2017-05-13\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-send-and-consume-orderly\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-send-and-consume-orderly](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Producer 顺序发送](#)\n- [3. Consumer 顺序消费](#)\n\t- [3.1 获得(锁定)消息队列](#)\n\t- [3.2 移除消息队列](#)\n\t- [3.3 消费消息队列](#)\n\t\t- [3.1.1 消费消息](#)\n\t\t- [3.1.2 处理消费结果](#)\n\t\t- [3.13 消息处理队列核心方法](#)\n\n# 1. 概述\n\n**建议**前置阅读内容：\n\n* [《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)\n* [《RocketMQ 源码分析 —— Message 拉取与消费（下）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)\n\n当然对 `Message` 发送与消费已经有一定了解的同学，可以选择跳过。\n\n-------\n\n`RocketMQ` 提供了两种顺序级别：\n\n* 普通顺序消息 ：`Producer` 将相关联的消息发送到相同的消息队列。\n* 完全严格顺序 ：在 `普通顺序消息` 的基础上，`Consumer` 严格顺序消费。\n\n绝大部分场景下只需要用到**普通顺序消息**。  \n例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，**不会产生系统逻辑上BUG**。另外，`普通顺序消息`性能能更加好。  \n那么什么时候使用使用**完全严格顺序**？如下是来自官方文档的说明：\n> 目前已知的应用只有数据库 `binlog` 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息\n\n-------\n\n😈上代码！！！\n\n# 2. `Producer` 顺序发送\n\n官方发送顺序消息的**例子**：\n\n```Java\n  1: package org.apache.rocketmq.example.ordermessage;\n  2: \n  3: import java.io.UnsupportedEncodingException;\n  4: import java.util.List;\n  5: import org.apache.rocketmq.client.exception.MQBrokerException;\n  6: import org.apache.rocketmq.client.exception.MQClientException;\n  7: import org.apache.rocketmq.client.producer.DefaultMQProducer;\n  8: import org.apache.rocketmq.client.producer.MQProducer;\n  9: import org.apache.rocketmq.client.producer.MessageQueueSelector;\n 10: import org.apache.rocketmq.client.producer.SendResult;\n 11: import org.apache.rocketmq.common.message.Message;\n 12: import org.apache.rocketmq.common.message.MessageQueue;\n 13: import org.apache.rocketmq.remoting.common.RemotingHelper;\n 14: import org.apache.rocketmq.remoting.exception.RemotingException;\n 15: \n 16: public class Producer {\n 17:     public static void main(String[] args) throws UnsupportedEncodingException {\n 18:         try {\n 19:             MQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n 20:             producer.start();\n 21: \n 22:             String[] tags = new String[] {\"TagA\", \"TagB\", \"TagC\", \"TagD\", \"TagE\"};\n 23:             for (int i = 0; i < 100; i++) {\n 24:                 int orderId = i % 10;\n 25:                 Message msg =\n 26:                     new Message(\"TopicTestjjj\", tags[i % tags.length], \"KEY\" + i,\n 27:                         (\"Hello RocketMQ \" + i).getBytes(RemotingHelper.DEFAULT_CHARSET));\n 28:                 SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n 29:                     @Override\n 30:                     public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n 31:                         Integer id = (Integer) arg;\n 32:                         int index = id % mqs.size();\n 33:                         return mqs.get(index);\n 34:                     }\n 35:                 }, orderId);\n 36: \n 37:                 System.out.printf(\"%s%n\", sendResult);\n 38:             }\n 39: \n 40:             producer.shutdown();\n 41:         } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {\n 42:             e.printStackTrace();\n 43:         }\n 44:     }\n 45: }\n```\n\n* 第 28 至 35 行 ：实现了根据 `id % mqs.size()` 来进行消息队列的选择。当前例子，**我们传递 `orderId` 作为参数，那么相同的 `orderId` 能够进入相同的消息队列**。\n\n-------\n\n`MessageQueueSelector` 接口的**源码**：\n\n```Java\n  1: public interface MessageQueueSelector {\n  2: \n  3:     /**\n  4:      * 选择消息队列\n  5:      *\n  6:      * @param mqs 消息队列\n  7:      * @param msg 消息\n  8:      * @param arg 参数\n  9:      * @return 消息队列\n 10:      */\n 11:     MessageQueue select(final List<MessageQueue> mqs, final Message msg, final Object arg);\n 12: }\n```\n-------\n\n`Producer` 选择队列发送消息方法的**源码**：\n\n```Java\n 16: private SendResult sendSelectImpl(//\n 17:     Message msg, //\n 18:     MessageQueueSelector selector, //\n 19:     Object arg, //\n 20:     final CommunicationMode communicationMode, //\n 21:     final SendCallback sendCallback, final long timeout//\n 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 23:     this.makeSureStateOK();\n 24:     Validators.checkMessage(msg, this.defaultMQProducer);\n 25: \n 26:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 27:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 28:         MessageQueue mq = null;\n 29:         try {\n 30:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);\n 31:         } catch (Throwable e) {\n 32:             throw new MQClientException(\"select message queue throwed exception.\", e);\n 33:         }\n 34: \n 35:         if (mq != null) {\n 36:             return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout);\n 37:         } else {\n 38:             throw new MQClientException(\"select message queue return null.\", null);\n 39:         }\n 40:     }\n 41: \n 42:     throw new MQClientException(\"No route info for this topic, \" + msg.getTopic(), null);\n 43: }\n```\n\n* 第 30 行 ：选择消息队列。\n* 第 36 行 ：发送消息。\n\n# 3. `Consumer` 严格顺序消费\n\n`Consumer` 在严格顺序消费时，通过 **三** 把锁保证严格顺序消费。\n\n* `Broker` 消息队列锁（**分布式锁**） ：\n    * 集群模式下，`Consumer` 从 `Broker` 获得该锁后，才能进行消息拉取、消费。\n    * 广播模式下，`Consumer` 无需该锁。\n* `Consumer` 消息队列锁（**本地锁**） ：`Consumer` 获得该锁才能操作消息队列。\n* `Consumer` 消息处理队列消费锁（**本地锁**） ：`Consumer` 获得该锁才能消费消息队列。\n\n**可能同学有疑问，为什么有 `Consumer` 消息队列锁还需要有 `Consumer` 消息队列消费锁呢**？😈让我们带着疑问继续往下看。\n\n-------\n\n## 3.1 获得(锁定)消息队列\n\n**集群模式**下，`Consumer` 更新属于自己的消息队列时，会向 `Broker` 锁定该消息队列（*广播模式下不需要*）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RebalanceImpl.java】\n  2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) {\n  3: // ..... 此处省略部分代码 \n  4:     // 增加 不在processQueueTable && 存在于mqSet 里的消息队列。\n  5:     List<PullRequest> pullRequestList = new ArrayList<>(); // 拉消息请求数组\n  6:     for (MessageQueue mq : mqSet) {\n  7:         if (!this.processQueueTable.containsKey(mq)) {\n  8:             if (isOrder && !this.lock(mq)) { // 顺序消息锁定消息队列\n  9:                 log.warn(\"doRebalance, {}, add a new mq failed, {}, because lock failed\", consumerGroup, mq);\n 10:                 continue;\n 11:             }\n 12: \n 13:             this.removeDirtyOffset(mq);\n 14:             ProcessQueue pq = new ProcessQueue();\n 15:             long nextOffset = this.computePullFromWhere(mq);\n 16:             if (nextOffset >= 0) {\n 17:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);\n 18:                 if (pre != null) {\n 19:                     log.info(\"doRebalance, {}, mq already exists, {}\", consumerGroup, mq);\n 20:                 } else {\n 21:                     log.info(\"doRebalance, {}, add a new mq, {}\", consumerGroup, mq);\n 22:                     PullRequest pullRequest = new PullRequest();\n 23:                     pullRequest.setConsumerGroup(consumerGroup);\n 24:                     pullRequest.setNextOffset(nextOffset);\n 25:                     pullRequest.setMessageQueue(mq);\n 26:                     pullRequest.setProcessQueue(pq);\n 27:                     pullRequestList.add(pullRequest);\n 28:                     changed = true;\n 29:                 }\n 30:             } else {\n 31:                 log.warn(\"doRebalance, {}, add new mq failed, {}\", consumerGroup, mq);\n 32:             }\n 33:         }\n 34:     }\n 35: \n 36: // ..... 此处省略部分代码 \n 37: }\n 38: \n 39: // ⬇️⬇️⬇️【RebalanceImpl.java】\n 40: /**\n 41:  * 请求Broker获得指定消息队列的分布式锁\n 42:  *\n 43:  * @param mq 队列\n 44:  * @return 是否成功\n 45:  */\n 46: public boolean lock(final MessageQueue mq) {\n 47:     FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);\n 48:     if (findBrokerResult != null) {\n 49:         LockBatchRequestBody requestBody = new LockBatchRequestBody();\n 50:         requestBody.setConsumerGroup(this.consumerGroup);\n 51:         requestBody.setClientId(this.mQClientFactory.getClientId());\n 52:         requestBody.getMqSet().add(mq);\n 53: \n 54:         try {\n 55:             // 请求Broker获得指定消息队列的分布式锁\n 56:             Set<MessageQueue> lockedMq =\n 57:                 this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);\n 58: \n 59:             // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。\n 60:             for (MessageQueue mmqq : lockedMq) {\n 61:                 ProcessQueue processQueue = this.processQueueTable.get(mmqq);\n 62:                 if (processQueue != null) {\n 63:                     processQueue.setLocked(true);\n 64:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());\n 65:                 }\n 66:             }\n 67: \n 68:             boolean lockOK = lockedMq.contains(mq);\n 69:             log.info(\"the message queue lock {}, {} {}\",\n 70:                 lockOK ? \"OK\" : \"Failed\",\n 71:                 this.consumerGroup,\n 72:                 mq);\n 73:             return lockOK;\n 74:         } catch (Exception e) {\n 75:             log.error(\"lockBatchMQ exception, \" + mq, e);\n 76:         }\n 77:     }\n 78: \n 79:     return false;\n 80: }\n```\n\n* ⬆️⬆️⬆️\n* 第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。\n\n-------\n\n`Broker` 消息队列锁会过期，默认配置 30s。因此，`Consumer` 需要不断向 `Broker` 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: public void start() {\n  3:     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) {\n  4:         this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  5:             @Override\n  6:             public void run() {\n  7:                 ConsumeMessageOrderlyService.this.lockMQPeriodically();\n  8:             }\n  9:         }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);\n 10:     }\n 11: }\n```\n\n## 3.2 移除消息队列\n\n集群模式下，`Consumer` 移除自己的消息队列时，会向 `Broker` 解锁该消息队列（广播模式下不需要）。核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【RebalancePushImpl.java】\n  2: /**\n  3:  * 移除不需要的队列相关的信息\n  4:  * 1. 持久化消费进度，并移除之\n  5:  * 2. 顺序消费&集群模式，解锁对该队列的锁定\n  6:  *\n  7:  * @param mq 消息队列\n  8:  * @param pq 消息处理队列\n  9:  * @return 是否移除成功\n 10:  */\n 11: @Override\n 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n 13:     // 同步队列的消费进度，并移除之。\n 14:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);\n 15:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);\n 16:     // 集群模式下，顺序消费移除时，解锁对队列的锁定\n 17:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()\n 18:         && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {\n 19:         try {\n 20:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {\n 21:                 try {\n 22:                     return this.unlockDelay(mq, pq);\n 23:                 } finally {\n 24:                     pq.getLockConsume().unlock();\n 25:                 }\n 26:             } else {\n 27:                 log.warn(\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\", //\n 28:                     mq, //\n 29:                     pq.getTryUnlockTimes());\n 30: \n 31:                 pq.incTryUnlockTimes();\n 32:             }\n 33:         } catch (Exception e) {\n 34:             log.error(\"removeUnnecessaryMessageQueue Exception\", e);\n 35:         }\n 36: \n 37:         return false;\n 38:     }\n 39:     return true;\n 40: }\n 41: \n 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】\n 43: /**\n 44:  * 延迟解锁 Broker 消息队列锁\n 45:  * 当消息处理队列不存在消息，则直接解锁\n 46:  *\n 47:  * @param mq 消息队列\n 48:  * @param pq 消息处理队列\n 49:  * @return 是否解锁成功\n 50:  */\n 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {\n 52:     if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除\n 53:         log.info(\"[{}]unlockDelay, begin {} \", mq.hashCode(), mq);\n 54:         this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {\n 55:             @Override\n 56:             public void run() {\n 57:                 log.info(\"[{}]unlockDelay, execute at once {}\", mq.hashCode(), mq);\n 58:                 RebalancePushImpl.this.unlock(mq, true);\n 59:             }\n 60:         }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);\n 61:     } else {\n 62:         this.unlock(mq, true);\n 63:     }\n 64:     return true;\n 65: }\n```\n\n* ⬆️⬆️⬆️\n* 第 20 至 32 行 ：获取**消息队列消费锁**，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的  `Consumer` 和当前 `Consumer` 同时消费该消息队列，导致消息无法严格顺序消费。\n* 第 51 至 64 行 ：解锁 `Broker` 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 `Broker` 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。\n\n## 3.3 消费消息队列\n\n😏本节会类比**并发消费消费队列**，建议对照 [PushConsumer并发消费消息](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/#6、PushConsumer-消费消息) 一起理解。\n\n### 3.1.1 消费消息\n\n![顺序消费活动图-消费消息](http://www.yunai.me/images/RocketMQ/2017_05_13/01.png)\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: class ConsumeRequest implements Runnable {\n  3: \n  4:     /**\n  5:      * 消息处理队列\n  6:      */\n  7:     private final ProcessQueue processQueue;\n  8:     /**\n  9:      * 消息队列\n 10:      */\n 11:     private final MessageQueue messageQueue;\n 12: \n 13:     @Override\n 14:     public void run() {\n 15:         if (this.processQueue.isDropped()) {\n 16:             log.warn(\"run, the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n 17:             return;\n 18:         }\n 19: \n 20:         // 获得 Consumer 消息队列锁\n 21:         final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);\n 22:         synchronized (objLock) {\n 23:             // (广播模式) 或者 (集群模式 && Broker消息队列锁有效)\n 24:             if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 25:                 || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) {\n 26:                 final long beginTime = System.currentTimeMillis();\n 27:                 // 循环\n 28:                 for (boolean continueConsume = true; continueConsume; ) {\n 29:                     if (this.processQueue.isDropped()) {\n 30:                         log.warn(\"the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n 31:                         break;\n 32:                     }\n 33: \n 34:                     // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求\n 35:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 36:                         && !this.processQueue.isLocked()) {\n 37:                         log.warn(\"the message queue not locked, so consume later, {}\", this.messageQueue);\n 38:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);\n 39:                         break;\n 40:                     }\n 41:                     // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求\n 42:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())\n 43:                         && this.processQueue.isLockExpired()) {\n 44:                         log.warn(\"the message queue lock expired, so consume later, {}\", this.messageQueue);\n 45:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);\n 46:                         break;\n 47:                     }\n 48: \n 49:                     // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。\n 50:                     long interval = System.currentTimeMillis() - beginTime;\n 51:                     if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) {\n 52:                         ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);\n 53:                         break;\n 54:                     }\n 55: \n 56:                     // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。\n 57:                     final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n 58:                     List<MessageExt> msgs = this.processQueue.takeMessags(consumeBatchSize);\n 59:                     if (!msgs.isEmpty()) {\n 60:                         final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);\n 61: \n 62:                         ConsumeOrderlyStatus status = null;\n 63: \n 64:                         // ....省略代码：Hook：before\n 65: \n 66:                         // 执行消费\n 67:                         long beginTimestamp = System.currentTimeMillis();\n 68:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;\n 69:                         boolean hasException = false;\n 70:                         try {\n 71:                             this.processQueue.getLockConsume().lock(); // 锁定队列消费锁\n 72: \n 73:                             if (this.processQueue.isDropped()) {\n 74:                                 log.warn(\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\",\n 75:                                     this.messageQueue);\n 76:                                 break;\n 77:                             }\n 78: \n 79:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);\n 80:                         } catch (Throwable e) {\n 81:                             log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\", //\n 82:                                 RemotingHelper.exceptionSimpleDesc(e), //\n 83:                                 ConsumeMessageOrderlyService.this.consumerGroup, //\n 84:                                 msgs, //\n 85:                                 messageQueue);\n 86:                             hasException = true;\n 87:                         } finally {\n 88:                             this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁\n 89:                         }\n 90: \n 91:                         // ....省略代码：解析消费结果状态\n 92: \n 93:                         // ....省略代码：Hook：after\n 94: \n 95:                         ConsumeMessageOrderlyService.this.getConsumerStatsManager()\n 96:                             .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);\n 97: \n 98:                         // 处理消费结果\n 99:                         continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);\n100:                     } else {\n101:                         continueConsume = false;\n102:                     }\n103:                 }\n104:             } else {\n105:                 if (this.processQueue.isDropped()) {\n106:                     log.warn(\"the message queue not be able to consume, because it's dropped. {}\", this.messageQueue);\n107:                     return;\n108:                 }\n109: \n110:                 ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);\n111:             }\n112:         }\n113:     }\n114: \n115: }\n```\n\n* ⬆️⬆️⬆️\n* 第 20 行 ：获得 `Consumer` 消息队列锁。\n* 第 58 行 ：从消息处理队列顺序获得消息。**和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。**\n* 第 71 行 ：获得 `Consumer` 消息处理队列消费锁。相比【`Consumer`消息队列锁】，其粒度较小。这就是上文提到的❓**为什么有`Consumer`消息队列锁还需要有 Consumer 消息队列消费锁呢**的原因。\n* 第 79 行 ：**执行消费**。\n* 第 99 行 ：处理消费结果。\n\n### 3.1.2 处理消费结果\n\n顺序消费消息结果 (`ConsumeOrderlyStatus`) 有四种情况：\n\n* `SUCCESS` ：消费成功**但不提交**。\n* `ROLLBACK` ：消费失败，消费回滚。\n* `COMMIT` ：消费成功提交并且提交。\n* `SUSPEND_CURRENT_QUEUE_A_MOMENT` ：消费失败，挂起消费队列一会会，稍后继续消费。\n\n考虑到 `ROLLBACK` 、`COMMIT` 暂时只使用在 `MySQL binlog` 场景，官方将这两状态标记为 `@Deprecated`。当然，相应的实现逻辑依然保留。\n\n在**并发消费**场景时，如果消费失败，`Consumer` 会将消费失败消息发回到 `Broker` 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。\n\n但是在**完全严格顺序消费**消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 \n\n不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，`Consumer` 会将消费失败超过上限的消息发回到 `Broker` 死信队列。\n\n让我们来看看代码：\n\n```Java\n  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】\n  2: /**\n  3:  * 处理消费结果，并返回是否继续消费\n  4:  *\n  5:  * @param msgs 消息\n  6:  * @param status 消费结果状态\n  7:  * @param context 消费Context\n  8:  * @param consumeRequest 消费请求\n  9:  * @return 是否继续消费\n 10:  */\n 11: public boolean processConsumeResult(//\n 12:     final List<MessageExt> msgs, //\n 13:     final ConsumeOrderlyStatus status, //\n 14:     final ConsumeOrderlyContext context, //\n 15:     final ConsumeRequest consumeRequest//\n 16: ) {\n 17:     boolean continueConsume = true;\n 18:     long commitOffset = -1L;\n 19:     if (context.isAutoCommit()) {\n 20:         switch (status) {\n 21:             case COMMIT:\n 22:             case ROLLBACK:\n 23:                 log.warn(\"the message queue consume result is illegal, we think you want to ack these message {}\", consumeRequest.getMessageQueue());\n 24:             case SUCCESS:\n 25:                 // 提交消息已消费成功到消息处理队列\n 26:                 commitOffset = consumeRequest.getProcessQueue().commit();\n 27:                 // 统计\n 28:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 29:                 break;\n 30:             case SUSPEND_CURRENT_QUEUE_A_MOMENT:\n 31:                 // 统计\n 32:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 33:                 if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms\n 34:                     // 设置消息重新消费\n 35:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);\n 36:                     // 提交延迟消费请求\n 37:                     this.submitConsumeRequestLater(//\n 38:                         consumeRequest.getProcessQueue(), //\n 39:                         consumeRequest.getMessageQueue(), //\n 40:                         context.getSuspendCurrentQueueTimeMillis());\n 41:                     continueConsume = false;\n 42:                 } else {\n 43:                     commitOffset = consumeRequest.getProcessQueue().commit();\n 44:                 }\n 45:                 break;\n 46:             default:\n 47:                 break;\n 48:         }\n 49:     } else {\n 50:         switch (status) {\n 51:             case SUCCESS:\n 52:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 53:                 break;\n 54:             case COMMIT:\n 55:                 // 提交消息已消费成功到消息处理队列\n 56:                 commitOffset = consumeRequest.getProcessQueue().commit();\n 57:                 break;\n 58:             case ROLLBACK:\n 59:                 // 设置消息重新消费\n 60:                 consumeRequest.getProcessQueue().rollback();\n 61:                 this.submitConsumeRequestLater(//\n 62:                     consumeRequest.getProcessQueue(), //\n 63:                     consumeRequest.getMessageQueue(), //\n 64:                     context.getSuspendCurrentQueueTimeMillis());\n 65:                 continueConsume = false;\n 66:                 break;\n 67:             case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms\n 68:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());\n 69:                 if (checkReconsumeTimes(msgs)) {\n 70:                     // 设置消息重新消费\n 71:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);\n 72:                     // 提交延迟消费请求\n 73:                     this.submitConsumeRequestLater(//\n 74:                         consumeRequest.getProcessQueue(), //\n 75:                         consumeRequest.getMessageQueue(), //\n 76:                         context.getSuspendCurrentQueueTimeMillis());\n 77:                     continueConsume = false;\n 78:                 }\n 79:                 break;\n 80:             default:\n 81:                 break;\n 82:         }\n 83:     }\n 84: \n 85:     // 消息处理队列未dropped，提交有效消费进度\n 86:     if (commitOffset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {\n 87:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);\n 88:     }\n 89: \n 90:     return continueConsume;\n 91: }\n 92: \n 93: private int getMaxReconsumeTimes() {\n 94:     // default reconsume times: Integer.MAX_VALUE\n 95:     if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {\n 96:         return Integer.MAX_VALUE;\n 97:     } else {\n 98:         return this.defaultMQPushConsumer.getMaxReconsumeTimes();\n 99:     }\n100: }\n101: \n102: /**\n103:  * 计算是否要暂停消费\n104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功\n105:  *\n106:  * @param msgs 消息\n107:  * @return 是否要暂停\n108:  */\n109: private boolean checkReconsumeTimes(List<MessageExt> msgs) {\n110:     boolean suspend = false;\n111:     if (msgs != null && !msgs.isEmpty()) {\n112:         for (MessageExt msg : msgs) {\n113:             if (msg.getReconsumeTimes() >= getMaxReconsumeTimes()) {\n114:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));\n115:                 if (!sendMessageBack(msg)) { // 发回失败，中断\n116:                     suspend = true;\n117:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n118:                 }\n119:             } else {\n120:                 suspend = true;\n121:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n122:             }\n123:         }\n124:     }\n125:     return suspend;\n126: }\n127: \n128: /**\n129:  * 发回消息。\n130:  * 消息发回broker后，对应的消息队列是死信队列。\n131:  *\n132:  * @param msg 消息\n133:  * @return 是否发送成功\n134:  */\n135: public boolean sendMessageBack(final MessageExt msg) {\n136:     try {\n137:         // max reconsume times exceeded then send to dead letter queue.\n138:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());\n139:         String originMsgId = MessageAccessor.getOriginMessageId(msg);\n140:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);\n141:         newMsg.setFlag(msg.getFlag());\n142:         MessageAccessor.setProperties(newMsg, msg.getProperties());\n143:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());\n144:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));\n145:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));\n146:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());\n147: \n148:         this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);\n149:         return true;\n150:     } catch (Exception e) {\n151:         log.error(\"sendMessageBack exception, group: \" + this.consumerGroup + \" msg: \" + msg.toString(), e);\n152:     }\n153: \n154:     return false;\n155: }\n```\n\n* ⬆️⬆️⬆️\n* 第 21 至 29 行 ：消费成功。在自动提交进度( `AutoCommit` )的情况下，`COMMIT`、`ROLLBACK`、`SUCCESS` 逻辑**已经统一**。\n* 第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 `Broker` 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。\n* 第 85 至 88 行 ：提交消费进度。\n\n### 3.13 消息处理队列核心方法\n\n😈涉及到的四个核心方法的源码：\n\n```Java\n  1: // ⬇️⬇️⬇️【ProcessQueue.java】\n  2: /**\n  3:  * 消息映射\n  4:  * key：消息队列位置\n  5:  */\n  6: private final TreeMap<Long, MessageExt> msgTreeMap = new TreeMap<>();    /**\n  7:  * 消息映射临时存储（消费中的消息）\n  8:  */\n  9: private final TreeMap<Long, MessageExt> msgTreeMapTemp = new TreeMap<>();\n 10: \n 11: /**\n 12:  * 回滚消费中的消息\n 13:  * 逻辑类似于{@link #makeMessageToCosumeAgain(List)}\n 14:  */\n 15: public void rollback() {\n 16:     try {\n 17:         this.lockTreeMap.writeLock().lockInterruptibly();\n 18:         try {\n 19:             this.msgTreeMap.putAll(this.msgTreeMapTemp);\n 20:             this.msgTreeMapTemp.clear();\n 21:         } finally {\n 22:             this.lockTreeMap.writeLock().unlock();\n 23:         }\n 24:     } catch (InterruptedException e) {\n 25:         log.error(\"rollback exception\", e);\n 26:     }\n 27: }\n 28: \n 29: /**\n 30:  * 提交消费中的消息已消费成功，返回消费进度\n 31:  *\n 32:  * @return 消费进度\n 33:  */\n 34: public long commit() {\n 35:     try {\n 36:         this.lockTreeMap.writeLock().lockInterruptibly();\n 37:         try {\n 38:             // 消费进度\n 39:             Long offset = this.msgTreeMapTemp.lastKey();\n 40: \n 41:             //\n 42:             msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));\n 43: \n 44:             //\n 45:             this.msgTreeMapTemp.clear();\n 46: \n 47:             // 返回消费进度\n 48:             if (offset != null) {\n 49:                 return offset + 1;\n 50:             }\n 51:         } finally {\n 52:             this.lockTreeMap.writeLock().unlock();\n 53:         }\n 54:     } catch (InterruptedException e) {\n 55:         log.error(\"commit exception\", e);\n 56:     }\n 57: \n 58:     return -1;\n 59: }\n 60: \n 61: /**\n 62:  * 指定消息重新消费\n 63:  * 逻辑类似于{@link #rollback()}\n 64:  *\n 65:  * @param msgs 消息\n 66:  */\n 67: public void makeMessageToCosumeAgain(List<MessageExt> msgs) {\n 68:     try {\n 69:         this.lockTreeMap.writeLock().lockInterruptibly();\n 70:         try {\n 71:             for (MessageExt msg : msgs) {\n 72:                 this.msgTreeMapTemp.remove(msg.getQueueOffset());\n 73:                 this.msgTreeMap.put(msg.getQueueOffset(), msg);\n 74:             }\n 75:         } finally {\n 76:             this.lockTreeMap.writeLock().unlock();\n 77:         }\n 78:     } catch (InterruptedException e) {\n 79:         log.error(\"makeMessageToCosumeAgain exception\", e);\n 80:     }\n 81: }\n 82: \n 83: /**\n 84:  * 获得持有消息前N条\n 85:  *\n 86:  * @param batchSize 条数\n 87:  * @return 消息\n 88:  */\n 89: public List<MessageExt> takeMessags(final int batchSize) {\n 90:     List<MessageExt> result = new ArrayList<>(batchSize);\n 91:     final long now = System.currentTimeMillis();\n 92:     try {\n 93:         this.lockTreeMap.writeLock().lockInterruptibly();\n 94:         this.lastConsumeTimestamp = now;\n 95:         try {\n 96:             if (!this.msgTreeMap.isEmpty()) {\n 97:                 for (int i = 0; i < batchSize; i++) {\n 98:                     Map.Entry<Long, MessageExt> entry = this.msgTreeMap.pollFirstEntry();\n 99:                     if (entry != null) {\n100:                         result.add(entry.getValue());\n101:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());\n102:                     } else {\n103:                         break;\n104:                     }\n105:                 }\n106:             }\n107: \n108:             if (result.isEmpty()) {\n109:                 consuming = false;\n110:             }\n111:         } finally {\n112:             this.lockTreeMap.writeLock().unlock();\n113:         }\n114:     } catch (InterruptedException e) {\n115:         log.error(\"take Messages exception\", e);\n116:     }\n117: \n118:     return result;\n119: }\n```\n\n\n","slug":"RocketMQ/message-send-and-consume-orderly","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzag000vag5d6gdn43nw","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly\">http://www.yunai.me/RocketMQ/message-send-and-consume-orderly</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Producer 顺序发送</a></li>\n<li><a href=\"#\">3. Consumer 顺序消费</a><ul>\n<li><a href=\"#\">3.1 获得(锁定)消息队列</a></li>\n<li><a href=\"#\">3.2 移除消息队列</a></li>\n<li><a href=\"#\">3.3 消费消息队列</a><ul>\n<li><a href=\"#\">3.1.1 消费消息</a></li>\n<li><a href=\"#\">3.1.2 处理消费结果</a></li>\n<li><a href=\"#\">3.13 消息处理队列核心方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>建议</strong>前置阅读内容：</p>\n<ul>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a></li>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">《RocketMQ 源码分析 —— Message 拉取与消费（下）》</a></li>\n</ul>\n<p>当然对 <code>Message</code> 发送与消费已经有一定了解的同学，可以选择跳过。</p>\n<hr>\n<p><code>RocketMQ</code> 提供了两种顺序级别：</p>\n<ul>\n<li>普通顺序消息 ：<code>Producer</code> 将相关联的消息发送到相同的消息队列。</li>\n<li>完全严格顺序 ：在 <code>普通顺序消息</code> 的基础上，<code>Consumer</code> 严格顺序消费。</li>\n</ul>\n<p>绝大部分场景下只需要用到<strong>普通顺序消息</strong>。<br>例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，<strong>不会产生系统逻辑上BUG</strong>。另外，<code>普通顺序消息</code>性能能更加好。<br>那么什么时候使用使用<strong>完全严格顺序</strong>？如下是来自官方文档的说明：</p>\n<blockquote>\n<p>目前已知的应用只有数据库 <code>binlog</code> 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息</p>\n</blockquote>\n<hr>\n<p>😈上代码！！！</p>\n<h1 id=\"2-Producer-顺序发送\"><a href=\"#2-Producer-顺序发送\" class=\"headerlink\" title=\"2. Producer 顺序发送\"></a>2. <code>Producer</code> 顺序发送</h1><p>官方发送顺序消息的<strong>例子</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">package</span> org.apache.rocketmq.example.ordermessage;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.exception.MQClientException;</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.MQProducer;</div><div class=\"line\"> <span class=\"number\">9</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.MessageQueueSelector;</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.SendResult;</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.common.message.Message;</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageQueue;</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException </span>&#123;</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             MQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">\"please_rename_unique_group_name\"</span>);</div><div class=\"line\"><span class=\"number\">20</span>:             producer.start();</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:             String[] tags = <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">\"TagA\"</span>, <span class=\"string\">\"TagB\"</span>, <span class=\"string\">\"TagC\"</span>, <span class=\"string\">\"TagD\"</span>, <span class=\"string\">\"TagE\"</span>&#125;;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"keyword\">int</span> orderId = i % <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"number\">25</span>:                 Message msg =</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">new</span> Message(<span class=\"string\">\"TopicTestjjj\"</span>, tags[i % tags.length], <span class=\"string\">\"KEY\"</span> + i,</div><div class=\"line\"><span class=\"number\">27</span>:                         (<span class=\"string\">\"Hello RocketMQ \"</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</div><div class=\"line\"><span class=\"number\">28</span>:                 SendResult sendResult = producer.send(msg, <span class=\"keyword\">new</span> MessageQueueSelector() &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">select</span><span class=\"params\">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         Integer id = (Integer) arg;</div><div class=\"line\"><span class=\"number\">32</span>:                         <span class=\"keyword\">int</span> index = id % mqs.size();</div><div class=\"line\"><span class=\"number\">33</span>:                         <span class=\"keyword\">return</span> mqs.get(index);</div><div class=\"line\"><span class=\"number\">34</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125;, orderId);</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:                 System.out.printf(<span class=\"string\">\"%s%n\"</span>, sendResult);</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:             producer.shutdown();</div><div class=\"line\"><span class=\"number\">41</span>:         &#125; <span class=\"keyword\">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             e.printStackTrace();</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 28 至 35 行 ：实现了根据 <code>id % mqs.size()</code> 来进行消息队列的选择。当前例子，<strong>我们传递 <code>orderId</code> 作为参数，那么相同的 <code>orderId</code> 能够进入相同的消息队列</strong>。</li>\n</ul>\n<hr>\n<p><code>MessageQueueSelector</code> 接口的<strong>源码</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MessageQueueSelector</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 选择消息队列</div><div class=\"line\"> 5:      *</div><div class=\"line\"> 6:      * <span class=\"doctag\">@param</span> mqs 消息队列</div><div class=\"line\"> 7:      * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 8:      * <span class=\"doctag\">@param</span> arg 参数</div><div class=\"line\"> 9:      * <span class=\"doctag\">@return</span> 消息队列</div><div class=\"line\">10:      */</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"function\">MessageQueue <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageQueue&gt; mqs, <span class=\"keyword\">final</span> Message msg, <span class=\"keyword\">final</span> Object arg)</span></span>;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<p><code>Producer</code> 选择队列发送消息方法的<strong>源码</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">16</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendSelectImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">17</span>:     Message msg, //</div><div class=\"line\"><span class=\"number\">18</span>:     MessageQueueSelector selector, //</div><div class=\"line\"><span class=\"number\">19</span>:     Object arg, //</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"><span class=\"number\">22</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"><span class=\"number\">24</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:         MessageQueue mq = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</div><div class=\"line\"><span class=\"number\">31</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"select message queue throwed exception.\"</span>, e);</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class=\"keyword\">null</span>, timeout);</div><div class=\"line\"><span class=\"number\">37</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"select message queue return null.\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>:         &#125;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"No route info for this topic, \"</span> + msg.getTopic(), <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 30 行 ：选择消息队列。</li>\n<li>第 36 行 ：发送消息。</li>\n</ul>\n<h1 id=\"3-Consumer-严格顺序消费\"><a href=\"#3-Consumer-严格顺序消费\" class=\"headerlink\" title=\"3. Consumer 严格顺序消费\"></a>3. <code>Consumer</code> 严格顺序消费</h1><p><code>Consumer</code> 在严格顺序消费时，通过 <strong>三</strong> 把锁保证严格顺序消费。</p>\n<ul>\n<li><code>Broker</code> 消息队列锁（<strong>分布式锁</strong>） ：<ul>\n<li>集群模式下，<code>Consumer</code> 从 <code>Broker</code> 获得该锁后，才能进行消息拉取、消费。</li>\n<li>广播模式下，<code>Consumer</code> 无需该锁。</li>\n</ul>\n</li>\n<li><code>Consumer</code> 消息队列锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能操作消息队列。</li>\n<li><code>Consumer</code> 消息处理队列消费锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能消费消息队列。</li>\n</ul>\n<p><strong>可能同学有疑问，为什么有 <code>Consumer</code> 消息队列锁还需要有 <code>Consumer</code> 消息队列消费锁呢</strong>？😈让我们带着疑问继续往下看。</p>\n<hr>\n<h2 id=\"3-1-获得-锁定-消息队列\"><a href=\"#3-1-获得-锁定-消息队列\" class=\"headerlink\" title=\"3.1 获得(锁定)消息队列\"></a>3.1 获得(锁定)消息队列</h2><p><strong>集群模式</strong>下，<code>Consumer</code> 更新属于自己的消息队列时，会向 <code>Broker</code> 锁定该消息队列（<em>广播模式下不需要</em>）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalanceImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateProcessQueueTableInRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> Set&lt;MessageQueue&gt; mqSet, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"comment\">// ..... 此处省略部分代码 </span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。</span></div><div class=\"line\"> <span class=\"number\">5</span>:     List&lt;PullRequest&gt; pullRequestList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 拉消息请求数组</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : mqSet) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.processQueueTable.containsKey(mq)) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">if</span> (isOrder &amp;&amp; !<span class=\"keyword\">this</span>.lock(mq)) &#123; <span class=\"comment\">// 顺序消息锁定消息队列</span></div><div class=\"line\"> <span class=\"number\">9</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">11</span>:             &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.removeDirtyOffset(mq);</div><div class=\"line\"><span class=\"number\">14</span>:             ProcessQueue pq = <span class=\"keyword\">new</span> ProcessQueue();</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">long</span> nextOffset = <span class=\"keyword\">this</span>.computePullFromWhere(mq);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">if</span> (nextOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                 ProcessQueue pre = <span class=\"keyword\">this</span>.processQueueTable.putIfAbsent(mq, pq);</div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">22</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest();</div><div class=\"line\"><span class=\"number\">23</span>:                     pullRequest.setConsumerGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">24</span>:                     pullRequest.setNextOffset(nextOffset);</div><div class=\"line\"><span class=\"number\">25</span>:                     pullRequest.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">26</span>:                     pullRequest.setProcessQueue(pq);</div><div class=\"line\"><span class=\"number\">27</span>:                     pullRequestList.add(pullRequest);</div><div class=\"line\"><span class=\"number\">28</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: <span class=\"comment\">// ..... 此处省略部分代码 </span></div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalanceImpl.java】</span></div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"comment\">/**</span></div><div class=\"line\">41:  * 请求Broker获得指定消息队列的分布式锁</div><div class=\"line\">42:  *</div><div class=\"line\">43:  * <span class=\"doctag\">@param</span> mq 队列</div><div class=\"line\">44:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">45:  */</div><div class=\"line\"><span class=\"number\">46</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">47</span>:     FindBrokerResult findBrokerResult = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">48</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">49</span>:         LockBatchRequestBody requestBody = <span class=\"keyword\">new</span> LockBatchRequestBody();</div><div class=\"line\"><span class=\"number\">50</span>:         requestBody.setConsumerGroup(<span class=\"keyword\">this</span>.consumerGroup);</div><div class=\"line\"><span class=\"number\">51</span>:         requestBody.setClientId(<span class=\"keyword\">this</span>.mQClientFactory.getClientId());</div><div class=\"line\"><span class=\"number\">52</span>:         requestBody.getMqSet().add(mq);</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"comment\">// 请求Broker获得指定消息队列的分布式锁</span></div><div class=\"line\"><span class=\"number\">56</span>:             Set&lt;MessageQueue&gt; lockedMq =</div><div class=\"line\"><span class=\"number\">57</span>:                 <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, <span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:             <span class=\"comment\">// 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。</span></div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">for</span> (MessageQueue mmqq : lockedMq) &#123;</div><div class=\"line\"><span class=\"number\">61</span>:                 ProcessQueue processQueue = <span class=\"keyword\">this</span>.processQueueTable.get(mmqq);</div><div class=\"line\"><span class=\"number\">62</span>:                 <span class=\"keyword\">if</span> (processQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:                     processQueue.setLocked(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">64</span>:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());</div><div class=\"line\"><span class=\"number\">65</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">66</span>:             &#125;</div><div class=\"line\"><span class=\"number\">67</span>: </div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">boolean</span> lockOK = lockedMq.contains(mq);</div><div class=\"line\"><span class=\"number\">69</span>:             log.info(<span class=\"string\">\"the message queue lock &#123;&#125;, &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">70</span>:                 lockOK ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Failed\"</span>,</div><div class=\"line\"><span class=\"number\">71</span>:                 <span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"><span class=\"number\">72</span>:                 mq);</div><div class=\"line\"><span class=\"number\">73</span>:             <span class=\"keyword\">return</span> lockOK;</div><div class=\"line\"><span class=\"number\">74</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">75</span>:             log.error(<span class=\"string\">\"lockBatchMQ exception, \"</span> + mq, e);</div><div class=\"line\"><span class=\"number\">76</span>:         &#125;</div><div class=\"line\"><span class=\"number\">77</span>:     &#125;</div><div class=\"line\"><span class=\"number\">78</span>: </div><div class=\"line\"><span class=\"number\">79</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">80</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。</li>\n</ul>\n<hr>\n<p><code>Broker</code> 消息队列锁会过期，默认配置 30s。因此，<code>Consumer</code> 需要不断向 <code>Broker</code> 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.lockMQPeriodically();</div><div class=\"line\"> <span class=\"number\">8</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:         &#125;, <span class=\"number\">1000</span> * <span class=\"number\">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-移除消息队列\"><a href=\"#3-2-移除消息队列\" class=\"headerlink\" title=\"3.2 移除消息队列\"></a>3.2 移除消息队列</h2><p>集群模式下，<code>Consumer</code> 移除自己的消息队列时，会向 <code>Broker</code> 解锁该消息队列（广播模式下不需要）。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalancePushImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 移除不需要的队列相关的信息</div><div class=\"line\"> 4:  * 1. 持久化消费进度，并移除之</div><div class=\"line\"> 5:  * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定</div><div class=\"line\"> 6:  *</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> pq 消息处理队列</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 是否移除成功</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 同步队列的消费进度，并移除之。</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"comment\">// 集群模式下，顺序消费移除时，解锁对队列的锁定</span></div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.isConsumeOrderly()</div><div class=\"line\"><span class=\"number\">18</span>:         &amp;&amp; MessageModel.CLUSTERING.equals(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (pq.getLockConsume().tryLock(<span class=\"number\">1000</span>, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.unlockDelay(mq, pq);</div><div class=\"line\"><span class=\"number\">23</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                     pq.getLockConsume().unlock();</div><div class=\"line\"><span class=\"number\">25</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">26</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                 log.warn(<span class=\"string\">\"[WRONG]mq is consuming, so can not unlock it, &#123;&#125;. maybe hanged for a while, &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">28</span>:                     mq, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">29</span>:                     pq.getTryUnlockTimes());</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:                 pq.incTryUnlockTimes();</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:             log.error(<span class=\"string\">\"removeUnnecessaryMessageQueue Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">40</span>: &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalancePushImpl.java】</span></div><div class=\"line\"><span class=\"number\">43</span>: <span class=\"comment\">/**</span></div><div class=\"line\">44:  * 延迟解锁 Broker 消息队列锁</div><div class=\"line\">45:  * 当消息处理队列不存在消息，则直接解锁</div><div class=\"line\">46:  *</div><div class=\"line\">47:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\">48:  * <span class=\"doctag\">@param</span> pq 消息处理队列</div><div class=\"line\">49:  * <span class=\"doctag\">@return</span> 是否解锁成功</div><div class=\"line\">50:  */</div><div class=\"line\"><span class=\"number\">51</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">unlockDelay</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"keyword\">if</span> (pq.hasTempMessage()) &#123; <span class=\"comment\">// TODO 疑问：为什么要延迟移除</span></div><div class=\"line\"><span class=\"number\">53</span>:         log.info(<span class=\"string\">\"[&#123;&#125;]unlockDelay, begin &#123;&#125; \"</span>, mq.hashCode(), mq);</div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">56</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:                 log.info(<span class=\"string\">\"[&#123;&#125;]unlockDelay, execute at once &#123;&#125;\"</span>, mq.hashCode(), mq);</div><div class=\"line\"><span class=\"number\">58</span>:                 RebalancePushImpl.<span class=\"keyword\">this</span>.unlock(mq, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:         &#125;, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">61</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">this</span>.unlock(mq, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">65</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 20 至 32 行 ：获取<strong>消息队列消费锁</strong>，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的  <code>Consumer</code> 和当前 <code>Consumer</code> 同时消费该消息队列，导致消息无法严格顺序消费。</li>\n<li>第 51 至 64 行 ：解锁 <code>Broker</code> 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 <code>Broker</code> 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。</li>\n</ul>\n<h2 id=\"3-3-消费消息队列\"><a href=\"#3-3-消费消息队列\" class=\"headerlink\" title=\"3.3 消费消息队列\"></a>3.3 消费消息队列</h2><p>😏本节会类比<strong>并发消费消费队列</strong>，建议对照 <a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/#6、PushConsumer-消费消息\">PushConsumer并发消费消息</a> 一起理解。</p>\n<h3 id=\"3-1-1-消费消息\"><a href=\"#3-1-1-消费消息\" class=\"headerlink\" title=\"3.1.1 消费消息\"></a>3.1.1 消费消息</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_13/01.png\" alt=\"顺序消费活动图-消费消息\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeRequest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>: </div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  5:      * 消息处理队列</div><div class=\"line\">  6:      */</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ProcessQueue processQueue;</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  9:      * 消息队列</div><div class=\"line\"> 10:      */</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageQueue messageQueue;</div><div class=\"line\"> <span class=\"number\">12</span>: </div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:             log.warn(<span class=\"string\">\"run, the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"comment\">// 获得 Consumer 消息队列锁</span></div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">synchronized</span> (objLock) &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"comment\">// (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效)</span></div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">25</span>:                 || (<span class=\"keyword\">this</span>.processQueue.isLocked() &amp;&amp; !<span class=\"keyword\">this</span>.processQueue.isLockExpired())) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTime = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"comment\">// 循环</span></div><div class=\"line\"> <span class=\"number\">28</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> continueConsume = <span class=\"keyword\">true</span>; continueConsume; ) &#123;</div><div class=\"line\"> <span class=\"number\">29</span>:                     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                         log.warn(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">31</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">32</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:                     <span class=\"comment\">// 消息队列分布式锁未锁定，提交延迟获得锁并消费请求</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">36</span>:                         &amp;&amp; !<span class=\"keyword\">this</span>.processQueue.isLocked()) &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                         log.warn(<span class=\"string\">\"the message queue not locked, so consume later, &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">38</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">39</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">40</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"comment\">// 消息队列分布式锁已经过期，提交延迟获得锁并消费请求</span></div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">43</span>:                         &amp;&amp; <span class=\"keyword\">this</span>.processQueue.isLockExpired()) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:                         log.warn(<span class=\"string\">\"the message queue lock expired, so consume later, &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">45</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">46</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">47</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>: </div><div class=\"line\"> <span class=\"number\">49</span>:                     <span class=\"comment\">// 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。</span></div><div class=\"line\"> <span class=\"number\">50</span>:                     <span class=\"keyword\">long</span> interval = System.currentTimeMillis() - beginTime;</div><div class=\"line\"> <span class=\"number\">51</span>:                     <span class=\"keyword\">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">53</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>: </div><div class=\"line\"> <span class=\"number\">56</span>:                     <span class=\"comment\">// 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。</span></div><div class=\"line\"> <span class=\"number\">57</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> consumeBatchSize = ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</div><div class=\"line\"> <span class=\"number\">58</span>:                     List&lt;MessageExt&gt; msgs = <span class=\"keyword\">this</span>.processQueue.takeMessags(consumeBatchSize);</div><div class=\"line\"> <span class=\"number\">59</span>:                     <span class=\"keyword\">if</span> (!msgs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                         <span class=\"keyword\">final</span> ConsumeOrderlyContext context = <span class=\"keyword\">new</span> ConsumeOrderlyContext(<span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">61</span>: </div><div class=\"line\"> <span class=\"number\">62</span>:                         ConsumeOrderlyStatus status = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:                         <span class=\"comment\">// ....省略代码：Hook：before</span></div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                         <span class=\"comment\">// 执行消费</span></div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">68</span>:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</div><div class=\"line\"> <span class=\"number\">69</span>:                         <span class=\"keyword\">boolean</span> hasException = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:                             <span class=\"keyword\">this</span>.processQueue.getLockConsume().lock(); <span class=\"comment\">// 锁定队列消费锁</span></div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                                 log.warn(<span class=\"string\">\"consumeMessage, the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">75</span>:                                     <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">78</span>: </div><div class=\"line\"> <span class=\"number\">79</span>:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</div><div class=\"line\"> <span class=\"number\">80</span>:                         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:                             log.warn(<span class=\"string\">\"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">82</span>:                                 RemotingHelper.exceptionSimpleDesc(e), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">84</span>:                                 msgs, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">85</span>:                                 messageQueue);</div><div class=\"line\"> <span class=\"number\">86</span>:                             hasException = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">87</span>:                         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">88</span>:                             <span class=\"keyword\">this</span>.processQueue.getLockConsume().unlock(); <span class=\"comment\">// 锁定队列消费锁</span></div><div class=\"line\"> <span class=\"number\">89</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// ....省略代码：解析消费结果状态</span></div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:                         <span class=\"comment\">// ....省略代码：Hook：after</span></div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.getConsumerStatsManager()</div><div class=\"line\"> <span class=\"number\">96</span>:                             .incConsumeRT(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</div><div class=\"line\"> <span class=\"number\">97</span>: </div><div class=\"line\"> <span class=\"number\">98</span>:                         <span class=\"comment\">// 处理消费结果</span></div><div class=\"line\"> <span class=\"number\">99</span>:                         continueConsume = ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.processConsumeResult(msgs, status, context, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">100</span>:                     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                         continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">102</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">103</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">104</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">105</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">106</span>:                     log.warn(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"><span class=\"number\">107</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">108</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"number\">111</span>:             &#125;</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>:     &#125;</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 20 行 ：获得 <code>Consumer</code> 消息队列锁。</li>\n<li>第 58 行 ：从消息处理队列顺序获得消息。<strong>和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。</strong></li>\n<li>第 71 行 ：获得 <code>Consumer</code> 消息处理队列消费锁。相比【<code>Consumer</code>消息队列锁】，其粒度较小。这就是上文提到的❓<strong>为什么有<code>Consumer</code>消息队列锁还需要有 Consumer 消息队列消费锁呢</strong>的原因。</li>\n<li>第 79 行 ：<strong>执行消费</strong>。</li>\n<li>第 99 行 ：处理消费结果。</li>\n</ul>\n<h3 id=\"3-1-2-处理消费结果\"><a href=\"#3-1-2-处理消费结果\" class=\"headerlink\" title=\"3.1.2 处理消费结果\"></a>3.1.2 处理消费结果</h3><p>顺序消费消息结果 (<code>ConsumeOrderlyStatus</code>) 有四种情况：</p>\n<ul>\n<li><code>SUCCESS</code> ：消费成功<strong>但不提交</strong>。</li>\n<li><code>ROLLBACK</code> ：消费失败，消费回滚。</li>\n<li><code>COMMIT</code> ：消费成功提交并且提交。</li>\n<li><code>SUSPEND_CURRENT_QUEUE_A_MOMENT</code> ：消费失败，挂起消费队列一会会，稍后继续消费。</li>\n</ul>\n<p>考虑到 <code>ROLLBACK</code> 、<code>COMMIT</code> 暂时只使用在 <code>MySQL binlog</code> 场景，官方将这两状态标记为 <code>@Deprecated</code>。当然，相应的实现逻辑依然保留。</p>\n<p>在<strong>并发消费</strong>场景时，如果消费失败，<code>Consumer</code> 会将消费失败消息发回到 <code>Broker</code> 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。</p>\n<p>但是在<strong>完全严格顺序消费</strong>消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 </p>\n<p>不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，<code>Consumer</code> 会将消费失败超过上限的消息发回到 <code>Broker</code> 死信队列。</p>\n<p>让我们来看看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 处理消费结果，并返回是否继续消费</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> status 消费结果状态</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> context 消费Context</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> consumeRequest 消费请求</div><div class=\"line\">  9:  * <span class=\"doctag\">@return</span> 是否继续消费</div><div class=\"line\"> 10:  */</div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">processConsumeResult</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> ConsumeOrderlyStatus status, //</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">final</span> ConsumeOrderlyContext context, //</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</div><div class=\"line\"> <span class=\"number\">16</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">boolean</span> continueConsume = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">long</span> commitOffset = -<span class=\"number\">1L</span>;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (context.isAutoCommit()) &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">case</span> COMMIT:</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">case</span> ROLLBACK:</div><div class=\"line\"> <span class=\"number\">23</span>:                 log.warn(<span class=\"string\">\"the message queue consume result is illegal, we think you want to ack these message &#123;&#125;\"</span>, consumeRequest.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">case</span> SUCCESS:</div><div class=\"line\"> <span class=\"number\">25</span>:                 <span class=\"comment\">// 提交消息已消费成功到消息处理队列</span></div><div class=\"line\"> <span class=\"number\">26</span>:                 commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">28</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">33</span>:                 <span class=\"keyword\">if</span> (checkReconsumeTimes(msgs)) &#123; <span class=\"comment\">// 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms</span></div><div class=\"line\"> <span class=\"number\">34</span>:                     <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</div><div class=\"line\"> <span class=\"number\">36</span>:                     <span class=\"comment\">// 提交延迟消费请求</span></div><div class=\"line\"> <span class=\"number\">37</span>:                     <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">38</span>:                         consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">39</span>:                         consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">40</span>:                         context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">41</span>:                     continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                     commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">44</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">45</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">46</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">47</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:         <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:             <span class=\"keyword\">case</span> SUCCESS:</div><div class=\"line\"> <span class=\"number\">52</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">53</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">case</span> COMMIT:</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"comment\">// 提交消息已消费成功到消息处理队列</span></div><div class=\"line\"> <span class=\"number\">56</span>:                 commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"keyword\">case</span> ROLLBACK:</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">60</span>:                 consumeRequest.getProcessQueue().rollback();</div><div class=\"line\"> <span class=\"number\">61</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">62</span>:                     consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">63</span>:                     consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">64</span>:                     context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">65</span>:                 continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">66</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT: <span class=\"comment\">// 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms</span></div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">69</span>:                 <span class=\"keyword\">if</span> (checkReconsumeTimes(msgs)) &#123;</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">71</span>:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</div><div class=\"line\"> <span class=\"number\">72</span>:                     <span class=\"comment\">// 提交延迟消费请求</span></div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">74</span>:                         consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">75</span>:                         consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">76</span>:                         context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">77</span>:                     continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">80</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">81</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">82</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">83</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">84</span>: </div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"comment\">// 消息处理队列未dropped，提交有效消费进度</span></div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"keyword\">if</span> (commitOffset &gt;= <span class=\"number\">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">88</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:     <span class=\"keyword\">return</span> continueConsume;</div><div class=\"line\"> <span class=\"number\">91</span>: &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxReconsumeTimes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"comment\">// default reconsume times: Integer.MAX_VALUE</span></div><div class=\"line\"> <span class=\"number\">95</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes() == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"keyword\">return</span> Integer.MAX_VALUE;</div><div class=\"line\"> <span class=\"number\">97</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">99</span>:     &#125;</div><div class=\"line\"><span class=\"number\">100</span>: &#125;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"comment\">/**</span></div><div class=\"line\">103:  * 计算是否要暂停消费</div><div class=\"line\">104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功</div><div class=\"line\">105:  *</div><div class=\"line\">106:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">107:  * <span class=\"doctag\">@return</span> 是否要暂停</div><div class=\"line\">108:  */</div><div class=\"line\"><span class=\"number\">109</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkReconsumeTimes</span><span class=\"params\">(List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"keyword\">boolean</span> suspend = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">111</span>:     <span class=\"keyword\">if</span> (msgs != <span class=\"keyword\">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:             <span class=\"keyword\">if</span> (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">115</span>:                 <span class=\"keyword\">if</span> (!sendMessageBack(msg)) &#123; <span class=\"comment\">// 发回失败，中断</span></div><div class=\"line\"><span class=\"number\">116</span>:                     suspend = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">118</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">119</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">120</span>:                 suspend = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">121</span>:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">122</span>:             &#125;</div><div class=\"line\"><span class=\"number\">123</span>:         &#125;</div><div class=\"line\"><span class=\"number\">124</span>:     &#125;</div><div class=\"line\"><span class=\"number\">125</span>:     <span class=\"keyword\">return</span> suspend;</div><div class=\"line\"><span class=\"number\">126</span>: &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>: <span class=\"comment\">/**</span></div><div class=\"line\">129:  * 发回消息。</div><div class=\"line\">130:  * 消息发回broker后，对应的消息队列是死信队列。</div><div class=\"line\">131:  *</div><div class=\"line\">132:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">133:  * <span class=\"doctag\">@return</span> 是否发送成功</div><div class=\"line\">134:  */</div><div class=\"line\"><span class=\"number\">135</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageBack</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExt msg)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">136</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">137</span>:         <span class=\"comment\">// max reconsume times exceeded then send to dead letter queue.</span></div><div class=\"line\"><span class=\"number\">138</span>:         Message newMsg = <span class=\"keyword\">new</span> Message(MixAll.getRetryTopic(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</div><div class=\"line\"><span class=\"number\">139</span>:         String originMsgId = MessageAccessor.getOriginMessageId(msg);</div><div class=\"line\"><span class=\"number\">140</span>:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">141</span>:         newMsg.setFlag(msg.getFlag());</div><div class=\"line\"><span class=\"number\">142</span>:         MessageAccessor.setProperties(newMsg, msg.getProperties());</div><div class=\"line\"><span class=\"number\">143</span>:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">144</span>:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">145</span>:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">146</span>:         newMsg.setDelayTimeLevel(<span class=\"number\">3</span> + msg.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">147</span>: </div><div class=\"line\"><span class=\"number\">148</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);</div><div class=\"line\"><span class=\"number\">149</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">150</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">151</span>:         log.error(<span class=\"string\">\"sendMessageBack exception, group: \"</span> + <span class=\"keyword\">this</span>.consumerGroup + <span class=\"string\">\" msg: \"</span> + msg.toString(), e);</div><div class=\"line\"><span class=\"number\">152</span>:     &#125;</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">155</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 21 至 29 行 ：消费成功。在自动提交进度( <code>AutoCommit</code> )的情况下，<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SUCCESS</code> 逻辑<strong>已经统一</strong>。</li>\n<li>第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 <code>Broker</code> 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。</li>\n<li>第 85 至 88 行 ：提交消费进度。</li>\n</ul>\n<h3 id=\"3-13-消息处理队列核心方法\"><a href=\"#3-13-消息处理队列核心方法\" class=\"headerlink\" title=\"3.13 消息处理队列核心方法\"></a>3.13 消息处理队列核心方法</h3><p>😈涉及到的四个核心方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ProcessQueue.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 消息映射</div><div class=\"line\">  4:  * key：消息队列位置</div><div class=\"line\">  5:  */</div><div class=\"line\">  <span class=\"number\">6</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();    <span class=\"comment\">/**</span></div><div class=\"line\">  7:  * 消息映射临时存储（消费中的消息）</div><div class=\"line\">  8:  */</div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 12:  * 回滚消费中的消息</div><div class=\"line\"> 13:  * 逻辑类似于&#123;<span class=\"doctag\">@link</span> #makeMessageToCosumeAgain(List)&#125;</div><div class=\"line\"> 14:  */</div><div class=\"line\"> <span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rollback</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.msgTreeMap.putAll(<span class=\"keyword\">this</span>.msgTreeMapTemp);</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.msgTreeMapTemp.clear();</div><div class=\"line\"> <span class=\"number\">21</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:         log.error(<span class=\"string\">\"rollback exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">27</span>: &#125;</div><div class=\"line\"> <span class=\"number\">28</span>: </div><div class=\"line\"> <span class=\"number\">29</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 30:  * 提交消费中的消息已消费成功，返回消费进度</div><div class=\"line\"> 31:  *</div><div class=\"line\"> 32:  * <span class=\"doctag\">@return</span> 消费进度</div><div class=\"line\"> 33:  */</div><div class=\"line\"> <span class=\"number\">34</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">commit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">37</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:             <span class=\"comment\">// 消费进度</span></div><div class=\"line\"> <span class=\"number\">39</span>:             Long offset = <span class=\"keyword\">this</span>.msgTreeMapTemp.lastKey();</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:             <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">42</span>:             msgCount.addAndGet(<span class=\"keyword\">this</span>.msgTreeMapTemp.size() * (-<span class=\"number\">1</span>));</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:             <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">45</span>:             <span class=\"keyword\">this</span>.msgTreeMapTemp.clear();</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:             <span class=\"comment\">// 返回消费进度</span></div><div class=\"line\"> <span class=\"number\">48</span>:             <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">49</span>:                 <span class=\"keyword\">return</span> offset + <span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">50</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">51</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">53</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:         log.error(<span class=\"string\">\"commit exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">56</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">59</span>: &#125;</div><div class=\"line\"> <span class=\"number\">60</span>: </div><div class=\"line\"> <span class=\"number\">61</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 62:  * 指定消息重新消费</div><div class=\"line\"> 63:  * 逻辑类似于&#123;<span class=\"doctag\">@link</span> #rollback()&#125;</div><div class=\"line\"> 64:  *</div><div class=\"line\"> 65:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\"> 66:  */</div><div class=\"line\"> <span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeMessageToCosumeAgain</span><span class=\"params\">(List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">70</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">this</span>.msgTreeMapTemp.remove(msg.getQueueOffset());</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.msgTreeMap.put(msg.getQueueOffset(), msg);</div><div class=\"line\"> <span class=\"number\">74</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">75</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">77</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:         log.error(<span class=\"string\">\"makeMessageToCosumeAgain exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">80</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: &#125;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 84:  * 获得持有消息前N条</div><div class=\"line\"> 85:  *</div><div class=\"line\"> 86:  * <span class=\"doctag\">@param</span> batchSize 条数</div><div class=\"line\"> 87:  * <span class=\"doctag\">@return</span> 消息</div><div class=\"line\"> 88:  */</div><div class=\"line\"> <span class=\"number\">89</span>: <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageExt&gt; <span class=\"title\">takeMessags</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> batchSize)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">90</span>:     List&lt;MessageExt&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(batchSize);</div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">92</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"keyword\">this</span>.lastConsumeTimestamp = now;</div><div class=\"line\"> <span class=\"number\">95</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:             <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">97</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; batchSize; i++) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                     Map.Entry&lt;Long, MessageExt&gt; entry = <span class=\"keyword\">this</span>.msgTreeMap.pollFirstEntry();</div><div class=\"line\"> <span class=\"number\">99</span>:                     <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">100</span>:                         result.add(entry.getValue());</div><div class=\"line\"><span class=\"number\">101</span>:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());</div><div class=\"line\"><span class=\"number\">102</span>:                     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">103</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">104</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">105</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">106</span>:             &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">if</span> (result.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:                 consuming = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">110</span>:             &#125;</div><div class=\"line\"><span class=\"number\">111</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">112</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">113</span>:         &#125;</div><div class=\"line\"><span class=\"number\">114</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">115</span>:         log.error(<span class=\"string\">\"take Messages exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">116</span>:     &#125;</div><div class=\"line\"><span class=\"number\">117</span>: </div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">119</span>: &#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly\">http://www.yunai.me/RocketMQ/message-send-and-consume-orderly</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Producer 顺序发送</a></li>\n<li><a href=\"#\">3. Consumer 顺序消费</a><ul>\n<li><a href=\"#\">3.1 获得(锁定)消息队列</a></li>\n<li><a href=\"#\">3.2 移除消息队列</a></li>\n<li><a href=\"#\">3.3 消费消息队列</a><ul>\n<li><a href=\"#\">3.1.1 消费消息</a></li>\n<li><a href=\"#\">3.1.2 处理消费结果</a></li>\n<li><a href=\"#\">3.13 消息处理队列核心方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>建议</strong>前置阅读内容：</p>\n<ul>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a></li>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">《RocketMQ 源码分析 —— Message 拉取与消费（下）》</a></li>\n</ul>\n<p>当然对 <code>Message</code> 发送与消费已经有一定了解的同学，可以选择跳过。</p>\n<hr>\n<p><code>RocketMQ</code> 提供了两种顺序级别：</p>\n<ul>\n<li>普通顺序消息 ：<code>Producer</code> 将相关联的消息发送到相同的消息队列。</li>\n<li>完全严格顺序 ：在 <code>普通顺序消息</code> 的基础上，<code>Consumer</code> 严格顺序消费。</li>\n</ul>\n<p>绝大部分场景下只需要用到<strong>普通顺序消息</strong>。<br>例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，<strong>不会产生系统逻辑上BUG</strong>。另外，<code>普通顺序消息</code>性能能更加好。<br>那么什么时候使用使用<strong>完全严格顺序</strong>？如下是来自官方文档的说明：</p>\n<blockquote>\n<p>目前已知的应用只有数据库 <code>binlog</code> 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息</p>\n</blockquote>\n<hr>\n<p>😈上代码！！！</p>\n<h1 id=\"2-Producer-顺序发送\"><a href=\"#2-Producer-顺序发送\" class=\"headerlink\" title=\"2. Producer 顺序发送\"></a>2. <code>Producer</code> 顺序发送</h1><p>官方发送顺序消息的<strong>例子</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">package</span> org.apache.rocketmq.example.ordermessage;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">import</span> java.util.List;</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.exception.MQClientException;</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.MQProducer;</div><div class=\"line\"> <span class=\"number\">9</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.MessageQueueSelector;</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.client.producer.SendResult;</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.common.message.Message;</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.common.message.MessageQueue;</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Producer</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException </span>&#123;</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             MQProducer producer = <span class=\"keyword\">new</span> DefaultMQProducer(<span class=\"string\">\"please_rename_unique_group_name\"</span>);</div><div class=\"line\"><span class=\"number\">20</span>:             producer.start();</div><div class=\"line\"><span class=\"number\">21</span>: </div><div class=\"line\"><span class=\"number\">22</span>:             String[] tags = <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">\"TagA\"</span>, <span class=\"string\">\"TagB\"</span>, <span class=\"string\">\"TagC\"</span>, <span class=\"string\">\"TagD\"</span>, <span class=\"string\">\"TagE\"</span>&#125;;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"keyword\">int</span> orderId = i % <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"number\">25</span>:                 Message msg =</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">new</span> Message(<span class=\"string\">\"TopicTestjjj\"</span>, tags[i % tags.length], <span class=\"string\">\"KEY\"</span> + i,</div><div class=\"line\"><span class=\"number\">27</span>:                         (<span class=\"string\">\"Hello RocketMQ \"</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</div><div class=\"line\"><span class=\"number\">28</span>:                 SendResult sendResult = producer.send(msg, <span class=\"keyword\">new</span> MessageQueueSelector() &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"function\"><span class=\"keyword\">public</span> MessageQueue <span class=\"title\">select</span><span class=\"params\">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         Integer id = (Integer) arg;</div><div class=\"line\"><span class=\"number\">32</span>:                         <span class=\"keyword\">int</span> index = id % mqs.size();</div><div class=\"line\"><span class=\"number\">33</span>:                         <span class=\"keyword\">return</span> mqs.get(index);</div><div class=\"line\"><span class=\"number\">34</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125;, orderId);</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:                 System.out.printf(<span class=\"string\">\"%s%n\"</span>, sendResult);</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:             producer.shutdown();</div><div class=\"line\"><span class=\"number\">41</span>:         &#125; <span class=\"keyword\">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             e.printStackTrace();</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 28 至 35 行 ：实现了根据 <code>id % mqs.size()</code> 来进行消息队列的选择。当前例子，<strong>我们传递 <code>orderId</code> 作为参数，那么相同的 <code>orderId</code> 能够进入相同的消息队列</strong>。</li>\n</ul>\n<hr>\n<p><code>MessageQueueSelector</code> 接口的<strong>源码</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MessageQueueSelector</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 选择消息队列</div><div class=\"line\"> 5:      *</div><div class=\"line\"> 6:      * <span class=\"doctag\">@param</span> mqs 消息队列</div><div class=\"line\"> 7:      * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 8:      * <span class=\"doctag\">@param</span> arg 参数</div><div class=\"line\"> 9:      * <span class=\"doctag\">@return</span> 消息队列</div><div class=\"line\">10:      */</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"function\">MessageQueue <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageQueue&gt; mqs, <span class=\"keyword\">final</span> Message msg, <span class=\"keyword\">final</span> Object arg)</span></span>;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<p><code>Producer</code> 选择队列发送消息方法的<strong>源码</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">16</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendSelectImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">17</span>:     Message msg, //</div><div class=\"line\"><span class=\"number\">18</span>:     MessageQueueSelector selector, //</div><div class=\"line\"><span class=\"number\">19</span>:     Object arg, //</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"><span class=\"number\">22</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"><span class=\"number\">24</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:         MessageQueue mq = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</div><div class=\"line\"><span class=\"number\">31</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"select message queue throwed exception.\"</span>, e);</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class=\"keyword\">null</span>, timeout);</div><div class=\"line\"><span class=\"number\">37</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"select message queue return null.\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>:         &#125;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"No route info for this topic, \"</span> + msg.getTopic(), <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 30 行 ：选择消息队列。</li>\n<li>第 36 行 ：发送消息。</li>\n</ul>\n<h1 id=\"3-Consumer-严格顺序消费\"><a href=\"#3-Consumer-严格顺序消费\" class=\"headerlink\" title=\"3. Consumer 严格顺序消费\"></a>3. <code>Consumer</code> 严格顺序消费</h1><p><code>Consumer</code> 在严格顺序消费时，通过 <strong>三</strong> 把锁保证严格顺序消费。</p>\n<ul>\n<li><code>Broker</code> 消息队列锁（<strong>分布式锁</strong>） ：<ul>\n<li>集群模式下，<code>Consumer</code> 从 <code>Broker</code> 获得该锁后，才能进行消息拉取、消费。</li>\n<li>广播模式下，<code>Consumer</code> 无需该锁。</li>\n</ul>\n</li>\n<li><code>Consumer</code> 消息队列锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能操作消息队列。</li>\n<li><code>Consumer</code> 消息处理队列消费锁（<strong>本地锁</strong>） ：<code>Consumer</code> 获得该锁才能消费消息队列。</li>\n</ul>\n<p><strong>可能同学有疑问，为什么有 <code>Consumer</code> 消息队列锁还需要有 <code>Consumer</code> 消息队列消费锁呢</strong>？😈让我们带着疑问继续往下看。</p>\n<hr>\n<h2 id=\"3-1-获得-锁定-消息队列\"><a href=\"#3-1-获得-锁定-消息队列\" class=\"headerlink\" title=\"3.1 获得(锁定)消息队列\"></a>3.1 获得(锁定)消息队列</h2><p><strong>集群模式</strong>下，<code>Consumer</code> 更新属于自己的消息队列时，会向 <code>Broker</code> 锁定该消息队列（<em>广播模式下不需要</em>）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalanceImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateProcessQueueTableInRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> Set&lt;MessageQueue&gt; mqSet, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>: <span class=\"comment\">// ..... 此处省略部分代码 </span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。</span></div><div class=\"line\"> <span class=\"number\">5</span>:     List&lt;PullRequest&gt; pullRequestList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 拉消息请求数组</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : mqSet) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.processQueueTable.containsKey(mq)) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">if</span> (isOrder &amp;&amp; !<span class=\"keyword\">this</span>.lock(mq)) &#123; <span class=\"comment\">// 顺序消息锁定消息队列</span></div><div class=\"line\"> <span class=\"number\">9</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">11</span>:             &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.removeDirtyOffset(mq);</div><div class=\"line\"><span class=\"number\">14</span>:             ProcessQueue pq = <span class=\"keyword\">new</span> ProcessQueue();</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">long</span> nextOffset = <span class=\"keyword\">this</span>.computePullFromWhere(mq);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">if</span> (nextOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                 ProcessQueue pre = <span class=\"keyword\">this</span>.processQueueTable.putIfAbsent(mq, pq);</div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">22</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest();</div><div class=\"line\"><span class=\"number\">23</span>:                     pullRequest.setConsumerGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">24</span>:                     pullRequest.setNextOffset(nextOffset);</div><div class=\"line\"><span class=\"number\">25</span>:                     pullRequest.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">26</span>:                     pullRequest.setProcessQueue(pq);</div><div class=\"line\"><span class=\"number\">27</span>:                     pullRequestList.add(pullRequest);</div><div class=\"line\"><span class=\"number\">28</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>: <span class=\"comment\">// ..... 此处省略部分代码 </span></div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalanceImpl.java】</span></div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"comment\">/**</span></div><div class=\"line\">41:  * 请求Broker获得指定消息队列的分布式锁</div><div class=\"line\">42:  *</div><div class=\"line\">43:  * <span class=\"doctag\">@param</span> mq 队列</div><div class=\"line\">44:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">45:  */</div><div class=\"line\"><span class=\"number\">46</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">47</span>:     FindBrokerResult findBrokerResult = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">48</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">49</span>:         LockBatchRequestBody requestBody = <span class=\"keyword\">new</span> LockBatchRequestBody();</div><div class=\"line\"><span class=\"number\">50</span>:         requestBody.setConsumerGroup(<span class=\"keyword\">this</span>.consumerGroup);</div><div class=\"line\"><span class=\"number\">51</span>:         requestBody.setClientId(<span class=\"keyword\">this</span>.mQClientFactory.getClientId());</div><div class=\"line\"><span class=\"number\">52</span>:         requestBody.getMqSet().add(mq);</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"comment\">// 请求Broker获得指定消息队列的分布式锁</span></div><div class=\"line\"><span class=\"number\">56</span>:             Set&lt;MessageQueue&gt; lockedMq =</div><div class=\"line\"><span class=\"number\">57</span>:                 <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, <span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:             <span class=\"comment\">// 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。</span></div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">for</span> (MessageQueue mmqq : lockedMq) &#123;</div><div class=\"line\"><span class=\"number\">61</span>:                 ProcessQueue processQueue = <span class=\"keyword\">this</span>.processQueueTable.get(mmqq);</div><div class=\"line\"><span class=\"number\">62</span>:                 <span class=\"keyword\">if</span> (processQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">63</span>:                     processQueue.setLocked(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">64</span>:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());</div><div class=\"line\"><span class=\"number\">65</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">66</span>:             &#125;</div><div class=\"line\"><span class=\"number\">67</span>: </div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">boolean</span> lockOK = lockedMq.contains(mq);</div><div class=\"line\"><span class=\"number\">69</span>:             log.info(<span class=\"string\">\"the message queue lock &#123;&#125;, &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">70</span>:                 lockOK ? <span class=\"string\">\"OK\"</span> : <span class=\"string\">\"Failed\"</span>,</div><div class=\"line\"><span class=\"number\">71</span>:                 <span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"><span class=\"number\">72</span>:                 mq);</div><div class=\"line\"><span class=\"number\">73</span>:             <span class=\"keyword\">return</span> lockOK;</div><div class=\"line\"><span class=\"number\">74</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">75</span>:             log.error(<span class=\"string\">\"lockBatchMQ exception, \"</span> + mq, e);</div><div class=\"line\"><span class=\"number\">76</span>:         &#125;</div><div class=\"line\"><span class=\"number\">77</span>:     &#125;</div><div class=\"line\"><span class=\"number\">78</span>: </div><div class=\"line\"><span class=\"number\">79</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">80</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。</li>\n</ul>\n<hr>\n<p><code>Broker</code> 消息队列锁会过期，默认配置 30s。因此，<code>Consumer</code> 需要不断向 <code>Broker</code> 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.lockMQPeriodically();</div><div class=\"line\"> <span class=\"number\">8</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:         &#125;, <span class=\"number\">1000</span> * <span class=\"number\">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-移除消息队列\"><a href=\"#3-2-移除消息队列\" class=\"headerlink\" title=\"3.2 移除消息队列\"></a>3.2 移除消息队列</h2><p>集群模式下，<code>Consumer</code> 移除自己的消息队列时，会向 <code>Broker</code> 解锁该消息队列（广播模式下不需要）。核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalancePushImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 移除不需要的队列相关的信息</div><div class=\"line\"> 4:  * 1. 持久化消费进度，并移除之</div><div class=\"line\"> 5:  * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定</div><div class=\"line\"> 6:  *</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> pq 消息处理队列</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 是否移除成功</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 同步队列的消费进度，并移除之。</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"comment\">// 集群模式下，顺序消费移除时，解锁对队列的锁定</span></div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.isConsumeOrderly()</div><div class=\"line\"><span class=\"number\">18</span>:         &amp;&amp; MessageModel.CLUSTERING.equals(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (pq.getLockConsume().tryLock(<span class=\"number\">1000</span>, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.unlockDelay(mq, pq);</div><div class=\"line\"><span class=\"number\">23</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                     pq.getLockConsume().unlock();</div><div class=\"line\"><span class=\"number\">25</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">26</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                 log.warn(<span class=\"string\">\"[WRONG]mq is consuming, so can not unlock it, &#123;&#125;. maybe hanged for a while, &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">28</span>:                     mq, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">29</span>:                     pq.getTryUnlockTimes());</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:                 pq.incTryUnlockTimes();</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:             log.error(<span class=\"string\">\"removeUnnecessaryMessageQueue Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">40</span>: &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>: <span class=\"comment\">// ⬇️⬇️⬇️【RebalancePushImpl.java】</span></div><div class=\"line\"><span class=\"number\">43</span>: <span class=\"comment\">/**</span></div><div class=\"line\">44:  * 延迟解锁 Broker 消息队列锁</div><div class=\"line\">45:  * 当消息处理队列不存在消息，则直接解锁</div><div class=\"line\">46:  *</div><div class=\"line\">47:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\">48:  * <span class=\"doctag\">@param</span> pq 消息处理队列</div><div class=\"line\">49:  * <span class=\"doctag\">@return</span> 是否解锁成功</div><div class=\"line\">50:  */</div><div class=\"line\"><span class=\"number\">51</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">unlockDelay</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"keyword\">if</span> (pq.hasTempMessage()) &#123; <span class=\"comment\">// TODO 疑问：为什么要延迟移除</span></div><div class=\"line\"><span class=\"number\">53</span>:         log.info(<span class=\"string\">\"[&#123;&#125;]unlockDelay, begin &#123;&#125; \"</span>, mq.hashCode(), mq);</div><div class=\"line\"><span class=\"number\">54</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">56</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:                 log.info(<span class=\"string\">\"[&#123;&#125;]unlockDelay, execute at once &#123;&#125;\"</span>, mq.hashCode(), mq);</div><div class=\"line\"><span class=\"number\">58</span>:                 RebalancePushImpl.<span class=\"keyword\">this</span>.unlock(mq, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:         &#125;, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">61</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">this</span>.unlock(mq, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">65</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 20 至 32 行 ：获取<strong>消息队列消费锁</strong>，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的  <code>Consumer</code> 和当前 <code>Consumer</code> 同时消费该消息队列，导致消息无法严格顺序消费。</li>\n<li>第 51 至 64 行 ：解锁 <code>Broker</code> 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 <code>Broker</code> 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。</li>\n</ul>\n<h2 id=\"3-3-消费消息队列\"><a href=\"#3-3-消费消息队列\" class=\"headerlink\" title=\"3.3 消费消息队列\"></a>3.3 消费消息队列</h2><p>😏本节会类比<strong>并发消费消费队列</strong>，建议对照 <a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/#6、PushConsumer-消费消息\">PushConsumer并发消费消息</a> 一起理解。</p>\n<h3 id=\"3-1-1-消费消息\"><a href=\"#3-1-1-消费消息\" class=\"headerlink\" title=\"3.1.1 消费消息\"></a>3.1.1 消费消息</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_13/01.png\" alt=\"顺序消费活动图-消费消息\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeRequest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>: </div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  5:      * 消息处理队列</div><div class=\"line\">  6:      */</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ProcessQueue processQueue;</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  9:      * 消息队列</div><div class=\"line\"> 10:      */</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageQueue messageQueue;</div><div class=\"line\"> <span class=\"number\">12</span>: </div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:             log.warn(<span class=\"string\">\"run, the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"comment\">// 获得 Consumer 消息队列锁</span></div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">synchronized</span> (objLock) &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"comment\">// (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效)</span></div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">25</span>:                 || (<span class=\"keyword\">this</span>.processQueue.isLocked() &amp;&amp; !<span class=\"keyword\">this</span>.processQueue.isLockExpired())) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTime = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"comment\">// 循环</span></div><div class=\"line\"> <span class=\"number\">28</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> continueConsume = <span class=\"keyword\">true</span>; continueConsume; ) &#123;</div><div class=\"line\"> <span class=\"number\">29</span>:                     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                         log.warn(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">31</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">32</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:                     <span class=\"comment\">// 消息队列分布式锁未锁定，提交延迟获得锁并消费请求</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">36</span>:                         &amp;&amp; !<span class=\"keyword\">this</span>.processQueue.isLocked()) &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                         log.warn(<span class=\"string\">\"the message queue not locked, so consume later, &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">38</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">39</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">40</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"comment\">// 消息队列分布式锁已经过期，提交延迟获得锁并消费请求</span></div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())</div><div class=\"line\"> <span class=\"number\">43</span>:                         &amp;&amp; <span class=\"keyword\">this</span>.processQueue.isLockExpired()) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:                         log.warn(<span class=\"string\">\"the message queue lock expired, so consume later, &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">45</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">46</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">47</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>: </div><div class=\"line\"> <span class=\"number\">49</span>:                     <span class=\"comment\">// 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。</span></div><div class=\"line\"> <span class=\"number\">50</span>:                     <span class=\"keyword\">long</span> interval = System.currentTimeMillis() - beginTime;</div><div class=\"line\"> <span class=\"number\">51</span>:                     <span class=\"keyword\">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">53</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>: </div><div class=\"line\"> <span class=\"number\">56</span>:                     <span class=\"comment\">// 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。</span></div><div class=\"line\"> <span class=\"number\">57</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> consumeBatchSize = ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</div><div class=\"line\"> <span class=\"number\">58</span>:                     List&lt;MessageExt&gt; msgs = <span class=\"keyword\">this</span>.processQueue.takeMessags(consumeBatchSize);</div><div class=\"line\"> <span class=\"number\">59</span>:                     <span class=\"keyword\">if</span> (!msgs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                         <span class=\"keyword\">final</span> ConsumeOrderlyContext context = <span class=\"keyword\">new</span> ConsumeOrderlyContext(<span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">61</span>: </div><div class=\"line\"> <span class=\"number\">62</span>:                         ConsumeOrderlyStatus status = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:                         <span class=\"comment\">// ....省略代码：Hook：before</span></div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                         <span class=\"comment\">// 执行消费</span></div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">68</span>:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</div><div class=\"line\"> <span class=\"number\">69</span>:                         <span class=\"keyword\">boolean</span> hasException = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:                             <span class=\"keyword\">this</span>.processQueue.getLockConsume().lock(); <span class=\"comment\">// 锁定队列消费锁</span></div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                                 log.warn(<span class=\"string\">\"consumeMessage, the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">75</span>:                                     <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">78</span>: </div><div class=\"line\"> <span class=\"number\">79</span>:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</div><div class=\"line\"> <span class=\"number\">80</span>:                         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:                             log.warn(<span class=\"string\">\"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">82</span>:                                 RemotingHelper.exceptionSimpleDesc(e), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">84</span>:                                 msgs, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">85</span>:                                 messageQueue);</div><div class=\"line\"> <span class=\"number\">86</span>:                             hasException = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">87</span>:                         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">88</span>:                             <span class=\"keyword\">this</span>.processQueue.getLockConsume().unlock(); <span class=\"comment\">// 锁定队列消费锁</span></div><div class=\"line\"> <span class=\"number\">89</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// ....省略代码：解析消费结果状态</span></div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:                         <span class=\"comment\">// ....省略代码：Hook：after</span></div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:                         ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.getConsumerStatsManager()</div><div class=\"line\"> <span class=\"number\">96</span>:                             .incConsumeRT(ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</div><div class=\"line\"> <span class=\"number\">97</span>: </div><div class=\"line\"> <span class=\"number\">98</span>:                         <span class=\"comment\">// 处理消费结果</span></div><div class=\"line\"> <span class=\"number\">99</span>:                         continueConsume = ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.processConsumeResult(msgs, status, context, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">100</span>:                     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                         continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">102</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">103</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">104</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">105</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">106</span>:                     log.warn(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"><span class=\"number\">107</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">108</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                 ConsumeMessageOrderlyService.<span class=\"keyword\">this</span>.tryLockLaterAndReconsume(<span class=\"keyword\">this</span>.messageQueue, <span class=\"keyword\">this</span>.processQueue, <span class=\"number\">100</span>);</div><div class=\"line\"><span class=\"number\">111</span>:             &#125;</div><div class=\"line\"><span class=\"number\">112</span>:         &#125;</div><div class=\"line\"><span class=\"number\">113</span>:     &#125;</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 20 行 ：获得 <code>Consumer</code> 消息队列锁。</li>\n<li>第 58 行 ：从消息处理队列顺序获得消息。<strong>和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。</strong></li>\n<li>第 71 行 ：获得 <code>Consumer</code> 消息处理队列消费锁。相比【<code>Consumer</code>消息队列锁】，其粒度较小。这就是上文提到的❓<strong>为什么有<code>Consumer</code>消息队列锁还需要有 Consumer 消息队列消费锁呢</strong>的原因。</li>\n<li>第 79 行 ：<strong>执行消费</strong>。</li>\n<li>第 99 行 ：处理消费结果。</li>\n</ul>\n<h3 id=\"3-1-2-处理消费结果\"><a href=\"#3-1-2-处理消费结果\" class=\"headerlink\" title=\"3.1.2 处理消费结果\"></a>3.1.2 处理消费结果</h3><p>顺序消费消息结果 (<code>ConsumeOrderlyStatus</code>) 有四种情况：</p>\n<ul>\n<li><code>SUCCESS</code> ：消费成功<strong>但不提交</strong>。</li>\n<li><code>ROLLBACK</code> ：消费失败，消费回滚。</li>\n<li><code>COMMIT</code> ：消费成功提交并且提交。</li>\n<li><code>SUSPEND_CURRENT_QUEUE_A_MOMENT</code> ：消费失败，挂起消费队列一会会，稍后继续消费。</li>\n</ul>\n<p>考虑到 <code>ROLLBACK</code> 、<code>COMMIT</code> 暂时只使用在 <code>MySQL binlog</code> 场景，官方将这两状态标记为 <code>@Deprecated</code>。当然，相应的实现逻辑依然保留。</p>\n<p>在<strong>并发消费</strong>场景时，如果消费失败，<code>Consumer</code> 会将消费失败消息发回到 <code>Broker</code> 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。</p>\n<p>但是在<strong>完全严格顺序消费</strong>消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 </p>\n<p>不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，<code>Consumer</code> 会将消费失败超过上限的消息发回到 <code>Broker</code> 死信队列。</p>\n<p>让我们来看看代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 处理消费结果，并返回是否继续消费</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> status 消费结果状态</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> context 消费Context</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> consumeRequest 消费请求</div><div class=\"line\">  9:  * <span class=\"doctag\">@return</span> 是否继续消费</div><div class=\"line\"> 10:  */</div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">processConsumeResult</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> ConsumeOrderlyStatus status, //</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">final</span> ConsumeOrderlyContext context, //</div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</div><div class=\"line\"> <span class=\"number\">16</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">boolean</span> continueConsume = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">long</span> commitOffset = -<span class=\"number\">1L</span>;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (context.isAutoCommit()) &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">case</span> COMMIT:</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">case</span> ROLLBACK:</div><div class=\"line\"> <span class=\"number\">23</span>:                 log.warn(<span class=\"string\">\"the message queue consume result is illegal, we think you want to ack these message &#123;&#125;\"</span>, consumeRequest.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">case</span> SUCCESS:</div><div class=\"line\"> <span class=\"number\">25</span>:                 <span class=\"comment\">// 提交消息已消费成功到消息处理队列</span></div><div class=\"line\"> <span class=\"number\">26</span>:                 commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">28</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">33</span>:                 <span class=\"keyword\">if</span> (checkReconsumeTimes(msgs)) &#123; <span class=\"comment\">// 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms</span></div><div class=\"line\"> <span class=\"number\">34</span>:                     <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</div><div class=\"line\"> <span class=\"number\">36</span>:                     <span class=\"comment\">// 提交延迟消费请求</span></div><div class=\"line\"> <span class=\"number\">37</span>:                     <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">38</span>:                         consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">39</span>:                         consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">40</span>:                         context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">41</span>:                     continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                     commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">44</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">45</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">46</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">47</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:         <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:             <span class=\"keyword\">case</span> SUCCESS:</div><div class=\"line\"> <span class=\"number\">52</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">53</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">case</span> COMMIT:</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"comment\">// 提交消息已消费成功到消息处理队列</span></div><div class=\"line\"> <span class=\"number\">56</span>:                 commitOffset = consumeRequest.getProcessQueue().commit();</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"keyword\">case</span> ROLLBACK:</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">60</span>:                 consumeRequest.getProcessQueue().rollback();</div><div class=\"line\"> <span class=\"number\">61</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">62</span>:                     consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">63</span>:                     consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">64</span>:                     context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">65</span>:                 continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">66</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT: <span class=\"comment\">// 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms</span></div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</div><div class=\"line\"> <span class=\"number\">69</span>:                 <span class=\"keyword\">if</span> (checkReconsumeTimes(msgs)) &#123;</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"comment\">// 设置消息重新消费</span></div><div class=\"line\"> <span class=\"number\">71</span>:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</div><div class=\"line\"> <span class=\"number\">72</span>:                     <span class=\"comment\">// 提交延迟消费请求</span></div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">this</span>.submitConsumeRequestLater(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">74</span>:                         consumeRequest.getProcessQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">75</span>:                         consumeRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">76</span>:                         context.getSuspendCurrentQueueTimeMillis());</div><div class=\"line\"> <span class=\"number\">77</span>:                     continueConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">80</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">81</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">82</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">83</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">84</span>: </div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"comment\">// 消息处理队列未dropped，提交有效消费进度</span></div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"keyword\">if</span> (commitOffset &gt;= <span class=\"number\">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">88</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:     <span class=\"keyword\">return</span> continueConsume;</div><div class=\"line\"> <span class=\"number\">91</span>: &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxReconsumeTimes</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"comment\">// default reconsume times: Integer.MAX_VALUE</span></div><div class=\"line\"> <span class=\"number\">95</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes() == -<span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"keyword\">return</span> Integer.MAX_VALUE;</div><div class=\"line\"> <span class=\"number\">97</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultMQPushConsumer.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">99</span>:     &#125;</div><div class=\"line\"><span class=\"number\">100</span>: &#125;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"comment\">/**</span></div><div class=\"line\">103:  * 计算是否要暂停消费</div><div class=\"line\">104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功</div><div class=\"line\">105:  *</div><div class=\"line\">106:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">107:  * <span class=\"doctag\">@return</span> 是否要暂停</div><div class=\"line\">108:  */</div><div class=\"line\"><span class=\"number\">109</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkReconsumeTimes</span><span class=\"params\">(List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"keyword\">boolean</span> suspend = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">111</span>:     <span class=\"keyword\">if</span> (msgs != <span class=\"keyword\">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:             <span class=\"keyword\">if</span> (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">115</span>:                 <span class=\"keyword\">if</span> (!sendMessageBack(msg)) &#123; <span class=\"comment\">// 发回失败，中断</span></div><div class=\"line\"><span class=\"number\">116</span>:                     suspend = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">118</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">119</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">120</span>:                 suspend = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">121</span>:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">122</span>:             &#125;</div><div class=\"line\"><span class=\"number\">123</span>:         &#125;</div><div class=\"line\"><span class=\"number\">124</span>:     &#125;</div><div class=\"line\"><span class=\"number\">125</span>:     <span class=\"keyword\">return</span> suspend;</div><div class=\"line\"><span class=\"number\">126</span>: &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>: <span class=\"comment\">/**</span></div><div class=\"line\">129:  * 发回消息。</div><div class=\"line\">130:  * 消息发回broker后，对应的消息队列是死信队列。</div><div class=\"line\">131:  *</div><div class=\"line\">132:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">133:  * <span class=\"doctag\">@return</span> 是否发送成功</div><div class=\"line\">134:  */</div><div class=\"line\"><span class=\"number\">135</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageBack</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExt msg)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">136</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">137</span>:         <span class=\"comment\">// max reconsume times exceeded then send to dead letter queue.</span></div><div class=\"line\"><span class=\"number\">138</span>:         Message newMsg = <span class=\"keyword\">new</span> Message(MixAll.getRetryTopic(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</div><div class=\"line\"><span class=\"number\">139</span>:         String originMsgId = MessageAccessor.getOriginMessageId(msg);</div><div class=\"line\"><span class=\"number\">140</span>:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">141</span>:         newMsg.setFlag(msg.getFlag());</div><div class=\"line\"><span class=\"number\">142</span>:         MessageAccessor.setProperties(newMsg, msg.getProperties());</div><div class=\"line\"><span class=\"number\">143</span>:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">144</span>:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">145</span>:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">146</span>:         newMsg.setDelayTimeLevel(<span class=\"number\">3</span> + msg.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">147</span>: </div><div class=\"line\"><span class=\"number\">148</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);</div><div class=\"line\"><span class=\"number\">149</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">150</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">151</span>:         log.error(<span class=\"string\">\"sendMessageBack exception, group: \"</span> + <span class=\"keyword\">this</span>.consumerGroup + <span class=\"string\">\" msg: \"</span> + msg.toString(), e);</div><div class=\"line\"><span class=\"number\">152</span>:     &#125;</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">155</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>⬆️⬆️⬆️</li>\n<li>第 21 至 29 行 ：消费成功。在自动提交进度( <code>AutoCommit</code> )的情况下，<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SUCCESS</code> 逻辑<strong>已经统一</strong>。</li>\n<li>第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 <code>Broker</code> 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。</li>\n<li>第 85 至 88 行 ：提交消费进度。</li>\n</ul>\n<h3 id=\"3-13-消息处理队列核心方法\"><a href=\"#3-13-消息处理队列核心方法\" class=\"headerlink\" title=\"3.13 消息处理队列核心方法\"></a>3.13 消息处理队列核心方法</h3><p>😈涉及到的四个核心方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ProcessQueue.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 消息映射</div><div class=\"line\">  4:  * key：消息队列位置</div><div class=\"line\">  5:  */</div><div class=\"line\">  <span class=\"number\">6</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();    <span class=\"comment\">/**</span></div><div class=\"line\">  7:  * 消息映射临时存储（消费中的消息）</div><div class=\"line\">  8:  */</div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 12:  * 回滚消费中的消息</div><div class=\"line\"> 13:  * 逻辑类似于&#123;<span class=\"doctag\">@link</span> #makeMessageToCosumeAgain(List)&#125;</div><div class=\"line\"> 14:  */</div><div class=\"line\"> <span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rollback</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.msgTreeMap.putAll(<span class=\"keyword\">this</span>.msgTreeMapTemp);</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.msgTreeMapTemp.clear();</div><div class=\"line\"> <span class=\"number\">21</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:         log.error(<span class=\"string\">\"rollback exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">27</span>: &#125;</div><div class=\"line\"> <span class=\"number\">28</span>: </div><div class=\"line\"> <span class=\"number\">29</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 30:  * 提交消费中的消息已消费成功，返回消费进度</div><div class=\"line\"> 31:  *</div><div class=\"line\"> 32:  * <span class=\"doctag\">@return</span> 消费进度</div><div class=\"line\"> 33:  */</div><div class=\"line\"> <span class=\"number\">34</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">commit</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">37</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:             <span class=\"comment\">// 消费进度</span></div><div class=\"line\"> <span class=\"number\">39</span>:             Long offset = <span class=\"keyword\">this</span>.msgTreeMapTemp.lastKey();</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:             <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">42</span>:             msgCount.addAndGet(<span class=\"keyword\">this</span>.msgTreeMapTemp.size() * (-<span class=\"number\">1</span>));</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:             <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">45</span>:             <span class=\"keyword\">this</span>.msgTreeMapTemp.clear();</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:             <span class=\"comment\">// 返回消费进度</span></div><div class=\"line\"> <span class=\"number\">48</span>:             <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">49</span>:                 <span class=\"keyword\">return</span> offset + <span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">50</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">51</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">53</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:         log.error(<span class=\"string\">\"commit exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">56</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">59</span>: &#125;</div><div class=\"line\"> <span class=\"number\">60</span>: </div><div class=\"line\"> <span class=\"number\">61</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 62:  * 指定消息重新消费</div><div class=\"line\"> 63:  * 逻辑类似于&#123;<span class=\"doctag\">@link</span> #rollback()&#125;</div><div class=\"line\"> 64:  *</div><div class=\"line\"> 65:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\"> 66:  */</div><div class=\"line\"> <span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeMessageToCosumeAgain</span><span class=\"params\">(List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">70</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">this</span>.msgTreeMapTemp.remove(msg.getQueueOffset());</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.msgTreeMap.put(msg.getQueueOffset(), msg);</div><div class=\"line\"> <span class=\"number\">74</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">75</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"> <span class=\"number\">77</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:         log.error(<span class=\"string\">\"makeMessageToCosumeAgain exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">80</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: &#125;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 84:  * 获得持有消息前N条</div><div class=\"line\"> 85:  *</div><div class=\"line\"> 86:  * <span class=\"doctag\">@param</span> batchSize 条数</div><div class=\"line\"> 87:  * <span class=\"doctag\">@return</span> 消息</div><div class=\"line\"> 88:  */</div><div class=\"line\"> <span class=\"number\">89</span>: <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageExt&gt; <span class=\"title\">takeMessags</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> batchSize)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">90</span>:     List&lt;MessageExt&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(batchSize);</div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">92</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"keyword\">this</span>.lastConsumeTimestamp = now;</div><div class=\"line\"> <span class=\"number\">95</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:             <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">97</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; batchSize; i++) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                     Map.Entry&lt;Long, MessageExt&gt; entry = <span class=\"keyword\">this</span>.msgTreeMap.pollFirstEntry();</div><div class=\"line\"> <span class=\"number\">99</span>:                     <span class=\"keyword\">if</span> (entry != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">100</span>:                         result.add(entry.getValue());</div><div class=\"line\"><span class=\"number\">101</span>:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());</div><div class=\"line\"><span class=\"number\">102</span>:                     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">103</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">104</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">105</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">106</span>:             &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">if</span> (result.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:                 consuming = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">110</span>:             &#125;</div><div class=\"line\"><span class=\"number\">111</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">112</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">113</span>:         &#125;</div><div class=\"line\"><span class=\"number\">114</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">115</span>:         log.error(<span class=\"string\">\"take Messages exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">116</span>:     &#125;</div><div class=\"line\"><span class=\"number\">117</span>: </div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">119</span>: &#125;</div></pre></td></tr></table></figure>\n"},{"title":"RocketMQ 源码分析 —— 高可用","date":"2017-05-13T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/high-availability](http://www.yunai.me/RocketMQ/high-availability)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Namesrv 高可用](#)\n\t- [2.1 Broker 注册到 Namesrv](#)\n\t- [2.2 Producer、Consumer 访问 Namesrv](#)\n- [3. Broker 高可用](#)\n\t- [3.2 Broker 主从](#)\n\t\t- [3.1.1 配置](#)\n\t\t- [3.1.2 组件](#)\n\t\t- [3.1.3 通信协议](#)\n\t\t- [3.1.4 Slave](#)\n\t\t- [3.1.5 Master](#)\n\t\t- [3.1.6 Master_SYNC](#)\n\t- [3.2 Producer 发送消息](#)\n\t- [3.3 Consumer 消费消息](#)\n- [4. 总结](#)\n\n# 1. 概述\n\n本文主要解析 `Namesrv`、`Broker` 如何实现高可用，`Producer`、`Consumer` 怎么与它们通信保证高可用。\n\n# 2. Namesrv 高可用\n\n**启动多个 `Namesrv` 实现高可用。**  \n相较于 `Zookeeper`、`Consul`、`Etcd` 等，`Namesrv` 是一个**超轻量级**的注册中心，提供**命名服务**。\n\n## 2.1 Broker 注册到 Namesrv\n\n* 📌 **多个 `Namesrv` 之间，没有任何关系（不存在类似 `Zookeeper` 的 `Leader`/`Follower` 等角色），不进行通信与数据同步。通过 `Broker` 循环注册多个 `Namesrv`。**\n\n```Java\n  1: // ⬇️⬇️⬇️【BrokerOuterAPI.java】\n  2: public RegisterBrokerResult registerBrokerAll(\n  3:     final String clusterName,\n  4:     final String brokerAddr,\n  5:     final String brokerName,\n  6:     final long brokerId,\n  7:     final String haServerAddr,\n  8:     final TopicConfigSerializeWrapper topicConfigWrapper,\n  9:     final List<String> filterServerList,\n 10:     final boolean oneway,\n 11:     final int timeoutMills) {\n 12:     RegisterBrokerResult registerBrokerResult = null;\n 13: \n 14:     List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();\n 15:     if (nameServerAddressList != null) {\n 16:         for (String namesrvAddr : nameServerAddressList) { // 循环多个 Namesrv\n 17:             try {\n 18:                 RegisterBrokerResult result = this.registerBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId,\n 19:                     haServerAddr, topicConfigWrapper, filterServerList, oneway, timeoutMills);\n 20:                 if (result != null) {\n 21:                     registerBrokerResult = result;\n 22:                 }\n 23: \n 24:                 log.info(\"register broker to name server {} OK\", namesrvAddr);\n 25:             } catch (Exception e) {\n 26:                 log.warn(\"registerBroker Exception, {}\", namesrvAddr, e);\n 27:             }\n 28:         }\n 29:     }\n 30: \n 31:     return registerBrokerResult;\n 32: }\n```\n\n## 2.2 Producer、Consumer 访问 Namesrv\n\n* 📌 **`Producer`、`Consumer` 从 `Namesrv`列表选择一个可连接的进行通信。**\n\n```Java\n  1: // ⬇️⬇️⬇️【NettyRemotingClient.java】\n  2: private Channel getAndCreateNameserverChannel() throws InterruptedException {\n  3:     // 返回已选择、可连接Namesrv\n  4:     String addr = this.namesrvAddrChoosed.get();\n  5:     if (addr != null) {\n  6:         ChannelWrapper cw = this.channelTables.get(addr);\n  7:         if (cw != null && cw.isOK()) {\n  8:             return cw.getChannel();\n  9:         }\n 10:     }\n 11:     //\n 12:     final List<String> addrList = this.namesrvAddrList.get();\n 13:     if (this.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n 14:         try {\n 15:             // 返回已选择、可连接的Namesrv\n 16:             addr = this.namesrvAddrChoosed.get();\n 17:             if (addr != null) {\n 18:                 ChannelWrapper cw = this.channelTables.get(addr);\n 19:                 if (cw != null && cw.isOK()) {\n 20:                     return cw.getChannel();\n 21:                 }\n 22:             }\n 23:             // 从【Namesrv列表】中选择一个连接的返回\n 24:             if (addrList != null && !addrList.isEmpty()) {\n 25:                 for (int i = 0; i < addrList.size(); i++) {\n 26:                     int index = this.namesrvIndex.incrementAndGet();\n 27:                     index = Math.abs(index);\n 28:                     index = index % addrList.size();\n 29:                     String newAddr = addrList.get(index);\n 30: \n 31:                     this.namesrvAddrChoosed.set(newAddr);\n 32:                     Channel channelNew = this.createChannel(newAddr);\n 33:                     if (channelNew != null)\n 34:                         return channelNew;\n 35:                 }\n 36:             }\n 37:         } catch (Exception e) {\n 38:             log.error(\"getAndCreateNameserverChannel: create name server channel exception\", e);\n 39:         } finally {\n 40:             this.lockNamesrvChannel.unlock();\n 41:         }\n 42:     } else {\n 43:         log.warn(\"getAndCreateNameserverChannel: try to lock name server, but timeout, {}ms\", LOCK_TIMEOUT_MILLIS);\n 44:     }\n 45: \n 46:     return null;\n 47: }\n```\n\n# 3. Broker 高可用\n\n**启动多个 `Broker分组` 形成 `集群` 实现高可用。**  \n**`Broker分组` = `Master节点`x1 + `Slave节点`xN。**  \n类似 `MySQL`，`Master节点` 提供**读写**服务，`Slave节点` 只提供**读**服务。  \n\n## 3.2 Broker 主从\n\n* **每个分组，`Master`节点 不断发送新的 `CommitLog` 给 `Slave`节点。 `Slave`节点 不断上报本地的 `CommitLog` 已经同步到的位置给 `Master`节点。**\n* **`Broker分组` 与 `Broker分组` 之间没有任何关系，不进行通信与数据同步。**\n* **消费进度 目前不支持 `Master`/`Slave` 同步。**\n\n集群内，`Master`节点 有**两种**类型：`Master_SYNC`、`Master_ASYNC`：前者在 `Producer` 发送消息时，等待 `Slave`节点 存储完毕后再返回发送结果，而后者不需要等待。\n\n\n### 3.1.1 配置\n\n目前官方提供三套配置：\n\n* **2m-2s-async**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| --- | --- | --- | --- |\n| DefaultCluster | broker-a | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-a | SLAVE | 1 |\n| DefaultCluster | broker-b | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-b | SLAVE | 1 |\n\n* **2m-2s-sync**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| ---| --- | --- | --- |\n| DefaultCluster | broker-a | SYNC_MASTER | 0 |\n| DefaultCluster | broker-a | SLAVE | 1 |\n| DefaultCluster | broker-b | SYNC_MASTER | 0 |\n| DefaultCluster | broker-b | SLAVE | 1 |\n\n* **2m-noslave**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| ---| --- | --- | --- |\n| DefaultCluster | broker-a | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-b | ASYNC_MASTER | 0 |\n\n### 3.1.2 组件\n\n再看具体实现代码之前，我们来看看 `Master`/`Slave`节点 包含的组件：  \n![HA组件图.png](http://www.yunai.me/images/RocketMQ/2017_05_14/04.png)\n\n* `Master`节点\n    * `AcceptSocketService` ：接收 `Slave`节点 连接。\n    * `HAConnection`\n        * `ReadSocketService` ：**读**来自 `Slave`节点 的数据。 \n        * `WriteSocketService` ：**写**到往 `Slave`节点 的数据。\n* `Slave`节点\n    * `HAClient` ：对 `Master`节点 连接、读写数据。\n\n### 3.1.3 通信协议\n\n`Master`节点 与 `Slave`节点 **通信协议**很简单，只有如下两条。\n\n| 对象 | 用途 | 第几位 | 字段 | 数据类型 | 字节数 | 说明\n| :-- | :-- | :-- | :-- | :-- | :-- | :-- |\n| Slave=>Master | 上报CommitLog**已经**同步到的**物理**位置 |  |  |  |  |  |\n|  | | 0 | maxPhyOffset  |  Long | 8 | CommitLog最大物理位置 |\n| Master=>Slave | 传输新的 `CommitLog` 数据 |  |  |  |  |  |\n| | | 0 | fromPhyOffset | Long | 8 | CommitLog开始物理位置 | \n| | | 1 | size | Int | 4 | 传输CommitLog数据长度 | \n| | | 2 | body | Bytes | size | 传输CommitLog数据 | \n\n### 3.1.4 Slave\n\n![HAClient顺序图](http://www.yunai.me/images/RocketMQ/2017_05_14/02.png)\n\n-------\n\n* **`Slave` 主循环，实现了**不断不断不断**从 `Master` 传输 `CommitLog` 数据，上传 `Master` 自己本地的 `CommitLog` 已经同步物理位置。**\n\n```Java\n  1: // ⬇️⬇️⬇️【HAClient.java】\n  2: public void run() {\n  3:     log.info(this.getServiceName() + \" service started\");\n  4: \n  5:     while (!this.isStopped()) {\n  6:         try {\n  7:             if (this.connectMaster()) {\n  8:                 // 若到满足上报间隔，上报到Master进度\n  9:                 if (this.isTimeToReportOffset()) {\n 10:                     boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);\n 11:                     if (!result) {\n 12:                         this.closeMaster();\n 13:                     }\n 14:                 }\n 15: \n 16:                 this.selector.select(1000);\n 17: \n 18:                 // 处理读取事件\n 19:                 boolean ok = this.processReadEvent();\n 20:                 if (!ok) {\n 21:                     this.closeMaster();\n 22:                 }\n 23: \n 24:                 // 若进度有变化，上报到Master进度\n 25:                 if (!reportSlaveMaxOffsetPlus()) {\n 26:                     continue;\n 27:                 }\n 28: \n 29:                 // Master过久未返回数据，关闭连接\n 30:                 long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n 31:                 if (interval > HAService.this.getDefaultMessageStore().getMessageStoreConfig()\n 32:                     .getHaHousekeepingInterval()) {\n 33:                     log.warn(\"HAClient, housekeeping, found this connection[\" + this.masterAddress\n 34:                         + \"] expired, \" + interval);\n 35:                     this.closeMaster();\n 36:                     log.warn(\"HAClient, master not response some time, so close connection\");\n 37:                 }\n 38:             } else {\n 39:                 this.waitForRunning(1000 * 5);\n 40:             }\n 41:         } catch (Exception e) {\n 42:             log.warn(this.getServiceName() + \" service has exception. \", e);\n 43:             this.waitForRunning(1000 * 5);\n 44:         }\n 45:     }\n 46: \n 47:     log.info(this.getServiceName() + \" service end\");\n 48: }\n```\n\n* 第 8 至 14 行 ：**固定间隔（默认5s）**向 `Master` 上报 `Slave` 本地 `CommitLog` 已经同步到的物理位置。该操作还有**心跳**的作用。\n* 第 16 至 22 行 ：处理 `Master` 传输 `Slave` 的 `CommitLog` 数据。\n\n-------\n\n* **我们来看看 `#dispatchReadRequest(...)` 与 `#reportSlaveMaxOffset(...)` 是怎么实现的。**\n\n```Java\n  1: // 【HAClient.java】\n  2: /**\n  3:  * 读取Master传输的CommitLog数据，并返回是异常\n  4:  * 如果读取到数据，写入CommitLog\n  5:  * 异常原因：\n  6:  *   1. Master传输来的数据offset 不等于 Slave的CommitLog数据最大offset\n  7:  *   2. 上报到Master进度失败\n  8:  *\n  9:  * @return 是否异常\n 10:  */\n 11: private boolean dispatchReadRequest() {\n 12:     final int msgHeaderSize = 8 + 4; // phyoffset + size\n 13:     int readSocketPos = this.byteBufferRead.position();\n 14: \n 15:     while (true) {\n 16:         // 读取到请求\n 17:         int diff = this.byteBufferRead.position() - this.dispatchPostion;\n 18:         if (diff >= msgHeaderSize) {\n 19:             // 读取masterPhyOffset、bodySize。使用dispatchPostion的原因是：处理数据“粘包”导致数据读取不完整。\n 20:             long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPostion);\n 21:             int bodySize = this.byteBufferRead.getInt(this.dispatchPostion + 8);\n 22:             // 校验 Master传输来的数据offset 是否和 Slave的CommitLog数据最大offset 是否相同。\n 23:             long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();\n 24:             if (slavePhyOffset != 0) {\n 25:                 if (slavePhyOffset != masterPhyOffset) {\n 26:                     log.error(\"master pushed offset not equal the max phy offset in slave, SLAVE: \"\n 27:                         + slavePhyOffset + \" MASTER: \" + masterPhyOffset);\n 28:                     return false;\n 29:                 }\n 30:             }\n 31:             // 读取到消息\n 32:             if (diff >= (msgHeaderSize + bodySize)) {\n 33:                 // 写入CommitLog\n 34:                 byte[] bodyData = new byte[bodySize];\n 35:                 this.byteBufferRead.position(this.dispatchPostion + msgHeaderSize);\n 36:                 this.byteBufferRead.get(bodyData);\n 37:                 HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData);\n 38:                 // 设置处理到的位置\n 39:                 this.byteBufferRead.position(readSocketPos);\n 40:                 this.dispatchPostion += msgHeaderSize + bodySize;\n 41:                 // 上报到Master进度\n 42:                 if (!reportSlaveMaxOffsetPlus()) {\n 43:                     return false;\n 44:                 }\n 45:                 // 继续循环\n 46:                 continue;\n 47:             }\n 48:         }\n 49: \n 50:         // 空间写满，重新分配空间\n 51:         if (!this.byteBufferRead.hasRemaining()) {\n 52:             this.reallocateByteBuffer();\n 53:         }\n 54: \n 55:         break;\n 56:     }\n 57: \n 58:     return true;\n 59: }\n 60: \n 61: /**\n 62:  * 上报进度\n 63:  *\n 64:  * @param maxOffset 进度\n 65:  * @return 是否上报成功\n 66:  */\n 67: private boolean reportSlaveMaxOffset(final long maxOffset) {\n 68:     this.reportOffset.position(0);\n 69:     this.reportOffset.limit(8);\n 70:     this.reportOffset.putLong(maxOffset);\n 71:     this.reportOffset.position(0);\n 72:     this.reportOffset.limit(8);\n 73: \n 74:     for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n 75:         try {\n 76:             this.socketChannel.write(this.reportOffset);\n 77:         } catch (IOException e) {\n 78:             log.error(this.getServiceName()\n 79:                 + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n 80:             return false;\n 81:         }\n 82:     }\n 83: \n 84:     return !this.reportOffset.hasRemaining();\n 85: }\n```\n\n### 3.1.5 Master\n\n* **`ReadSocketService` 逻辑同 `HAClient#processReadEvent(...)` 基本相同，我们直接看代码。**\n\n```Java\n  1: // ⬇️⬇️⬇️【ReadSocketService.java】\n  2: private boolean processReadEvent() {\n  3:     int readSizeZeroTimes = 0;\n  4: \n  5:     // 清空byteBufferRead\n  6:     if (!this.byteBufferRead.hasRemaining()) {\n  7:         this.byteBufferRead.flip();\n  8:         this.processPostion = 0;\n  9:     }\n 10: \n 11:     while (this.byteBufferRead.hasRemaining()) {\n 12:         try {\n 13:             int readSize = this.socketChannel.read(this.byteBufferRead);\n 14:             if (readSize > 0) {\n 15:                 readSizeZeroTimes = 0;\n 16: \n 17:                 // 设置最后读取时间\n 18:                 this.lastReadTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n 19: \n 20:                 if ((this.byteBufferRead.position() - this.processPostion) >= 8) {\n 21:                     // 读取Slave 请求来的CommitLog的最大位置\n 22:                     int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);\n 23:                     long readOffset = this.byteBufferRead.getLong(pos - 8);\n 24:                     this.processPostion = pos;\n 25: \n 26:                     // 设置Slave CommitLog的最大位置\n 27:                     HAConnection.this.slaveAckOffset = readOffset;\n 28: \n 29:                     // 设置Slave 第一次请求的位置\n 30:                     if (HAConnection.this.slaveRequestOffset < 0) {\n 31:                         HAConnection.this.slaveRequestOffset = readOffset;\n 32:                         log.info(\"slave[\" + HAConnection.this.clientAddr + \"] request offset \" + readOffset);\n 33:                     }\n 34: \n 35:                     // 通知目前Slave进度。主要用于Master节点为同步类型的。\n 36:                     HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);\n 37:                 }\n 38:             } else if (readSize == 0) {\n 39:                 if (++readSizeZeroTimes >= 3) {\n 40:                     break;\n 41:                 }\n 42:             } else {\n 43:                 log.error(\"read socket[\" + HAConnection.this.clientAddr + \"] < 0\");\n 44:                 return false;\n 45:             }\n 46:         } catch (IOException e) {\n 47:             log.error(\"processReadEvent exception\", e);\n 48:             return false;\n 49:         }\n 50:     }\n 51: \n 52:     return true;\n 53: }\n```\n\n-------\n\n* **`WriteSocketService` 计算 `Slave`开始同步的位置后，不断向 `Slave` 传输新的 `CommitLog`数据。**\n\n![HA.WriteSocketService流程图](http://www.yunai.me/images/RocketMQ/2017_05_14/01.png)\n\n```Java\n  1: // ⬇️⬇️⬇️【WriteSocketService.java】\n  2: @Override\n  3: public void run() {\n  4:     HAConnection.log.info(this.getServiceName() + \" service started\");\n  5: \n  6:     while (!this.isStopped()) {\n  7:         try {\n  8:             this.selector.select(1000);\n  9: \n 10:             // 未获得Slave读取进度请求，sleep等待。\n 11:             if (-1 == HAConnection.this.slaveRequestOffset) {\n 12:                 Thread.sleep(10);\n 13:                 continue;\n 14:             }\n 15: \n 16:             // 计算初始化nextTransferFromWhere\n 17:             if (-1 == this.nextTransferFromWhere) {\n 18:                 if (0 == HAConnection.this.slaveRequestOffset) {\n 19:                     long masterOffset = HAConnection.this.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();\n 20:                     masterOffset = masterOffset - (masterOffset % HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getMapedFileSizeCommitLog());\n 21:                     if (masterOffset < 0) {\n 22:                         masterOffset = 0;\n 23:                     }\n 24: \n 25:                     this.nextTransferFromWhere = masterOffset;\n 26:                 } else {\n 27:                     this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset;\n 28:                 }\n 29: \n 30:                 log.info(\"master transfer data from \" + this.nextTransferFromWhere + \" to slave[\" + HAConnection.this.clientAddr\n 31:                     + \"], and slave request \" + HAConnection.this.slaveRequestOffset);\n 32:             }\n 33: \n 34:             if (this.lastWriteOver) {\n 35:                 long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n 36:                 if (interval > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) { // 心跳\n 37: \n 38:                     // Build Header\n 39:                     this.byteBufferHeader.position(0);\n 40:                     this.byteBufferHeader.limit(headerSize);\n 41:                     this.byteBufferHeader.putLong(this.nextTransferFromWhere);\n 42:                     this.byteBufferHeader.putInt(0);\n 43:                     this.byteBufferHeader.flip();\n 44: \n 45:                     this.lastWriteOver = this.transferData();\n 46:                     if (!this.lastWriteOver)\n 47:                         continue;\n 48:                 }\n 49:             } else { // 未传输完成，继续传输\n 50:                 this.lastWriteOver = this.transferData();\n 51:                 if (!this.lastWriteOver)\n 52:                     continue;\n 53:             }\n 54: \n 55:             // 选择新的CommitLog数据进行传输\n 56:             SelectMappedBufferResult selectResult =\n 57:                 HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);\n 58:             if (selectResult != null) {\n 59:                 int size = selectResult.getSize();\n 60:                 if (size > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) {\n 61:                     size = HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();\n 62:                 }\n 63: \n 64:                 long thisOffset = this.nextTransferFromWhere;\n 65:                 this.nextTransferFromWhere += size;\n 66: \n 67:                 selectResult.getByteBuffer().limit(size);\n 68:                 this.selectMappedBufferResult = selectResult;\n 69: \n 70:                 // Build Header\n 71:                 this.byteBufferHeader.position(0);\n 72:                 this.byteBufferHeader.limit(headerSize);\n 73:                 this.byteBufferHeader.putLong(thisOffset);\n 74:                 this.byteBufferHeader.putInt(size);\n 75:                 this.byteBufferHeader.flip();\n 76: \n 77:                 this.lastWriteOver = this.transferData();\n 78:             } else { // 没新的消息，挂起等待\n 79:                 HAConnection.this.haService.getWaitNotifyObject().allWaitForRunning(100);\n 80:             }\n 81:         } catch (Exception e) {\n 82: \n 83:             HAConnection.log.error(this.getServiceName() + \" service has exception.\", e);\n 84:             break;\n 85:         }\n 86:     }\n 87: \n 88:     // 断开连接 & 暂停写线程 & 暂停读线程 & 释放CommitLog\n 89:     if (this.selectMappedBufferResult != null) {\n 90:         this.selectMappedBufferResult.release();\n 91:     }\n 92: \n 93:     this.makeStop();\n 94: \n 95:     readSocketService.makeStop();\n 96: \n 97:     haService.removeConnection(HAConnection.this);\n 98: \n 99:     SelectionKey sk = this.socketChannel.keyFor(this.selector);\n100:     if (sk != null) {\n101:         sk.cancel();\n102:     }\n103: \n104:     try {\n105:         this.selector.close();\n106:         this.socketChannel.close();\n107:     } catch (IOException e) {\n108:         HAConnection.log.error(\"\", e);\n109:     }\n110: \n111:     HAConnection.log.info(this.getServiceName() + \" service end\");\n112: }\n113: \n114: /**\n115:  * 传输数据\n116:  */\n117: private boolean transferData() throws Exception {\n118:     int writeSizeZeroTimes = 0;\n119:     // Write Header\n120:     while (this.byteBufferHeader.hasRemaining()) {\n121:         int writeSize = this.socketChannel.write(this.byteBufferHeader);\n122:         if (writeSize > 0) {\n123:             writeSizeZeroTimes = 0;\n124:             this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n125:         } else if (writeSize == 0) {\n126:             if (++writeSizeZeroTimes >= 3) {\n127:                 break;\n128:             }\n129:         } else {\n130:             throw new Exception(\"ha master write header error < 0\");\n131:         }\n132:     }\n133: \n134:     if (null == this.selectMappedBufferResult) {\n135:         return !this.byteBufferHeader.hasRemaining();\n136:     }\n137: \n138:     writeSizeZeroTimes = 0;\n139: \n140:     // Write Body\n141:     if (!this.byteBufferHeader.hasRemaining()) {\n142:         while (this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {\n143:             int writeSize = this.socketChannel.write(this.selectMappedBufferResult.getByteBuffer());\n144:             if (writeSize > 0) {\n145:                 writeSizeZeroTimes = 0;\n146:                 this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n147:             } else if (writeSize == 0) {\n148:                 if (++writeSizeZeroTimes >= 3) {\n149:                     break;\n150:                 }\n151:             } else {\n152:                 throw new Exception(\"ha master write body error < 0\");\n153:             }\n154:         }\n155:     }\n156: \n157:     boolean result = !this.byteBufferHeader.hasRemaining() && !this.selectMappedBufferResult.getByteBuffer().hasRemaining();\n158: \n159:     if (!this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {\n160:         this.selectMappedBufferResult.release();\n161:         this.selectMappedBufferResult = null;\n162:     }\n163: \n164:     return result;\n165: }\n```\n\n### 3.1.6 Master_SYNC\n\n* **`Producer` 发送消息时，`Master_SYNC`节点 会等待 `Slave`节点 存储完毕后再返回发送结果。**\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  3:     // ....省略处理发送代码 \n  4:     // Synchronous write double 如果是同步Master，同步到从节点\n  5:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {\n  6:         HAService service = this.defaultMessageStore.getHaService();\n  7:         if (msg.isWaitStoreMsgOK()) {\n  8:             // Determine whether to wait\n  9:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {\n 10:                 if (null == request) {\n 11:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n 12:                 }\n 13:                 service.putRequest(request);\n 14: \n 15:                 // 唤醒WriteSocketService\n 16:                 service.getWaitNotifyObject().wakeupAll();\n 17: \n 18:                 boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n 19:                 if (!flushOK) {\n 20:                     log.error(\"do sync transfer other node, wait return, but failed, topic: \" + msg.getTopic() + \" tags: \"\n 21:                         + msg.getTags() + \" client address: \" + msg.getBornHostString());\n 22:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);\n 23:                 }\n 24:             }\n 25:             // Slave problem\n 26:             else {\n 27:                 // Tell the producer, slave not available\n 28:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);\n 29:             }\n 30:         }\n 31:     }\n 32: \n 33:     return putMessageResult;\n 34: }\n```\n\n* 第 16 行 ：唤醒 `WriteSocketService`。\n    * 唤醒后，`WriteSocketService` 挂起等待新消息结束，`Master` 传输 `Slave` 新的 `CommitLog` 数据。\n    * `Slave` 收到数据后，**立即**上报最新的 `CommitLog` 同步进度到 `Master`。`ReadSocketService` 唤醒**第 18 行**：`request#waitForFlush(...)`。\n\n我们来看下 `GroupTransferService` 的核心逻辑代码：\n\n```Java\n  1: // ⬇️⬇️⬇️【GroupTransferService.java】\n  2: private void doWaitTransfer() {\n  3:     synchronized (this.requestsRead) {\n  4:         if (!this.requestsRead.isEmpty()) {\n  5:             for (CommitLog.GroupCommitRequest req : this.requestsRead) {\n  6:                 // 等待Slave上传进度\n  7:                 boolean transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();\n  8:                 for (int i = 0; !transferOK && i < 5; i++) {\n  9:                     this.notifyTransferObject.waitForRunning(1000); // 唤醒\n 10:                     transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();\n 11:                 }\n 12: \n 13:                 if (!transferOK) {\n 14:                     log.warn(\"transfer messsage to slave timeout, \" + req.getNextOffset());\n 15:                 }\n 16: \n 17:                 // 唤醒请求，并设置是否Slave同步成功\n 18:                 req.wakeupCustomer(transferOK);\n 19:             }\n 20: \n 21:             this.requestsRead.clear();\n 22:         }\n 23:     }\n 24: }\n```\n\n## 3.2 Producer 发送消息\n\n* **`Producer` 发送消息时，会对 `Broker`集群 的所有队列进行选择。**\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: private SendResult sendDefaultImpl(//\n  3:     Message msg, //\n  4:     final CommunicationMode communicationMode, //\n  5:     final SendCallback sendCallback, //\n  6:     final long timeout//\n  7: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  8:     // .... 省略：处理【校验逻辑】\n  9:     // 获取 Topic路由信息\n 10:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 11:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 12:         MessageQueue mq = null; // 最后选择消息要发送到的队列\n 13:         Exception exception = null;\n 14:         SendResult sendResult = null; // 最后一次发送结果\n 15:         int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; // 同步多次调用\n 16:         int times = 0; // 第几次发送\n 17:         String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名\n 18:         // 循环调用发送消息，直到成功\n 19:         for (; times < timesTotal; times++) {\n 20:             String lastBrokerName = null == mq ? null : mq.getBrokerName();\n 21:             MessageQueue tmpmq = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); // 选择消息要发送到的队列\n 22:             if (tmpmq != null) {\n 23:                 mq = tmpmq;\n 24:                 brokersSent[times] = mq.getBrokerName();\n 25:                 try {\n 26:                     beginTimestampPrev = System.currentTimeMillis();\n 27:                     // 调用发送消息核心方法\n 28:                     sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);\n 29:                     endTimestamp = System.currentTimeMillis();\n 30:                     // 更新Broker可用性信息\n 31:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n 32:                     // .... 省略：处理【发送返回结果】\n 33:                     }\n 34:                 } catch (e) { // .... 省略：处理【异常】\n 35:                     \n 36:                 }\n 37:             } else {\n 38:                 break;\n 39:             }\n 40:         }\n 41:         // .... 省略：处理【发送返回结果】\n 42:     }\n 43:     // .... 省略：处理【找不到消息路由】\n 44: }\n```\n\n如下是调试 `#sendDefaultImpl(...)` 时 `TopicPublishInfo` 的结果，`Producer` 获得到了 `broker-a`,`broker-b` 两个 `Broker`分组 的消息队列：\n![Producer.TopicPublishInfo.调试.png](http://www.yunai.me/images/RocketMQ/2017_05_14/05.png)\n\n## 3.3 Consumer 消费消息\n\n* **`Consumer` 消费消息时，会对 `Broker`集群 的所有队列进行选择。**\n\n# 4. 总结\n\n![HA总结.jpeg](http://www.yunai.me/images/RocketMQ/2017_05_14/03.jpeg)\n\n\n","source":"_posts/RocketMQ/2017_05_14_RocketMQ源码分析——高可用.md","raw":"title: RocketMQ 源码分析 —— 高可用\ndate: 2017-05-14\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/high-availability\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/high-availability](http://www.yunai.me/RocketMQ/high-availability)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Namesrv 高可用](#)\n\t- [2.1 Broker 注册到 Namesrv](#)\n\t- [2.2 Producer、Consumer 访问 Namesrv](#)\n- [3. Broker 高可用](#)\n\t- [3.2 Broker 主从](#)\n\t\t- [3.1.1 配置](#)\n\t\t- [3.1.2 组件](#)\n\t\t- [3.1.3 通信协议](#)\n\t\t- [3.1.4 Slave](#)\n\t\t- [3.1.5 Master](#)\n\t\t- [3.1.6 Master_SYNC](#)\n\t- [3.2 Producer 发送消息](#)\n\t- [3.3 Consumer 消费消息](#)\n- [4. 总结](#)\n\n# 1. 概述\n\n本文主要解析 `Namesrv`、`Broker` 如何实现高可用，`Producer`、`Consumer` 怎么与它们通信保证高可用。\n\n# 2. Namesrv 高可用\n\n**启动多个 `Namesrv` 实现高可用。**  \n相较于 `Zookeeper`、`Consul`、`Etcd` 等，`Namesrv` 是一个**超轻量级**的注册中心，提供**命名服务**。\n\n## 2.1 Broker 注册到 Namesrv\n\n* 📌 **多个 `Namesrv` 之间，没有任何关系（不存在类似 `Zookeeper` 的 `Leader`/`Follower` 等角色），不进行通信与数据同步。通过 `Broker` 循环注册多个 `Namesrv`。**\n\n```Java\n  1: // ⬇️⬇️⬇️【BrokerOuterAPI.java】\n  2: public RegisterBrokerResult registerBrokerAll(\n  3:     final String clusterName,\n  4:     final String brokerAddr,\n  5:     final String brokerName,\n  6:     final long brokerId,\n  7:     final String haServerAddr,\n  8:     final TopicConfigSerializeWrapper topicConfigWrapper,\n  9:     final List<String> filterServerList,\n 10:     final boolean oneway,\n 11:     final int timeoutMills) {\n 12:     RegisterBrokerResult registerBrokerResult = null;\n 13: \n 14:     List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList();\n 15:     if (nameServerAddressList != null) {\n 16:         for (String namesrvAddr : nameServerAddressList) { // 循环多个 Namesrv\n 17:             try {\n 18:                 RegisterBrokerResult result = this.registerBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId,\n 19:                     haServerAddr, topicConfigWrapper, filterServerList, oneway, timeoutMills);\n 20:                 if (result != null) {\n 21:                     registerBrokerResult = result;\n 22:                 }\n 23: \n 24:                 log.info(\"register broker to name server {} OK\", namesrvAddr);\n 25:             } catch (Exception e) {\n 26:                 log.warn(\"registerBroker Exception, {}\", namesrvAddr, e);\n 27:             }\n 28:         }\n 29:     }\n 30: \n 31:     return registerBrokerResult;\n 32: }\n```\n\n## 2.2 Producer、Consumer 访问 Namesrv\n\n* 📌 **`Producer`、`Consumer` 从 `Namesrv`列表选择一个可连接的进行通信。**\n\n```Java\n  1: // ⬇️⬇️⬇️【NettyRemotingClient.java】\n  2: private Channel getAndCreateNameserverChannel() throws InterruptedException {\n  3:     // 返回已选择、可连接Namesrv\n  4:     String addr = this.namesrvAddrChoosed.get();\n  5:     if (addr != null) {\n  6:         ChannelWrapper cw = this.channelTables.get(addr);\n  7:         if (cw != null && cw.isOK()) {\n  8:             return cw.getChannel();\n  9:         }\n 10:     }\n 11:     //\n 12:     final List<String> addrList = this.namesrvAddrList.get();\n 13:     if (this.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n 14:         try {\n 15:             // 返回已选择、可连接的Namesrv\n 16:             addr = this.namesrvAddrChoosed.get();\n 17:             if (addr != null) {\n 18:                 ChannelWrapper cw = this.channelTables.get(addr);\n 19:                 if (cw != null && cw.isOK()) {\n 20:                     return cw.getChannel();\n 21:                 }\n 22:             }\n 23:             // 从【Namesrv列表】中选择一个连接的返回\n 24:             if (addrList != null && !addrList.isEmpty()) {\n 25:                 for (int i = 0; i < addrList.size(); i++) {\n 26:                     int index = this.namesrvIndex.incrementAndGet();\n 27:                     index = Math.abs(index);\n 28:                     index = index % addrList.size();\n 29:                     String newAddr = addrList.get(index);\n 30: \n 31:                     this.namesrvAddrChoosed.set(newAddr);\n 32:                     Channel channelNew = this.createChannel(newAddr);\n 33:                     if (channelNew != null)\n 34:                         return channelNew;\n 35:                 }\n 36:             }\n 37:         } catch (Exception e) {\n 38:             log.error(\"getAndCreateNameserverChannel: create name server channel exception\", e);\n 39:         } finally {\n 40:             this.lockNamesrvChannel.unlock();\n 41:         }\n 42:     } else {\n 43:         log.warn(\"getAndCreateNameserverChannel: try to lock name server, but timeout, {}ms\", LOCK_TIMEOUT_MILLIS);\n 44:     }\n 45: \n 46:     return null;\n 47: }\n```\n\n# 3. Broker 高可用\n\n**启动多个 `Broker分组` 形成 `集群` 实现高可用。**  \n**`Broker分组` = `Master节点`x1 + `Slave节点`xN。**  \n类似 `MySQL`，`Master节点` 提供**读写**服务，`Slave节点` 只提供**读**服务。  \n\n## 3.2 Broker 主从\n\n* **每个分组，`Master`节点 不断发送新的 `CommitLog` 给 `Slave`节点。 `Slave`节点 不断上报本地的 `CommitLog` 已经同步到的位置给 `Master`节点。**\n* **`Broker分组` 与 `Broker分组` 之间没有任何关系，不进行通信与数据同步。**\n* **消费进度 目前不支持 `Master`/`Slave` 同步。**\n\n集群内，`Master`节点 有**两种**类型：`Master_SYNC`、`Master_ASYNC`：前者在 `Producer` 发送消息时，等待 `Slave`节点 存储完毕后再返回发送结果，而后者不需要等待。\n\n\n### 3.1.1 配置\n\n目前官方提供三套配置：\n\n* **2m-2s-async**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| --- | --- | --- | --- |\n| DefaultCluster | broker-a | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-a | SLAVE | 1 |\n| DefaultCluster | broker-b | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-b | SLAVE | 1 |\n\n* **2m-2s-sync**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| ---| --- | --- | --- |\n| DefaultCluster | broker-a | SYNC_MASTER | 0 |\n| DefaultCluster | broker-a | SLAVE | 1 |\n| DefaultCluster | broker-b | SYNC_MASTER | 0 |\n| DefaultCluster | broker-b | SLAVE | 1 |\n\n* **2m-noslave**\n\n| brokerClusterName| brokerName | brokerRole | brokerId |\n| ---| --- | --- | --- |\n| DefaultCluster | broker-a | ASYNC_MASTER | 0 |\n| DefaultCluster | broker-b | ASYNC_MASTER | 0 |\n\n### 3.1.2 组件\n\n再看具体实现代码之前，我们来看看 `Master`/`Slave`节点 包含的组件：  \n![HA组件图.png](http://www.yunai.me/images/RocketMQ/2017_05_14/04.png)\n\n* `Master`节点\n    * `AcceptSocketService` ：接收 `Slave`节点 连接。\n    * `HAConnection`\n        * `ReadSocketService` ：**读**来自 `Slave`节点 的数据。 \n        * `WriteSocketService` ：**写**到往 `Slave`节点 的数据。\n* `Slave`节点\n    * `HAClient` ：对 `Master`节点 连接、读写数据。\n\n### 3.1.3 通信协议\n\n`Master`节点 与 `Slave`节点 **通信协议**很简单，只有如下两条。\n\n| 对象 | 用途 | 第几位 | 字段 | 数据类型 | 字节数 | 说明\n| :-- | :-- | :-- | :-- | :-- | :-- | :-- |\n| Slave=>Master | 上报CommitLog**已经**同步到的**物理**位置 |  |  |  |  |  |\n|  | | 0 | maxPhyOffset  |  Long | 8 | CommitLog最大物理位置 |\n| Master=>Slave | 传输新的 `CommitLog` 数据 |  |  |  |  |  |\n| | | 0 | fromPhyOffset | Long | 8 | CommitLog开始物理位置 | \n| | | 1 | size | Int | 4 | 传输CommitLog数据长度 | \n| | | 2 | body | Bytes | size | 传输CommitLog数据 | \n\n### 3.1.4 Slave\n\n![HAClient顺序图](http://www.yunai.me/images/RocketMQ/2017_05_14/02.png)\n\n-------\n\n* **`Slave` 主循环，实现了**不断不断不断**从 `Master` 传输 `CommitLog` 数据，上传 `Master` 自己本地的 `CommitLog` 已经同步物理位置。**\n\n```Java\n  1: // ⬇️⬇️⬇️【HAClient.java】\n  2: public void run() {\n  3:     log.info(this.getServiceName() + \" service started\");\n  4: \n  5:     while (!this.isStopped()) {\n  6:         try {\n  7:             if (this.connectMaster()) {\n  8:                 // 若到满足上报间隔，上报到Master进度\n  9:                 if (this.isTimeToReportOffset()) {\n 10:                     boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);\n 11:                     if (!result) {\n 12:                         this.closeMaster();\n 13:                     }\n 14:                 }\n 15: \n 16:                 this.selector.select(1000);\n 17: \n 18:                 // 处理读取事件\n 19:                 boolean ok = this.processReadEvent();\n 20:                 if (!ok) {\n 21:                     this.closeMaster();\n 22:                 }\n 23: \n 24:                 // 若进度有变化，上报到Master进度\n 25:                 if (!reportSlaveMaxOffsetPlus()) {\n 26:                     continue;\n 27:                 }\n 28: \n 29:                 // Master过久未返回数据，关闭连接\n 30:                 long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n 31:                 if (interval > HAService.this.getDefaultMessageStore().getMessageStoreConfig()\n 32:                     .getHaHousekeepingInterval()) {\n 33:                     log.warn(\"HAClient, housekeeping, found this connection[\" + this.masterAddress\n 34:                         + \"] expired, \" + interval);\n 35:                     this.closeMaster();\n 36:                     log.warn(\"HAClient, master not response some time, so close connection\");\n 37:                 }\n 38:             } else {\n 39:                 this.waitForRunning(1000 * 5);\n 40:             }\n 41:         } catch (Exception e) {\n 42:             log.warn(this.getServiceName() + \" service has exception. \", e);\n 43:             this.waitForRunning(1000 * 5);\n 44:         }\n 45:     }\n 46: \n 47:     log.info(this.getServiceName() + \" service end\");\n 48: }\n```\n\n* 第 8 至 14 行 ：**固定间隔（默认5s）**向 `Master` 上报 `Slave` 本地 `CommitLog` 已经同步到的物理位置。该操作还有**心跳**的作用。\n* 第 16 至 22 行 ：处理 `Master` 传输 `Slave` 的 `CommitLog` 数据。\n\n-------\n\n* **我们来看看 `#dispatchReadRequest(...)` 与 `#reportSlaveMaxOffset(...)` 是怎么实现的。**\n\n```Java\n  1: // 【HAClient.java】\n  2: /**\n  3:  * 读取Master传输的CommitLog数据，并返回是异常\n  4:  * 如果读取到数据，写入CommitLog\n  5:  * 异常原因：\n  6:  *   1. Master传输来的数据offset 不等于 Slave的CommitLog数据最大offset\n  7:  *   2. 上报到Master进度失败\n  8:  *\n  9:  * @return 是否异常\n 10:  */\n 11: private boolean dispatchReadRequest() {\n 12:     final int msgHeaderSize = 8 + 4; // phyoffset + size\n 13:     int readSocketPos = this.byteBufferRead.position();\n 14: \n 15:     while (true) {\n 16:         // 读取到请求\n 17:         int diff = this.byteBufferRead.position() - this.dispatchPostion;\n 18:         if (diff >= msgHeaderSize) {\n 19:             // 读取masterPhyOffset、bodySize。使用dispatchPostion的原因是：处理数据“粘包”导致数据读取不完整。\n 20:             long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPostion);\n 21:             int bodySize = this.byteBufferRead.getInt(this.dispatchPostion + 8);\n 22:             // 校验 Master传输来的数据offset 是否和 Slave的CommitLog数据最大offset 是否相同。\n 23:             long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();\n 24:             if (slavePhyOffset != 0) {\n 25:                 if (slavePhyOffset != masterPhyOffset) {\n 26:                     log.error(\"master pushed offset not equal the max phy offset in slave, SLAVE: \"\n 27:                         + slavePhyOffset + \" MASTER: \" + masterPhyOffset);\n 28:                     return false;\n 29:                 }\n 30:             }\n 31:             // 读取到消息\n 32:             if (diff >= (msgHeaderSize + bodySize)) {\n 33:                 // 写入CommitLog\n 34:                 byte[] bodyData = new byte[bodySize];\n 35:                 this.byteBufferRead.position(this.dispatchPostion + msgHeaderSize);\n 36:                 this.byteBufferRead.get(bodyData);\n 37:                 HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData);\n 38:                 // 设置处理到的位置\n 39:                 this.byteBufferRead.position(readSocketPos);\n 40:                 this.dispatchPostion += msgHeaderSize + bodySize;\n 41:                 // 上报到Master进度\n 42:                 if (!reportSlaveMaxOffsetPlus()) {\n 43:                     return false;\n 44:                 }\n 45:                 // 继续循环\n 46:                 continue;\n 47:             }\n 48:         }\n 49: \n 50:         // 空间写满，重新分配空间\n 51:         if (!this.byteBufferRead.hasRemaining()) {\n 52:             this.reallocateByteBuffer();\n 53:         }\n 54: \n 55:         break;\n 56:     }\n 57: \n 58:     return true;\n 59: }\n 60: \n 61: /**\n 62:  * 上报进度\n 63:  *\n 64:  * @param maxOffset 进度\n 65:  * @return 是否上报成功\n 66:  */\n 67: private boolean reportSlaveMaxOffset(final long maxOffset) {\n 68:     this.reportOffset.position(0);\n 69:     this.reportOffset.limit(8);\n 70:     this.reportOffset.putLong(maxOffset);\n 71:     this.reportOffset.position(0);\n 72:     this.reportOffset.limit(8);\n 73: \n 74:     for (int i = 0; i < 3 && this.reportOffset.hasRemaining(); i++) {\n 75:         try {\n 76:             this.socketChannel.write(this.reportOffset);\n 77:         } catch (IOException e) {\n 78:             log.error(this.getServiceName()\n 79:                 + \"reportSlaveMaxOffset this.socketChannel.write exception\", e);\n 80:             return false;\n 81:         }\n 82:     }\n 83: \n 84:     return !this.reportOffset.hasRemaining();\n 85: }\n```\n\n### 3.1.5 Master\n\n* **`ReadSocketService` 逻辑同 `HAClient#processReadEvent(...)` 基本相同，我们直接看代码。**\n\n```Java\n  1: // ⬇️⬇️⬇️【ReadSocketService.java】\n  2: private boolean processReadEvent() {\n  3:     int readSizeZeroTimes = 0;\n  4: \n  5:     // 清空byteBufferRead\n  6:     if (!this.byteBufferRead.hasRemaining()) {\n  7:         this.byteBufferRead.flip();\n  8:         this.processPostion = 0;\n  9:     }\n 10: \n 11:     while (this.byteBufferRead.hasRemaining()) {\n 12:         try {\n 13:             int readSize = this.socketChannel.read(this.byteBufferRead);\n 14:             if (readSize > 0) {\n 15:                 readSizeZeroTimes = 0;\n 16: \n 17:                 // 设置最后读取时间\n 18:                 this.lastReadTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n 19: \n 20:                 if ((this.byteBufferRead.position() - this.processPostion) >= 8) {\n 21:                     // 读取Slave 请求来的CommitLog的最大位置\n 22:                     int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);\n 23:                     long readOffset = this.byteBufferRead.getLong(pos - 8);\n 24:                     this.processPostion = pos;\n 25: \n 26:                     // 设置Slave CommitLog的最大位置\n 27:                     HAConnection.this.slaveAckOffset = readOffset;\n 28: \n 29:                     // 设置Slave 第一次请求的位置\n 30:                     if (HAConnection.this.slaveRequestOffset < 0) {\n 31:                         HAConnection.this.slaveRequestOffset = readOffset;\n 32:                         log.info(\"slave[\" + HAConnection.this.clientAddr + \"] request offset \" + readOffset);\n 33:                     }\n 34: \n 35:                     // 通知目前Slave进度。主要用于Master节点为同步类型的。\n 36:                     HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);\n 37:                 }\n 38:             } else if (readSize == 0) {\n 39:                 if (++readSizeZeroTimes >= 3) {\n 40:                     break;\n 41:                 }\n 42:             } else {\n 43:                 log.error(\"read socket[\" + HAConnection.this.clientAddr + \"] < 0\");\n 44:                 return false;\n 45:             }\n 46:         } catch (IOException e) {\n 47:             log.error(\"processReadEvent exception\", e);\n 48:             return false;\n 49:         }\n 50:     }\n 51: \n 52:     return true;\n 53: }\n```\n\n-------\n\n* **`WriteSocketService` 计算 `Slave`开始同步的位置后，不断向 `Slave` 传输新的 `CommitLog`数据。**\n\n![HA.WriteSocketService流程图](http://www.yunai.me/images/RocketMQ/2017_05_14/01.png)\n\n```Java\n  1: // ⬇️⬇️⬇️【WriteSocketService.java】\n  2: @Override\n  3: public void run() {\n  4:     HAConnection.log.info(this.getServiceName() + \" service started\");\n  5: \n  6:     while (!this.isStopped()) {\n  7:         try {\n  8:             this.selector.select(1000);\n  9: \n 10:             // 未获得Slave读取进度请求，sleep等待。\n 11:             if (-1 == HAConnection.this.slaveRequestOffset) {\n 12:                 Thread.sleep(10);\n 13:                 continue;\n 14:             }\n 15: \n 16:             // 计算初始化nextTransferFromWhere\n 17:             if (-1 == this.nextTransferFromWhere) {\n 18:                 if (0 == HAConnection.this.slaveRequestOffset) {\n 19:                     long masterOffset = HAConnection.this.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();\n 20:                     masterOffset = masterOffset - (masterOffset % HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getMapedFileSizeCommitLog());\n 21:                     if (masterOffset < 0) {\n 22:                         masterOffset = 0;\n 23:                     }\n 24: \n 25:                     this.nextTransferFromWhere = masterOffset;\n 26:                 } else {\n 27:                     this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset;\n 28:                 }\n 29: \n 30:                 log.info(\"master transfer data from \" + this.nextTransferFromWhere + \" to slave[\" + HAConnection.this.clientAddr\n 31:                     + \"], and slave request \" + HAConnection.this.slaveRequestOffset);\n 32:             }\n 33: \n 34:             if (this.lastWriteOver) {\n 35:                 long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n 36:                 if (interval > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) { // 心跳\n 37: \n 38:                     // Build Header\n 39:                     this.byteBufferHeader.position(0);\n 40:                     this.byteBufferHeader.limit(headerSize);\n 41:                     this.byteBufferHeader.putLong(this.nextTransferFromWhere);\n 42:                     this.byteBufferHeader.putInt(0);\n 43:                     this.byteBufferHeader.flip();\n 44: \n 45:                     this.lastWriteOver = this.transferData();\n 46:                     if (!this.lastWriteOver)\n 47:                         continue;\n 48:                 }\n 49:             } else { // 未传输完成，继续传输\n 50:                 this.lastWriteOver = this.transferData();\n 51:                 if (!this.lastWriteOver)\n 52:                     continue;\n 53:             }\n 54: \n 55:             // 选择新的CommitLog数据进行传输\n 56:             SelectMappedBufferResult selectResult =\n 57:                 HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);\n 58:             if (selectResult != null) {\n 59:                 int size = selectResult.getSize();\n 60:                 if (size > HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) {\n 61:                     size = HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();\n 62:                 }\n 63: \n 64:                 long thisOffset = this.nextTransferFromWhere;\n 65:                 this.nextTransferFromWhere += size;\n 66: \n 67:                 selectResult.getByteBuffer().limit(size);\n 68:                 this.selectMappedBufferResult = selectResult;\n 69: \n 70:                 // Build Header\n 71:                 this.byteBufferHeader.position(0);\n 72:                 this.byteBufferHeader.limit(headerSize);\n 73:                 this.byteBufferHeader.putLong(thisOffset);\n 74:                 this.byteBufferHeader.putInt(size);\n 75:                 this.byteBufferHeader.flip();\n 76: \n 77:                 this.lastWriteOver = this.transferData();\n 78:             } else { // 没新的消息，挂起等待\n 79:                 HAConnection.this.haService.getWaitNotifyObject().allWaitForRunning(100);\n 80:             }\n 81:         } catch (Exception e) {\n 82: \n 83:             HAConnection.log.error(this.getServiceName() + \" service has exception.\", e);\n 84:             break;\n 85:         }\n 86:     }\n 87: \n 88:     // 断开连接 & 暂停写线程 & 暂停读线程 & 释放CommitLog\n 89:     if (this.selectMappedBufferResult != null) {\n 90:         this.selectMappedBufferResult.release();\n 91:     }\n 92: \n 93:     this.makeStop();\n 94: \n 95:     readSocketService.makeStop();\n 96: \n 97:     haService.removeConnection(HAConnection.this);\n 98: \n 99:     SelectionKey sk = this.socketChannel.keyFor(this.selector);\n100:     if (sk != null) {\n101:         sk.cancel();\n102:     }\n103: \n104:     try {\n105:         this.selector.close();\n106:         this.socketChannel.close();\n107:     } catch (IOException e) {\n108:         HAConnection.log.error(\"\", e);\n109:     }\n110: \n111:     HAConnection.log.info(this.getServiceName() + \" service end\");\n112: }\n113: \n114: /**\n115:  * 传输数据\n116:  */\n117: private boolean transferData() throws Exception {\n118:     int writeSizeZeroTimes = 0;\n119:     // Write Header\n120:     while (this.byteBufferHeader.hasRemaining()) {\n121:         int writeSize = this.socketChannel.write(this.byteBufferHeader);\n122:         if (writeSize > 0) {\n123:             writeSizeZeroTimes = 0;\n124:             this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n125:         } else if (writeSize == 0) {\n126:             if (++writeSizeZeroTimes >= 3) {\n127:                 break;\n128:             }\n129:         } else {\n130:             throw new Exception(\"ha master write header error < 0\");\n131:         }\n132:     }\n133: \n134:     if (null == this.selectMappedBufferResult) {\n135:         return !this.byteBufferHeader.hasRemaining();\n136:     }\n137: \n138:     writeSizeZeroTimes = 0;\n139: \n140:     // Write Body\n141:     if (!this.byteBufferHeader.hasRemaining()) {\n142:         while (this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {\n143:             int writeSize = this.socketChannel.write(this.selectMappedBufferResult.getByteBuffer());\n144:             if (writeSize > 0) {\n145:                 writeSizeZeroTimes = 0;\n146:                 this.lastWriteTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n147:             } else if (writeSize == 0) {\n148:                 if (++writeSizeZeroTimes >= 3) {\n149:                     break;\n150:                 }\n151:             } else {\n152:                 throw new Exception(\"ha master write body error < 0\");\n153:             }\n154:         }\n155:     }\n156: \n157:     boolean result = !this.byteBufferHeader.hasRemaining() && !this.selectMappedBufferResult.getByteBuffer().hasRemaining();\n158: \n159:     if (!this.selectMappedBufferResult.getByteBuffer().hasRemaining()) {\n160:         this.selectMappedBufferResult.release();\n161:         this.selectMappedBufferResult = null;\n162:     }\n163: \n164:     return result;\n165: }\n```\n\n### 3.1.6 Master_SYNC\n\n* **`Producer` 发送消息时，`Master_SYNC`节点 会等待 `Slave`节点 存储完毕后再返回发送结果。**\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  3:     // ....省略处理发送代码 \n  4:     // Synchronous write double 如果是同步Master，同步到从节点\n  5:     if (BrokerRole.SYNC_MASTER == this.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) {\n  6:         HAService service = this.defaultMessageStore.getHaService();\n  7:         if (msg.isWaitStoreMsgOK()) {\n  8:             // Determine whether to wait\n  9:             if (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) {\n 10:                 if (null == request) {\n 11:                     request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());\n 12:                 }\n 13:                 service.putRequest(request);\n 14: \n 15:                 // 唤醒WriteSocketService\n 16:                 service.getWaitNotifyObject().wakeupAll();\n 17: \n 18:                 boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());\n 19:                 if (!flushOK) {\n 20:                     log.error(\"do sync transfer other node, wait return, but failed, topic: \" + msg.getTopic() + \" tags: \"\n 21:                         + msg.getTags() + \" client address: \" + msg.getBornHostString());\n 22:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);\n 23:                 }\n 24:             }\n 25:             // Slave problem\n 26:             else {\n 27:                 // Tell the producer, slave not available\n 28:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);\n 29:             }\n 30:         }\n 31:     }\n 32: \n 33:     return putMessageResult;\n 34: }\n```\n\n* 第 16 行 ：唤醒 `WriteSocketService`。\n    * 唤醒后，`WriteSocketService` 挂起等待新消息结束，`Master` 传输 `Slave` 新的 `CommitLog` 数据。\n    * `Slave` 收到数据后，**立即**上报最新的 `CommitLog` 同步进度到 `Master`。`ReadSocketService` 唤醒**第 18 行**：`request#waitForFlush(...)`。\n\n我们来看下 `GroupTransferService` 的核心逻辑代码：\n\n```Java\n  1: // ⬇️⬇️⬇️【GroupTransferService.java】\n  2: private void doWaitTransfer() {\n  3:     synchronized (this.requestsRead) {\n  4:         if (!this.requestsRead.isEmpty()) {\n  5:             for (CommitLog.GroupCommitRequest req : this.requestsRead) {\n  6:                 // 等待Slave上传进度\n  7:                 boolean transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();\n  8:                 for (int i = 0; !transferOK && i < 5; i++) {\n  9:                     this.notifyTransferObject.waitForRunning(1000); // 唤醒\n 10:                     transferOK = HAService.this.push2SlaveMaxOffset.get() >= req.getNextOffset();\n 11:                 }\n 12: \n 13:                 if (!transferOK) {\n 14:                     log.warn(\"transfer messsage to slave timeout, \" + req.getNextOffset());\n 15:                 }\n 16: \n 17:                 // 唤醒请求，并设置是否Slave同步成功\n 18:                 req.wakeupCustomer(transferOK);\n 19:             }\n 20: \n 21:             this.requestsRead.clear();\n 22:         }\n 23:     }\n 24: }\n```\n\n## 3.2 Producer 发送消息\n\n* **`Producer` 发送消息时，会对 `Broker`集群 的所有队列进行选择。**\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: private SendResult sendDefaultImpl(//\n  3:     Message msg, //\n  4:     final CommunicationMode communicationMode, //\n  5:     final SendCallback sendCallback, //\n  6:     final long timeout//\n  7: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n  8:     // .... 省略：处理【校验逻辑】\n  9:     // 获取 Topic路由信息\n 10:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());\n 11:     if (topicPublishInfo != null && topicPublishInfo.ok()) {\n 12:         MessageQueue mq = null; // 最后选择消息要发送到的队列\n 13:         Exception exception = null;\n 14:         SendResult sendResult = null; // 最后一次发送结果\n 15:         int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; // 同步多次调用\n 16:         int times = 0; // 第几次发送\n 17:         String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名\n 18:         // 循环调用发送消息，直到成功\n 19:         for (; times < timesTotal; times++) {\n 20:             String lastBrokerName = null == mq ? null : mq.getBrokerName();\n 21:             MessageQueue tmpmq = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); // 选择消息要发送到的队列\n 22:             if (tmpmq != null) {\n 23:                 mq = tmpmq;\n 24:                 brokersSent[times] = mq.getBrokerName();\n 25:                 try {\n 26:                     beginTimestampPrev = System.currentTimeMillis();\n 27:                     // 调用发送消息核心方法\n 28:                     sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);\n 29:                     endTimestamp = System.currentTimeMillis();\n 30:                     // 更新Broker可用性信息\n 31:                     this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);\n 32:                     // .... 省略：处理【发送返回结果】\n 33:                     }\n 34:                 } catch (e) { // .... 省略：处理【异常】\n 35:                     \n 36:                 }\n 37:             } else {\n 38:                 break;\n 39:             }\n 40:         }\n 41:         // .... 省略：处理【发送返回结果】\n 42:     }\n 43:     // .... 省略：处理【找不到消息路由】\n 44: }\n```\n\n如下是调试 `#sendDefaultImpl(...)` 时 `TopicPublishInfo` 的结果，`Producer` 获得到了 `broker-a`,`broker-b` 两个 `Broker`分组 的消息队列：\n![Producer.TopicPublishInfo.调试.png](http://www.yunai.me/images/RocketMQ/2017_05_14/05.png)\n\n## 3.3 Consumer 消费消息\n\n* **`Consumer` 消费消息时，会对 `Broker`集群 的所有队列进行选择。**\n\n# 4. 总结\n\n![HA总结.jpeg](http://www.yunai.me/images/RocketMQ/2017_05_14/03.jpeg)\n\n\n","slug":"RocketMQ/high-availability","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzah000wag5dkb4av5ix","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/high-availability\">http://www.yunai.me/RocketMQ/high-availability</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Namesrv 高可用</a><ul>\n<li><a href=\"#\">2.1 Broker 注册到 Namesrv</a></li>\n<li><a href=\"#\">2.2 Producer、Consumer 访问 Namesrv</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. Broker 高可用</a><ul>\n<li><a href=\"#\">3.2 Broker 主从</a><ul>\n<li><a href=\"#\">3.1.1 配置</a></li>\n<li><a href=\"#\">3.1.2 组件</a></li>\n<li><a href=\"#\">3.1.3 通信协议</a></li>\n<li><a href=\"#\">3.1.4 Slave</a></li>\n<li><a href=\"#\">3.1.5 Master</a></li>\n<li><a href=\"#\">3.1.6 Master_SYNC</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.2 Producer 发送消息</a></li>\n<li><a href=\"#\">3.3 Consumer 消费消息</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 总结</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>本文主要解析 <code>Namesrv</code>、<code>Broker</code> 如何实现高可用，<code>Producer</code>、<code>Consumer</code> 怎么与它们通信保证高可用。</p>\n<h1 id=\"2-Namesrv-高可用\"><a href=\"#2-Namesrv-高可用\" class=\"headerlink\" title=\"2. Namesrv 高可用\"></a>2. Namesrv 高可用</h1><p><strong>启动多个 <code>Namesrv</code> 实现高可用。</strong><br>相较于 <code>Zookeeper</code>、<code>Consul</code>、<code>Etcd</code> 等，<code>Namesrv</code> 是一个<strong>超轻量级</strong>的注册中心，提供<strong>命名服务</strong>。</p>\n<h2 id=\"2-1-Broker-注册到-Namesrv\"><a href=\"#2-1-Broker-注册到-Namesrv\" class=\"headerlink\" title=\"2.1 Broker 注册到 Namesrv\"></a>2.1 Broker 注册到 Namesrv</h2><ul>\n<li>📌 <strong>多个 <code>Namesrv</code> 之间，没有任何关系（不存在类似 <code>Zookeeper</code> 的 <code>Leader</code>/<code>Follower</code> 等角色），不进行通信与数据同步。通过 <code>Broker</code> 循环注册多个 <code>Namesrv</code>。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【BrokerOuterAPI.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RegisterBrokerResult <span class=\"title\">registerBrokerAll</span><span class=\"params\">(</span></span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> String clusterName,</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> String brokerAddr,</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> String brokerName,</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerId,</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> String haServerAddr,</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> List&lt;String&gt; filterServerList,</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> oneway,</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeoutMills) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:     RegisterBrokerResult registerBrokerResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     List&lt;String&gt; nameServerAddressList = <span class=\"keyword\">this</span>.remotingClient.getNameServerAddressList();</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (nameServerAddressList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">for</span> (String namesrvAddr : nameServerAddressList) &#123; <span class=\"comment\">// 循环多个 Namesrv</span></div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 RegisterBrokerResult result = <span class=\"keyword\">this</span>.registerBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId,</div><div class=\"line\"><span class=\"number\">19</span>:                     haServerAddr, topicConfigWrapper, filterServerList, oneway, timeoutMills);</div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     registerBrokerResult = result;</div><div class=\"line\"><span class=\"number\">22</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:                 log.info(<span class=\"string\">\"register broker to name server &#123;&#125; OK\"</span>, namesrvAddr);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 log.warn(<span class=\"string\">\"registerBroker Exception, &#123;&#125;\"</span>, namesrvAddr, e);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">return</span> registerBrokerResult;</div><div class=\"line\"><span class=\"number\">32</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-Producer、Consumer-访问-Namesrv\"><a href=\"#2-2-Producer、Consumer-访问-Namesrv\" class=\"headerlink\" title=\"2.2 Producer、Consumer 访问 Namesrv\"></a>2.2 Producer、Consumer 访问 Namesrv</h2><ul>\n<li>📌 <strong><code>Producer</code>、<code>Consumer</code> 从 <code>Namesrv</code>列表选择一个可连接的进行通信。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【NettyRemotingClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> Channel <span class=\"title\">getAndCreateNameserverChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 返回已选择、可连接Namesrv</span></div><div class=\"line\"> <span class=\"number\">4</span>:     String addr = <span class=\"keyword\">this</span>.namesrvAddrChoosed.get();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         ChannelWrapper cw = <span class=\"keyword\">this</span>.channelTables.get(addr);</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (cw != <span class=\"keyword\">null</span> &amp;&amp; cw.isOK()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">return</span> cw.getChannel();</div><div class=\"line\"> <span class=\"number\">9</span>:         &#125;</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> List&lt;String&gt; addrList = <span class=\"keyword\">this</span>.namesrvAddrList.get();</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"comment\">// 返回已选择、可连接的Namesrv</span></div><div class=\"line\"><span class=\"number\">16</span>:             addr = <span class=\"keyword\">this</span>.namesrvAddrChoosed.get();</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 ChannelWrapper cw = <span class=\"keyword\">this</span>.channelTables.get(addr);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">if</span> (cw != <span class=\"keyword\">null</span> &amp;&amp; cw.isOK()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     <span class=\"keyword\">return</span> cw.getChannel();</div><div class=\"line\"><span class=\"number\">21</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"comment\">// 从【Namesrv列表】中选择一个连接的返回</span></div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (addrList != <span class=\"keyword\">null</span> &amp;&amp; !addrList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addrList.size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">int</span> index = <span class=\"keyword\">this</span>.namesrvIndex.incrementAndGet();</div><div class=\"line\"><span class=\"number\">27</span>:                     index = Math.abs(index);</div><div class=\"line\"><span class=\"number\">28</span>:                     index = index % addrList.size();</div><div class=\"line\"><span class=\"number\">29</span>:                     String newAddr = addrList.get(index);</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">this</span>.namesrvAddrChoosed.set(newAddr);</div><div class=\"line\"><span class=\"number\">32</span>:                     Channel channelNew = <span class=\"keyword\">this</span>.createChannel(newAddr);</div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">if</span> (channelNew != <span class=\"keyword\">null</span>)</div><div class=\"line\"><span class=\"number\">34</span>:                         <span class=\"keyword\">return</span> channelNew;</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">36</span>:             &#125;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:             log.error(<span class=\"string\">\"getAndCreateNameserverChannel: create name server channel exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">39</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">40</span>:             <span class=\"keyword\">this</span>.lockNamesrvChannel.unlock();</div><div class=\"line\"><span class=\"number\">41</span>:         &#125;</div><div class=\"line\"><span class=\"number\">42</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">43</span>:         log.warn(<span class=\"string\">\"getAndCreateNameserverChannel: try to lock name server, but timeout, &#123;&#125;ms\"</span>, LOCK_TIMEOUT_MILLIS);</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-Broker-高可用\"><a href=\"#3-Broker-高可用\" class=\"headerlink\" title=\"3. Broker 高可用\"></a>3. Broker 高可用</h1><p><strong>启动多个 <code>Broker分组</code> 形成 <code>集群</code> 实现高可用。</strong><br><strong><code>Broker分组</code> = <code>Master节点</code>x1 + <code>Slave节点</code>xN。</strong><br>类似 <code>MySQL</code>，<code>Master节点</code> 提供<strong>读写</strong>服务，<code>Slave节点</code> 只提供<strong>读</strong>服务。  </p>\n<h2 id=\"3-2-Broker-主从\"><a href=\"#3-2-Broker-主从\" class=\"headerlink\" title=\"3.2 Broker 主从\"></a>3.2 Broker 主从</h2><ul>\n<li><strong>每个分组，<code>Master</code>节点 不断发送新的 <code>CommitLog</code> 给 <code>Slave</code>节点。 <code>Slave</code>节点 不断上报本地的 <code>CommitLog</code> 已经同步到的位置给 <code>Master</code>节点。</strong></li>\n<li><strong><code>Broker分组</code> 与 <code>Broker分组</code> 之间没有任何关系，不进行通信与数据同步。</strong></li>\n<li><strong>消费进度 目前不支持 <code>Master</code>/<code>Slave</code> 同步。</strong></li>\n</ul>\n<p>集群内，<code>Master</code>节点 有<strong>两种</strong>类型：<code>Master_SYNC</code>、<code>Master_ASYNC</code>：前者在 <code>Producer</code> 发送消息时，等待 <code>Slave</code>节点 存储完毕后再返回发送结果，而后者不需要等待。</p>\n<h3 id=\"3-1-1-配置\"><a href=\"#3-1-1-配置\" class=\"headerlink\" title=\"3.1.1 配置\"></a>3.1.1 配置</h3><p>目前官方提供三套配置：</p>\n<ul>\n<li><strong>2m-2s-async</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>2m-2s-sync</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>2m-noslave</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-2-组件\"><a href=\"#3-1-2-组件\" class=\"headerlink\" title=\"3.1.2 组件\"></a>3.1.2 组件</h3><p>再看具体实现代码之前，我们来看看 <code>Master</code>/<code>Slave</code>节点 包含的组件：<br><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/04.png\" alt=\"HA组件图.png\"></p>\n<ul>\n<li><code>Master</code>节点<ul>\n<li><code>AcceptSocketService</code> ：接收 <code>Slave</code>节点 连接。</li>\n<li><code>HAConnection</code><ul>\n<li><code>ReadSocketService</code> ：<strong>读</strong>来自 <code>Slave</code>节点 的数据。 </li>\n<li><code>WriteSocketService</code> ：<strong>写</strong>到往 <code>Slave</code>节点 的数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>Slave</code>节点<ul>\n<li><code>HAClient</code> ：对 <code>Master</code>节点 连接、读写数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1-3-通信协议\"><a href=\"#3-1-3-通信协议\" class=\"headerlink\" title=\"3.1.3 通信协议\"></a>3.1.3 通信协议</h3><p><code>Master</code>节点 与 <code>Slave</code>节点 <strong>通信协议</strong>很简单，只有如下两条。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">用途</th>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Slave=&gt;Master</td>\n<td style=\"text-align:left\">上报CommitLog<strong>已经</strong>同步到的<strong>物理</strong>位置</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">maxPhyOffset</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">CommitLog最大物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Master=&gt;Slave</td>\n<td style=\"text-align:left\">传输新的 <code>CommitLog</code> 数据</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">fromPhyOffset</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">CommitLog开始物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">传输CommitLog数据长度</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">body</td>\n<td style=\"text-align:left\">Bytes</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">传输CommitLog数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-4-Slave\"><a href=\"#3-1-4-Slave\" class=\"headerlink\" title=\"3.1.4 Slave\"></a>3.1.4 Slave</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/02.png\" alt=\"HAClient顺序图\"></p>\n<hr>\n<ul>\n<li><strong><code>Slave</code> 主循环，实现了</strong>不断不断不断<strong>从 <code>Master</code> 传输 <code>CommitLog</code> 数据，上传 <code>Master</code> 自己本地的 <code>CommitLog</code> 已经同步物理位置。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【HAClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connectMaster()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"comment\">// 若到满足上报间隔，上报到Master进度</span></div><div class=\"line\"> <span class=\"number\">9</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isTimeToReportOffset()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                     <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.reportSlaveMaxOffset(<span class=\"keyword\">this</span>.currentReportedOffset);</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">if</span> (!result) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:                         <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">13</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">this</span>.selector.select(<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"comment\">// 处理读取事件</span></div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">boolean</span> ok = <span class=\"keyword\">this</span>.processReadEvent();</div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> (!ok) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">22</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"comment\">// 若进度有变化，上报到Master进度</span></div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (!reportSlaveMaxOffsetPlus()) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"comment\">// Master过久未返回数据，关闭连接</span></div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">long</span> interval = HAService.<span class=\"keyword\">this</span>.getDefaultMessageStore().getSystemClock().now() - <span class=\"keyword\">this</span>.lastWriteTimestamp;</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">if</span> (interval &gt; HAService.<span class=\"keyword\">this</span>.getDefaultMessageStore().getMessageStoreConfig()</div><div class=\"line\"><span class=\"number\">32</span>:                     .getHaHousekeepingInterval()) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                     log.warn(<span class=\"string\">\"HAClient, housekeeping, found this connection[\"</span> + <span class=\"keyword\">this</span>.masterAddress</div><div class=\"line\"><span class=\"number\">34</span>:                         + <span class=\"string\">\"] expired, \"</span> + interval);</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">36</span>:                     log.warn(<span class=\"string\">\"HAClient, master not response some time, so close connection\"</span>);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"number\">40</span>:             &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"number\">44</span>:         &#125;</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">48</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 8 至 14 行 ：<strong>固定间隔（默认5s）</strong>向 <code>Master</code> 上报 <code>Slave</code> 本地 <code>CommitLog</code> 已经同步到的物理位置。该操作还有<strong>心跳</strong>的作用。</li>\n<li>第 16 至 22 行 ：处理 <code>Master</code> 传输 <code>Slave</code> 的 <code>CommitLog</code> 数据。</li>\n</ul>\n<hr>\n<ul>\n<li><strong>我们来看看 <code>#dispatchReadRequest(...)</code> 与 <code>#reportSlaveMaxOffset(...)</code> 是怎么实现的。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// 【HAClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 读取Master传输的CommitLog数据，并返回是异常</div><div class=\"line\"> 4:  * 如果读取到数据，写入CommitLog</div><div class=\"line\"> 5:  * 异常原因：</div><div class=\"line\"> 6:  *   1. Master传输来的数据offset 不等于 Slave的CommitLog数据最大offset</div><div class=\"line\"> 7:  *   2. 上报到Master进度失败</div><div class=\"line\"> 8:  *</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 是否异常</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchReadRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> msgHeaderSize = <span class=\"number\">8</span> + <span class=\"number\">4</span>; <span class=\"comment\">// phyoffset + size</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">int</span> readSocketPos = <span class=\"keyword\">this</span>.byteBufferRead.position();</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 读取到请求</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">int</span> diff = <span class=\"keyword\">this</span>.byteBufferRead.position() - <span class=\"keyword\">this</span>.dispatchPostion;</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">if</span> (diff &gt;= msgHeaderSize) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"comment\">// 读取masterPhyOffset、bodySize。使用dispatchPostion的原因是：处理数据“粘包”导致数据读取不完整。</span></div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">long</span> masterPhyOffset = <span class=\"keyword\">this</span>.byteBufferRead.getLong(<span class=\"keyword\">this</span>.dispatchPostion);</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">int</span> bodySize = <span class=\"keyword\">this</span>.byteBufferRead.getInt(<span class=\"keyword\">this</span>.dispatchPostion + <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"comment\">// 校验 Master传输来的数据offset 是否和 Slave的CommitLog数据最大offset 是否相同。</span></div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">long</span> slavePhyOffset = HAService.<span class=\"keyword\">this</span>.defaultMessageStore.getMaxPhyOffset();</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (slavePhyOffset != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (slavePhyOffset != masterPhyOffset) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     log.error(<span class=\"string\">\"master pushed offset not equal the max phy offset in slave, SLAVE: \"</span></div><div class=\"line\"><span class=\"number\">27</span>:                         + slavePhyOffset + <span class=\"string\">\" MASTER: \"</span> + masterPhyOffset);</div><div class=\"line\"><span class=\"number\">28</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"comment\">// 读取到消息</span></div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (diff &gt;= (msgHeaderSize + bodySize)) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"comment\">// 写入CommitLog</span></div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">byte</span>[] bodyData = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bodySize];</div><div class=\"line\"><span class=\"number\">35</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.position(<span class=\"keyword\">this</span>.dispatchPostion + msgHeaderSize);</div><div class=\"line\"><span class=\"number\">36</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.get(bodyData);</div><div class=\"line\"><span class=\"number\">37</span>:                 HAService.<span class=\"keyword\">this</span>.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData);</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"comment\">// 设置处理到的位置</span></div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.position(readSocketPos);</div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"keyword\">this</span>.dispatchPostion += msgHeaderSize + bodySize;</div><div class=\"line\"><span class=\"number\">41</span>:                 <span class=\"comment\">// 上报到Master进度</span></div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"keyword\">if</span> (!reportSlaveMaxOffsetPlus()) &#123;</div><div class=\"line\"><span class=\"number\">43</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">44</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">45</span>:                 <span class=\"comment\">// 继续循环</span></div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">47</span>:             &#125;</div><div class=\"line\"><span class=\"number\">48</span>:         &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:         <span class=\"comment\">// 空间写满，重新分配空间</span></div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.reallocateByteBuffer();</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125;</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">59</span>: &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>: <span class=\"comment\">/**</span></div><div class=\"line\">62:  * 上报进度</div><div class=\"line\">63:  *</div><div class=\"line\">64:  * <span class=\"doctag\">@param</span> maxOffset 进度</div><div class=\"line\">65:  * <span class=\"doctag\">@return</span> 是否上报成功</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">reportSlaveMaxOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:     <span class=\"keyword\">this</span>.reportOffset.position(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">this</span>.reportOffset.limit(<span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">70</span>:     <span class=\"keyword\">this</span>.reportOffset.putLong(maxOffset);</div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"keyword\">this</span>.reportOffset.position(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"keyword\">this</span>.reportOffset.limit(<span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">73</span>: </div><div class=\"line\"><span class=\"number\">74</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> &amp;&amp; <span class=\"keyword\">this</span>.reportOffset.hasRemaining(); i++) &#123;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">76</span>:             <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.reportOffset);</div><div class=\"line\"><span class=\"number\">77</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">78</span>:             log.error(<span class=\"keyword\">this</span>.getServiceName()</div><div class=\"line\"><span class=\"number\">79</span>:                 + <span class=\"string\">\"reportSlaveMaxOffset this.socketChannel.write exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">80</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">81</span>:         &#125;</div><div class=\"line\"><span class=\"number\">82</span>:     &#125;</div><div class=\"line\"><span class=\"number\">83</span>: </div><div class=\"line\"><span class=\"number\">84</span>:     <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.reportOffset.hasRemaining();</div><div class=\"line\"><span class=\"number\">85</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-1-5-Master\"><a href=\"#3-1-5-Master\" class=\"headerlink\" title=\"3.1.5 Master\"></a>3.1.5 Master</h3><ul>\n<li><strong><code>ReadSocketService</code> 逻辑同 <code>HAClient#processReadEvent(...)</code> 基本相同，我们直接看代码。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ReadSocketService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">processReadEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">int</span> readSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// 清空byteBufferRead</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.byteBufferRead.flip();</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">this</span>.processPostion = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;</div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">int</span> readSize = <span class=\"keyword\">this</span>.socketChannel.read(<span class=\"keyword\">this</span>.byteBufferRead);</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">if</span> (readSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 readSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 设置最后读取时间</span></div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">this</span>.lastReadTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> ((<span class=\"keyword\">this</span>.byteBufferRead.position() - <span class=\"keyword\">this</span>.processPostion) &gt;= <span class=\"number\">8</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"comment\">// 读取Slave 请求来的CommitLog的最大位置</span></div><div class=\"line\"><span class=\"number\">22</span>:                     <span class=\"keyword\">int</span> pos = <span class=\"keyword\">this</span>.byteBufferRead.position() - (<span class=\"keyword\">this</span>.byteBufferRead.position() % <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">long</span> readOffset = <span class=\"keyword\">this</span>.byteBufferRead.getLong(pos - <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">24</span>:                     <span class=\"keyword\">this</span>.processPostion = pos;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"comment\">// 设置Slave CommitLog的最大位置</span></div><div class=\"line\"><span class=\"number\">27</span>:                     HAConnection.<span class=\"keyword\">this</span>.slaveAckOffset = readOffset;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:                     <span class=\"comment\">// 设置Slave 第一次请求的位置</span></div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset = readOffset;</div><div class=\"line\"><span class=\"number\">32</span>:                         log.info(<span class=\"string\">\"slave[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr + <span class=\"string\">\"] request offset \"</span> + readOffset);</div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"comment\">// 通知目前Slave进度。主要用于Master节点为同步类型的。</span></div><div class=\"line\"><span class=\"number\">36</span>:                     HAConnection.<span class=\"keyword\">this</span>.haService.notifyTransferSome(HAConnection.<span class=\"keyword\">this</span>.slaveAckOffset);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (++readSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">43</span>:                 log.error(<span class=\"string\">\"read socket[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr + <span class=\"string\">\"] &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">45</span>:             &#125;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             log.error(<span class=\"string\">\"processReadEvent exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">48</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">49</span>:         &#125;</div><div class=\"line\"><span class=\"number\">50</span>:     &#125;</div><div class=\"line\"><span class=\"number\">51</span>: </div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">53</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li><strong><code>WriteSocketService</code> 计算 <code>Slave</code>开始同步的位置后，不断向 <code>Slave</code> 传输新的 <code>CommitLog</code>数据。</strong></li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/01.png\" alt=\"HA.WriteSocketService流程图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【WriteSocketService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">4</span>:     HAConnection.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\">  <span class=\"number\">5</span>: </div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\">  <span class=\"number\">7</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.selector.select(<span class=\"number\">1000</span>);</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:             <span class=\"comment\">// 未获得Slave读取进度请求，sleep等待。</span></div><div class=\"line\"> <span class=\"number\">11</span>:             <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset) &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:                 Thread.sleep(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">13</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">14</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"comment\">// 计算初始化nextTransferFromWhere</span></div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == <span class=\"keyword\">this</span>.nextTransferFromWhere) &#123;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:                     <span class=\"keyword\">long</span> masterOffset = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();</div><div class=\"line\"> <span class=\"number\">20</span>:                     masterOffset = masterOffset - (masterOffset % HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getMapedFileSizeCommitLog());</div><div class=\"line\"> <span class=\"number\">21</span>:                     <span class=\"keyword\">if</span> (masterOffset &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:                         masterOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:                     <span class=\"keyword\">this</span>.nextTransferFromWhere = masterOffset;</div><div class=\"line\"> <span class=\"number\">26</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:                     <span class=\"keyword\">this</span>.nextTransferFromWhere = HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset;</div><div class=\"line\"> <span class=\"number\">28</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:                 log.info(<span class=\"string\">\"master transfer data from \"</span> + <span class=\"keyword\">this</span>.nextTransferFromWhere + <span class=\"string\">\" to slave[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr</div><div class=\"line\"> <span class=\"number\">31</span>:                     + <span class=\"string\">\"], and slave request \"</span> + HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset);</div><div class=\"line\"> <span class=\"number\">32</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lastWriteOver) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">long</span> interval = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now() - <span class=\"keyword\">this</span>.lastWriteTimestamp;</div><div class=\"line\"> <span class=\"number\">36</span>:                 <span class=\"keyword\">if</span> (interval &gt; HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) &#123; <span class=\"comment\">// 心跳</span></div><div class=\"line\"> <span class=\"number\">37</span>: </div><div class=\"line\"> <span class=\"number\">38</span>:                     <span class=\"comment\">// Build Header</span></div><div class=\"line\"> <span class=\"number\">39</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.limit(headerSize);</div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.putLong(<span class=\"keyword\">this</span>.nextTransferFromWhere);</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.putInt(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.flip();</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:                     <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">46</span>:                     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.lastWriteOver)</div><div class=\"line\"> <span class=\"number\">47</span>:                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 未传输完成，继续传输</span></div><div class=\"line\"> <span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">51</span>:                 <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.lastWriteOver)</div><div class=\"line\"> <span class=\"number\">52</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">53</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:             <span class=\"comment\">// 选择新的CommitLog数据进行传输</span></div><div class=\"line\"> <span class=\"number\">56</span>:             SelectMappedBufferResult selectResult =</div><div class=\"line\"> <span class=\"number\">57</span>:                 HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class=\"keyword\">this</span>.nextTransferFromWhere);</div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"keyword\">if</span> (selectResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"keyword\">int</span> size = selectResult.getSize();</div><div class=\"line\"> <span class=\"number\">60</span>:                 <span class=\"keyword\">if</span> (size &gt; HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) &#123;</div><div class=\"line\"> <span class=\"number\">61</span>:                     size = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();</div><div class=\"line\"> <span class=\"number\">62</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"keyword\">long</span> thisOffset = <span class=\"keyword\">this</span>.nextTransferFromWhere;</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"keyword\">this</span>.nextTransferFromWhere += size;</div><div class=\"line\"> <span class=\"number\">66</span>: </div><div class=\"line\"> <span class=\"number\">67</span>:                 selectResult.getByteBuffer().limit(size);</div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">this</span>.selectMappedBufferResult = selectResult;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:                 <span class=\"comment\">// Build Header</span></div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.limit(headerSize);</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.putLong(thisOffset);</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.putInt(size);</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.flip();</div><div class=\"line\"> <span class=\"number\">76</span>: </div><div class=\"line\"> <span class=\"number\">77</span>:                 <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 没新的消息，挂起等待</span></div><div class=\"line\"> <span class=\"number\">79</span>:                 HAConnection.<span class=\"keyword\">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class=\"number\">100</span>);</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>:             HAConnection.log.error(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception.\"</span>, e);</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"comment\">// 断开连接 &amp; 暂停写线程 &amp; 暂停读线程 &amp; 释放CommitLog</span></div><div class=\"line\"> <span class=\"number\">89</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.selectMappedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult.release();</div><div class=\"line\"> <span class=\"number\">91</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">this</span>.makeStop();</div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:     readSocketService.makeStop();</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:     haService.removeConnection(HAConnection.<span class=\"keyword\">this</span>);</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:     SelectionKey sk = <span class=\"keyword\">this</span>.socketChannel.keyFor(<span class=\"keyword\">this</span>.selector);</div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">if</span> (sk != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:         sk.cancel();</div><div class=\"line\"><span class=\"number\">102</span>:     &#125;</div><div class=\"line\"><span class=\"number\">103</span>: </div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">this</span>.selector.close();</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">this</span>.socketChannel.close();</div><div class=\"line\"><span class=\"number\">107</span>:     &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">108</span>:         HAConnection.log.error(<span class=\"string\">\"\"</span>, e);</div><div class=\"line\"><span class=\"number\">109</span>:     &#125;</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:     HAConnection.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">112</span>: &#125;</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>: <span class=\"comment\">/**</span></div><div class=\"line\">115:  * 传输数据</div><div class=\"line\">116:  */</div><div class=\"line\"><span class=\"number\">117</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">int</span> writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">119</span>:     <span class=\"comment\">// Write Header</span></div><div class=\"line\"><span class=\"number\">120</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"keyword\">int</span> writeSize = <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.byteBufferHeader);</div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"keyword\">if</span> (writeSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">123</span>:             writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">this</span>.lastWriteTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">125</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (writeSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             <span class=\"keyword\">if</span> (++writeSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">127</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"ha master write header error &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">131</span>:         &#125;</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.selectMappedBufferResult) &#123;</div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining();</div><div class=\"line\"><span class=\"number\">136</span>:     &#125;</div><div class=\"line\"><span class=\"number\">137</span>: </div><div class=\"line\"><span class=\"number\">138</span>:     writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">139</span>: </div><div class=\"line\"><span class=\"number\">140</span>:     <span class=\"comment\">// Write Body</span></div><div class=\"line\"><span class=\"number\">141</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:         <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:             <span class=\"keyword\">int</span> writeSize = <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer());</div><div class=\"line\"><span class=\"number\">144</span>:             <span class=\"keyword\">if</span> (writeSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                 writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">146</span>:                 <span class=\"keyword\">this</span>.lastWriteTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">147</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (writeSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">if</span> (++writeSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">149</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">151</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">152</span>:                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"ha master write body error &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">153</span>:             &#125;</div><div class=\"line\"><span class=\"number\">154</span>:         &#125;</div><div class=\"line\"><span class=\"number\">155</span>:     &#125;</div><div class=\"line\"><span class=\"number\">156</span>: </div><div class=\"line\"><span class=\"number\">157</span>:     <span class=\"keyword\">boolean</span> result = !<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining() &amp;&amp; !<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining();</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult.release();</div><div class=\"line\"><span class=\"number\">161</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">162</span>:     &#125;</div><div class=\"line\"><span class=\"number\">163</span>: </div><div class=\"line\"><span class=\"number\">164</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">165</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-1-6-Master-SYNC\"><a href=\"#3-1-6-Master-SYNC\" class=\"headerlink\" title=\"3.1.6 Master_SYNC\"></a>3.1.6 Master_SYNC</h3><ul>\n<li><strong><code>Producer</code> 发送消息时，<code>Master_SYNC</code>节点 会等待 <code>Slave</code>节点 存储完毕后再返回发送结果。</strong></li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// ....省略处理发送代码 </span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// Synchronous write double 如果是同步Master，同步到从节点</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (BrokerRole.SYNC_MASTER == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         HAService service = <span class=\"keyword\">this</span>.defaultMessageStore.getHaService();</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"comment\">// Determine whether to wait</span></div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == request) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:                 service.putRequest(request);</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 唤醒WriteSocketService</span></div><div class=\"line\"><span class=\"number\">16</span>:                 service.getWaitNotifyObject().wakeupAll();</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">boolean</span> flushOK = request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     log.error(<span class=\"string\">\"do sync transfer other node, wait return, but failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span></div><div class=\"line\"><span class=\"number\">21</span>:                         + msg.getTags() + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">22</span>:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">23</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">24</span>:             &#125;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// Slave problem</span></div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                 <span class=\"comment\">// Tell the producer, slave not available</span></div><div class=\"line\"><span class=\"number\">28</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">29</span>:             &#125;</div><div class=\"line\"><span class=\"number\">30</span>:         &#125;</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">return</span> putMessageResult;</div><div class=\"line\"><span class=\"number\">34</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：唤醒 <code>WriteSocketService</code>。<ul>\n<li>唤醒后，<code>WriteSocketService</code> 挂起等待新消息结束，<code>Master</code> 传输 <code>Slave</code> 新的 <code>CommitLog</code> 数据。</li>\n<li><code>Slave</code> 收到数据后，<strong>立即</strong>上报最新的 <code>CommitLog</code> 同步进度到 <code>Master</code>。<code>ReadSocketService</code> 唤醒<strong>第 18 行</strong>：<code>request#waitForFlush(...)</code>。</li>\n</ul>\n</li>\n</ul>\n<p>我们来看下 <code>GroupTransferService</code> 的核心逻辑代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【GroupTransferService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWaitTransfer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">for</span> (CommitLog.GroupCommitRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 <span class=\"comment\">// 等待Slave上传进度</span></div><div class=\"line\"> <span class=\"number\">7</span>:                 <span class=\"keyword\">boolean</span> transferOK = HAService.<span class=\"keyword\">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; !transferOK &amp;&amp; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">this</span>.notifyTransferObject.waitForRunning(<span class=\"number\">1000</span>); <span class=\"comment\">// 唤醒</span></div><div class=\"line\"><span class=\"number\">10</span>:                     transferOK = HAService.<span class=\"keyword\">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</div><div class=\"line\"><span class=\"number\">11</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (!transferOK) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     log.warn(<span class=\"string\">\"transfer messsage to slave timeout, \"</span> + req.getNextOffset());</div><div class=\"line\"><span class=\"number\">15</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 唤醒请求，并设置是否Slave同步成功</span></div><div class=\"line\"><span class=\"number\">18</span>:                 req.wakeupCustomer(transferOK);</div><div class=\"line\"><span class=\"number\">19</span>:             &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.requestsRead.clear();</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>:     &#125;</div><div class=\"line\"><span class=\"number\">24</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Producer-发送消息\"><a href=\"#3-2-Producer-发送消息\" class=\"headerlink\" title=\"3.2 Producer 发送消息\"></a>3.2 Producer 发送消息</h2><ul>\n<li><strong><code>Producer</code> 发送消息时，会对 <code>Broker</code>集群 的所有队列进行选择。</strong></li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendDefaultImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">3</span>:     Message msg, //</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"> <span class=\"number\">7</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// .... 省略：处理【校验逻辑】</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// 获取 Topic路由信息</span></div><div class=\"line\"><span class=\"number\">10</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         MessageQueue mq = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后选择消息要发送到的队列</span></div><div class=\"line\"><span class=\"number\">13</span>:         Exception exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         SendResult sendResult = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后一次发送结果</span></div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class=\"number\">1</span>; <span class=\"comment\">// 同步多次调用</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; <span class=\"comment\">// 第几次发送</span></div><div class=\"line\"><span class=\"number\">17</span>:         String[] brokersSent = <span class=\"keyword\">new</span> String[timesTotal]; <span class=\"comment\">// 存储每次发送消息选择的broker名</span></div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"comment\">// 循环调用发送消息，直到成功</span></div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             String lastBrokerName = <span class=\"keyword\">null</span> == mq ? <span class=\"keyword\">null</span> : mq.getBrokerName();</div><div class=\"line\"><span class=\"number\">21</span>:             MessageQueue tmpmq = <span class=\"keyword\">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName); <span class=\"comment\">// 选择消息要发送到的队列</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">if</span> (tmpmq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:                 mq = tmpmq;</div><div class=\"line\"><span class=\"number\">24</span>:                 brokersSent[times] = mq.getBrokerName();</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     beginTimestampPrev = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">27</span>:                     <span class=\"comment\">// 调用发送消息核心方法</span></div><div class=\"line\"><span class=\"number\">28</span>:                     sendResult = <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class=\"line\"><span class=\"number\">29</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"comment\">// 更新Broker可用性信息</span></div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">32</span>:                     <span class=\"comment\">// .... 省略：处理【发送返回结果】</span></div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>:                 &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// .... 省略：处理【异常】</span></div><div class=\"line\"><span class=\"number\">35</span>:                     </div><div class=\"line\"><span class=\"number\">36</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">37</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">39</span>:             &#125;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"comment\">// .... 省略：处理【发送返回结果】</span></div><div class=\"line\"><span class=\"number\">42</span>:     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"comment\">// .... 省略：处理【找不到消息路由】</span></div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<p>如下是调试 <code>#sendDefaultImpl(...)</code> 时 <code>TopicPublishInfo</code> 的结果，<code>Producer</code> 获得到了 <code>broker-a</code>,<code>broker-b</code> 两个 <code>Broker</code>分组 的消息队列：<br><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/05.png\" alt=\"Producer.TopicPublishInfo.调试.png\"></p>\n<h2 id=\"3-3-Consumer-消费消息\"><a href=\"#3-3-Consumer-消费消息\" class=\"headerlink\" title=\"3.3 Consumer 消费消息\"></a>3.3 Consumer 消费消息</h2><ul>\n<li><strong><code>Consumer</code> 消费消息时，会对 <code>Broker</code>集群 的所有队列进行选择。</strong></li>\n</ul>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/03.jpeg\" alt=\"HA总结.jpeg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/high-availability\">http://www.yunai.me/RocketMQ/high-availability</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Namesrv 高可用</a><ul>\n<li><a href=\"#\">2.1 Broker 注册到 Namesrv</a></li>\n<li><a href=\"#\">2.2 Producer、Consumer 访问 Namesrv</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. Broker 高可用</a><ul>\n<li><a href=\"#\">3.2 Broker 主从</a><ul>\n<li><a href=\"#\">3.1.1 配置</a></li>\n<li><a href=\"#\">3.1.2 组件</a></li>\n<li><a href=\"#\">3.1.3 通信协议</a></li>\n<li><a href=\"#\">3.1.4 Slave</a></li>\n<li><a href=\"#\">3.1.5 Master</a></li>\n<li><a href=\"#\">3.1.6 Master_SYNC</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.2 Producer 发送消息</a></li>\n<li><a href=\"#\">3.3 Consumer 消费消息</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 总结</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>本文主要解析 <code>Namesrv</code>、<code>Broker</code> 如何实现高可用，<code>Producer</code>、<code>Consumer</code> 怎么与它们通信保证高可用。</p>\n<h1 id=\"2-Namesrv-高可用\"><a href=\"#2-Namesrv-高可用\" class=\"headerlink\" title=\"2. Namesrv 高可用\"></a>2. Namesrv 高可用</h1><p><strong>启动多个 <code>Namesrv</code> 实现高可用。</strong><br>相较于 <code>Zookeeper</code>、<code>Consul</code>、<code>Etcd</code> 等，<code>Namesrv</code> 是一个<strong>超轻量级</strong>的注册中心，提供<strong>命名服务</strong>。</p>\n<h2 id=\"2-1-Broker-注册到-Namesrv\"><a href=\"#2-1-Broker-注册到-Namesrv\" class=\"headerlink\" title=\"2.1 Broker 注册到 Namesrv\"></a>2.1 Broker 注册到 Namesrv</h2><ul>\n<li>📌 <strong>多个 <code>Namesrv</code> 之间，没有任何关系（不存在类似 <code>Zookeeper</code> 的 <code>Leader</code>/<code>Follower</code> 等角色），不进行通信与数据同步。通过 <code>Broker</code> 循环注册多个 <code>Namesrv</code>。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【BrokerOuterAPI.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RegisterBrokerResult <span class=\"title\">registerBrokerAll</span><span class=\"params\">(</span></span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> String clusterName,</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> String brokerAddr,</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> String brokerName,</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerId,</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> String haServerAddr,</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> List&lt;String&gt; filterServerList,</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> oneway,</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeoutMills) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:     RegisterBrokerResult registerBrokerResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     List&lt;String&gt; nameServerAddressList = <span class=\"keyword\">this</span>.remotingClient.getNameServerAddressList();</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (nameServerAddressList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">for</span> (String namesrvAddr : nameServerAddressList) &#123; <span class=\"comment\">// 循环多个 Namesrv</span></div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 RegisterBrokerResult result = <span class=\"keyword\">this</span>.registerBroker(namesrvAddr, clusterName, brokerAddr, brokerName, brokerId,</div><div class=\"line\"><span class=\"number\">19</span>:                     haServerAddr, topicConfigWrapper, filterServerList, oneway, timeoutMills);</div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     registerBrokerResult = result;</div><div class=\"line\"><span class=\"number\">22</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:                 log.info(<span class=\"string\">\"register broker to name server &#123;&#125; OK\"</span>, namesrvAddr);</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 log.warn(<span class=\"string\">\"registerBroker Exception, &#123;&#125;\"</span>, namesrvAddr, e);</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">return</span> registerBrokerResult;</div><div class=\"line\"><span class=\"number\">32</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-Producer、Consumer-访问-Namesrv\"><a href=\"#2-2-Producer、Consumer-访问-Namesrv\" class=\"headerlink\" title=\"2.2 Producer、Consumer 访问 Namesrv\"></a>2.2 Producer、Consumer 访问 Namesrv</h2><ul>\n<li>📌 <strong><code>Producer</code>、<code>Consumer</code> 从 <code>Namesrv</code>列表选择一个可连接的进行通信。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【NettyRemotingClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> Channel <span class=\"title\">getAndCreateNameserverChannel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 返回已选择、可连接Namesrv</span></div><div class=\"line\"> <span class=\"number\">4</span>:     String addr = <span class=\"keyword\">this</span>.namesrvAddrChoosed.get();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         ChannelWrapper cw = <span class=\"keyword\">this</span>.channelTables.get(addr);</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (cw != <span class=\"keyword\">null</span> &amp;&amp; cw.isOK()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">return</span> cw.getChannel();</div><div class=\"line\"> <span class=\"number\">9</span>:         &#125;</div><div class=\"line\"><span class=\"number\">10</span>:     &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> List&lt;String&gt; addrList = <span class=\"keyword\">this</span>.namesrvAddrList.get();</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lockNamesrvChannel.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"comment\">// 返回已选择、可连接的Namesrv</span></div><div class=\"line\"><span class=\"number\">16</span>:             addr = <span class=\"keyword\">this</span>.namesrvAddrChoosed.get();</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (addr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 ChannelWrapper cw = <span class=\"keyword\">this</span>.channelTables.get(addr);</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">if</span> (cw != <span class=\"keyword\">null</span> &amp;&amp; cw.isOK()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     <span class=\"keyword\">return</span> cw.getChannel();</div><div class=\"line\"><span class=\"number\">21</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"comment\">// 从【Namesrv列表】中选择一个连接的返回</span></div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (addrList != <span class=\"keyword\">null</span> &amp;&amp; !addrList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addrList.size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">int</span> index = <span class=\"keyword\">this</span>.namesrvIndex.incrementAndGet();</div><div class=\"line\"><span class=\"number\">27</span>:                     index = Math.abs(index);</div><div class=\"line\"><span class=\"number\">28</span>:                     index = index % addrList.size();</div><div class=\"line\"><span class=\"number\">29</span>:                     String newAddr = addrList.get(index);</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">this</span>.namesrvAddrChoosed.set(newAddr);</div><div class=\"line\"><span class=\"number\">32</span>:                     Channel channelNew = <span class=\"keyword\">this</span>.createChannel(newAddr);</div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">if</span> (channelNew != <span class=\"keyword\">null</span>)</div><div class=\"line\"><span class=\"number\">34</span>:                         <span class=\"keyword\">return</span> channelNew;</div><div class=\"line\"><span class=\"number\">35</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">36</span>:             &#125;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:             log.error(<span class=\"string\">\"getAndCreateNameserverChannel: create name server channel exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">39</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">40</span>:             <span class=\"keyword\">this</span>.lockNamesrvChannel.unlock();</div><div class=\"line\"><span class=\"number\">41</span>:         &#125;</div><div class=\"line\"><span class=\"number\">42</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">43</span>:         log.warn(<span class=\"string\">\"getAndCreateNameserverChannel: try to lock name server, but timeout, &#123;&#125;ms\"</span>, LOCK_TIMEOUT_MILLIS);</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-Broker-高可用\"><a href=\"#3-Broker-高可用\" class=\"headerlink\" title=\"3. Broker 高可用\"></a>3. Broker 高可用</h1><p><strong>启动多个 <code>Broker分组</code> 形成 <code>集群</code> 实现高可用。</strong><br><strong><code>Broker分组</code> = <code>Master节点</code>x1 + <code>Slave节点</code>xN。</strong><br>类似 <code>MySQL</code>，<code>Master节点</code> 提供<strong>读写</strong>服务，<code>Slave节点</code> 只提供<strong>读</strong>服务。  </p>\n<h2 id=\"3-2-Broker-主从\"><a href=\"#3-2-Broker-主从\" class=\"headerlink\" title=\"3.2 Broker 主从\"></a>3.2 Broker 主从</h2><ul>\n<li><strong>每个分组，<code>Master</code>节点 不断发送新的 <code>CommitLog</code> 给 <code>Slave</code>节点。 <code>Slave</code>节点 不断上报本地的 <code>CommitLog</code> 已经同步到的位置给 <code>Master</code>节点。</strong></li>\n<li><strong><code>Broker分组</code> 与 <code>Broker分组</code> 之间没有任何关系，不进行通信与数据同步。</strong></li>\n<li><strong>消费进度 目前不支持 <code>Master</code>/<code>Slave</code> 同步。</strong></li>\n</ul>\n<p>集群内，<code>Master</code>节点 有<strong>两种</strong>类型：<code>Master_SYNC</code>、<code>Master_ASYNC</code>：前者在 <code>Producer</code> 发送消息时，等待 <code>Slave</code>节点 存储完毕后再返回发送结果，而后者不需要等待。</p>\n<h3 id=\"3-1-1-配置\"><a href=\"#3-1-1-配置\" class=\"headerlink\" title=\"3.1.1 配置\"></a>3.1.1 配置</h3><p>目前官方提供三套配置：</p>\n<ul>\n<li><strong>2m-2s-async</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>2m-2s-sync</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>SLAVE</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>2m-noslave</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>brokerClusterName</th>\n<th>brokerName</th>\n<th>brokerRole</th>\n<th>brokerId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-a</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n<tr>\n<td>DefaultCluster</td>\n<td>broker-b</td>\n<td>ASYNC_MASTER</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-2-组件\"><a href=\"#3-1-2-组件\" class=\"headerlink\" title=\"3.1.2 组件\"></a>3.1.2 组件</h3><p>再看具体实现代码之前，我们来看看 <code>Master</code>/<code>Slave</code>节点 包含的组件：<br><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/04.png\" alt=\"HA组件图.png\"></p>\n<ul>\n<li><code>Master</code>节点<ul>\n<li><code>AcceptSocketService</code> ：接收 <code>Slave</code>节点 连接。</li>\n<li><code>HAConnection</code><ul>\n<li><code>ReadSocketService</code> ：<strong>读</strong>来自 <code>Slave</code>节点 的数据。 </li>\n<li><code>WriteSocketService</code> ：<strong>写</strong>到往 <code>Slave</code>节点 的数据。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>Slave</code>节点<ul>\n<li><code>HAClient</code> ：对 <code>Master</code>节点 连接、读写数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-1-3-通信协议\"><a href=\"#3-1-3-通信协议\" class=\"headerlink\" title=\"3.1.3 通信协议\"></a>3.1.3 通信协议</h3><p><code>Master</code>节点 与 <code>Slave</code>节点 <strong>通信协议</strong>很简单，只有如下两条。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">对象</th>\n<th style=\"text-align:left\">用途</th>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Slave=&gt;Master</td>\n<td style=\"text-align:left\">上报CommitLog<strong>已经</strong>同步到的<strong>物理</strong>位置</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">maxPhyOffset</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">CommitLog最大物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Master=&gt;Slave</td>\n<td style=\"text-align:left\">传输新的 <code>CommitLog</code> 数据</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">fromPhyOffset</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">CommitLog开始物理位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">传输CommitLog数据长度</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">body</td>\n<td style=\"text-align:left\">Bytes</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">传输CommitLog数据</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"3-1-4-Slave\"><a href=\"#3-1-4-Slave\" class=\"headerlink\" title=\"3.1.4 Slave\"></a>3.1.4 Slave</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/02.png\" alt=\"HAClient顺序图\"></p>\n<hr>\n<ul>\n<li><strong><code>Slave</code> 主循环，实现了</strong>不断不断不断<strong>从 <code>Master</code> 传输 <code>CommitLog</code> 数据，上传 <code>Master</code> 自己本地的 <code>CommitLog</code> 已经同步物理位置。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【HAClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connectMaster()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"comment\">// 若到满足上报间隔，上报到Master进度</span></div><div class=\"line\"> <span class=\"number\">9</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isTimeToReportOffset()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                     <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.reportSlaveMaxOffset(<span class=\"keyword\">this</span>.currentReportedOffset);</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">if</span> (!result) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:                         <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">13</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">this</span>.selector.select(<span class=\"number\">1000</span>);</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"comment\">// 处理读取事件</span></div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">boolean</span> ok = <span class=\"keyword\">this</span>.processReadEvent();</div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> (!ok) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">22</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:                 <span class=\"comment\">// 若进度有变化，上报到Master进度</span></div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (!reportSlaveMaxOffsetPlus()) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"comment\">// Master过久未返回数据，关闭连接</span></div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">long</span> interval = HAService.<span class=\"keyword\">this</span>.getDefaultMessageStore().getSystemClock().now() - <span class=\"keyword\">this</span>.lastWriteTimestamp;</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">if</span> (interval &gt; HAService.<span class=\"keyword\">this</span>.getDefaultMessageStore().getMessageStoreConfig()</div><div class=\"line\"><span class=\"number\">32</span>:                     .getHaHousekeepingInterval()) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                     log.warn(<span class=\"string\">\"HAClient, housekeeping, found this connection[\"</span> + <span class=\"keyword\">this</span>.masterAddress</div><div class=\"line\"><span class=\"number\">34</span>:                         + <span class=\"string\">\"] expired, \"</span> + interval);</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">this</span>.closeMaster();</div><div class=\"line\"><span class=\"number\">36</span>:                     log.warn(<span class=\"string\">\"HAClient, master not response some time, so close connection\"</span>);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"number\">40</span>:             &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">1000</span> * <span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"number\">44</span>:         &#125;</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">48</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 8 至 14 行 ：<strong>固定间隔（默认5s）</strong>向 <code>Master</code> 上报 <code>Slave</code> 本地 <code>CommitLog</code> 已经同步到的物理位置。该操作还有<strong>心跳</strong>的作用。</li>\n<li>第 16 至 22 行 ：处理 <code>Master</code> 传输 <code>Slave</code> 的 <code>CommitLog</code> 数据。</li>\n</ul>\n<hr>\n<ul>\n<li><strong>我们来看看 <code>#dispatchReadRequest(...)</code> 与 <code>#reportSlaveMaxOffset(...)</code> 是怎么实现的。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// 【HAClient.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 读取Master传输的CommitLog数据，并返回是异常</div><div class=\"line\"> 4:  * 如果读取到数据，写入CommitLog</div><div class=\"line\"> 5:  * 异常原因：</div><div class=\"line\"> 6:  *   1. Master传输来的数据offset 不等于 Slave的CommitLog数据最大offset</div><div class=\"line\"> 7:  *   2. 上报到Master进度失败</div><div class=\"line\"> 8:  *</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 是否异常</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchReadRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> msgHeaderSize = <span class=\"number\">8</span> + <span class=\"number\">4</span>; <span class=\"comment\">// phyoffset + size</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">int</span> readSocketPos = <span class=\"keyword\">this</span>.byteBufferRead.position();</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 读取到请求</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">int</span> diff = <span class=\"keyword\">this</span>.byteBufferRead.position() - <span class=\"keyword\">this</span>.dispatchPostion;</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">if</span> (diff &gt;= msgHeaderSize) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"comment\">// 读取masterPhyOffset、bodySize。使用dispatchPostion的原因是：处理数据“粘包”导致数据读取不完整。</span></div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">long</span> masterPhyOffset = <span class=\"keyword\">this</span>.byteBufferRead.getLong(<span class=\"keyword\">this</span>.dispatchPostion);</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">int</span> bodySize = <span class=\"keyword\">this</span>.byteBufferRead.getInt(<span class=\"keyword\">this</span>.dispatchPostion + <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"comment\">// 校验 Master传输来的数据offset 是否和 Slave的CommitLog数据最大offset 是否相同。</span></div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">long</span> slavePhyOffset = HAService.<span class=\"keyword\">this</span>.defaultMessageStore.getMaxPhyOffset();</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (slavePhyOffset != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (slavePhyOffset != masterPhyOffset) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     log.error(<span class=\"string\">\"master pushed offset not equal the max phy offset in slave, SLAVE: \"</span></div><div class=\"line\"><span class=\"number\">27</span>:                         + slavePhyOffset + <span class=\"string\">\" MASTER: \"</span> + masterPhyOffset);</div><div class=\"line\"><span class=\"number\">28</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"comment\">// 读取到消息</span></div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (diff &gt;= (msgHeaderSize + bodySize)) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"comment\">// 写入CommitLog</span></div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">byte</span>[] bodyData = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[bodySize];</div><div class=\"line\"><span class=\"number\">35</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.position(<span class=\"keyword\">this</span>.dispatchPostion + msgHeaderSize);</div><div class=\"line\"><span class=\"number\">36</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.get(bodyData);</div><div class=\"line\"><span class=\"number\">37</span>:                 HAService.<span class=\"keyword\">this</span>.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData);</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"comment\">// 设置处理到的位置</span></div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">this</span>.byteBufferRead.position(readSocketPos);</div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"keyword\">this</span>.dispatchPostion += msgHeaderSize + bodySize;</div><div class=\"line\"><span class=\"number\">41</span>:                 <span class=\"comment\">// 上报到Master进度</span></div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"keyword\">if</span> (!reportSlaveMaxOffsetPlus()) &#123;</div><div class=\"line\"><span class=\"number\">43</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">44</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">45</span>:                 <span class=\"comment\">// 继续循环</span></div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">47</span>:             &#125;</div><div class=\"line\"><span class=\"number\">48</span>:         &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:         <span class=\"comment\">// 空间写满，重新分配空间</span></div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.reallocateByteBuffer();</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125;</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">59</span>: &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>: <span class=\"comment\">/**</span></div><div class=\"line\">62:  * 上报进度</div><div class=\"line\">63:  *</div><div class=\"line\">64:  * <span class=\"doctag\">@param</span> maxOffset 进度</div><div class=\"line\">65:  * <span class=\"doctag\">@return</span> 是否上报成功</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">reportSlaveMaxOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:     <span class=\"keyword\">this</span>.reportOffset.position(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">this</span>.reportOffset.limit(<span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">70</span>:     <span class=\"keyword\">this</span>.reportOffset.putLong(maxOffset);</div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"keyword\">this</span>.reportOffset.position(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"keyword\">this</span>.reportOffset.limit(<span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">73</span>: </div><div class=\"line\"><span class=\"number\">74</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span> &amp;&amp; <span class=\"keyword\">this</span>.reportOffset.hasRemaining(); i++) &#123;</div><div class=\"line\"><span class=\"number\">75</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">76</span>:             <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.reportOffset);</div><div class=\"line\"><span class=\"number\">77</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">78</span>:             log.error(<span class=\"keyword\">this</span>.getServiceName()</div><div class=\"line\"><span class=\"number\">79</span>:                 + <span class=\"string\">\"reportSlaveMaxOffset this.socketChannel.write exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">80</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">81</span>:         &#125;</div><div class=\"line\"><span class=\"number\">82</span>:     &#125;</div><div class=\"line\"><span class=\"number\">83</span>: </div><div class=\"line\"><span class=\"number\">84</span>:     <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.reportOffset.hasRemaining();</div><div class=\"line\"><span class=\"number\">85</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-1-5-Master\"><a href=\"#3-1-5-Master\" class=\"headerlink\" title=\"3.1.5 Master\"></a>3.1.5 Master</h3><ul>\n<li><strong><code>ReadSocketService</code> 逻辑同 <code>HAClient#processReadEvent(...)</code> 基本相同，我们直接看代码。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ReadSocketService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">processReadEvent</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">int</span> readSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// 清空byteBufferRead</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.byteBufferRead.flip();</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">this</span>.processPostion = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;</div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.byteBufferRead.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">int</span> readSize = <span class=\"keyword\">this</span>.socketChannel.read(<span class=\"keyword\">this</span>.byteBufferRead);</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">if</span> (readSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 readSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 设置最后读取时间</span></div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">this</span>.lastReadTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:                 <span class=\"keyword\">if</span> ((<span class=\"keyword\">this</span>.byteBufferRead.position() - <span class=\"keyword\">this</span>.processPostion) &gt;= <span class=\"number\">8</span>) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"comment\">// 读取Slave 请求来的CommitLog的最大位置</span></div><div class=\"line\"><span class=\"number\">22</span>:                     <span class=\"keyword\">int</span> pos = <span class=\"keyword\">this</span>.byteBufferRead.position() - (<span class=\"keyword\">this</span>.byteBufferRead.position() % <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">long</span> readOffset = <span class=\"keyword\">this</span>.byteBufferRead.getLong(pos - <span class=\"number\">8</span>);</div><div class=\"line\"><span class=\"number\">24</span>:                     <span class=\"keyword\">this</span>.processPostion = pos;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"comment\">// 设置Slave CommitLog的最大位置</span></div><div class=\"line\"><span class=\"number\">27</span>:                     HAConnection.<span class=\"keyword\">this</span>.slaveAckOffset = readOffset;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:                     <span class=\"comment\">// 设置Slave 第一次请求的位置</span></div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset = readOffset;</div><div class=\"line\"><span class=\"number\">32</span>:                         log.info(<span class=\"string\">\"slave[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr + <span class=\"string\">\"] request offset \"</span> + readOffset);</div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"comment\">// 通知目前Slave进度。主要用于Master节点为同步类型的。</span></div><div class=\"line\"><span class=\"number\">36</span>:                     HAConnection.<span class=\"keyword\">this</span>.haService.notifyTransferSome(HAConnection.<span class=\"keyword\">this</span>.slaveAckOffset);</div><div class=\"line\"><span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (++readSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">43</span>:                 log.error(<span class=\"string\">\"read socket[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr + <span class=\"string\">\"] &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">45</span>:             &#125;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             log.error(<span class=\"string\">\"processReadEvent exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">48</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">49</span>:         &#125;</div><div class=\"line\"><span class=\"number\">50</span>:     &#125;</div><div class=\"line\"><span class=\"number\">51</span>: </div><div class=\"line\"><span class=\"number\">52</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">53</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li><strong><code>WriteSocketService</code> 计算 <code>Slave</code>开始同步的位置后，不断向 <code>Slave</code> 传输新的 <code>CommitLog</code>数据。</strong></li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/01.png\" alt=\"HA.WriteSocketService流程图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【WriteSocketService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\">  <span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">4</span>:     HAConnection.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\">  <span class=\"number\">5</span>: </div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\">  <span class=\"number\">7</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.selector.select(<span class=\"number\">1000</span>);</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:             <span class=\"comment\">// 未获得Slave读取进度请求，sleep等待。</span></div><div class=\"line\"> <span class=\"number\">11</span>:             <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset) &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:                 Thread.sleep(<span class=\"number\">10</span>);</div><div class=\"line\"> <span class=\"number\">13</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">14</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"comment\">// 计算初始化nextTransferFromWhere</span></div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == <span class=\"keyword\">this</span>.nextTransferFromWhere) &#123;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:                     <span class=\"keyword\">long</span> masterOffset = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();</div><div class=\"line\"> <span class=\"number\">20</span>:                     masterOffset = masterOffset - (masterOffset % HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getMapedFileSizeCommitLog());</div><div class=\"line\"> <span class=\"number\">21</span>:                     <span class=\"keyword\">if</span> (masterOffset &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:                         masterOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:                     <span class=\"keyword\">this</span>.nextTransferFromWhere = masterOffset;</div><div class=\"line\"> <span class=\"number\">26</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:                     <span class=\"keyword\">this</span>.nextTransferFromWhere = HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset;</div><div class=\"line\"> <span class=\"number\">28</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:                 log.info(<span class=\"string\">\"master transfer data from \"</span> + <span class=\"keyword\">this</span>.nextTransferFromWhere + <span class=\"string\">\" to slave[\"</span> + HAConnection.<span class=\"keyword\">this</span>.clientAddr</div><div class=\"line\"> <span class=\"number\">31</span>:                     + <span class=\"string\">\"], and slave request \"</span> + HAConnection.<span class=\"keyword\">this</span>.slaveRequestOffset);</div><div class=\"line\"> <span class=\"number\">32</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lastWriteOver) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">long</span> interval = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now() - <span class=\"keyword\">this</span>.lastWriteTimestamp;</div><div class=\"line\"> <span class=\"number\">36</span>:                 <span class=\"keyword\">if</span> (interval &gt; HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) &#123; <span class=\"comment\">// 心跳</span></div><div class=\"line\"> <span class=\"number\">37</span>: </div><div class=\"line\"> <span class=\"number\">38</span>:                     <span class=\"comment\">// Build Header</span></div><div class=\"line\"> <span class=\"number\">39</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.limit(headerSize);</div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.putLong(<span class=\"keyword\">this</span>.nextTransferFromWhere);</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.putInt(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:                     <span class=\"keyword\">this</span>.byteBufferHeader.flip();</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:                     <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">46</span>:                     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.lastWriteOver)</div><div class=\"line\"> <span class=\"number\">47</span>:                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 未传输完成，继续传输</span></div><div class=\"line\"> <span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">51</span>:                 <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.lastWriteOver)</div><div class=\"line\"> <span class=\"number\">52</span>:                     <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">53</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:             <span class=\"comment\">// 选择新的CommitLog数据进行传输</span></div><div class=\"line\"> <span class=\"number\">56</span>:             SelectMappedBufferResult selectResult =</div><div class=\"line\"> <span class=\"number\">57</span>:                 HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class=\"keyword\">this</span>.nextTransferFromWhere);</div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"keyword\">if</span> (selectResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"keyword\">int</span> size = selectResult.getSize();</div><div class=\"line\"> <span class=\"number\">60</span>:                 <span class=\"keyword\">if</span> (size &gt; HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) &#123;</div><div class=\"line\"> <span class=\"number\">61</span>:                     size = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();</div><div class=\"line\"> <span class=\"number\">62</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"keyword\">long</span> thisOffset = <span class=\"keyword\">this</span>.nextTransferFromWhere;</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"keyword\">this</span>.nextTransferFromWhere += size;</div><div class=\"line\"> <span class=\"number\">66</span>: </div><div class=\"line\"> <span class=\"number\">67</span>:                 selectResult.getByteBuffer().limit(size);</div><div class=\"line\"> <span class=\"number\">68</span>:                 <span class=\"keyword\">this</span>.selectMappedBufferResult = selectResult;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:                 <span class=\"comment\">// Build Header</span></div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.limit(headerSize);</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.putLong(thisOffset);</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.putInt(size);</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">this</span>.byteBufferHeader.flip();</div><div class=\"line\"> <span class=\"number\">76</span>: </div><div class=\"line\"> <span class=\"number\">77</span>:                 <span class=\"keyword\">this</span>.lastWriteOver = <span class=\"keyword\">this</span>.transferData();</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 没新的消息，挂起等待</span></div><div class=\"line\"> <span class=\"number\">79</span>:                 HAConnection.<span class=\"keyword\">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class=\"number\">100</span>);</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>:             HAConnection.log.error(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception.\"</span>, e);</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"comment\">// 断开连接 &amp; 暂停写线程 &amp; 暂停读线程 &amp; 释放CommitLog</span></div><div class=\"line\"> <span class=\"number\">89</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.selectMappedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult.release();</div><div class=\"line\"> <span class=\"number\">91</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">this</span>.makeStop();</div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:     readSocketService.makeStop();</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:     haService.removeConnection(HAConnection.<span class=\"keyword\">this</span>);</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:     SelectionKey sk = <span class=\"keyword\">this</span>.socketChannel.keyFor(<span class=\"keyword\">this</span>.selector);</div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">if</span> (sk != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:         sk.cancel();</div><div class=\"line\"><span class=\"number\">102</span>:     &#125;</div><div class=\"line\"><span class=\"number\">103</span>: </div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">this</span>.selector.close();</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">this</span>.socketChannel.close();</div><div class=\"line\"><span class=\"number\">107</span>:     &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">108</span>:         HAConnection.log.error(<span class=\"string\">\"\"</span>, e);</div><div class=\"line\"><span class=\"number\">109</span>:     &#125;</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:     HAConnection.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">112</span>: &#125;</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>: <span class=\"comment\">/**</span></div><div class=\"line\">115:  * 传输数据</div><div class=\"line\">116:  */</div><div class=\"line\"><span class=\"number\">117</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferData</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"keyword\">int</span> writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">119</span>:     <span class=\"comment\">// Write Header</span></div><div class=\"line\"><span class=\"number\">120</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"keyword\">int</span> writeSize = <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.byteBufferHeader);</div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"keyword\">if</span> (writeSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">123</span>:             writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">this</span>.lastWriteTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">125</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (writeSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             <span class=\"keyword\">if</span> (++writeSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">127</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"ha master write header error &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">131</span>:         &#125;</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.selectMappedBufferResult) &#123;</div><div class=\"line\"><span class=\"number\">135</span>:         <span class=\"keyword\">return</span> !<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining();</div><div class=\"line\"><span class=\"number\">136</span>:     &#125;</div><div class=\"line\"><span class=\"number\">137</span>: </div><div class=\"line\"><span class=\"number\">138</span>:     writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">139</span>: </div><div class=\"line\"><span class=\"number\">140</span>:     <span class=\"comment\">// Write Body</span></div><div class=\"line\"><span class=\"number\">141</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:         <span class=\"keyword\">while</span> (<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:             <span class=\"keyword\">int</span> writeSize = <span class=\"keyword\">this</span>.socketChannel.write(<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer());</div><div class=\"line\"><span class=\"number\">144</span>:             <span class=\"keyword\">if</span> (writeSize &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                 writeSizeZeroTimes = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">146</span>:                 <span class=\"keyword\">this</span>.lastWriteTimestamp = HAConnection.<span class=\"keyword\">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</div><div class=\"line\"><span class=\"number\">147</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (writeSize == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">if</span> (++writeSizeZeroTimes &gt;= <span class=\"number\">3</span>) &#123;</div><div class=\"line\"><span class=\"number\">149</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">151</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">152</span>:                 <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"ha master write body error &lt; 0\"</span>);</div><div class=\"line\"><span class=\"number\">153</span>:             &#125;</div><div class=\"line\"><span class=\"number\">154</span>:         &#125;</div><div class=\"line\"><span class=\"number\">155</span>:     &#125;</div><div class=\"line\"><span class=\"number\">156</span>: </div><div class=\"line\"><span class=\"number\">157</span>:     <span class=\"keyword\">boolean</span> result = !<span class=\"keyword\">this</span>.byteBufferHeader.hasRemaining() &amp;&amp; !<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining();</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.selectMappedBufferResult.getByteBuffer().hasRemaining()) &#123;</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult.release();</div><div class=\"line\"><span class=\"number\">161</span>:         <span class=\"keyword\">this</span>.selectMappedBufferResult = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">162</span>:     &#125;</div><div class=\"line\"><span class=\"number\">163</span>: </div><div class=\"line\"><span class=\"number\">164</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">165</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-1-6-Master-SYNC\"><a href=\"#3-1-6-Master-SYNC\" class=\"headerlink\" title=\"3.1.6 Master_SYNC\"></a>3.1.6 Master_SYNC</h3><ul>\n<li><strong><code>Producer</code> 发送消息时，<code>Master_SYNC</code>节点 会等待 <code>Slave</code>节点 存储完毕后再返回发送结果。</strong></li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// ....省略处理发送代码 </span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"comment\">// Synchronous write double 如果是同步Master，同步到从节点</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (BrokerRole.SYNC_MASTER == <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         HAService service = <span class=\"keyword\">this</span>.defaultMessageStore.getHaService();</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">if</span> (msg.isWaitStoreMsgOK()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"comment\">// Determine whether to wait</span></div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == request) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     request = <span class=\"keyword\">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:                 service.putRequest(request);</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"comment\">// 唤醒WriteSocketService</span></div><div class=\"line\"><span class=\"number\">16</span>:                 service.getWaitNotifyObject().wakeupAll();</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">boolean</span> flushOK = request.waitForFlush(<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">if</span> (!flushOK) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     log.error(<span class=\"string\">\"do sync transfer other node, wait return, but failed, topic: \"</span> + msg.getTopic() + <span class=\"string\">\" tags: \"</span></div><div class=\"line\"><span class=\"number\">21</span>:                         + msg.getTags() + <span class=\"string\">\" client address: \"</span> + msg.getBornHostString());</div><div class=\"line\"><span class=\"number\">22</span>:                     putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</div><div class=\"line\"><span class=\"number\">23</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">24</span>:             &#125;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// Slave problem</span></div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                 <span class=\"comment\">// Tell the producer, slave not available</span></div><div class=\"line\"><span class=\"number\">28</span>:                 putMessageResult.setPutMessageStatus(PutMessageStatus.SLAVE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">29</span>:             &#125;</div><div class=\"line\"><span class=\"number\">30</span>:         &#125;</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">return</span> putMessageResult;</div><div class=\"line\"><span class=\"number\">34</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：唤醒 <code>WriteSocketService</code>。<ul>\n<li>唤醒后，<code>WriteSocketService</code> 挂起等待新消息结束，<code>Master</code> 传输 <code>Slave</code> 新的 <code>CommitLog</code> 数据。</li>\n<li><code>Slave</code> 收到数据后，<strong>立即</strong>上报最新的 <code>CommitLog</code> 同步进度到 <code>Master</code>。<code>ReadSocketService</code> 唤醒<strong>第 18 行</strong>：<code>request#waitForFlush(...)</code>。</li>\n</ul>\n</li>\n</ul>\n<p>我们来看下 <code>GroupTransferService</code> 的核心逻辑代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【GroupTransferService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doWaitTransfer</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">for</span> (CommitLog.GroupCommitRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 <span class=\"comment\">// 等待Slave上传进度</span></div><div class=\"line\"> <span class=\"number\">7</span>:                 <span class=\"keyword\">boolean</span> transferOK = HAService.<span class=\"keyword\">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; !transferOK &amp;&amp; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">this</span>.notifyTransferObject.waitForRunning(<span class=\"number\">1000</span>); <span class=\"comment\">// 唤醒</span></div><div class=\"line\"><span class=\"number\">10</span>:                     transferOK = HAService.<span class=\"keyword\">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</div><div class=\"line\"><span class=\"number\">11</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (!transferOK) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     log.warn(<span class=\"string\">\"transfer messsage to slave timeout, \"</span> + req.getNextOffset());</div><div class=\"line\"><span class=\"number\">15</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 唤醒请求，并设置是否Slave同步成功</span></div><div class=\"line\"><span class=\"number\">18</span>:                 req.wakeupCustomer(transferOK);</div><div class=\"line\"><span class=\"number\">19</span>:             &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.requestsRead.clear();</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>:     &#125;</div><div class=\"line\"><span class=\"number\">24</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Producer-发送消息\"><a href=\"#3-2-Producer-发送消息\" class=\"headerlink\" title=\"3.2 Producer 发送消息\"></a>3.2 Producer 发送消息</h2><ul>\n<li><strong><code>Producer</code> 发送消息时，会对 <code>Broker</code>集群 的所有队列进行选择。</strong></li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> SendResult <span class=\"title\">sendDefaultImpl</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">3</span>:     Message msg, //</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode, //</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> SendCallback sendCallback, //</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeout//</div><div class=\"line\"> <span class=\"number\">7</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// .... 省略：处理【校验逻辑】</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// 获取 Topic路由信息</span></div><div class=\"line\"><span class=\"number\">10</span>:     TopicPublishInfo topicPublishInfo = <span class=\"keyword\">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">if</span> (topicPublishInfo != <span class=\"keyword\">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         MessageQueue mq = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后选择消息要发送到的队列</span></div><div class=\"line\"><span class=\"number\">13</span>:         Exception exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         SendResult sendResult = <span class=\"keyword\">null</span>; <span class=\"comment\">// 最后一次发送结果</span></div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class=\"number\">1</span>; <span class=\"comment\">// 同步多次调用</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">int</span> times = <span class=\"number\">0</span>; <span class=\"comment\">// 第几次发送</span></div><div class=\"line\"><span class=\"number\">17</span>:         String[] brokersSent = <span class=\"keyword\">new</span> String[timesTotal]; <span class=\"comment\">// 存储每次发送消息选择的broker名</span></div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"comment\">// 循环调用发送消息，直到成功</span></div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">for</span> (; times &lt; timesTotal; times++) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             String lastBrokerName = <span class=\"keyword\">null</span> == mq ? <span class=\"keyword\">null</span> : mq.getBrokerName();</div><div class=\"line\"><span class=\"number\">21</span>:             MessageQueue tmpmq = <span class=\"keyword\">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName); <span class=\"comment\">// 选择消息要发送到的队列</span></div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">if</span> (tmpmq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:                 mq = tmpmq;</div><div class=\"line\"><span class=\"number\">24</span>:                 brokersSent[times] = mq.getBrokerName();</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                     beginTimestampPrev = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">27</span>:                     <span class=\"comment\">// 调用发送消息核心方法</span></div><div class=\"line\"><span class=\"number\">28</span>:                     sendResult = <span class=\"keyword\">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</div><div class=\"line\"><span class=\"number\">29</span>:                     endTimestamp = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"comment\">// 更新Broker可用性信息</span></div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">32</span>:                     <span class=\"comment\">// .... 省略：处理【发送返回结果】</span></div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>:                 &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// .... 省略：处理【异常】</span></div><div class=\"line\"><span class=\"number\">35</span>:                     </div><div class=\"line\"><span class=\"number\">36</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">37</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">39</span>:             &#125;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"comment\">// .... 省略：处理【发送返回结果】</span></div><div class=\"line\"><span class=\"number\">42</span>:     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"comment\">// .... 省略：处理【找不到消息路由】</span></div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<p>如下是调试 <code>#sendDefaultImpl(...)</code> 时 <code>TopicPublishInfo</code> 的结果，<code>Producer</code> 获得到了 <code>broker-a</code>,<code>broker-b</code> 两个 <code>Broker</code>分组 的消息队列：<br><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/05.png\" alt=\"Producer.TopicPublishInfo.调试.png\"></p>\n<h2 id=\"3-3-Consumer-消费消息\"><a href=\"#3-3-Consumer-消费消息\" class=\"headerlink\" title=\"3.3 Consumer 消费消息\"></a>3.3 Consumer 消费消息</h2><ul>\n<li><strong><code>Consumer</code> 消费消息时，会对 <code>Broker</code>集群 的所有队列进行选择。</strong></li>\n</ul>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_14/03.jpeg\" alt=\"HA总结.jpeg\"></p>\n"},{"title":"RocketMQ 源码分析 —— 定时消息与消息重试","date":"2017-05-14T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-schedule-and-retry](http://www.yunai.me/RocketMQ/message-schedule-and-retry)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 定时消息](#)\n\t- [2.1 延迟级别](#)\n\t- [2.2 Producer 发送定时消息](#)\n\t- [2.3 Broker 存储定时消息](#)\n\t- [2.4 Broker 发送定时消息](#)\n\t- [2.5 Broker 持久化定时发送进度](#)\n- [3. 消息重试](#)\n\n# 1. 概述\n\n**建议**前置阅读内容：\n\n* [《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)\n* [《RocketMQ 源码分析 —— Message 拉取与消费（下）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)\n\n😈 为什么把**定时消息**与**消息重试**放在一起？你猜。  \n👻 你猜我猜不猜。\n\n# 2. 定时消息\n\n> **定时消息**是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。\n\n下图是**定时消息**的处理逻辑图：\n\n![定时消息逻辑图.png](http://www.yunai.me/images/RocketMQ/2017_05_15/02.png)\n\n## 2.1 延迟级别\n\n`RocketMQ` 目前只支持**固定精度**的定时消息。官方说法如下：\n> 如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。\n\n* 延迟级别：\n\n| 延迟级别 | 时间 |\n| --- | --- |\n| 1   |  1s |\n| 2   |  5s |\n| 3   | 10s |\n| 4   | 30s |\n| 5   |  1m |\n| 6   |  2m |\n| 7   |  3m |\n| 8   | 4m  |\n| 9   | 5m  |\n| 10  | 6m  |\n| 11  | 7m  |\n| 12  | 8m  |\n| 13  | 9m  |\n| 14  | 10m |\n| 15  | 20m |\n| 16  | 30m |\n| 17  | 1h  |\n| 18  | 2h  |\n\n* 核心源码如下：\n\n    ```Java\n      1: // ⬇️⬇️⬇️【MessageStoreConfig.java】\n      2: /**\n      3:  * 消息延迟级别字符串配置\n      4:  */\n      5: private String messageDelayLevel = \"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\";\n      6: \n      7: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n      8: /**\n      9:  * 解析延迟级别\n     10:  *\n     11:  * @return 是否解析成功\n     12:  */\n     13: public boolean parseDelayLevel() {\n     14:     HashMap<String, Long> timeUnitTable = new HashMap<>();\n     15:     timeUnitTable.put(\"s\", 1000L);\n     16:     timeUnitTable.put(\"m\", 1000L * 60);\n     17:     timeUnitTable.put(\"h\", 1000L * 60 * 60);\n     18:     timeUnitTable.put(\"d\", 1000L * 60 * 60 * 24);\n     19: \n     20:     String levelString = this.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();\n     21:     try {\n     22:         String[] levelArray = levelString.split(\" \");\n     23:         for (int i = 0; i < levelArray.length; i++) {\n     24:             String value = levelArray[i];\n     25:             String ch = value.substring(value.length() - 1);\n     26:             Long tu = timeUnitTable.get(ch);\n     27: \n     28:             int level = i + 1;\n     29:             if (level > this.maxDelayLevel) {\n     30:                 this.maxDelayLevel = level;\n     31:             }\n     32:             long num = Long.parseLong(value.substring(0, value.length() - 1));\n     33:             long delayTimeMillis = tu * num;\n     34:             this.delayLevelTable.put(level, delayTimeMillis);\n     35:         }\n     36:     } catch (Exception e) {\n     37:         log.error(\"parseDelayLevel exception\", e);\n     38:         log.info(\"levelString String = {}\", levelString);\n     39:         return false;\n     40:     }\n     41: \n     42:     return true;\n     43: }\n    ```\n\n## 2.2 Producer 发送定时消息\n\n* 🦅发送时，设置消息的**延迟级别**。\n\n```Java\nMessage msg = new Message(...);\nmsg.setDelayTimeLevel(level);\n```\n\n## 2.3 Broker 存储定时消息\n\n* 🦅 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX`。\n* 🦅 延迟级别 与 消息队列编号 做**固定映射：QueueId = DelayLevel - 1**。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: /**\n  3:  * 添加消息，返回消息结果\n  4:  *\n  5:  * @param msg 消息\n  6:  * @return 结果\n  7:  */\n  8: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  9:     // ....(省略代码) \n 10: \n 11:     // 定时消息处理\n 12:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n 13:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//\n 14:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n 15:         // Delay Delivery\n 16:         if (msg.getDelayTimeLevel() > 0) {\n 17:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 18:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n 19:             }\n 20: \n 21:             // 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX` 。\n 22:             topic = ScheduleMessageService.SCHEDULE_TOPIC;\n 23: \n 24:             // 延迟级别 与 消息队列编号 做固定映射\n 25:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n 26: \n 27:             // Backup real topic, queueId\n 28:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n 30:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n 31: \n 32:             msg.setTopic(topic);\n 33:             msg.setQueueId(queueId);\n 34:         }\n 35:     }\n 36: \n 37:     // ....(省略代码) \n 38: }\n 39: \n 40: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n 41: /**\n 42:  * 根据 延迟级别 计算 消息队列编号\n 43:  * QueueId = DelayLevel - 1\n 44:  *\n 45:  * @param delayLevel 延迟级别\n 46:  * @return 消息队列编号\n 47:  */\n 48: public static int delayLevel2QueueId(final int delayLevel) {\n 49:     return delayLevel - 1;\n 50: }\n```\n\n-------\n\n* 🦅 生成 `ConsumeQueue` 时，每条消息的 `tagsCode` 使用【消息计划消费时间】。这样，`ScheduleMessageService` 在轮询 `ConsumeQueue` 时，可以使用 `tagsCode` 进行过滤。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: /**\n  3:  * check the message and returns the message size\n  4:  *\n  5:  * @return 0 Come the end of the file // >0 Normal messages // -1 Message checksum failure\n  6:  */\n  7: public DispatchRequest checkMessageAndReturnSize(ByteBuffer byteBuffer, final boolean checkCRC, final boolean readBody) {\n  8:     try {\n  9:         // // ....(省略代码)\n 10: \n 11:         // 17 properties\n 12:         short propertiesLength = byteBuffer.getShort();\n 13:         if (propertiesLength > 0) {\n 14:             // ....(省略代码)\n 15:             String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);\n 16:             if (tags != null && tags.length() > 0) {\n 17:                 tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);\n 18:             }\n 19: \n 20:             // Timing message processing\n 21:             {\n 22:                 String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);\n 23:                 if (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) && t != null) {\n 24:                     int delayLevel = Integer.parseInt(t);\n 25: \n 26:                     if (delayLevel > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 27:                         delayLevel = this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();\n 28:                     }\n 29: \n 30:                     if (delayLevel > 0) {\n 31:                         tagsCode = this.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,\n 32:                             storeTimestamp);\n 33:                     }\n 34:                 }\n 35:             }\n 36:         }\n 37: \n 38:         // ....(省略代码)\n 39: \n 40:         return new DispatchRequest(//\n 41:             topic, // 1\n 42:             queueId, // 2\n 43:             physicOffset, // 3\n 44:             totalSize, // 4\n 45:             tagsCode, // 5\n 46:             storeTimestamp, // 6\n 47:             queueOffset, // 7\n 48:             keys, // 8\n 49:             uniqKey, //9\n 50:             sysFlag, // 9\n 51:             preparedTransactionOffset// 10\n 52:         );\n 53:     } catch (Exception e) {\n 54:     }\n 55: \n 56:     return new DispatchRequest(-1, false /* success */);\n 57: }\n 58: \n 59: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n 60: /**\n 61:  * 计算 投递时间【计划消费时间】\n 62:  *\n 63:  * @param delayLevel 延迟级别\n 64:  * @param storeTimestamp 存储时间\n 65:  * @return 投递时间【计划消费时间】\n 66:  */\n 67: public long computeDeliverTimestamp(final int delayLevel, final long storeTimestamp) {\n 68:     Long time = this.delayLevelTable.get(delayLevel);\n 69:     if (time != null) {\n 70:         return time + storeTimestamp;\n 71:     }\n 72: \n 73:     return storeTimestamp + 1000;\n 74: }\n```\n\n## 2.4 Broker 发送定时消息\n\n* 🦅 对 `SCHEDULE_TOPIC_XXXX` 每条消费队列对应**单独一个**定时任务进行轮询，发送 **到达投递时间【计划消费时间】** 的消息。\n\n下图是发送定时消息的处理逻辑图：\n\n![定时消息定时逻辑](http://www.yunai.me/images/RocketMQ/2017_05_15/01.png)\n\n实现代码如下：\n\n```Java\n  1: /**\n  2:  * ⬇️⬇️⬇️ 发送（投递）延迟消息定时任务\n  3:  */\n  4: class DeliverDelayedMessageTimerTask extends TimerTask {\n  5:     /**\n  6:      * 延迟级别\n  7:      */\n  8:     private final int delayLevel;\n  9:     /**\n 10:      * 位置\n 11:      */\n 12:     private final long offset;\n 13: \n 14:     public DeliverDelayedMessageTimerTask(int delayLevel, long offset) {\n 15:         this.delayLevel = delayLevel;\n 16:         this.offset = offset;\n 17:     }\n 18: \n 19:     @Override\n 20:     public void run() {\n 21:         try {\n 22:             this.executeOnTimeup();\n 23:         } catch (Exception e) {\n 24:             // XXX: warn and notify me\n 25:             log.error(\"ScheduleMessageService, executeOnTimeup exception\", e);\n 26:             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(\n 27:                 this.delayLevel, this.offset), DELAY_FOR_A_PERIOD);\n 28:         }\n 29:     }\n 30: \n 31:     /**\n 32:      * 纠正可投递时间。\n 33:      * 因为发送级别对应的发送间隔可以调整，如果超过当前间隔，则修正成当前配置，避免后面的消息无法发送。\n 34:      *\n 35:      * @param now 当前时间\n 36:      * @param deliverTimestamp 投递时间\n 37:      * @return 纠正结果\n 38:      */\n 39:     private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {\n 40:         long result = deliverTimestamp;\n 41: \n 42:         long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n 43:         if (deliverTimestamp > maxTimestamp) {\n 44:             result = now;\n 45:         }\n 46: \n 47:         return result;\n 48:     }\n 49: \n 50:     public void executeOnTimeup() {\n 51:         ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));\n 52: \n 53:         long failScheduleOffset = offset;\n 54: \n 55:         if (cq != null) {\n 56:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n 57:             if (bufferCQ != null) {\n 58:                 try {\n 59:                     long nextOffset = offset;\n 60:                     int i = 0;\n 61:                     for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n 62:                         long offsetPy = bufferCQ.getByteBuffer().getLong();\n 63:                         int sizePy = bufferCQ.getByteBuffer().getInt();\n 64:                         long tagsCode = bufferCQ.getByteBuffer().getLong();\n 65: \n 66:                         long now = System.currentTimeMillis();\n 67:                         long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n 68: \n 69:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n 70: \n 71:                         long countdown = deliverTimestamp - now;\n 72: \n 73:                         if (countdown <= 0) { // 消息到达可发送时间\n 74:                             MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n 75:                             if (msgExt != null) {\n 76:                                 try {\n 77:                                     // 发送消息\n 78:                                     MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);\n 79:                                     PutMessageResult putMessageResult = ScheduleMessageService.this.defaultMessageStore.putMessage(msgInner);\n 80:                                     if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) { // 发送成功\n 81:                                         continue;\n 82:                                     } else { // 发送失败\n 83:                                         // XXX: warn and notify me\n 84:                                         log.error(\"ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}\", msgExt.getTopic(), msgExt.getMsgId());\n 85: \n 86:                                         // 安排下一次任务\n 87:                                         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);\n 88: \n 89:                                         // 更新进度\n 90:                                         ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n 91:                                         return;\n 92:                                     }\n 93:                                 } catch (Exception e) {\n 94:                                     // XXX: warn and notify me\n 95:                                     log.error(\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\"\n 96:                                             + msgExt + \", nextOffset=\" + nextOffset + \",offsetPy=\" + offsetPy + \",sizePy=\" + sizePy, e);\n 97:                                 }\n 98:                             }\n 99:                         } else {\n100:                             // 安排下一次任务\n101:                             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown);\n102: \n103:                             // 更新进度\n104:                             ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n105:                             return;\n106:                         }\n107:                     } // end of for\n108: \n109:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n110: \n111:                     // 安排下一次任务\n112:                     ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);\n113: \n114:                     // 更新进度\n115:                     ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n116:                     return;\n117:                 } finally {\n118:                     bufferCQ.release();\n119:                 }\n120:             } // end of if (bufferCQ != null)\n121:             else { // 消费队列已经被删除部分，跳转到最小的消费进度\n122:                 long cqMinOffset = cq.getMinOffsetInQueue();\n123:                 if (offset < cqMinOffset) {\n124:                     failScheduleOffset = cqMinOffset;\n125:                     log.error(\"schedule CQ offset invalid. offset=\" + offset + \", cqMinOffset=\"\n126:                         + cqMinOffset + \", queueId=\" + cq.getQueueId());\n127:                 }\n128:             }\n129:         } // end of if (cq != null)\n130: \n131:         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);\n132:     }\n133: \n134:     /**\n135:      * 设置消息内容\n136:      *\n137:      * @param msgExt 消息\n138:      * @return 消息\n139:      */\n140:     private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {\n141:         MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n142:         msgInner.setBody(msgExt.getBody());\n143:         msgInner.setFlag(msgExt.getFlag());\n144:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());\n145: \n146:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());\n147:         long tagsCodeValue =\n148:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());\n149:         msgInner.setTagsCode(tagsCodeValue);\n150:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));\n151: \n152:         msgInner.setSysFlag(msgExt.getSysFlag());\n153:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());\n154:         msgInner.setBornHost(msgExt.getBornHost());\n155:         msgInner.setStoreHost(msgExt.getStoreHost());\n156:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());\n157: \n158:         msgInner.setWaitStoreMsgOK(false);\n159:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);\n160: \n161:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));\n162: \n163:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);\n164:         int queueId = Integer.parseInt(queueIdStr);\n165:         msgInner.setQueueId(queueId);\n166: \n167:         return msgInner;\n168:     }\n169: }\n```\n\n## 2.5 Broker 持久化定时发送进度\n\n* 🦅 定时消息发送进度存储在文件(`../config/delayOffset.json`)里\n* 🦅 每 10s 定时持久化发送进度。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n  2: /**\n  3: public void start() {\n  4:     // 定时发送消息\n  5:     for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n  6:         Integer level = entry.getKey();\n  7:         Long timeDelay = entry.getValue();\n  8:         Long offset = this.offsetTable.get(level);\n  9:         if (null == offset) {\n 10:             offset = 0L;\n 11:         }\n 12: \n 13:         if (timeDelay != null) {\n 14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);\n 15:         }\n 16:     }\n 17: \n 18:     // 定时持久化发送进度\n 19:     this.timer.scheduleAtFixedRate(new TimerTask() {\n 20: \n 21:         @Override\n 22:         public void run() {\n 23:             try {\n 24:                 ScheduleMessageService.this.persist();\n 25:             } catch (Exception e) {\n 26:                 log.error(\"scheduleAtFixedRate flush exception\", e);\n 27:             }\n 28:         }\n 29:     }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());\n 30: }\n```\n\n# 3. 消息重试\n\n> Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。\n\n* 🦅 `Consumer` 将消费失败的消息发回 `Broker`，进入**延迟消息队列**。即，消费失败的消息，不会立即消费。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SendMessageProcessor.java】\n  2: /**\n  3:  * 消费者发回消息\n  4:  *\n  5:  * @param ctx ctx\n  6:  * @param request 请求\n  7:  * @return 响应\n  8:  * @throws RemotingCommandException 当远程调用异常\n  9:  */\n 10: private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)\n 11:     throws RemotingCommandException {\n 12:     // ....(省略代码)\n 13:     // 处理 delayLevel（独有）。\n 14:     int delayLevel = requestHeader.getDelayLevel();\n 15:     int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 16:     if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 17:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 18:     }\n 19:     if (msgExt.getReconsumeTimes() >= maxReconsumeTimes//\n 20:     // ....(省略代码)\n 21:     } else {\n 22:         if (0 == delayLevel) {\n 23:             delayLevel = 3 + msgExt.getReconsumeTimes();\n 24:         }\n 25:         msgExt.setDelayTimeLevel(delayLevel);\n 26:     }\n 27: \n 28:     // ....(省略代码)\n 29:     return response;\n 30: }\n```\n\n","source":"_posts/RocketMQ/2017_05_15_RocketMQ源码分析——定时消息与消息重试.md","raw":"title: RocketMQ 源码分析 —— 定时消息与消息重试\ndate: 2017-05-15\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-schedule-and-retry\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-schedule-and-retry](http://www.yunai.me/RocketMQ/message-schedule-and-retry)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 定时消息](#)\n\t- [2.1 延迟级别](#)\n\t- [2.2 Producer 发送定时消息](#)\n\t- [2.3 Broker 存储定时消息](#)\n\t- [2.4 Broker 发送定时消息](#)\n\t- [2.5 Broker 持久化定时发送进度](#)\n- [3. 消息重试](#)\n\n# 1. 概述\n\n**建议**前置阅读内容：\n\n* [《RocketMQ 源码分析 —— Message 发送与接收》](http://www.yunai.me/RocketMQ/message-send-and-receive/)\n* [《RocketMQ 源码分析 —— Message 拉取与消费（下）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)\n\n😈 为什么把**定时消息**与**消息重试**放在一起？你猜。  \n👻 你猜我猜不猜。\n\n# 2. 定时消息\n\n> **定时消息**是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。\n\n下图是**定时消息**的处理逻辑图：\n\n![定时消息逻辑图.png](http://www.yunai.me/images/RocketMQ/2017_05_15/02.png)\n\n## 2.1 延迟级别\n\n`RocketMQ` 目前只支持**固定精度**的定时消息。官方说法如下：\n> 如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。\n\n* 延迟级别：\n\n| 延迟级别 | 时间 |\n| --- | --- |\n| 1   |  1s |\n| 2   |  5s |\n| 3   | 10s |\n| 4   | 30s |\n| 5   |  1m |\n| 6   |  2m |\n| 7   |  3m |\n| 8   | 4m  |\n| 9   | 5m  |\n| 10  | 6m  |\n| 11  | 7m  |\n| 12  | 8m  |\n| 13  | 9m  |\n| 14  | 10m |\n| 15  | 20m |\n| 16  | 30m |\n| 17  | 1h  |\n| 18  | 2h  |\n\n* 核心源码如下：\n\n    ```Java\n      1: // ⬇️⬇️⬇️【MessageStoreConfig.java】\n      2: /**\n      3:  * 消息延迟级别字符串配置\n      4:  */\n      5: private String messageDelayLevel = \"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\";\n      6: \n      7: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n      8: /**\n      9:  * 解析延迟级别\n     10:  *\n     11:  * @return 是否解析成功\n     12:  */\n     13: public boolean parseDelayLevel() {\n     14:     HashMap<String, Long> timeUnitTable = new HashMap<>();\n     15:     timeUnitTable.put(\"s\", 1000L);\n     16:     timeUnitTable.put(\"m\", 1000L * 60);\n     17:     timeUnitTable.put(\"h\", 1000L * 60 * 60);\n     18:     timeUnitTable.put(\"d\", 1000L * 60 * 60 * 24);\n     19: \n     20:     String levelString = this.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();\n     21:     try {\n     22:         String[] levelArray = levelString.split(\" \");\n     23:         for (int i = 0; i < levelArray.length; i++) {\n     24:             String value = levelArray[i];\n     25:             String ch = value.substring(value.length() - 1);\n     26:             Long tu = timeUnitTable.get(ch);\n     27: \n     28:             int level = i + 1;\n     29:             if (level > this.maxDelayLevel) {\n     30:                 this.maxDelayLevel = level;\n     31:             }\n     32:             long num = Long.parseLong(value.substring(0, value.length() - 1));\n     33:             long delayTimeMillis = tu * num;\n     34:             this.delayLevelTable.put(level, delayTimeMillis);\n     35:         }\n     36:     } catch (Exception e) {\n     37:         log.error(\"parseDelayLevel exception\", e);\n     38:         log.info(\"levelString String = {}\", levelString);\n     39:         return false;\n     40:     }\n     41: \n     42:     return true;\n     43: }\n    ```\n\n## 2.2 Producer 发送定时消息\n\n* 🦅发送时，设置消息的**延迟级别**。\n\n```Java\nMessage msg = new Message(...);\nmsg.setDelayTimeLevel(level);\n```\n\n## 2.3 Broker 存储定时消息\n\n* 🦅 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX`。\n* 🦅 延迟级别 与 消息队列编号 做**固定映射：QueueId = DelayLevel - 1**。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: /**\n  3:  * 添加消息，返回消息结果\n  4:  *\n  5:  * @param msg 消息\n  6:  * @return 结果\n  7:  */\n  8: public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n  9:     // ....(省略代码) \n 10: \n 11:     // 定时消息处理\n 12:     final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n 13:     if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE//\n 14:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n 15:         // Delay Delivery\n 16:         if (msg.getDelayTimeLevel() > 0) {\n 17:             if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 18:                 msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n 19:             }\n 20: \n 21:             // 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX` 。\n 22:             topic = ScheduleMessageService.SCHEDULE_TOPIC;\n 23: \n 24:             // 延迟级别 与 消息队列编号 做固定映射\n 25:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n 26: \n 27:             // Backup real topic, queueId\n 28:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n 29:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n 30:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n 31: \n 32:             msg.setTopic(topic);\n 33:             msg.setQueueId(queueId);\n 34:         }\n 35:     }\n 36: \n 37:     // ....(省略代码) \n 38: }\n 39: \n 40: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n 41: /**\n 42:  * 根据 延迟级别 计算 消息队列编号\n 43:  * QueueId = DelayLevel - 1\n 44:  *\n 45:  * @param delayLevel 延迟级别\n 46:  * @return 消息队列编号\n 47:  */\n 48: public static int delayLevel2QueueId(final int delayLevel) {\n 49:     return delayLevel - 1;\n 50: }\n```\n\n-------\n\n* 🦅 生成 `ConsumeQueue` 时，每条消息的 `tagsCode` 使用【消息计划消费时间】。这样，`ScheduleMessageService` 在轮询 `ConsumeQueue` 时，可以使用 `tagsCode` 进行过滤。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【CommitLog.java】\n  2: /**\n  3:  * check the message and returns the message size\n  4:  *\n  5:  * @return 0 Come the end of the file // >0 Normal messages // -1 Message checksum failure\n  6:  */\n  7: public DispatchRequest checkMessageAndReturnSize(ByteBuffer byteBuffer, final boolean checkCRC, final boolean readBody) {\n  8:     try {\n  9:         // // ....(省略代码)\n 10: \n 11:         // 17 properties\n 12:         short propertiesLength = byteBuffer.getShort();\n 13:         if (propertiesLength > 0) {\n 14:             // ....(省略代码)\n 15:             String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);\n 16:             if (tags != null && tags.length() > 0) {\n 17:                 tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);\n 18:             }\n 19: \n 20:             // Timing message processing\n 21:             {\n 22:                 String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);\n 23:                 if (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) && t != null) {\n 24:                     int delayLevel = Integer.parseInt(t);\n 25: \n 26:                     if (delayLevel > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n 27:                         delayLevel = this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();\n 28:                     }\n 29: \n 30:                     if (delayLevel > 0) {\n 31:                         tagsCode = this.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,\n 32:                             storeTimestamp);\n 33:                     }\n 34:                 }\n 35:             }\n 36:         }\n 37: \n 38:         // ....(省略代码)\n 39: \n 40:         return new DispatchRequest(//\n 41:             topic, // 1\n 42:             queueId, // 2\n 43:             physicOffset, // 3\n 44:             totalSize, // 4\n 45:             tagsCode, // 5\n 46:             storeTimestamp, // 6\n 47:             queueOffset, // 7\n 48:             keys, // 8\n 49:             uniqKey, //9\n 50:             sysFlag, // 9\n 51:             preparedTransactionOffset// 10\n 52:         );\n 53:     } catch (Exception e) {\n 54:     }\n 55: \n 56:     return new DispatchRequest(-1, false /* success */);\n 57: }\n 58: \n 59: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n 60: /**\n 61:  * 计算 投递时间【计划消费时间】\n 62:  *\n 63:  * @param delayLevel 延迟级别\n 64:  * @param storeTimestamp 存储时间\n 65:  * @return 投递时间【计划消费时间】\n 66:  */\n 67: public long computeDeliverTimestamp(final int delayLevel, final long storeTimestamp) {\n 68:     Long time = this.delayLevelTable.get(delayLevel);\n 69:     if (time != null) {\n 70:         return time + storeTimestamp;\n 71:     }\n 72: \n 73:     return storeTimestamp + 1000;\n 74: }\n```\n\n## 2.4 Broker 发送定时消息\n\n* 🦅 对 `SCHEDULE_TOPIC_XXXX` 每条消费队列对应**单独一个**定时任务进行轮询，发送 **到达投递时间【计划消费时间】** 的消息。\n\n下图是发送定时消息的处理逻辑图：\n\n![定时消息定时逻辑](http://www.yunai.me/images/RocketMQ/2017_05_15/01.png)\n\n实现代码如下：\n\n```Java\n  1: /**\n  2:  * ⬇️⬇️⬇️ 发送（投递）延迟消息定时任务\n  3:  */\n  4: class DeliverDelayedMessageTimerTask extends TimerTask {\n  5:     /**\n  6:      * 延迟级别\n  7:      */\n  8:     private final int delayLevel;\n  9:     /**\n 10:      * 位置\n 11:      */\n 12:     private final long offset;\n 13: \n 14:     public DeliverDelayedMessageTimerTask(int delayLevel, long offset) {\n 15:         this.delayLevel = delayLevel;\n 16:         this.offset = offset;\n 17:     }\n 18: \n 19:     @Override\n 20:     public void run() {\n 21:         try {\n 22:             this.executeOnTimeup();\n 23:         } catch (Exception e) {\n 24:             // XXX: warn and notify me\n 25:             log.error(\"ScheduleMessageService, executeOnTimeup exception\", e);\n 26:             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(\n 27:                 this.delayLevel, this.offset), DELAY_FOR_A_PERIOD);\n 28:         }\n 29:     }\n 30: \n 31:     /**\n 32:      * 纠正可投递时间。\n 33:      * 因为发送级别对应的发送间隔可以调整，如果超过当前间隔，则修正成当前配置，避免后面的消息无法发送。\n 34:      *\n 35:      * @param now 当前时间\n 36:      * @param deliverTimestamp 投递时间\n 37:      * @return 纠正结果\n 38:      */\n 39:     private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {\n 40:         long result = deliverTimestamp;\n 41: \n 42:         long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n 43:         if (deliverTimestamp > maxTimestamp) {\n 44:             result = now;\n 45:         }\n 46: \n 47:         return result;\n 48:     }\n 49: \n 50:     public void executeOnTimeup() {\n 51:         ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));\n 52: \n 53:         long failScheduleOffset = offset;\n 54: \n 55:         if (cq != null) {\n 56:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n 57:             if (bufferCQ != null) {\n 58:                 try {\n 59:                     long nextOffset = offset;\n 60:                     int i = 0;\n 61:                     for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n 62:                         long offsetPy = bufferCQ.getByteBuffer().getLong();\n 63:                         int sizePy = bufferCQ.getByteBuffer().getInt();\n 64:                         long tagsCode = bufferCQ.getByteBuffer().getLong();\n 65: \n 66:                         long now = System.currentTimeMillis();\n 67:                         long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n 68: \n 69:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n 70: \n 71:                         long countdown = deliverTimestamp - now;\n 72: \n 73:                         if (countdown <= 0) { // 消息到达可发送时间\n 74:                             MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n 75:                             if (msgExt != null) {\n 76:                                 try {\n 77:                                     // 发送消息\n 78:                                     MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);\n 79:                                     PutMessageResult putMessageResult = ScheduleMessageService.this.defaultMessageStore.putMessage(msgInner);\n 80:                                     if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) { // 发送成功\n 81:                                         continue;\n 82:                                     } else { // 发送失败\n 83:                                         // XXX: warn and notify me\n 84:                                         log.error(\"ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}\", msgExt.getTopic(), msgExt.getMsgId());\n 85: \n 86:                                         // 安排下一次任务\n 87:                                         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);\n 88: \n 89:                                         // 更新进度\n 90:                                         ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n 91:                                         return;\n 92:                                     }\n 93:                                 } catch (Exception e) {\n 94:                                     // XXX: warn and notify me\n 95:                                     log.error(\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\"\n 96:                                             + msgExt + \", nextOffset=\" + nextOffset + \",offsetPy=\" + offsetPy + \",sizePy=\" + sizePy, e);\n 97:                                 }\n 98:                             }\n 99:                         } else {\n100:                             // 安排下一次任务\n101:                             ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown);\n102: \n103:                             // 更新进度\n104:                             ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n105:                             return;\n106:                         }\n107:                     } // end of for\n108: \n109:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n110: \n111:                     // 安排下一次任务\n112:                     ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);\n113: \n114:                     // 更新进度\n115:                     ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);\n116:                     return;\n117:                 } finally {\n118:                     bufferCQ.release();\n119:                 }\n120:             } // end of if (bufferCQ != null)\n121:             else { // 消费队列已经被删除部分，跳转到最小的消费进度\n122:                 long cqMinOffset = cq.getMinOffsetInQueue();\n123:                 if (offset < cqMinOffset) {\n124:                     failScheduleOffset = cqMinOffset;\n125:                     log.error(\"schedule CQ offset invalid. offset=\" + offset + \", cqMinOffset=\"\n126:                         + cqMinOffset + \", queueId=\" + cq.getQueueId());\n127:                 }\n128:             }\n129:         } // end of if (cq != null)\n130: \n131:         ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);\n132:     }\n133: \n134:     /**\n135:      * 设置消息内容\n136:      *\n137:      * @param msgExt 消息\n138:      * @return 消息\n139:      */\n140:     private MessageExtBrokerInner messageTimeup(MessageExt msgExt) {\n141:         MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n142:         msgInner.setBody(msgExt.getBody());\n143:         msgInner.setFlag(msgExt.getFlag());\n144:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());\n145: \n146:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());\n147:         long tagsCodeValue =\n148:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());\n149:         msgInner.setTagsCode(tagsCodeValue);\n150:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));\n151: \n152:         msgInner.setSysFlag(msgExt.getSysFlag());\n153:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());\n154:         msgInner.setBornHost(msgExt.getBornHost());\n155:         msgInner.setStoreHost(msgExt.getStoreHost());\n156:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());\n157: \n158:         msgInner.setWaitStoreMsgOK(false);\n159:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);\n160: \n161:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));\n162: \n163:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);\n164:         int queueId = Integer.parseInt(queueIdStr);\n165:         msgInner.setQueueId(queueId);\n166: \n167:         return msgInner;\n168:     }\n169: }\n```\n\n## 2.5 Broker 持久化定时发送进度\n\n* 🦅 定时消息发送进度存储在文件(`../config/delayOffset.json`)里\n* 🦅 每 10s 定时持久化发送进度。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【ScheduleMessageService.java】\n  2: /**\n  3: public void start() {\n  4:     // 定时发送消息\n  5:     for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n  6:         Integer level = entry.getKey();\n  7:         Long timeDelay = entry.getValue();\n  8:         Long offset = this.offsetTable.get(level);\n  9:         if (null == offset) {\n 10:             offset = 0L;\n 11:         }\n 12: \n 13:         if (timeDelay != null) {\n 14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);\n 15:         }\n 16:     }\n 17: \n 18:     // 定时持久化发送进度\n 19:     this.timer.scheduleAtFixedRate(new TimerTask() {\n 20: \n 21:         @Override\n 22:         public void run() {\n 23:             try {\n 24:                 ScheduleMessageService.this.persist();\n 25:             } catch (Exception e) {\n 26:                 log.error(\"scheduleAtFixedRate flush exception\", e);\n 27:             }\n 28:         }\n 29:     }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());\n 30: }\n```\n\n# 3. 消息重试\n\n> Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。\n\n* 🦅 `Consumer` 将消费失败的消息发回 `Broker`，进入**延迟消息队列**。即，消费失败的消息，不会立即消费。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【SendMessageProcessor.java】\n  2: /**\n  3:  * 消费者发回消息\n  4:  *\n  5:  * @param ctx ctx\n  6:  * @param request 请求\n  7:  * @return 响应\n  8:  * @throws RemotingCommandException 当远程调用异常\n  9:  */\n 10: private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)\n 11:     throws RemotingCommandException {\n 12:     // ....(省略代码)\n 13:     // 处理 delayLevel（独有）。\n 14:     int delayLevel = requestHeader.getDelayLevel();\n 15:     int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 16:     if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 17:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 18:     }\n 19:     if (msgExt.getReconsumeTimes() >= maxReconsumeTimes//\n 20:     // ....(省略代码)\n 21:     } else {\n 22:         if (0 == delayLevel) {\n 23:             delayLevel = 3 + msgExt.getReconsumeTimes();\n 24:         }\n 25:         msgExt.setDelayTimeLevel(delayLevel);\n 26:     }\n 27: \n 28:     // ....(省略代码)\n 29:     return response;\n 30: }\n```\n\n","slug":"RocketMQ/message-schedule-and-retry","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzai000zag5dmhu7mtut","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-schedule-and-retry\">http://www.yunai.me/RocketMQ/message-schedule-and-retry</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 定时消息</a><ul>\n<li><a href=\"#\">2.1 延迟级别</a></li>\n<li><a href=\"#\">2.2 Producer 发送定时消息</a></li>\n<li><a href=\"#\">2.3 Broker 存储定时消息</a></li>\n<li><a href=\"#\">2.4 Broker 发送定时消息</a></li>\n<li><a href=\"#\">2.5 Broker 持久化定时发送进度</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 消息重试</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>建议</strong>前置阅读内容：</p>\n<ul>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a></li>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">《RocketMQ 源码分析 —— Message 拉取与消费（下）》</a></li>\n</ul>\n<p>😈 为什么把<strong>定时消息</strong>与<strong>消息重试</strong>放在一起？你猜。<br>👻 你猜我猜不猜。</p>\n<h1 id=\"2-定时消息\"><a href=\"#2-定时消息\" class=\"headerlink\" title=\"2. 定时消息\"></a>2. 定时消息</h1><blockquote>\n<p><strong>定时消息</strong>是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。</p>\n</blockquote>\n<p>下图是<strong>定时消息</strong>的处理逻辑图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_15/02.png\" alt=\"定时消息逻辑图.png\"></p>\n<h2 id=\"2-1-延迟级别\"><a href=\"#2-1-延迟级别\" class=\"headerlink\" title=\"2.1 延迟级别\"></a>2.1 延迟级别</h2><p><code>RocketMQ</code> 目前只支持<strong>固定精度</strong>的定时消息。官方说法如下：</p>\n<blockquote>\n<p>如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。</p>\n</blockquote>\n<ul>\n<li>延迟级别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>延迟级别</th>\n<th>时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1s</td>\n</tr>\n<tr>\n<td>2</td>\n<td>5s</td>\n</tr>\n<tr>\n<td>3</td>\n<td>10s</td>\n</tr>\n<tr>\n<td>4</td>\n<td>30s</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1m</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2m</td>\n</tr>\n<tr>\n<td>7</td>\n<td>3m</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4m</td>\n</tr>\n<tr>\n<td>9</td>\n<td>5m</td>\n</tr>\n<tr>\n<td>10</td>\n<td>6m</td>\n</tr>\n<tr>\n<td>11</td>\n<td>7m</td>\n</tr>\n<tr>\n<td>12</td>\n<td>8m</td>\n</tr>\n<tr>\n<td>13</td>\n<td>9m</td>\n</tr>\n<tr>\n<td>14</td>\n<td>10m</td>\n</tr>\n<tr>\n<td>15</td>\n<td>20m</td>\n</tr>\n<tr>\n<td>16</td>\n<td>30m</td>\n</tr>\n<tr>\n<td>17</td>\n<td>1h</td>\n</tr>\n<tr>\n<td>18</td>\n<td>2h</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>核心源码如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MessageStoreConfig.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 消息延迟级别字符串配置</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">private</span> String messageDelayLevel = <span class=\"string\">\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\"</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 9:  * 解析延迟级别</div><div class=\"line\">10:  *</div><div class=\"line\">11:  * <span class=\"doctag\">@return</span> 是否解析成功</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parseDelayLevel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">14</span>:     HashMap&lt;String, Long&gt; timeUnitTable = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"number\">15</span>:     timeUnitTable.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">1000L</span>);</div><div class=\"line\"><span class=\"number\">16</span>:     timeUnitTable.put(<span class=\"string\">\"m\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span>);</div><div class=\"line\"><span class=\"number\">17</span>:     timeUnitTable.put(<span class=\"string\">\"h\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>);</div><div class=\"line\"><span class=\"number\">18</span>:     timeUnitTable.put(<span class=\"string\">\"d\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     String levelString = <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:         String[] levelArray = levelString.split(<span class=\"string\">\" \"</span>);</div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; levelArray.length; i++) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             String value = levelArray[i];</div><div class=\"line\"><span class=\"number\">25</span>:             String ch = value.substring(value.length() - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">26</span>:             Long tu = timeUnitTable.get(ch);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">int</span> level = i + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (level &gt; <span class=\"keyword\">this</span>.maxDelayLevel) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">this</span>.maxDelayLevel = level;</div><div class=\"line\"><span class=\"number\">31</span>:             &#125;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">long</span> num = Long.parseLong(value.substring(<span class=\"number\">0</span>, value.length() - <span class=\"number\">1</span>));</div><div class=\"line\"><span class=\"number\">33</span>:             <span class=\"keyword\">long</span> delayTimeMillis = tu * num;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.delayLevelTable.put(level, delayTimeMillis);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:         log.error(<span class=\"string\">\"parseDelayLevel exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">38</span>:         log.info(<span class=\"string\">\"levelString String = &#123;&#125;\"</span>, levelString);</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2-2-Producer-发送定时消息\"><a href=\"#2-2-Producer-发送定时消息\" class=\"headerlink\" title=\"2.2 Producer 发送定时消息\"></a>2.2 Producer 发送定时消息</h2><ul>\n<li>🦅发送时，设置消息的<strong>延迟级别</strong>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Message msg = <span class=\"keyword\">new</span> Message(...);</div><div class=\"line\">msg.setDelayTimeLevel(level);</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Broker-存储定时消息\"><a href=\"#2-3-Broker-存储定时消息\" class=\"headerlink\" title=\"2.3 Broker 存储定时消息\"></a>2.3 Broker 存储定时消息</h2><ul>\n<li>🦅 存储消息时，延迟消息进入 <code>Topic</code> 为 <code>SCHEDULE_TOPIC_XXXX</code>。</li>\n<li>🦅 延迟级别 与 消息队列编号 做<strong>固定映射：QueueId = DelayLevel - 1</strong>。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 添加消息，返回消息结果</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 结果</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// ....(省略代码) </span></div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">// 定时消息处理</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">14</span>:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"comment\">// Delay Delivery</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 msg.setDelayTimeLevel(<span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</div><div class=\"line\"><span class=\"number\">19</span>:             &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX` 。</span></div><div class=\"line\"><span class=\"number\">22</span>:             topic = ScheduleMessageService.SCHEDULE_TOPIC;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// 延迟级别 与 消息队列编号 做固定映射</span></div><div class=\"line\"><span class=\"number\">25</span>:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"comment\">// Backup real topic, queueId</span></div><div class=\"line\"><span class=\"number\">28</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">29</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</div><div class=\"line\"><span class=\"number\">30</span>:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             msg.setTopic(topic);</div><div class=\"line\"><span class=\"number\">33</span>:             msg.setQueueId(queueId);</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"comment\">// ....(省略代码) </span></div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"><span class=\"number\">41</span>: <span class=\"comment\">/**</span></div><div class=\"line\">42:  * 根据 延迟级别 计算 消息队列编号</div><div class=\"line\">43:  * QueueId = DelayLevel - 1</div><div class=\"line\">44:  *</div><div class=\"line\">45:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\">46:  * <span class=\"doctag\">@return</span> 消息队列编号</div><div class=\"line\">47:  */</div><div class=\"line\"><span class=\"number\">48</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">delayLevel2QueueId</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">49</span>:     <span class=\"keyword\">return</span> delayLevel - <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">50</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>🦅 生成 <code>ConsumeQueue</code> 时，每条消息的 <code>tagsCode</code> 使用【消息计划消费时间】。这样，<code>ScheduleMessageService</code> 在轮询 <code>ConsumeQueue</code> 时，可以使用 <code>tagsCode</code> 进行过滤。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * check the message and returns the message size</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> 0 Come the end of the file // &gt;0 Normal messages // -1 Message checksum failure</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> DispatchRequest <span class=\"title\">checkMessageAndReturnSize</span><span class=\"params\">(ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> checkCRC, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> readBody)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"comment\">// // ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// 17 properties</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">short</span> propertiesLength = byteBuffer.getShort();</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">15</span>:             String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">if</span> (tags != <span class=\"keyword\">null</span> &amp;&amp; tags.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                 tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);</div><div class=\"line\"><span class=\"number\">18</span>:             &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"comment\">// Timing message processing</span></div><div class=\"line\"><span class=\"number\">21</span>:             &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                 String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                     <span class=\"keyword\">int</span> delayLevel = Integer.parseInt(t);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">if</span> (delayLevel &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                         delayLevel = <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();</div><div class=\"line\"><span class=\"number\">28</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (delayLevel &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         tagsCode = <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,</div><div class=\"line\"><span class=\"number\">32</span>:                             storeTimestamp);</div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">35</span>:             &#125;</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DispatchRequest(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">41</span>:             topic, <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"number\">42</span>:             queueId, <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"number\">43</span>:             physicOffset, <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"number\">44</span>:             totalSize, <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">45</span>:             tagsCode, <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"number\">46</span>:             storeTimestamp, <span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"number\">47</span>:             queueOffset, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">48</span>:             keys, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">49</span>:             uniqKey, <span class=\"comment\">//9</span></div><div class=\"line\"><span class=\"number\">50</span>:             sysFlag, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">51</span>:             preparedTransactionOffset<span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">52</span>:         );</div><div class=\"line\"><span class=\"number\">53</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">54</span>:     &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DispatchRequest(-<span class=\"number\">1</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* success */</span>);</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"><span class=\"number\">60</span>: <span class=\"comment\">/**</span></div><div class=\"line\">61:  * 计算 投递时间【计划消费时间】</div><div class=\"line\">62:  *</div><div class=\"line\">63:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\">64:  * <span class=\"doctag\">@param</span> storeTimestamp 存储时间</div><div class=\"line\">65:  * <span class=\"doctag\">@return</span> 投递时间【计划消费时间】</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">computeDeliverTimestamp</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> storeTimestamp)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:     Long time = <span class=\"keyword\">this</span>.delayLevelTable.get(delayLevel);</div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">if</span> (time != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">return</span> time + storeTimestamp;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125;</div><div class=\"line\"><span class=\"number\">72</span>: </div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"keyword\">return</span> storeTimestamp + <span class=\"number\">1000</span>;</div><div class=\"line\"><span class=\"number\">74</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-Broker-发送定时消息\"><a href=\"#2-4-Broker-发送定时消息\" class=\"headerlink\" title=\"2.4 Broker 发送定时消息\"></a>2.4 Broker 发送定时消息</h2><ul>\n<li>🦅 对 <code>SCHEDULE_TOPIC_XXXX</code> 每条消费队列对应<strong>单独一个</strong>定时任务进行轮询，发送 <strong>到达投递时间【计划消费时间】</strong> 的消息。</li>\n</ul>\n<p>下图是发送定时消息的处理逻辑图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_15/01.png\" alt=\"定时消息定时逻辑\"></p>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * ⬇️⬇️⬇️ 发送（投递）延迟消息定时任务</div><div class=\"line\">  3:  */</div><div class=\"line\">  <span class=\"number\">4</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeliverDelayedMessageTimerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  6:      * 延迟级别</div><div class=\"line\">  7:      */</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel;</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 10:      * 位置</div><div class=\"line\"> 11:      */</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset;</div><div class=\"line\"> <span class=\"number\">13</span>: </div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DeliverDelayedMessageTimerTask</span><span class=\"params\">(<span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">this</span>.delayLevel = delayLevel;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.offset = offset;</div><div class=\"line\"> <span class=\"number\">17</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">18</span>: </div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.executeOnTimeup();</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">25</span>:             log.error(<span class=\"string\">\"ScheduleMessageService, executeOnTimeup exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:             ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"keyword\">this</span>.delayLevel, <span class=\"keyword\">this</span>.offset), DELAY_FOR_A_PERIOD);</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 32:      * 纠正可投递时间。</div><div class=\"line\"> 33:      * 因为发送级别对应的发送间隔可以调整，如果超过当前间隔，则修正成当前配置，避免后面的消息无法发送。</div><div class=\"line\"> 34:      *</div><div class=\"line\"> 35:      * <span class=\"doctag\">@param</span> now 当前时间</div><div class=\"line\"> 36:      * <span class=\"doctag\">@param</span> deliverTimestamp 投递时间</div><div class=\"line\"> 37:      * <span class=\"doctag\">@return</span> 纠正结果</div><div class=\"line\"> 38:      */</div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">correctDeliverTimestamp</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deliverTimestamp)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">40</span>:         <span class=\"keyword\">long</span> result = deliverTimestamp;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"keyword\">long</span> maxTimestamp = now + ScheduleMessageService.<span class=\"keyword\">this</span>.delayLevelTable.get(<span class=\"keyword\">this</span>.delayLevel);</div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">if</span> (deliverTimestamp &gt; maxTimestamp) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:             result = now;</div><div class=\"line\"> <span class=\"number\">45</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"> <span class=\"number\">48</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOnTimeup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">51</span>:         ConsumeQueue cq = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));</div><div class=\"line\"> <span class=\"number\">52</span>: </div><div class=\"line\"> <span class=\"number\">53</span>:         <span class=\"keyword\">long</span> failScheduleOffset = offset;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">if</span> (cq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class=\"keyword\">this</span>.offset);</div><div class=\"line\"> <span class=\"number\">57</span>:             <span class=\"keyword\">if</span> (bufferCQ != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">58</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                     <span class=\"keyword\">long</span> nextOffset = offset;</div><div class=\"line\"> <span class=\"number\">60</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                     <span class=\"keyword\">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"> <span class=\"number\">62</span>:                         <span class=\"keyword\">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">63</span>:                         <span class=\"keyword\">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">64</span>:                         <span class=\"keyword\">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                         <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"keyword\">long</span> deliverTimestamp = <span class=\"keyword\">this</span>.correctDeliverTimestamp(now, tagsCode);</div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:                         <span class=\"keyword\">long</span> countdown = deliverTimestamp - now;</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:                         <span class=\"keyword\">if</span> (countdown &lt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 消息到达可发送时间</span></div><div class=\"line\"> <span class=\"number\">74</span>:                             MessageExt msgExt = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);</div><div class=\"line\"> <span class=\"number\">75</span>:                             <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:                                     <span class=\"comment\">// 发送消息</span></div><div class=\"line\"> <span class=\"number\">78</span>:                                     MessageExtBrokerInner msgInner = <span class=\"keyword\">this</span>.messageTimeup(msgExt);</div><div class=\"line\"> <span class=\"number\">79</span>:                                     PutMessageResult putMessageResult = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.putMessage(msgInner);</div><div class=\"line\"> <span class=\"number\">80</span>:                                     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span> &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123; <span class=\"comment\">// 发送成功</span></div><div class=\"line\"> <span class=\"number\">81</span>:                                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">82</span>:                                     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 发送失败</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                         <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">84</span>:                                         log.error(<span class=\"string\">\"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;\"</span>, msgExt.getTopic(), msgExt.getMsgId());</div><div class=\"line\"> <span class=\"number\">85</span>: </div><div class=\"line\"> <span class=\"number\">86</span>:                                         <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"> <span class=\"number\">87</span>:                                         ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);</div><div class=\"line\"> <span class=\"number\">88</span>: </div><div class=\"line\"> <span class=\"number\">89</span>:                                         <span class=\"comment\">// 更新进度</span></div><div class=\"line\"> <span class=\"number\">90</span>:                                         ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"> <span class=\"number\">91</span>:                                         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">92</span>:                                     &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:                                 &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:                                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">95</span>:                                     log.error(<span class=\"string\">\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\"</span></div><div class=\"line\"> <span class=\"number\">96</span>:                                             + msgExt + <span class=\"string\">\", nextOffset=\"</span> + nextOffset + <span class=\"string\">\",offsetPy=\"</span> + offsetPy + <span class=\"string\">\",sizePy=\"</span> + sizePy, e);</div><div class=\"line\"> <span class=\"number\">97</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">99</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">100</span>:                             <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"><span class=\"number\">101</span>:                             ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), countdown);</div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:                             <span class=\"comment\">// 更新进度</span></div><div class=\"line\"><span class=\"number\">104</span>:                             ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"><span class=\"number\">105</span>:                             <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">107</span>:                     &#125; <span class=\"comment\">// end of for</span></div><div class=\"line\"><span class=\"number\">108</span>: </div><div class=\"line\"><span class=\"number\">109</span>:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:                     <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"><span class=\"number\">112</span>:                     ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>:                     <span class=\"comment\">// 更新进度</span></div><div class=\"line\"><span class=\"number\">115</span>:                     ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"><span class=\"number\">116</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">118</span>:                     bufferCQ.release();</div><div class=\"line\"><span class=\"number\">119</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">120</span>:             &#125; <span class=\"comment\">// end of if (bufferCQ != null)</span></div><div class=\"line\"><span class=\"number\">121</span>:             <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 消费队列已经被删除部分，跳转到最小的消费进度</span></div><div class=\"line\"><span class=\"number\">122</span>:                 <span class=\"keyword\">long</span> cqMinOffset = cq.getMinOffsetInQueue();</div><div class=\"line\"><span class=\"number\">123</span>:                 <span class=\"keyword\">if</span> (offset &lt; cqMinOffset) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:                     failScheduleOffset = cqMinOffset;</div><div class=\"line\"><span class=\"number\">125</span>:                     log.error(<span class=\"string\">\"schedule CQ offset invalid. offset=\"</span> + offset + <span class=\"string\">\", cqMinOffset=\"</span></div><div class=\"line\"><span class=\"number\">126</span>:                         + cqMinOffset + <span class=\"string\">\", queueId=\"</span> + cq.getQueueId());</div><div class=\"line\"><span class=\"number\">127</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"comment\">// end of if (cq != null)</span></div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:         ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">135:      * 设置消息内容</div><div class=\"line\">136:      *</div><div class=\"line\">137:      * <span class=\"doctag\">@param</span> msgExt 消息</div><div class=\"line\">138:      * <span class=\"doctag\">@return</span> 消息</div><div class=\"line\">139:      */</div><div class=\"line\"><span class=\"number\">140</span>:     <span class=\"function\"><span class=\"keyword\">private</span> MessageExtBrokerInner <span class=\"title\">messageTimeup</span><span class=\"params\">(MessageExt msgExt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">141</span>:         MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">142</span>:         msgInner.setBody(msgExt.getBody());</div><div class=\"line\"><span class=\"number\">143</span>:         msgInner.setFlag(msgExt.getFlag());</div><div class=\"line\"><span class=\"number\">144</span>:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());</div><div class=\"line\"><span class=\"number\">145</span>: </div><div class=\"line\"><span class=\"number\">146</span>:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"keyword\">long</span> tagsCodeValue =</div><div class=\"line\"><span class=\"number\">148</span>:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());</div><div class=\"line\"><span class=\"number\">149</span>:         msgInner.setTagsCode(tagsCodeValue);</div><div class=\"line\"><span class=\"number\">150</span>:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</div><div class=\"line\"><span class=\"number\">151</span>: </div><div class=\"line\"><span class=\"number\">152</span>:         msgInner.setSysFlag(msgExt.getSysFlag());</div><div class=\"line\"><span class=\"number\">153</span>:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">154</span>:         msgInner.setBornHost(msgExt.getBornHost());</div><div class=\"line\"><span class=\"number\">155</span>:         msgInner.setStoreHost(msgExt.getStoreHost());</div><div class=\"line\"><span class=\"number\">156</span>:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">157</span>: </div><div class=\"line\"><span class=\"number\">158</span>:         msgInner.setWaitStoreMsgOK(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">159</span>:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</div><div class=\"line\"><span class=\"number\">160</span>: </div><div class=\"line\"><span class=\"number\">161</span>:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);</div><div class=\"line\"><span class=\"number\">164</span>:         <span class=\"keyword\">int</span> queueId = Integer.parseInt(queueIdStr);</div><div class=\"line\"><span class=\"number\">165</span>:         msgInner.setQueueId(queueId);</div><div class=\"line\"><span class=\"number\">166</span>: </div><div class=\"line\"><span class=\"number\">167</span>:         <span class=\"keyword\">return</span> msgInner;</div><div class=\"line\"><span class=\"number\">168</span>:     &#125;</div><div class=\"line\"><span class=\"number\">169</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-5-Broker-持久化定时发送进度\"><a href=\"#2-5-Broker-持久化定时发送进度\" class=\"headerlink\" title=\"2.5 Broker 持久化定时发送进度\"></a>2.5 Broker 持久化定时发送进度</h2><ul>\n<li>🦅 定时消息发送进度存储在文件(<code>../config/delayOffset.json</code>)里</li>\n<li>🦅 每 10s 定时持久化发送进度。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3: public void start() &#123;</div><div class=\"line\"> 4:     // 定时发送消息</div><div class=\"line\"> 5:     for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) &#123;</div><div class=\"line\"> 6:         Integer level = entry.getKey();</div><div class=\"line\"> 7:         Long timeDelay = entry.getValue();</div><div class=\"line\"> 8:         Long offset = this.offsetTable.get(level);</div><div class=\"line\"> 9:         if (null == offset) &#123;</div><div class=\"line\">10:             offset = 0L;</div><div class=\"line\">11:         &#125;</div><div class=\"line\">12: </div><div class=\"line\">13:         if (timeDelay != null) &#123;</div><div class=\"line\">14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</div><div class=\"line\">15:         &#125;</div><div class=\"line\">16:     &#125;</div><div class=\"line\">17: </div><div class=\"line\">18:     // 定时持久化发送进度</div><div class=\"line\">19:     this.timer.scheduleAtFixedRate(new TimerTask() &#123;</div><div class=\"line\">20: </div><div class=\"line\">21:         <span class=\"doctag\">@Override</span></div><div class=\"line\">22:         public void run() &#123;</div><div class=\"line\">23:             try &#123;</div><div class=\"line\">24:                 ScheduleMessageService.this.persist();</div><div class=\"line\">25:             &#125; catch (Exception e) &#123;</div><div class=\"line\">26:                 log.error(\"scheduleAtFixedRate flush exception\", e);</div><div class=\"line\">27:             &#125;</div><div class=\"line\">28:         &#125;</div><div class=\"line\">29:     &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</div><div class=\"line\">30: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-消息重试\"><a href=\"#3-消息重试\" class=\"headerlink\" title=\"3. 消息重试\"></a>3. 消息重试</h1><blockquote>\n<p>Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。</p>\n</blockquote>\n<ul>\n<li>🦅 <code>Consumer</code> 将消费失败的消息发回 <code>Broker</code>，进入<strong>延迟消息队列</strong>。即，消费失败的消息，不会立即消费。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SendMessageProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 消费者发回消息</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> ctx ctx</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> request 请求</div><div class=\"line\"> 7:  * <span class=\"doctag\">@return</span> 响应</div><div class=\"line\"> 8:  * <span class=\"doctag\">@throws</span> RemotingCommandException 当远程调用异常</div><div class=\"line\"> 9:  */</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">consumerSendMsgBack</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span></span></div><div class=\"line\">11:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 处理 delayLevel（独有）。</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">int</span> delayLevel = requestHeader.getDelayLevel();</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">21</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == delayLevel) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             delayLevel = <span class=\"number\">3</span> + msgExt.getReconsumeTimes();</div><div class=\"line\"><span class=\"number\">24</span>:         &#125;</div><div class=\"line\"><span class=\"number\">25</span>:         msgExt.setDelayTimeLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">30</span>: &#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-schedule-and-retry\">http://www.yunai.me/RocketMQ/message-schedule-and-retry</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 定时消息</a><ul>\n<li><a href=\"#\">2.1 延迟级别</a></li>\n<li><a href=\"#\">2.2 Producer 发送定时消息</a></li>\n<li><a href=\"#\">2.3 Broker 存储定时消息</a></li>\n<li><a href=\"#\">2.4 Broker 发送定时消息</a></li>\n<li><a href=\"#\">2.5 Broker 持久化定时发送进度</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 消息重试</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>建议</strong>前置阅读内容：</p>\n<ul>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/\">《RocketMQ 源码分析 —— Message 发送与接收》</a></li>\n<li><a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">《RocketMQ 源码分析 —— Message 拉取与消费（下）》</a></li>\n</ul>\n<p>😈 为什么把<strong>定时消息</strong>与<strong>消息重试</strong>放在一起？你猜。<br>👻 你猜我猜不猜。</p>\n<h1 id=\"2-定时消息\"><a href=\"#2-定时消息\" class=\"headerlink\" title=\"2. 定时消息\"></a>2. 定时消息</h1><blockquote>\n<p><strong>定时消息</strong>是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。</p>\n</blockquote>\n<p>下图是<strong>定时消息</strong>的处理逻辑图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_15/02.png\" alt=\"定时消息逻辑图.png\"></p>\n<h2 id=\"2-1-延迟级别\"><a href=\"#2-1-延迟级别\" class=\"headerlink\" title=\"2.1 延迟级别\"></a>2.1 延迟级别</h2><p><code>RocketMQ</code> 目前只支持<strong>固定精度</strong>的定时消息。官方说法如下：</p>\n<blockquote>\n<p>如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销。</p>\n</blockquote>\n<ul>\n<li>延迟级别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>延迟级别</th>\n<th>时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1s</td>\n</tr>\n<tr>\n<td>2</td>\n<td>5s</td>\n</tr>\n<tr>\n<td>3</td>\n<td>10s</td>\n</tr>\n<tr>\n<td>4</td>\n<td>30s</td>\n</tr>\n<tr>\n<td>5</td>\n<td>1m</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2m</td>\n</tr>\n<tr>\n<td>7</td>\n<td>3m</td>\n</tr>\n<tr>\n<td>8</td>\n<td>4m</td>\n</tr>\n<tr>\n<td>9</td>\n<td>5m</td>\n</tr>\n<tr>\n<td>10</td>\n<td>6m</td>\n</tr>\n<tr>\n<td>11</td>\n<td>7m</td>\n</tr>\n<tr>\n<td>12</td>\n<td>8m</td>\n</tr>\n<tr>\n<td>13</td>\n<td>9m</td>\n</tr>\n<tr>\n<td>14</td>\n<td>10m</td>\n</tr>\n<tr>\n<td>15</td>\n<td>20m</td>\n</tr>\n<tr>\n<td>16</td>\n<td>30m</td>\n</tr>\n<tr>\n<td>17</td>\n<td>1h</td>\n</tr>\n<tr>\n<td>18</td>\n<td>2h</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>核心源码如下：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MessageStoreConfig.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 消息延迟级别字符串配置</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">private</span> String messageDelayLevel = <span class=\"string\">\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\"</span>;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 9:  * 解析延迟级别</div><div class=\"line\">10:  *</div><div class=\"line\">11:  * <span class=\"doctag\">@return</span> 是否解析成功</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parseDelayLevel</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">14</span>:     HashMap&lt;String, Long&gt; timeUnitTable = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"><span class=\"number\">15</span>:     timeUnitTable.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">1000L</span>);</div><div class=\"line\"><span class=\"number\">16</span>:     timeUnitTable.put(<span class=\"string\">\"m\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span>);</div><div class=\"line\"><span class=\"number\">17</span>:     timeUnitTable.put(<span class=\"string\">\"h\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span>);</div><div class=\"line\"><span class=\"number\">18</span>:     timeUnitTable.put(<span class=\"string\">\"d\"</span>, <span class=\"number\">1000L</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     String levelString = <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:         String[] levelArray = levelString.split(<span class=\"string\">\" \"</span>);</div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; levelArray.length; i++) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             String value = levelArray[i];</div><div class=\"line\"><span class=\"number\">25</span>:             String ch = value.substring(value.length() - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">26</span>:             Long tu = timeUnitTable.get(ch);</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">int</span> level = i + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">if</span> (level &gt; <span class=\"keyword\">this</span>.maxDelayLevel) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">this</span>.maxDelayLevel = level;</div><div class=\"line\"><span class=\"number\">31</span>:             &#125;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">long</span> num = Long.parseLong(value.substring(<span class=\"number\">0</span>, value.length() - <span class=\"number\">1</span>));</div><div class=\"line\"><span class=\"number\">33</span>:             <span class=\"keyword\">long</span> delayTimeMillis = tu * num;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.delayLevelTable.put(level, delayTimeMillis);</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:         log.error(<span class=\"string\">\"parseDelayLevel exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">38</span>:         log.info(<span class=\"string\">\"levelString String = &#123;&#125;\"</span>, levelString);</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2-2-Producer-发送定时消息\"><a href=\"#2-2-Producer-发送定时消息\" class=\"headerlink\" title=\"2.2 Producer 发送定时消息\"></a>2.2 Producer 发送定时消息</h2><ul>\n<li>🦅发送时，设置消息的<strong>延迟级别</strong>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">Message msg = <span class=\"keyword\">new</span> Message(...);</div><div class=\"line\">msg.setDelayTimeLevel(level);</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Broker-存储定时消息\"><a href=\"#2-3-Broker-存储定时消息\" class=\"headerlink\" title=\"2.3 Broker 存储定时消息\"></a>2.3 Broker 存储定时消息</h2><ul>\n<li>🦅 存储消息时，延迟消息进入 <code>Topic</code> 为 <code>SCHEDULE_TOPIC_XXXX</code>。</li>\n<li>🦅 延迟级别 与 消息队列编号 做<strong>固定映射：QueueId = DelayLevel - 1</strong>。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 添加消息，返回消息结果</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 结果</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> PutMessageResult <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// ....(省略代码) </span></div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">// 定时消息处理</span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">14</span>:         || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"comment\">// Delay Delivery</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             <span class=\"keyword\">if</span> (msg.getDelayTimeLevel() &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                 msg.setDelayTimeLevel(<span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</div><div class=\"line\"><span class=\"number\">19</span>:             &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"comment\">// 存储消息时，延迟消息进入 `Topic` 为 `SCHEDULE_TOPIC_XXXX` 。</span></div><div class=\"line\"><span class=\"number\">22</span>:             topic = ScheduleMessageService.SCHEDULE_TOPIC;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"comment\">// 延迟级别 与 消息队列编号 做固定映射</span></div><div class=\"line\"><span class=\"number\">25</span>:             queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"comment\">// Backup real topic, queueId</span></div><div class=\"line\"><span class=\"number\">28</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">29</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</div><div class=\"line\"><span class=\"number\">30</span>:             msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             msg.setTopic(topic);</div><div class=\"line\"><span class=\"number\">33</span>:             msg.setQueueId(queueId);</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"comment\">// ....(省略代码) </span></div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"><span class=\"number\">41</span>: <span class=\"comment\">/**</span></div><div class=\"line\">42:  * 根据 延迟级别 计算 消息队列编号</div><div class=\"line\">43:  * QueueId = DelayLevel - 1</div><div class=\"line\">44:  *</div><div class=\"line\">45:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\">46:  * <span class=\"doctag\">@return</span> 消息队列编号</div><div class=\"line\">47:  */</div><div class=\"line\"><span class=\"number\">48</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">delayLevel2QueueId</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">49</span>:     <span class=\"keyword\">return</span> delayLevel - <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">50</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<ul>\n<li>🦅 生成 <code>ConsumeQueue</code> 时，每条消息的 <code>tagsCode</code> 使用【消息计划消费时间】。这样，<code>ScheduleMessageService</code> 在轮询 <code>ConsumeQueue</code> 时，可以使用 <code>tagsCode</code> 进行过滤。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【CommitLog.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * check the message and returns the message size</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> 0 Come the end of the file // &gt;0 Normal messages // -1 Message checksum failure</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> DispatchRequest <span class=\"title\">checkMessageAndReturnSize</span><span class=\"params\">(ByteBuffer byteBuffer, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> checkCRC, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> readBody)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"comment\">// // ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// 17 properties</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">short</span> propertiesLength = byteBuffer.getShort();</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">if</span> (propertiesLength &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">15</span>:             String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">if</span> (tags != <span class=\"keyword\">null</span> &amp;&amp; tags.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                 tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);</div><div class=\"line\"><span class=\"number\">18</span>:             &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"comment\">// Timing message processing</span></div><div class=\"line\"><span class=\"number\">21</span>:             &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                 String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</div><div class=\"line\"><span class=\"number\">23</span>:                 <span class=\"keyword\">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                     <span class=\"keyword\">int</span> delayLevel = Integer.parseInt(t);</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:                     <span class=\"keyword\">if</span> (delayLevel &gt; <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                         delayLevel = <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();</div><div class=\"line\"><span class=\"number\">28</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (delayLevel &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         tagsCode = <span class=\"keyword\">this</span>.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,</div><div class=\"line\"><span class=\"number\">32</span>:                             storeTimestamp);</div><div class=\"line\"><span class=\"number\">33</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">34</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">35</span>:             &#125;</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DispatchRequest(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">41</span>:             topic, <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"number\">42</span>:             queueId, <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"number\">43</span>:             physicOffset, <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"number\">44</span>:             totalSize, <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">45</span>:             tagsCode, <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"number\">46</span>:             storeTimestamp, <span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"number\">47</span>:             queueOffset, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">48</span>:             keys, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">49</span>:             uniqKey, <span class=\"comment\">//9</span></div><div class=\"line\"><span class=\"number\">50</span>:             sysFlag, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">51</span>:             preparedTransactionOffset<span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">52</span>:         );</div><div class=\"line\"><span class=\"number\">53</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">54</span>:     &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DispatchRequest(-<span class=\"number\">1</span>, <span class=\"keyword\">false</span> <span class=\"comment\">/* success */</span>);</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"><span class=\"number\">60</span>: <span class=\"comment\">/**</span></div><div class=\"line\">61:  * 计算 投递时间【计划消费时间】</div><div class=\"line\">62:  *</div><div class=\"line\">63:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\">64:  * <span class=\"doctag\">@param</span> storeTimestamp 存储时间</div><div class=\"line\">65:  * <span class=\"doctag\">@return</span> 投递时间【计划消费时间】</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">computeDeliverTimestamp</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> storeTimestamp)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:     Long time = <span class=\"keyword\">this</span>.delayLevelTable.get(delayLevel);</div><div class=\"line\"><span class=\"number\">69</span>:     <span class=\"keyword\">if</span> (time != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">70</span>:         <span class=\"keyword\">return</span> time + storeTimestamp;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125;</div><div class=\"line\"><span class=\"number\">72</span>: </div><div class=\"line\"><span class=\"number\">73</span>:     <span class=\"keyword\">return</span> storeTimestamp + <span class=\"number\">1000</span>;</div><div class=\"line\"><span class=\"number\">74</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-Broker-发送定时消息\"><a href=\"#2-4-Broker-发送定时消息\" class=\"headerlink\" title=\"2.4 Broker 发送定时消息\"></a>2.4 Broker 发送定时消息</h2><ul>\n<li>🦅 对 <code>SCHEDULE_TOPIC_XXXX</code> 每条消费队列对应<strong>单独一个</strong>定时任务进行轮询，发送 <strong>到达投递时间【计划消费时间】</strong> 的消息。</li>\n</ul>\n<p>下图是发送定时消息的处理逻辑图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_15/01.png\" alt=\"定时消息定时逻辑\"></p>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * ⬇️⬇️⬇️ 发送（投递）延迟消息定时任务</div><div class=\"line\">  3:  */</div><div class=\"line\">  <span class=\"number\">4</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeliverDelayedMessageTimerTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  6:      * 延迟级别</div><div class=\"line\">  7:      */</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel;</div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 10:      * 位置</div><div class=\"line\"> 11:      */</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset;</div><div class=\"line\"> <span class=\"number\">13</span>: </div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DeliverDelayedMessageTimerTask</span><span class=\"params\">(<span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">this</span>.delayLevel = delayLevel;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.offset = offset;</div><div class=\"line\"> <span class=\"number\">17</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">18</span>: </div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.executeOnTimeup();</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">25</span>:             log.error(<span class=\"string\">\"ScheduleMessageService, executeOnTimeup exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:             ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(</div><div class=\"line\"> <span class=\"number\">27</span>:                 <span class=\"keyword\">this</span>.delayLevel, <span class=\"keyword\">this</span>.offset), DELAY_FOR_A_PERIOD);</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 32:      * 纠正可投递时间。</div><div class=\"line\"> 33:      * 因为发送级别对应的发送间隔可以调整，如果超过当前间隔，则修正成当前配置，避免后面的消息无法发送。</div><div class=\"line\"> 34:      *</div><div class=\"line\"> 35:      * <span class=\"doctag\">@param</span> now 当前时间</div><div class=\"line\"> 36:      * <span class=\"doctag\">@param</span> deliverTimestamp 投递时间</div><div class=\"line\"> 37:      * <span class=\"doctag\">@return</span> 纠正结果</div><div class=\"line\"> 38:      */</div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">correctDeliverTimestamp</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deliverTimestamp)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">40</span>:         <span class=\"keyword\">long</span> result = deliverTimestamp;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"keyword\">long</span> maxTimestamp = now + ScheduleMessageService.<span class=\"keyword\">this</span>.delayLevelTable.get(<span class=\"keyword\">this</span>.delayLevel);</div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">if</span> (deliverTimestamp &gt; maxTimestamp) &#123;</div><div class=\"line\"> <span class=\"number\">44</span>:             result = now;</div><div class=\"line\"> <span class=\"number\">45</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"> <span class=\"number\">48</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: </div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeOnTimeup</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">51</span>:         ConsumeQueue cq = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,  delayLevel2QueueId(delayLevel));</div><div class=\"line\"> <span class=\"number\">52</span>: </div><div class=\"line\"> <span class=\"number\">53</span>:         <span class=\"keyword\">long</span> failScheduleOffset = offset;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">if</span> (cq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:             SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class=\"keyword\">this</span>.offset);</div><div class=\"line\"> <span class=\"number\">57</span>:             <span class=\"keyword\">if</span> (bufferCQ != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">58</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">59</span>:                     <span class=\"keyword\">long</span> nextOffset = offset;</div><div class=\"line\"> <span class=\"number\">60</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                     <span class=\"keyword\">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"> <span class=\"number\">62</span>:                         <span class=\"keyword\">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">63</span>:                         <span class=\"keyword\">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">64</span>:                         <span class=\"keyword\">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                         <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"keyword\">long</span> deliverTimestamp = <span class=\"keyword\">this</span>.correctDeliverTimestamp(now, tagsCode);</div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:                         nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:                         <span class=\"keyword\">long</span> countdown = deliverTimestamp - now;</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:                         <span class=\"keyword\">if</span> (countdown &lt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 消息到达可发送时间</span></div><div class=\"line\"> <span class=\"number\">74</span>:                             MessageExt msgExt = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);</div><div class=\"line\"> <span class=\"number\">75</span>:                             <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:                                     <span class=\"comment\">// 发送消息</span></div><div class=\"line\"> <span class=\"number\">78</span>:                                     MessageExtBrokerInner msgInner = <span class=\"keyword\">this</span>.messageTimeup(msgExt);</div><div class=\"line\"> <span class=\"number\">79</span>:                                     PutMessageResult putMessageResult = ScheduleMessageService.<span class=\"keyword\">this</span>.defaultMessageStore.putMessage(msgInner);</div><div class=\"line\"> <span class=\"number\">80</span>:                                     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span> &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123; <span class=\"comment\">// 发送成功</span></div><div class=\"line\"> <span class=\"number\">81</span>:                                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">82</span>:                                     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 发送失败</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                         <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">84</span>:                                         log.error(<span class=\"string\">\"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;\"</span>, msgExt.getTopic(), msgExt.getMsgId());</div><div class=\"line\"> <span class=\"number\">85</span>: </div><div class=\"line\"> <span class=\"number\">86</span>:                                         <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"> <span class=\"number\">87</span>:                                         ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);</div><div class=\"line\"> <span class=\"number\">88</span>: </div><div class=\"line\"> <span class=\"number\">89</span>:                                         <span class=\"comment\">// 更新进度</span></div><div class=\"line\"> <span class=\"number\">90</span>:                                         ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"> <span class=\"number\">91</span>:                                         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">92</span>:                                     &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:                                 &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:                                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">95</span>:                                     log.error(<span class=\"string\">\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\"</span></div><div class=\"line\"> <span class=\"number\">96</span>:                                             + msgExt + <span class=\"string\">\", nextOffset=\"</span> + nextOffset + <span class=\"string\">\",offsetPy=\"</span> + offsetPy + <span class=\"string\">\",sizePy=\"</span> + sizePy, e);</div><div class=\"line\"> <span class=\"number\">97</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">99</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">100</span>:                             <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"><span class=\"number\">101</span>:                             ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), countdown);</div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:                             <span class=\"comment\">// 更新进度</span></div><div class=\"line\"><span class=\"number\">104</span>:                             ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"><span class=\"number\">105</span>:                             <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">107</span>:                     &#125; <span class=\"comment\">// end of for</span></div><div class=\"line\"><span class=\"number\">108</span>: </div><div class=\"line\"><span class=\"number\">109</span>:                     nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:                     <span class=\"comment\">// 安排下一次任务</span></div><div class=\"line\"><span class=\"number\">112</span>:                     ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</div><div class=\"line\"><span class=\"number\">113</span>: </div><div class=\"line\"><span class=\"number\">114</span>:                     <span class=\"comment\">// 更新进度</span></div><div class=\"line\"><span class=\"number\">115</span>:                     ScheduleMessageService.<span class=\"keyword\">this</span>.updateOffset(<span class=\"keyword\">this</span>.delayLevel, nextOffset);</div><div class=\"line\"><span class=\"number\">116</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">118</span>:                     bufferCQ.release();</div><div class=\"line\"><span class=\"number\">119</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">120</span>:             &#125; <span class=\"comment\">// end of if (bufferCQ != null)</span></div><div class=\"line\"><span class=\"number\">121</span>:             <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 消费队列已经被删除部分，跳转到最小的消费进度</span></div><div class=\"line\"><span class=\"number\">122</span>:                 <span class=\"keyword\">long</span> cqMinOffset = cq.getMinOffsetInQueue();</div><div class=\"line\"><span class=\"number\">123</span>:                 <span class=\"keyword\">if</span> (offset &lt; cqMinOffset) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:                     failScheduleOffset = cqMinOffset;</div><div class=\"line\"><span class=\"number\">125</span>:                     log.error(<span class=\"string\">\"schedule CQ offset invalid. offset=\"</span> + offset + <span class=\"string\">\", cqMinOffset=\"</span></div><div class=\"line\"><span class=\"number\">126</span>:                         + cqMinOffset + <span class=\"string\">\", queueId=\"</span> + cq.getQueueId());</div><div class=\"line\"><span class=\"number\">127</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">128</span>:             &#125;</div><div class=\"line\"><span class=\"number\">129</span>:         &#125; <span class=\"comment\">// end of if (cq != null)</span></div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:         ScheduleMessageService.<span class=\"keyword\">this</span>.timer.schedule(<span class=\"keyword\">new</span> DeliverDelayedMessageTimerTask(<span class=\"keyword\">this</span>.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);</div><div class=\"line\"><span class=\"number\">132</span>:     &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">135:      * 设置消息内容</div><div class=\"line\">136:      *</div><div class=\"line\">137:      * <span class=\"doctag\">@param</span> msgExt 消息</div><div class=\"line\">138:      * <span class=\"doctag\">@return</span> 消息</div><div class=\"line\">139:      */</div><div class=\"line\"><span class=\"number\">140</span>:     <span class=\"function\"><span class=\"keyword\">private</span> MessageExtBrokerInner <span class=\"title\">messageTimeup</span><span class=\"params\">(MessageExt msgExt)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">141</span>:         MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">142</span>:         msgInner.setBody(msgExt.getBody());</div><div class=\"line\"><span class=\"number\">143</span>:         msgInner.setFlag(msgExt.getFlag());</div><div class=\"line\"><span class=\"number\">144</span>:         MessageAccessor.setProperties(msgInner, msgExt.getProperties());</div><div class=\"line\"><span class=\"number\">145</span>: </div><div class=\"line\"><span class=\"number\">146</span>:         TopicFilterType topicFilterType = MessageExt.parseTopicFilterType(msgInner.getSysFlag());</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"keyword\">long</span> tagsCodeValue =</div><div class=\"line\"><span class=\"number\">148</span>:             MessageExtBrokerInner.tagsString2tagsCode(topicFilterType, msgInner.getTags());</div><div class=\"line\"><span class=\"number\">149</span>:         msgInner.setTagsCode(tagsCodeValue);</div><div class=\"line\"><span class=\"number\">150</span>:         msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</div><div class=\"line\"><span class=\"number\">151</span>: </div><div class=\"line\"><span class=\"number\">152</span>:         msgInner.setSysFlag(msgExt.getSysFlag());</div><div class=\"line\"><span class=\"number\">153</span>:         msgInner.setBornTimestamp(msgExt.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">154</span>:         msgInner.setBornHost(msgExt.getBornHost());</div><div class=\"line\"><span class=\"number\">155</span>:         msgInner.setStoreHost(msgExt.getStoreHost());</div><div class=\"line\"><span class=\"number\">156</span>:         msgInner.setReconsumeTimes(msgExt.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">157</span>: </div><div class=\"line\"><span class=\"number\">158</span>:         msgInner.setWaitStoreMsgOK(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">159</span>:         MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</div><div class=\"line\"><span class=\"number\">160</span>: </div><div class=\"line\"><span class=\"number\">161</span>:         msgInner.setTopic(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC));</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:         String queueIdStr = msgInner.getProperty(MessageConst.PROPERTY_REAL_QUEUE_ID);</div><div class=\"line\"><span class=\"number\">164</span>:         <span class=\"keyword\">int</span> queueId = Integer.parseInt(queueIdStr);</div><div class=\"line\"><span class=\"number\">165</span>:         msgInner.setQueueId(queueId);</div><div class=\"line\"><span class=\"number\">166</span>: </div><div class=\"line\"><span class=\"number\">167</span>:         <span class=\"keyword\">return</span> msgInner;</div><div class=\"line\"><span class=\"number\">168</span>:     &#125;</div><div class=\"line\"><span class=\"number\">169</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-5-Broker-持久化定时发送进度\"><a href=\"#2-5-Broker-持久化定时发送进度\" class=\"headerlink\" title=\"2.5 Broker 持久化定时发送进度\"></a>2.5 Broker 持久化定时发送进度</h2><ul>\n<li>🦅 定时消息发送进度存储在文件(<code>../config/delayOffset.json</code>)里</li>\n<li>🦅 每 10s 定时持久化发送进度。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【ScheduleMessageService.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3: public void start() &#123;</div><div class=\"line\"> 4:     // 定时发送消息</div><div class=\"line\"> 5:     for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) &#123;</div><div class=\"line\"> 6:         Integer level = entry.getKey();</div><div class=\"line\"> 7:         Long timeDelay = entry.getValue();</div><div class=\"line\"> 8:         Long offset = this.offsetTable.get(level);</div><div class=\"line\"> 9:         if (null == offset) &#123;</div><div class=\"line\">10:             offset = 0L;</div><div class=\"line\">11:         &#125;</div><div class=\"line\">12: </div><div class=\"line\">13:         if (timeDelay != null) &#123;</div><div class=\"line\">14:             this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</div><div class=\"line\">15:         &#125;</div><div class=\"line\">16:     &#125;</div><div class=\"line\">17: </div><div class=\"line\">18:     // 定时持久化发送进度</div><div class=\"line\">19:     this.timer.scheduleAtFixedRate(new TimerTask() &#123;</div><div class=\"line\">20: </div><div class=\"line\">21:         <span class=\"doctag\">@Override</span></div><div class=\"line\">22:         public void run() &#123;</div><div class=\"line\">23:             try &#123;</div><div class=\"line\">24:                 ScheduleMessageService.this.persist();</div><div class=\"line\">25:             &#125; catch (Exception e) &#123;</div><div class=\"line\">26:                 log.error(\"scheduleAtFixedRate flush exception\", e);</div><div class=\"line\">27:             &#125;</div><div class=\"line\">28:         &#125;</div><div class=\"line\">29:     &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</div><div class=\"line\">30: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-消息重试\"><a href=\"#3-消息重试\" class=\"headerlink\" title=\"3. 消息重试\"></a>3. 消息重试</h1><blockquote>\n<p>Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。</p>\n</blockquote>\n<ul>\n<li>🦅 <code>Consumer</code> 将消费失败的消息发回 <code>Broker</code>，进入<strong>延迟消息队列</strong>。即，消费失败的消息，不会立即消费。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【SendMessageProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 消费者发回消息</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> ctx ctx</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> request 请求</div><div class=\"line\"> 7:  * <span class=\"doctag\">@return</span> 响应</div><div class=\"line\"> 8:  * <span class=\"doctag\">@throws</span> RemotingCommandException 当远程调用异常</div><div class=\"line\"> 9:  */</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">consumerSendMsgBack</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span></span></div><div class=\"line\">11:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 处理 delayLevel（独有）。</span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">int</span> delayLevel = requestHeader.getDelayLevel();</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">21</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == delayLevel) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             delayLevel = <span class=\"number\">3</span> + msgExt.getReconsumeTimes();</div><div class=\"line\"><span class=\"number\">24</span>:         &#125;</div><div class=\"line\"><span class=\"number\">25</span>:         msgExt.setDelayTimeLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">30</span>: &#125;</div></pre></td></tr></table></figure>\n"},{"title":"RocketMQ 源码分析 —— Filtersrv","date":"2017-05-16T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/filtersrv](http://www.yunai.me/RocketMQ/filtersrv)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Filtersrv 注册到 Broker](#)\n- [3. 过滤类](#)\n\t- [3.1 Consumer 订阅时设置 过滤类代码](#)\n\t- [3.2 Consumer 上传 过滤类代码](#)\n\t- [3.3 Filter 编译 过滤类代码](#)\n- [4. 过滤消息](#)\n\t- [4.1 Consumer 从 Filtersrv 拉取消息](#)\n\t- [4.2 Filtersrv 从 Broker 拉取消息](#)\n- [5. Filtersrv 高可用](#)\n\n# 1. 概述\n\n`Filtersrv` ，负责**自定义规则**过滤 `Consumer` 从 `Broker` 拉取的消息。\n\n![Filtersrv.png](http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png)\n\n为什么 `Broker` 不提供过滤消息的功能呢？我们来看看官方的说法：\n\n> * Broker 端消息过滤  \n>  在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。 缺点是增加了 Broker 的负担，实现相对复杂。  \n> (1). 淘宝 Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。  \n> (2). 淘宝 RocketMQ 支持按照简单的 Message Tag 过滤，也支持按照 Message Header、body 进行过滤。  \n(3). CORBA Notification 规范中也支持灵活的语法表达式过滤。  \n> * Consumer 端消息过滤  \n> 这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 Consumer 端。\n\n**就是在这种考虑下，`Filtersrv` 出现了。减少了 `Broker` 的负担，又减少了 `Consumer` 接收无用的消息。当然缺点也是有的，多了一层 `Filtersrv` 网络开销。**\n \n# 2. Filtersrv 注册到 Broker\n\n* 🦅 一个 `Filtersrv` **只**对应一个 `Broker`。\n* 🦅 一个 `Broker` 可以对应**多个** `Filtersrv`。**`Filtersrv` 的高可用通过启动多个 `Filtersrv` 实现**。\n* 🦅 `Filtersrv` 注册失败时，主动**退出关闭**。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FiltersrvController.java】\n  2: public boolean initialize() {\n  3:     // ....(省略代码)\n  4: \n  5:     // 固定间隔注册到Broker\n  6:     this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  7: \n  8:         @Override\n  9:         public void run() {\n 10:             FiltersrvController.this.registerFilterServerToBroker();\n 11:         }\n 12:     }, 15, 10, TimeUnit.SECONDS); // TODO edit by 芋艿：initialDelay时间太短，可能导致初始化失败。从3=》15\n 13: \n 14:     // ....(省略代码)\n 15: }\n 16: \n 17: /**\n 18:  * 注册Filtersrv 到 Broker\n 19:  * ！！！如果注册失败，关闭Filtersrv\n 20:  */\n 21: public void registerFilterServerToBroker() {\n 22:     try {\n 23:         RegisterFilterServerResponseHeader responseHeader =\n 24:             this.filterServerOuterAPI.registerFilterServerToBroker(\n 25:                 this.filtersrvConfig.getConnectWhichBroker(), this.localAddr());\n 26:         this.defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getPullAPIWrapper()\n 27:             .setDefaultBrokerId(responseHeader.getBrokerId());\n 28: \n 29:         if (null == this.brokerName) {\n 30:             this.brokerName = responseHeader.getBrokerName();\n 31:         }\n 32: \n 33:         log.info(\"register filter server<{}> to broker<{}> OK, Return: {} {}\",\n 34:             this.localAddr(),\n 35:             this.filtersrvConfig.getConnectWhichBroker(),\n 36:             responseHeader.getBrokerName(),\n 37:             responseHeader.getBrokerId());\n 38:     } catch (Exception e) {\n 39:         log.warn(\"register filter server Exception\", e);\n 40: \n 41:         log.warn(\"access broker failed, kill oneself\");\n 42:         System.exit(-1); // 异常退出\n 43:     }\n 44: }\n```\n\n# 3. 过滤类 \n\n![Filtersrv过滤类](http://www.yunai.me/images/RocketMQ/2017_05_17/03.png)\n\n## 3.1 Consumer 订阅时设置 过滤类代码\n\n* 🦅 `Consumer` 针对每个 `Topic` 可以订阅不同的 `过滤类代码`。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQPushConsumer.java】\n  2: @Override\n  3: public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {\n  4:     this.defaultMQPushConsumerImpl.subscribe(topic, fullClassName, filterClassSource);\n  5: }\n```\n\n## 3.2 Consumer 上传 过滤类代码\n\n* 🦅 `Consumer` 心跳注册到 `Broker` 的同时，上传 `过滤类代码` 到 `Broker` 对应的**所有** `Filtersrv`。\n\n```Java\n  1: // ⬇️⬇️⬇️【MQClientInstance.java】\n  2: /**\n  3:  * 发送心跳到Broker，上传过滤类源码到Filtersrv\n  4:  */\n  5: public void sendHeartbeatToAllBrokerWithLock() {\n  6:     if (this.lockHeartbeat.tryLock()) {\n  7:         try {\n  8:             this.sendHeartbeatToAllBroker();\n  9:             this.uploadFilterClassSource();\n 10:         } catch (final Exception e) {\n 11:             log.error(\"sendHeartbeatToAllBroker exception\", e);\n 12:         } finally {\n 13:             this.lockHeartbeat.unlock();\n 14:         }\n 15:     } else {\n 16:         log.warn(\"lock heartBeat, but failed.\");\n 17:     }\n 18: }\n 19: \n 20: /**\n 21:  * 上传过滤类到Filtersrv\n 22:  */\n 23: private void uploadFilterClassSource() {\n 24:     Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();\n 25:     while (it.hasNext()) {\n 26:         Entry<String, MQConsumerInner> next = it.next();\n 27:         MQConsumerInner consumer = next.getValue();\n 28:         if (ConsumeType.CONSUME_PASSIVELY == consumer.consumeType()) {\n 29:             Set<SubscriptionData> subscriptions = consumer.subscriptions();\n 30:             for (SubscriptionData sub : subscriptions) {\n 31:                 if (sub.isClassFilterMode() && sub.getFilterClassSource() != null) {\n 32:                     final String consumerGroup = consumer.groupName();\n 33:                     final String className = sub.getSubString();\n 34:                     final String topic = sub.getTopic();\n 35:                     final String filterClassSource = sub.getFilterClassSource();\n 36:                     try {\n 37:                         this.uploadFilterClassToAllFilterServer(consumerGroup, className, topic, filterClassSource);\n 38:                     } catch (Exception e) {\n 39:                         log.error(\"uploadFilterClassToAllFilterServer Exception\", e);\n 40:                     }\n 41:                 }\n 42:             }\n 43:         }\n 44:     }\n 45: }\n```\n\n## 3.3 Filter 编译 过滤类代码\n\n* 🦅 `Filtersrv` 处理 `Consumer` 上传的 `过滤类代码`，并进行**编译**使用。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FilterClassManager.java】\n  2: /**\n  3:  * 注册过滤类\n  4:  *\n  5:  * @param consumerGroup 消费分组\n  6:  * @param topic Topic\n  7:  * @param className 过滤类名\n  8:  * @param classCRC 过滤类源码CRC\n  9:  * @param filterSourceBinary 过滤类源码\n 10:  * @return 是否注册成功\n 11:  */\n 12: public boolean registerFilterClass(final String consumerGroup, final String topic,\n 13:     final String className, final int classCRC, final byte[] filterSourceBinary) {\n 14:     final String key = buildKey(consumerGroup, topic);\n 15:     // 判断是否要注册新的过滤类\n 16:     boolean registerNew = false;\n 17:     FilterClassInfo filterClassInfoPrev = this.filterClassTable.get(key);\n 18:     if (null == filterClassInfoPrev) {\n 19:         registerNew = true;\n 20:     } else {\n 21:         if (this.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) {\n 22:             if (filterClassInfoPrev.getClassCRC() != classCRC && classCRC != 0) { // 类有变化\n 23:                 registerNew = true;\n 24:             }\n 25:         }\n 26:     }\n 27:     // 注册新的过滤类\n 28:     if (registerNew) {\n 29:         synchronized (this.compileLock) {\n 30:             filterClassInfoPrev = this.filterClassTable.get(key);\n 31:             if (null != filterClassInfoPrev && filterClassInfoPrev.getClassCRC() == classCRC) {\n 32:                 return true;\n 33:             }\n 34:             try {\n 35:                 FilterClassInfo filterClassInfoNew = new FilterClassInfo();\n 36:                 filterClassInfoNew.setClassName(className);\n 37:                 filterClassInfoNew.setClassCRC(0);\n 38:                 filterClassInfoNew.setMessageFilter(null);\n 39: \n 40:                 if (this.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) {\n 41:                     String javaSource = new String(filterSourceBinary, MixAll.DEFAULT_CHARSET);\n 42:                     // 编译新的过滤类\n 43:                     Class<?> newClass = DynaCode.compileAndLoadClass(className, javaSource);\n 44:                     // 创建新的过滤类对象\n 45:                     Object newInstance = newClass.newInstance();\n 46:                     filterClassInfoNew.setMessageFilter((MessageFilter) newInstance);\n 47:                     filterClassInfoNew.setClassCRC(classCRC);\n 48:                 }\n 49: \n 50:                 this.filterClassTable.put(key, filterClassInfoNew);\n 51:             } catch (Throwable e) {\n 52:                 String info = String.format(\"FilterServer, registerFilterClass Exception, consumerGroup: %s topic: %s className: %s\",\n 53:                             consumerGroup, topic, className);\n 54:                 log.error(info, e);\n 55:                 return false;\n 56:             }\n 57:         }\n 58:     }\n 59: \n 60:     return true;\n 61: }\n```\n\n-------\n\n# 4. 过滤消息\n\n![Filtersrv.png](http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png)\n\n## 4.1 Consumer 从 Filtersrv 拉取消息\n\n* 🦅 `Consumer` 拉取 **使用过滤类方式订阅** 的消费消息时，从 `Broker` 对应的 `Filtersrv` 列表**随机**选择一个拉取消息。**如果选择不到 `Filtersrv`，则无法拉取消息。因此，`Filtersrv` 一定要做高可用**。\n\n```Java\n  1: // ⬇️⬇️⬇️【PullAPIWrapper.java】\n  2: /**\n  3:  * 拉取消息核心方法\n  4:  *\n  5:  * @param mq 消息嘟列\n  6:  * @param subExpression 订阅表达式\n  7:  * @param subVersion 订阅版本号\n  8:  * @param offset 拉取队列开始位置\n  9:  * @param maxNums 批量拉 取消息数量\n 10:  * @param sysFlag 拉取系统标识\n 11:  * @param commitOffset 提交消费进度\n 12:  * @param brokerSuspendMaxTimeMillis broker挂起请求最大时间\n 13:  * @param timeoutMillis 请求broker超时时间\n 14:  * @param communicationMode 通讯模式\n 15:  * @param pullCallback 拉取回调\n 16:  * @return 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。\n 17:  * @throws MQClientException 当寻找不到 broker 时，或发生其他client异常\n 18:  * @throws RemotingException 当远程调用发生异常时\n 19:  * @throws MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。\n 20:  * @throws InterruptedException 当发生中断异常时\n 21:  */\n 22: protected PullResult pullKernelImpl(\n 23:     final MessageQueue mq,\n 24:     final String subExpression,\n 25:     final long subVersion,\n 26:     final long offset,\n 27:     final int maxNums,\n 28:     final int sysFlag,\n 29:     final long commitOffset,\n 30:     final long brokerSuspendMaxTimeMillis,\n 31:     final long timeoutMillis,\n 32:     final CommunicationMode communicationMode,\n 33:     final PullCallback pullCallback\n 34: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 35:     // // ....(省略代码)\n 36:     // 请求拉取消息\n 37:     if (findBrokerResult != null) {\n 38:         // ....(省略代码)\n 39:         // 若订阅topic使用过滤类，使用filtersrv获取消息\n 40:         String brokerAddr = findBrokerResult.getBrokerAddr();\n 41:         if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {\n 42:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n 43:         }\n 44: \n 45:         PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(\n 46:             brokerAddr,\n 47:             requestHeader,\n 48:             timeoutMillis,\n 49:             communicationMode,\n 50:             pullCallback);\n 51: \n 52:         return pullResult;\n 53:     }\n 54: \n 55:     // Broker信息不存在，则抛出异常\n 56:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n 57: }\n 58: \n 59: /**\n 60:  * 计算filtersrv地址。如果有多个filtersrv，随机选择一个。\n 61:  *\n 62:  * @param topic Topic\n 63:  * @param brokerAddr broker地址\n 64:  * @return filtersrv地址\n 65:  * @throws MQClientException 当filtersrv不存在时\n 66:  */\n 67: private String computPullFromWhichFilterServer(final String topic, final String brokerAddr)\n 68:     throws MQClientException {\n 69:     ConcurrentHashMap<String, TopicRouteData> topicRouteTable = this.mQClientFactory.getTopicRouteTable();\n 70:     if (topicRouteTable != null) {\n 71:         TopicRouteData topicRouteData = topicRouteTable.get(topic);\n 72:         List<String> list = topicRouteData.getFilterServerTable().get(brokerAddr);\n 73:         if (list != null && !list.isEmpty()) {\n 74:             return list.get(randomNum() % list.size());\n 75:         }\n 76:     }\n 77:     throw new MQClientException(\"Find Filter Server Failed, Broker Addr: \" + brokerAddr + \" topic: \"\n 78:         + topic, null);\n 79: }\n```\n\n## 4.2 Filtersrv 从 Broker 拉取消息\n\n* 🦅 `Filtersrv` 拉取消息后，会建议 `Consumer` 向 `Broker主节点` 拉取消息。\n* 🦅 `Filtersrv` 可以理解成一个 `Consumer`，向 `Broker` 拉取消息时，实际使用的 `DefaultMQPullConsumer.java` 的方法和逻辑。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultRequestProcessor.java】\n  2: /**\n  3:  * 拉取消息\n  4:  *\n  5:  * @param ctx 拉取消息context\n  6:  * @param request 拉取消息请求\n  7:  * @return 响应\n  8:  * @throws Exception 当发生异常时\n  9:  */\n 10: private RemotingCommand pullMessageForward(final ChannelHandlerContext ctx, final RemotingCommand request) throws Exception {\n 11:     final RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n 12:     final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n 13:     final PullMessageRequestHeader requestHeader =\n 14:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n 15: \n 16:     final FilterContext filterContext = new FilterContext();\n 17:     filterContext.setConsumerGroup(requestHeader.getConsumerGroup());\n 18: \n 19:     response.setOpaque(request.getOpaque());\n 20: \n 21:     DefaultMQPullConsumer pullConsumer = this.filtersrvController.getDefaultMQPullConsumer();\n 22: \n 23:     // 校验Topic过滤类是否完整\n 24:     final FilterClassInfo findFilterClass = this.filtersrvController.getFilterClassManager().findFilterClass(requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 25:     if (null == findFilterClass) {\n 26:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 27:         response.setRemark(\"Find Filter class failed, not registered\");\n 28:         return response;\n 29:     }\n 30:     if (null == findFilterClass.getMessageFilter()) {\n 31:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 32:         response.setRemark(\"Find Filter class failed, registered but no class\");\n 33:         return response;\n 34:     }\n 35: \n 36:     // 设置下次请求从 Broker主节点。\n 37:     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n 38: \n 39:     MessageQueue mq = new MessageQueue();\n 40:     mq.setTopic(requestHeader.getTopic());\n 41:     mq.setQueueId(requestHeader.getQueueId());\n 42:     mq.setBrokerName(this.filtersrvController.getBrokerName());\n 43:     long offset = requestHeader.getQueueOffset();\n 44:     int maxNums = requestHeader.getMaxMsgNums();\n 45: \n 46:     final PullCallback pullCallback = new PullCallback() {\n 47: \n 48:         @Override\n 49:         public void onSuccess(PullResult pullResult) {\n 50:             responseHeader.setMaxOffset(pullResult.getMaxOffset());\n 51:             responseHeader.setMinOffset(pullResult.getMinOffset());\n 52:             responseHeader.setNextBeginOffset(pullResult.getNextBeginOffset());\n 53:             response.setRemark(null);\n 54: \n 55:             switch (pullResult.getPullStatus()) {\n 56:                 case FOUND:\n 57:                     response.setCode(ResponseCode.SUCCESS);\n 58: \n 59:                     List<MessageExt> msgListOK = new ArrayList<MessageExt>();\n 60:                     try {\n 61:                         for (MessageExt msg : pullResult.getMsgFoundList()) {\n 62:                             // 使用过滤类过滤消息\n 63:                             boolean match = findFilterClass.getMessageFilter().match(msg, filterContext);\n 64:                             if (match) {\n 65:                                 msgListOK.add(msg);\n 66:                             }\n 67:                         }\n 68: \n 69:                         if (!msgListOK.isEmpty()) {\n 70:                             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, msgListOK);\n 71:                             return;\n 72:                         } else {\n 73:                             response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n 74:                         }\n 75:                     } catch (Throwable e) {\n 76:                         final String error =\n 77:                             String.format(\"do Message Filter Exception, ConsumerGroup: %s Topic: %s \",\n 78:                                 requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 79:                         log.error(error, e);\n 80: \n 81:                         response.setCode(ResponseCode.SYSTEM_ERROR);\n 82:                         response.setRemark(error + RemotingHelper.exceptionSimpleDesc(e));\n 83:                         returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n 84:                         return;\n 85:                     }\n 86: \n 87:                     break;\n 88:                 case NO_MATCHED_MSG:\n 89:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n 90:                     break;\n 91:                 case NO_NEW_MSG:\n 92:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n 93:                     break;\n 94:                 case OFFSET_ILLEGAL:\n 95:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n 96:                     break;\n 97:                 default:\n 98:                     break;\n 99:             }\n100: \n101:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n102:         }\n103: \n104:         @Override\n105:         public void onException(Throwable e) {\n106:             response.setCode(ResponseCode.SYSTEM_ERROR);\n107:             response.setRemark(\"Pull Callback Exception, \" + RemotingHelper.exceptionSimpleDesc(e));\n108:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n109:             return;\n110:         }\n111:     };\n112: \n113:     // 拉取消息\n114:     pullConsumer.pullBlockIfNotFound(mq, null, offset, maxNums, pullCallback);\n115:     return null;\n116: }\n``` \n\n# 5. Filtersrv 高可用\n\n![Filtersrv过可用](http://www.yunai.me/images/RocketMQ/2017_05_17/02.png)\n\n\n","source":"_posts/RocketMQ/2017_05_17_RocketMQ源码分析——Filtersrv.md","raw":"title: RocketMQ 源码分析 —— Filtersrv\ndate: 2017-05-17\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/filtersrv\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/filtersrv](http://www.yunai.me/RocketMQ/filtersrv)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. Filtersrv 注册到 Broker](#)\n- [3. 过滤类](#)\n\t- [3.1 Consumer 订阅时设置 过滤类代码](#)\n\t- [3.2 Consumer 上传 过滤类代码](#)\n\t- [3.3 Filter 编译 过滤类代码](#)\n- [4. 过滤消息](#)\n\t- [4.1 Consumer 从 Filtersrv 拉取消息](#)\n\t- [4.2 Filtersrv 从 Broker 拉取消息](#)\n- [5. Filtersrv 高可用](#)\n\n# 1. 概述\n\n`Filtersrv` ，负责**自定义规则**过滤 `Consumer` 从 `Broker` 拉取的消息。\n\n![Filtersrv.png](http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png)\n\n为什么 `Broker` 不提供过滤消息的功能呢？我们来看看官方的说法：\n\n> * Broker 端消息过滤  \n>  在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。 缺点是增加了 Broker 的负担，实现相对复杂。  \n> (1). 淘宝 Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。  \n> (2). 淘宝 RocketMQ 支持按照简单的 Message Tag 过滤，也支持按照 Message Header、body 进行过滤。  \n(3). CORBA Notification 规范中也支持灵活的语法表达式过滤。  \n> * Consumer 端消息过滤  \n> 这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 Consumer 端。\n\n**就是在这种考虑下，`Filtersrv` 出现了。减少了 `Broker` 的负担，又减少了 `Consumer` 接收无用的消息。当然缺点也是有的，多了一层 `Filtersrv` 网络开销。**\n \n# 2. Filtersrv 注册到 Broker\n\n* 🦅 一个 `Filtersrv` **只**对应一个 `Broker`。\n* 🦅 一个 `Broker` 可以对应**多个** `Filtersrv`。**`Filtersrv` 的高可用通过启动多个 `Filtersrv` 实现**。\n* 🦅 `Filtersrv` 注册失败时，主动**退出关闭**。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FiltersrvController.java】\n  2: public boolean initialize() {\n  3:     // ....(省略代码)\n  4: \n  5:     // 固定间隔注册到Broker\n  6:     this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  7: \n  8:         @Override\n  9:         public void run() {\n 10:             FiltersrvController.this.registerFilterServerToBroker();\n 11:         }\n 12:     }, 15, 10, TimeUnit.SECONDS); // TODO edit by 芋艿：initialDelay时间太短，可能导致初始化失败。从3=》15\n 13: \n 14:     // ....(省略代码)\n 15: }\n 16: \n 17: /**\n 18:  * 注册Filtersrv 到 Broker\n 19:  * ！！！如果注册失败，关闭Filtersrv\n 20:  */\n 21: public void registerFilterServerToBroker() {\n 22:     try {\n 23:         RegisterFilterServerResponseHeader responseHeader =\n 24:             this.filterServerOuterAPI.registerFilterServerToBroker(\n 25:                 this.filtersrvConfig.getConnectWhichBroker(), this.localAddr());\n 26:         this.defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getPullAPIWrapper()\n 27:             .setDefaultBrokerId(responseHeader.getBrokerId());\n 28: \n 29:         if (null == this.brokerName) {\n 30:             this.brokerName = responseHeader.getBrokerName();\n 31:         }\n 32: \n 33:         log.info(\"register filter server<{}> to broker<{}> OK, Return: {} {}\",\n 34:             this.localAddr(),\n 35:             this.filtersrvConfig.getConnectWhichBroker(),\n 36:             responseHeader.getBrokerName(),\n 37:             responseHeader.getBrokerId());\n 38:     } catch (Exception e) {\n 39:         log.warn(\"register filter server Exception\", e);\n 40: \n 41:         log.warn(\"access broker failed, kill oneself\");\n 42:         System.exit(-1); // 异常退出\n 43:     }\n 44: }\n```\n\n# 3. 过滤类 \n\n![Filtersrv过滤类](http://www.yunai.me/images/RocketMQ/2017_05_17/03.png)\n\n## 3.1 Consumer 订阅时设置 过滤类代码\n\n* 🦅 `Consumer` 针对每个 `Topic` 可以订阅不同的 `过滤类代码`。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQPushConsumer.java】\n  2: @Override\n  3: public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {\n  4:     this.defaultMQPushConsumerImpl.subscribe(topic, fullClassName, filterClassSource);\n  5: }\n```\n\n## 3.2 Consumer 上传 过滤类代码\n\n* 🦅 `Consumer` 心跳注册到 `Broker` 的同时，上传 `过滤类代码` 到 `Broker` 对应的**所有** `Filtersrv`。\n\n```Java\n  1: // ⬇️⬇️⬇️【MQClientInstance.java】\n  2: /**\n  3:  * 发送心跳到Broker，上传过滤类源码到Filtersrv\n  4:  */\n  5: public void sendHeartbeatToAllBrokerWithLock() {\n  6:     if (this.lockHeartbeat.tryLock()) {\n  7:         try {\n  8:             this.sendHeartbeatToAllBroker();\n  9:             this.uploadFilterClassSource();\n 10:         } catch (final Exception e) {\n 11:             log.error(\"sendHeartbeatToAllBroker exception\", e);\n 12:         } finally {\n 13:             this.lockHeartbeat.unlock();\n 14:         }\n 15:     } else {\n 16:         log.warn(\"lock heartBeat, but failed.\");\n 17:     }\n 18: }\n 19: \n 20: /**\n 21:  * 上传过滤类到Filtersrv\n 22:  */\n 23: private void uploadFilterClassSource() {\n 24:     Iterator<Entry<String, MQConsumerInner>> it = this.consumerTable.entrySet().iterator();\n 25:     while (it.hasNext()) {\n 26:         Entry<String, MQConsumerInner> next = it.next();\n 27:         MQConsumerInner consumer = next.getValue();\n 28:         if (ConsumeType.CONSUME_PASSIVELY == consumer.consumeType()) {\n 29:             Set<SubscriptionData> subscriptions = consumer.subscriptions();\n 30:             for (SubscriptionData sub : subscriptions) {\n 31:                 if (sub.isClassFilterMode() && sub.getFilterClassSource() != null) {\n 32:                     final String consumerGroup = consumer.groupName();\n 33:                     final String className = sub.getSubString();\n 34:                     final String topic = sub.getTopic();\n 35:                     final String filterClassSource = sub.getFilterClassSource();\n 36:                     try {\n 37:                         this.uploadFilterClassToAllFilterServer(consumerGroup, className, topic, filterClassSource);\n 38:                     } catch (Exception e) {\n 39:                         log.error(\"uploadFilterClassToAllFilterServer Exception\", e);\n 40:                     }\n 41:                 }\n 42:             }\n 43:         }\n 44:     }\n 45: }\n```\n\n## 3.3 Filter 编译 过滤类代码\n\n* 🦅 `Filtersrv` 处理 `Consumer` 上传的 `过滤类代码`，并进行**编译**使用。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【FilterClassManager.java】\n  2: /**\n  3:  * 注册过滤类\n  4:  *\n  5:  * @param consumerGroup 消费分组\n  6:  * @param topic Topic\n  7:  * @param className 过滤类名\n  8:  * @param classCRC 过滤类源码CRC\n  9:  * @param filterSourceBinary 过滤类源码\n 10:  * @return 是否注册成功\n 11:  */\n 12: public boolean registerFilterClass(final String consumerGroup, final String topic,\n 13:     final String className, final int classCRC, final byte[] filterSourceBinary) {\n 14:     final String key = buildKey(consumerGroup, topic);\n 15:     // 判断是否要注册新的过滤类\n 16:     boolean registerNew = false;\n 17:     FilterClassInfo filterClassInfoPrev = this.filterClassTable.get(key);\n 18:     if (null == filterClassInfoPrev) {\n 19:         registerNew = true;\n 20:     } else {\n 21:         if (this.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) {\n 22:             if (filterClassInfoPrev.getClassCRC() != classCRC && classCRC != 0) { // 类有变化\n 23:                 registerNew = true;\n 24:             }\n 25:         }\n 26:     }\n 27:     // 注册新的过滤类\n 28:     if (registerNew) {\n 29:         synchronized (this.compileLock) {\n 30:             filterClassInfoPrev = this.filterClassTable.get(key);\n 31:             if (null != filterClassInfoPrev && filterClassInfoPrev.getClassCRC() == classCRC) {\n 32:                 return true;\n 33:             }\n 34:             try {\n 35:                 FilterClassInfo filterClassInfoNew = new FilterClassInfo();\n 36:                 filterClassInfoNew.setClassName(className);\n 37:                 filterClassInfoNew.setClassCRC(0);\n 38:                 filterClassInfoNew.setMessageFilter(null);\n 39: \n 40:                 if (this.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) {\n 41:                     String javaSource = new String(filterSourceBinary, MixAll.DEFAULT_CHARSET);\n 42:                     // 编译新的过滤类\n 43:                     Class<?> newClass = DynaCode.compileAndLoadClass(className, javaSource);\n 44:                     // 创建新的过滤类对象\n 45:                     Object newInstance = newClass.newInstance();\n 46:                     filterClassInfoNew.setMessageFilter((MessageFilter) newInstance);\n 47:                     filterClassInfoNew.setClassCRC(classCRC);\n 48:                 }\n 49: \n 50:                 this.filterClassTable.put(key, filterClassInfoNew);\n 51:             } catch (Throwable e) {\n 52:                 String info = String.format(\"FilterServer, registerFilterClass Exception, consumerGroup: %s topic: %s className: %s\",\n 53:                             consumerGroup, topic, className);\n 54:                 log.error(info, e);\n 55:                 return false;\n 56:             }\n 57:         }\n 58:     }\n 59: \n 60:     return true;\n 61: }\n```\n\n-------\n\n# 4. 过滤消息\n\n![Filtersrv.png](http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png)\n\n## 4.1 Consumer 从 Filtersrv 拉取消息\n\n* 🦅 `Consumer` 拉取 **使用过滤类方式订阅** 的消费消息时，从 `Broker` 对应的 `Filtersrv` 列表**随机**选择一个拉取消息。**如果选择不到 `Filtersrv`，则无法拉取消息。因此，`Filtersrv` 一定要做高可用**。\n\n```Java\n  1: // ⬇️⬇️⬇️【PullAPIWrapper.java】\n  2: /**\n  3:  * 拉取消息核心方法\n  4:  *\n  5:  * @param mq 消息嘟列\n  6:  * @param subExpression 订阅表达式\n  7:  * @param subVersion 订阅版本号\n  8:  * @param offset 拉取队列开始位置\n  9:  * @param maxNums 批量拉 取消息数量\n 10:  * @param sysFlag 拉取系统标识\n 11:  * @param commitOffset 提交消费进度\n 12:  * @param brokerSuspendMaxTimeMillis broker挂起请求最大时间\n 13:  * @param timeoutMillis 请求broker超时时间\n 14:  * @param communicationMode 通讯模式\n 15:  * @param pullCallback 拉取回调\n 16:  * @return 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。\n 17:  * @throws MQClientException 当寻找不到 broker 时，或发生其他client异常\n 18:  * @throws RemotingException 当远程调用发生异常时\n 19:  * @throws MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。\n 20:  * @throws InterruptedException 当发生中断异常时\n 21:  */\n 22: protected PullResult pullKernelImpl(\n 23:     final MessageQueue mq,\n 24:     final String subExpression,\n 25:     final long subVersion,\n 26:     final long offset,\n 27:     final int maxNums,\n 28:     final int sysFlag,\n 29:     final long commitOffset,\n 30:     final long brokerSuspendMaxTimeMillis,\n 31:     final long timeoutMillis,\n 32:     final CommunicationMode communicationMode,\n 33:     final PullCallback pullCallback\n 34: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 35:     // // ....(省略代码)\n 36:     // 请求拉取消息\n 37:     if (findBrokerResult != null) {\n 38:         // ....(省略代码)\n 39:         // 若订阅topic使用过滤类，使用filtersrv获取消息\n 40:         String brokerAddr = findBrokerResult.getBrokerAddr();\n 41:         if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) {\n 42:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n 43:         }\n 44: \n 45:         PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(\n 46:             brokerAddr,\n 47:             requestHeader,\n 48:             timeoutMillis,\n 49:             communicationMode,\n 50:             pullCallback);\n 51: \n 52:         return pullResult;\n 53:     }\n 54: \n 55:     // Broker信息不存在，则抛出异常\n 56:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n 57: }\n 58: \n 59: /**\n 60:  * 计算filtersrv地址。如果有多个filtersrv，随机选择一个。\n 61:  *\n 62:  * @param topic Topic\n 63:  * @param brokerAddr broker地址\n 64:  * @return filtersrv地址\n 65:  * @throws MQClientException 当filtersrv不存在时\n 66:  */\n 67: private String computPullFromWhichFilterServer(final String topic, final String brokerAddr)\n 68:     throws MQClientException {\n 69:     ConcurrentHashMap<String, TopicRouteData> topicRouteTable = this.mQClientFactory.getTopicRouteTable();\n 70:     if (topicRouteTable != null) {\n 71:         TopicRouteData topicRouteData = topicRouteTable.get(topic);\n 72:         List<String> list = topicRouteData.getFilterServerTable().get(brokerAddr);\n 73:         if (list != null && !list.isEmpty()) {\n 74:             return list.get(randomNum() % list.size());\n 75:         }\n 76:     }\n 77:     throw new MQClientException(\"Find Filter Server Failed, Broker Addr: \" + brokerAddr + \" topic: \"\n 78:         + topic, null);\n 79: }\n```\n\n## 4.2 Filtersrv 从 Broker 拉取消息\n\n* 🦅 `Filtersrv` 拉取消息后，会建议 `Consumer` 向 `Broker主节点` 拉取消息。\n* 🦅 `Filtersrv` 可以理解成一个 `Consumer`，向 `Broker` 拉取消息时，实际使用的 `DefaultMQPullConsumer.java` 的方法和逻辑。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultRequestProcessor.java】\n  2: /**\n  3:  * 拉取消息\n  4:  *\n  5:  * @param ctx 拉取消息context\n  6:  * @param request 拉取消息请求\n  7:  * @return 响应\n  8:  * @throws Exception 当发生异常时\n  9:  */\n 10: private RemotingCommand pullMessageForward(final ChannelHandlerContext ctx, final RemotingCommand request) throws Exception {\n 11:     final RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n 12:     final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n 13:     final PullMessageRequestHeader requestHeader =\n 14:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n 15: \n 16:     final FilterContext filterContext = new FilterContext();\n 17:     filterContext.setConsumerGroup(requestHeader.getConsumerGroup());\n 18: \n 19:     response.setOpaque(request.getOpaque());\n 20: \n 21:     DefaultMQPullConsumer pullConsumer = this.filtersrvController.getDefaultMQPullConsumer();\n 22: \n 23:     // 校验Topic过滤类是否完整\n 24:     final FilterClassInfo findFilterClass = this.filtersrvController.getFilterClassManager().findFilterClass(requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 25:     if (null == findFilterClass) {\n 26:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 27:         response.setRemark(\"Find Filter class failed, not registered\");\n 28:         return response;\n 29:     }\n 30:     if (null == findFilterClass.getMessageFilter()) {\n 31:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 32:         response.setRemark(\"Find Filter class failed, registered but no class\");\n 33:         return response;\n 34:     }\n 35: \n 36:     // 设置下次请求从 Broker主节点。\n 37:     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n 38: \n 39:     MessageQueue mq = new MessageQueue();\n 40:     mq.setTopic(requestHeader.getTopic());\n 41:     mq.setQueueId(requestHeader.getQueueId());\n 42:     mq.setBrokerName(this.filtersrvController.getBrokerName());\n 43:     long offset = requestHeader.getQueueOffset();\n 44:     int maxNums = requestHeader.getMaxMsgNums();\n 45: \n 46:     final PullCallback pullCallback = new PullCallback() {\n 47: \n 48:         @Override\n 49:         public void onSuccess(PullResult pullResult) {\n 50:             responseHeader.setMaxOffset(pullResult.getMaxOffset());\n 51:             responseHeader.setMinOffset(pullResult.getMinOffset());\n 52:             responseHeader.setNextBeginOffset(pullResult.getNextBeginOffset());\n 53:             response.setRemark(null);\n 54: \n 55:             switch (pullResult.getPullStatus()) {\n 56:                 case FOUND:\n 57:                     response.setCode(ResponseCode.SUCCESS);\n 58: \n 59:                     List<MessageExt> msgListOK = new ArrayList<MessageExt>();\n 60:                     try {\n 61:                         for (MessageExt msg : pullResult.getMsgFoundList()) {\n 62:                             // 使用过滤类过滤消息\n 63:                             boolean match = findFilterClass.getMessageFilter().match(msg, filterContext);\n 64:                             if (match) {\n 65:                                 msgListOK.add(msg);\n 66:                             }\n 67:                         }\n 68: \n 69:                         if (!msgListOK.isEmpty()) {\n 70:                             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, msgListOK);\n 71:                             return;\n 72:                         } else {\n 73:                             response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n 74:                         }\n 75:                     } catch (Throwable e) {\n 76:                         final String error =\n 77:                             String.format(\"do Message Filter Exception, ConsumerGroup: %s Topic: %s \",\n 78:                                 requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 79:                         log.error(error, e);\n 80: \n 81:                         response.setCode(ResponseCode.SYSTEM_ERROR);\n 82:                         response.setRemark(error + RemotingHelper.exceptionSimpleDesc(e));\n 83:                         returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n 84:                         return;\n 85:                     }\n 86: \n 87:                     break;\n 88:                 case NO_MATCHED_MSG:\n 89:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n 90:                     break;\n 91:                 case NO_NEW_MSG:\n 92:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n 93:                     break;\n 94:                 case OFFSET_ILLEGAL:\n 95:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n 96:                     break;\n 97:                 default:\n 98:                     break;\n 99:             }\n100: \n101:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n102:         }\n103: \n104:         @Override\n105:         public void onException(Throwable e) {\n106:             response.setCode(ResponseCode.SYSTEM_ERROR);\n107:             response.setRemark(\"Pull Callback Exception, \" + RemotingHelper.exceptionSimpleDesc(e));\n108:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, null);\n109:             return;\n110:         }\n111:     };\n112: \n113:     // 拉取消息\n114:     pullConsumer.pullBlockIfNotFound(mq, null, offset, maxNums, pullCallback);\n115:     return null;\n116: }\n``` \n\n# 5. Filtersrv 高可用\n\n![Filtersrv过可用](http://www.yunai.me/images/RocketMQ/2017_05_17/02.png)\n\n\n","slug":"RocketMQ/filtersrv","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzaj0010ag5d0kiosnza","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/filtersrv\">http://www.yunai.me/RocketMQ/filtersrv</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Filtersrv 注册到 Broker</a></li>\n<li><a href=\"#\">3. 过滤类</a><ul>\n<li><a href=\"#\">3.1 Consumer 订阅时设置 过滤类代码</a></li>\n<li><a href=\"#\">3.2 Consumer 上传 过滤类代码</a></li>\n<li><a href=\"#\">3.3 Filter 编译 过滤类代码</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 过滤消息</a><ul>\n<li><a href=\"#\">4.1 Consumer 从 Filtersrv 拉取消息</a></li>\n<li><a href=\"#\">4.2 Filtersrv 从 Broker 拉取消息</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5. Filtersrv 高可用</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><code>Filtersrv</code> ，负责<strong>自定义规则</strong>过滤 <code>Consumer</code> 从 <code>Broker</code> 拉取的消息。</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png\" alt=\"Filtersrv.png\"></p>\n<p>为什么 <code>Broker</code> 不提供过滤消息的功能呢？我们来看看官方的说法：</p>\n<blockquote>\n<ul>\n<li>Broker 端消息过滤<br>在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。 缺点是增加了 Broker 的负担，实现相对复杂。<br>(1). 淘宝 Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。<br>(2). 淘宝 RocketMQ 支持按照简单的 Message Tag 过滤，也支持按照 Message Header、body 进行过滤。<br>(3). CORBA Notification 规范中也支持灵活的语法表达式过滤。  </li>\n<li>Consumer 端消息过滤<br>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 Consumer 端。</li>\n</ul>\n</blockquote>\n<p><strong>就是在这种考虑下，<code>Filtersrv</code> 出现了。减少了 <code>Broker</code> 的负担，又减少了 <code>Consumer</code> 接收无用的消息。当然缺点也是有的，多了一层 <code>Filtersrv</code> 网络开销。</strong></p>\n<h1 id=\"2-Filtersrv-注册到-Broker\"><a href=\"#2-Filtersrv-注册到-Broker\" class=\"headerlink\" title=\"2. Filtersrv 注册到 Broker\"></a>2. Filtersrv 注册到 Broker</h1><ul>\n<li>🦅 一个 <code>Filtersrv</code> <strong>只</strong>对应一个 <code>Broker</code>。</li>\n<li>🦅 一个 <code>Broker</code> 可以对应<strong>多个</strong> <code>Filtersrv</code>。<strong><code>Filtersrv</code> 的高可用通过启动多个 <code>Filtersrv</code> 实现</strong>。</li>\n<li>🦅 <code>Filtersrv</code> 注册失败时，主动<strong>退出关闭</strong>。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FiltersrvController.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// 固定间隔注册到Broker</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:             FiltersrvController.<span class=\"keyword\">this</span>.registerFilterServerToBroker();</div><div class=\"line\"><span class=\"number\">11</span>:         &#125;</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;, <span class=\"number\">15</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS); <span class=\"comment\">// TODO edit by 芋艿：initialDelay时间太短，可能导致初始化失败。从3=》15</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>: <span class=\"comment\">/**</span></div><div class=\"line\">18:  * 注册Filtersrv 到 Broker</div><div class=\"line\">19:  * ！！！如果注册失败，关闭Filtersrv</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerFilterServerToBroker</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">23</span>:         RegisterFilterServerResponseHeader responseHeader =</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.filterServerOuterAPI.registerFilterServerToBroker(</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">this</span>.filtersrvConfig.getConnectWhichBroker(), <span class=\"keyword\">this</span>.localAddr());</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">this</span>.defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getPullAPIWrapper()</div><div class=\"line\"><span class=\"number\">27</span>:             .setDefaultBrokerId(responseHeader.getBrokerId());</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.brokerName) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">this</span>.brokerName = responseHeader.getBrokerName();</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:         log.info(<span class=\"string\">\"register filter server&lt;&#123;&#125;&gt; to broker&lt;&#123;&#125;&gt; OK, Return: &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.localAddr(),</div><div class=\"line\"><span class=\"number\">35</span>:             <span class=\"keyword\">this</span>.filtersrvConfig.getConnectWhichBroker(),</div><div class=\"line\"><span class=\"number\">36</span>:             responseHeader.getBrokerName(),</div><div class=\"line\"><span class=\"number\">37</span>:             responseHeader.getBrokerId());</div><div class=\"line\"><span class=\"number\">38</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:         log.warn(<span class=\"string\">\"register filter server Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>:         log.warn(<span class=\"string\">\"access broker failed, kill oneself\"</span>);</div><div class=\"line\"><span class=\"number\">42</span>:         System.exit(-<span class=\"number\">1</span>); <span class=\"comment\">// 异常退出</span></div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-过滤类\"><a href=\"#3-过滤类\" class=\"headerlink\" title=\"3. 过滤类\"></a>3. 过滤类</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/03.png\" alt=\"Filtersrv过滤类\"></p>\n<h2 id=\"3-1-Consumer-订阅时设置-过滤类代码\"><a href=\"#3-1-Consumer-订阅时设置-过滤类代码\" class=\"headerlink\" title=\"3.1 Consumer 订阅时设置 过滤类代码\"></a>3.1 Consumer 订阅时设置 过滤类代码</h2><ul>\n<li>🦅 <code>Consumer</code> 针对每个 <code>Topic</code> 可以订阅不同的 <code>过滤类代码</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQPushConsumer.java】</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(String topic, String fullClassName, String filterClassSource)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"><span class=\"number\">4</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.subscribe(topic, fullClassName, filterClassSource);</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Consumer-上传-过滤类代码\"><a href=\"#3-2-Consumer-上传-过滤类代码\" class=\"headerlink\" title=\"3.2 Consumer 上传 过滤类代码\"></a>3.2 Consumer 上传 过滤类代码</h2><ul>\n<li>🦅 <code>Consumer</code> 心跳注册到 <code>Broker</code> 的同时，上传 <code>过滤类代码</code> 到 <code>Broker</code> 对应的<strong>所有</strong> <code>Filtersrv</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MQClientInstance.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 发送心跳到Broker，上传过滤类源码到Filtersrv</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendHeartbeatToAllBrokerWithLock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lockHeartbeat.tryLock()) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.sendHeartbeatToAllBroker();</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">this</span>.uploadFilterClassSource();</div><div class=\"line\"><span class=\"number\">10</span>:         &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> Exception e) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             log.error(<span class=\"string\">\"sendHeartbeatToAllBroker exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">12</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.lockHeartbeat.unlock();</div><div class=\"line\"><span class=\"number\">14</span>:         &#125;</div><div class=\"line\"><span class=\"number\">15</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         log.warn(<span class=\"string\">\"lock heartBeat, but failed.\"</span>);</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>: <span class=\"comment\">/**</span></div><div class=\"line\">21:  * 上传过滤类到Filtersrv</div><div class=\"line\">22:  */</div><div class=\"line\"><span class=\"number\">23</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadFilterClassSource</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">24</span>:     Iterator&lt;Entry&lt;String, MQConsumerInner&gt;&gt; it = <span class=\"keyword\">this</span>.consumerTable.entrySet().iterator();</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:         Entry&lt;String, MQConsumerInner&gt; next = it.next();</div><div class=\"line\"><span class=\"number\">27</span>:         MQConsumerInner consumer = next.getValue();</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (ConsumeType.CONSUME_PASSIVELY == consumer.consumeType()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             Set&lt;SubscriptionData&gt; subscriptions = consumer.subscriptions();</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">for</span> (SubscriptionData sub : subscriptions) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">if</span> (sub.isClassFilterMode() &amp;&amp; sub.getFilterClassSource() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                     <span class=\"keyword\">final</span> String consumerGroup = consumer.groupName();</div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">final</span> String className = sub.getSubString();</div><div class=\"line\"><span class=\"number\">34</span>:                     <span class=\"keyword\">final</span> String topic = sub.getTopic();</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">final</span> String filterClassSource = sub.getFilterClassSource();</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                         <span class=\"keyword\">this</span>.uploadFilterClassToAllFilterServer(consumerGroup, className, topic, filterClassSource);</div><div class=\"line\"><span class=\"number\">38</span>:                     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                         log.error(<span class=\"string\">\"uploadFilterClassToAllFilterServer Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">40</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>:             &#125;</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-Filter-编译-过滤类代码\"><a href=\"#3-3-Filter-编译-过滤类代码\" class=\"headerlink\" title=\"3.3 Filter 编译 过滤类代码\"></a>3.3 Filter 编译 过滤类代码</h2><ul>\n<li>🦅 <code>Filtersrv</code> 处理 <code>Consumer</code> 上传的 <code>过滤类代码</code>，并进行<strong>编译</strong>使用。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FilterClassManager.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 注册过滤类</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> consumerGroup 消费分组</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> className 过滤类名</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> classCRC 过滤类源码CRC</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> filterSourceBinary 过滤类源码</div><div class=\"line\">10:  * <span class=\"doctag\">@return</span> 是否注册成功</div><div class=\"line\">11:  */</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">registerFilterClass</span><span class=\"params\">(<span class=\"keyword\">final</span> String consumerGroup, <span class=\"keyword\">final</span> String topic,</span></span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">final</span> String className, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> classCRC, <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] filterSourceBinary) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> String key = buildKey(consumerGroup, topic);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 判断是否要注册新的过滤类</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">boolean</span> registerNew = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">17</span>:     FilterClassInfo filterClassInfoPrev = <span class=\"keyword\">this</span>.filterClassTable.get(key);</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == filterClassInfoPrev) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         registerNew = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">if</span> (filterClassInfoPrev.getClassCRC() != classCRC &amp;&amp; classCRC != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 类有变化</span></div><div class=\"line\"><span class=\"number\">23</span>:                 registerNew = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             &#125;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">// 注册新的过滤类</span></div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">if</span> (registerNew) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.compileLock) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             filterClassInfoPrev = <span class=\"keyword\">this</span>.filterClassTable.get(key);</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != filterClassInfoPrev &amp;&amp; filterClassInfoPrev.getClassCRC() == classCRC) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 FilterClassInfo filterClassInfoNew = <span class=\"keyword\">new</span> FilterClassInfo();</div><div class=\"line\"><span class=\"number\">36</span>:                 filterClassInfoNew.setClassName(className);</div><div class=\"line\"><span class=\"number\">37</span>:                 filterClassInfoNew.setClassCRC(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">38</span>:                 filterClassInfoNew.setMessageFilter(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) &#123;</div><div class=\"line\"><span class=\"number\">41</span>:                     String javaSource = <span class=\"keyword\">new</span> String(filterSourceBinary, MixAll.DEFAULT_CHARSET);</div><div class=\"line\"><span class=\"number\">42</span>:                     <span class=\"comment\">// 编译新的过滤类</span></div><div class=\"line\"><span class=\"number\">43</span>:                     Class&lt;?&gt; newClass = DynaCode.compileAndLoadClass(className, javaSource);</div><div class=\"line\"><span class=\"number\">44</span>:                     <span class=\"comment\">// 创建新的过滤类对象</span></div><div class=\"line\"><span class=\"number\">45</span>:                     Object newInstance = newClass.newInstance();</div><div class=\"line\"><span class=\"number\">46</span>:                     filterClassInfoNew.setMessageFilter((MessageFilter) newInstance);</div><div class=\"line\"><span class=\"number\">47</span>:                     filterClassInfoNew.setClassCRC(classCRC);</div><div class=\"line\"><span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.filterClassTable.put(key, filterClassInfoNew);</div><div class=\"line\"><span class=\"number\">51</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                 String info = String.format(<span class=\"string\">\"FilterServer, registerFilterClass Exception, consumerGroup: %s topic: %s className: %s\"</span>,</div><div class=\"line\"><span class=\"number\">53</span>:                             consumerGroup, topic, className);</div><div class=\"line\"><span class=\"number\">54</span>:                 log.error(info, e);</div><div class=\"line\"><span class=\"number\">55</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">56</span>:             &#125;</div><div class=\"line\"><span class=\"number\">57</span>:         &#125;</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">61</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"4-过滤消息\"><a href=\"#4-过滤消息\" class=\"headerlink\" title=\"4. 过滤消息\"></a>4. 过滤消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png\" alt=\"Filtersrv.png\"></p>\n<h2 id=\"4-1-Consumer-从-Filtersrv-拉取消息\"><a href=\"#4-1-Consumer-从-Filtersrv-拉取消息\" class=\"headerlink\" title=\"4.1 Consumer 从 Filtersrv 拉取消息\"></a>4.1 Consumer 从 Filtersrv 拉取消息</h2><ul>\n<li>🦅 <code>Consumer</code> 拉取 <strong>使用过滤类方式订阅</strong> 的消费消息时，从 <code>Broker</code> 对应的 <code>Filtersrv</code> 列表<strong>随机</strong>选择一个拉取消息。<strong>如果选择不到 <code>Filtersrv</code>，则无法拉取消息。因此，<code>Filtersrv</code> 一定要做高可用</strong>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【PullAPIWrapper.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 拉取消息核心方法</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> mq 消息嘟列</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> subExpression 订阅表达式</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> subVersion 订阅版本号</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> offset 拉取队列开始位置</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> maxNums 批量拉 取消息数量</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> sysFlag 拉取系统标识</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> commitOffset 提交消费进度</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> brokerSuspendMaxTimeMillis broker挂起请求最大时间</div><div class=\"line\">13:  * <span class=\"doctag\">@param</span> timeoutMillis 请求broker超时时间</div><div class=\"line\">14:  * <span class=\"doctag\">@param</span> communicationMode 通讯模式</div><div class=\"line\">15:  * <span class=\"doctag\">@param</span> pullCallback 拉取回调</div><div class=\"line\">16:  * <span class=\"doctag\">@return</span> 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。</div><div class=\"line\">17:  * <span class=\"doctag\">@throws</span> MQClientException 当寻找不到 broker 时，或发生其他client异常</div><div class=\"line\">18:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">19:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。</div><div class=\"line\">20:  * <span class=\"doctag\">@throws</span> InterruptedException 当发生中断异常时</div><div class=\"line\">21:  */</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"function\"><span class=\"keyword\">protected</span> PullResult <span class=\"title\">pullKernelImpl</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">final</span> MessageQueue mq,</div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">final</span> String subExpression,</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> subVersion,</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset,</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxNums,</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sysFlag,</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> commitOffset,</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerSuspendMaxTimeMillis,</div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode,</div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback</div><div class=\"line\"><span class=\"number\">34</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"comment\">// // ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"comment\">// 请求拉取消息</span></div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"comment\">// 若订阅topic使用过滤类，使用filtersrv获取消息</span></div><div class=\"line\"><span class=\"number\">40</span>:         String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:         PullResult pullResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(</div><div class=\"line\"><span class=\"number\">46</span>:             brokerAddr,</div><div class=\"line\"><span class=\"number\">47</span>:             requestHeader,</div><div class=\"line\"><span class=\"number\">48</span>:             timeoutMillis,</div><div class=\"line\"><span class=\"number\">49</span>:             communicationMode,</div><div class=\"line\"><span class=\"number\">50</span>:             pullCallback);</div><div class=\"line\"><span class=\"number\">51</span>: </div><div class=\"line\"><span class=\"number\">52</span>:         <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">53</span>:     &#125;</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"comment\">// Broker信息不存在，则抛出异常</span></div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: <span class=\"comment\">/**</span></div><div class=\"line\">60:  * 计算filtersrv地址。如果有多个filtersrv，随机选择一个。</div><div class=\"line\">61:  *</div><div class=\"line\">62:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\">63:  * <span class=\"doctag\">@param</span> brokerAddr broker地址</div><div class=\"line\">64:  * <span class=\"doctag\">@return</span> filtersrv地址</div><div class=\"line\">65:  * <span class=\"doctag\">@throws</span> MQClientException 当filtersrv不存在时</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">computPullFromWhichFilterServer</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> String brokerAddr)</span></span></div><div class=\"line\">68:     <span class=\"keyword\">throws</span> MQClientException &#123;</div><div class=\"line\"><span class=\"number\">69</span>:     ConcurrentHashMap&lt;String, TopicRouteData&gt; topicRouteTable = <span class=\"keyword\">this</span>.mQClientFactory.getTopicRouteTable();</div><div class=\"line\"><span class=\"number\">70</span>:     <span class=\"keyword\">if</span> (topicRouteTable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">71</span>:         TopicRouteData topicRouteData = topicRouteTable.get(topic);</div><div class=\"line\"><span class=\"number\">72</span>:         List&lt;String&gt; list = topicRouteData.getFilterServerTable().get(brokerAddr);</div><div class=\"line\"><span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (list != <span class=\"keyword\">null</span> &amp;&amp; !list.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:             <span class=\"keyword\">return</span> list.get(randomNum() % list.size());</div><div class=\"line\"><span class=\"number\">75</span>:         &#125;</div><div class=\"line\"><span class=\"number\">76</span>:     &#125;</div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"Find Filter Server Failed, Broker Addr: \"</span> + brokerAddr + <span class=\"string\">\" topic: \"</span></div><div class=\"line\"><span class=\"number\">78</span>:         + topic, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">79</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-2-Filtersrv-从-Broker-拉取消息\"><a href=\"#4-2-Filtersrv-从-Broker-拉取消息\" class=\"headerlink\" title=\"4.2 Filtersrv 从 Broker 拉取消息\"></a>4.2 Filtersrv 从 Broker 拉取消息</h2><ul>\n<li>🦅 <code>Filtersrv</code> 拉取消息后，会建议 <code>Consumer</code> 向 <code>Broker主节点</code> 拉取消息。</li>\n<li>🦅 <code>Filtersrv</code> 可以理解成一个 <code>Consumer</code>，向 <code>Broker</code> 拉取消息时，实际使用的 <code>DefaultMQPullConsumer.java</code> 的方法和逻辑。</li>\n</ul>\n<pre><code class=\"Java\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultRequestProcessor.java】</span>\n  <span class=\"number\">2</span>: <span class=\"comment\">/**\n  3:  * 拉取消息\n  4:  *\n  5:  * <span class=\"doctag\">@param</span> ctx 拉取消息context\n  6:  * <span class=\"doctag\">@param</span> request 拉取消息请求\n  7:  * <span class=\"doctag\">@return</span> 响应\n  8:  * <span class=\"doctag\">@throws</span> Exception 当发生异常时\n  9:  */</span>\n <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">pullMessageForward</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span> <span class=\"keyword\">throws</span> Exception </span>{\n <span class=\"number\">11</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> PullMessageRequestHeader requestHeader =\n <span class=\"number\">14</span>:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n <span class=\"number\">15</span>: \n <span class=\"number\">16</span>:     <span class=\"keyword\">final</span> FilterContext filterContext = <span class=\"keyword\">new</span> FilterContext();\n <span class=\"number\">17</span>:     filterContext.setConsumerGroup(requestHeader.getConsumerGroup());\n <span class=\"number\">18</span>: \n <span class=\"number\">19</span>:     response.setOpaque(request.getOpaque());\n <span class=\"number\">20</span>: \n <span class=\"number\">21</span>:     DefaultMQPullConsumer pullConsumer = <span class=\"keyword\">this</span>.filtersrvController.getDefaultMQPullConsumer();\n <span class=\"number\">22</span>: \n <span class=\"number\">23</span>:     <span class=\"comment\">// 校验Topic过滤类是否完整</span>\n <span class=\"number\">24</span>:     <span class=\"keyword\">final</span> FilterClassInfo findFilterClass = <span class=\"keyword\">this</span>.filtersrvController.getFilterClassManager().findFilterClass(requestHeader.getConsumerGroup(), requestHeader.getTopic());\n <span class=\"number\">25</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findFilterClass) {\n <span class=\"number\">26</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">27</span>:         response.setRemark(<span class=\"string\">\"Find Filter class failed, not registered\"</span>);\n <span class=\"number\">28</span>:         <span class=\"keyword\">return</span> response;\n <span class=\"number\">29</span>:     }\n <span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findFilterClass.getMessageFilter()) {\n <span class=\"number\">31</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">32</span>:         response.setRemark(<span class=\"string\">\"Find Filter class failed, registered but no class\"</span>);\n <span class=\"number\">33</span>:         <span class=\"keyword\">return</span> response;\n <span class=\"number\">34</span>:     }\n <span class=\"number\">35</span>: \n <span class=\"number\">36</span>:     <span class=\"comment\">// 设置下次请求从 Broker主节点。</span>\n <span class=\"number\">37</span>:     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n <span class=\"number\">38</span>: \n <span class=\"number\">39</span>:     MessageQueue mq = <span class=\"keyword\">new</span> MessageQueue();\n <span class=\"number\">40</span>:     mq.setTopic(requestHeader.getTopic());\n <span class=\"number\">41</span>:     mq.setQueueId(requestHeader.getQueueId());\n <span class=\"number\">42</span>:     mq.setBrokerName(<span class=\"keyword\">this</span>.filtersrvController.getBrokerName());\n <span class=\"number\">43</span>:     <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();\n <span class=\"number\">44</span>:     <span class=\"keyword\">int</span> maxNums = requestHeader.getMaxMsgNums();\n <span class=\"number\">45</span>: \n <span class=\"number\">46</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback = <span class=\"keyword\">new</span> PullCallback() {\n <span class=\"number\">47</span>: \n <span class=\"number\">48</span>:         <span class=\"meta\">@Override</span>\n <span class=\"number\">49</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(PullResult pullResult)</span> </span>{\n <span class=\"number\">50</span>:             responseHeader.setMaxOffset(pullResult.getMaxOffset());\n <span class=\"number\">51</span>:             responseHeader.setMinOffset(pullResult.getMinOffset());\n <span class=\"number\">52</span>:             responseHeader.setNextBeginOffset(pullResult.getNextBeginOffset());\n <span class=\"number\">53</span>:             response.setRemark(<span class=\"keyword\">null</span>);\n <span class=\"number\">54</span>: \n <span class=\"number\">55</span>:             <span class=\"keyword\">switch</span> (pullResult.getPullStatus()) {\n <span class=\"number\">56</span>:                 <span class=\"keyword\">case</span> FOUND:\n <span class=\"number\">57</span>:                     response.setCode(ResponseCode.SUCCESS);\n <span class=\"number\">58</span>: \n <span class=\"number\">59</span>:                     List&lt;MessageExt&gt; msgListOK = <span class=\"keyword\">new</span> ArrayList&lt;MessageExt&gt;();\n <span class=\"number\">60</span>:                     <span class=\"keyword\">try</span> {\n <span class=\"number\">61</span>:                         <span class=\"keyword\">for</span> (MessageExt msg : pullResult.getMsgFoundList()) {\n <span class=\"number\">62</span>:                             <span class=\"comment\">// 使用过滤类过滤消息</span>\n <span class=\"number\">63</span>:                             <span class=\"keyword\">boolean</span> match = findFilterClass.getMessageFilter().match(msg, filterContext);\n <span class=\"number\">64</span>:                             <span class=\"keyword\">if</span> (match) {\n <span class=\"number\">65</span>:                                 msgListOK.add(msg);\n <span class=\"number\">66</span>:                             }\n <span class=\"number\">67</span>:                         }\n <span class=\"number\">68</span>: \n <span class=\"number\">69</span>:                         <span class=\"keyword\">if</span> (!msgListOK.isEmpty()) {\n <span class=\"number\">70</span>:                             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, msgListOK);\n <span class=\"number\">71</span>:                             <span class=\"keyword\">return</span>;\n <span class=\"number\">72</span>:                         } <span class=\"keyword\">else</span> {\n <span class=\"number\">73</span>:                             response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n <span class=\"number\">74</span>:                         }\n <span class=\"number\">75</span>:                     } <span class=\"keyword\">catch</span> (Throwable e) {\n <span class=\"number\">76</span>:                         <span class=\"keyword\">final</span> String error =\n <span class=\"number\">77</span>:                             String.format(<span class=\"string\">\"do Message Filter Exception, ConsumerGroup: %s Topic: %s \"</span>,\n <span class=\"number\">78</span>:                                 requestHeader.getConsumerGroup(), requestHeader.getTopic());\n <span class=\"number\">79</span>:                         log.error(error, e);\n <span class=\"number\">80</span>: \n <span class=\"number\">81</span>:                         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">82</span>:                         response.setRemark(error + RemotingHelper.exceptionSimpleDesc(e));\n <span class=\"number\">83</span>:                         returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n <span class=\"number\">84</span>:                         <span class=\"keyword\">return</span>;\n <span class=\"number\">85</span>:                     }\n <span class=\"number\">86</span>: \n <span class=\"number\">87</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">88</span>:                 <span class=\"keyword\">case</span> NO_MATCHED_MSG:\n <span class=\"number\">89</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n <span class=\"number\">90</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">91</span>:                 <span class=\"keyword\">case</span> NO_NEW_MSG:\n <span class=\"number\">92</span>:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n <span class=\"number\">93</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">94</span>:                 <span class=\"keyword\">case</span> OFFSET_ILLEGAL:\n <span class=\"number\">95</span>:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n <span class=\"number\">96</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">97</span>:                 <span class=\"keyword\">default</span>:\n <span class=\"number\">98</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">99</span>:             }\n<span class=\"number\">100</span>: \n<span class=\"number\">101</span>:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n<span class=\"number\">102</span>:         }\n<span class=\"number\">103</span>: \n<span class=\"number\">104</span>:         <span class=\"meta\">@Override</span>\n<span class=\"number\">105</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>{\n<span class=\"number\">106</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);\n<span class=\"number\">107</span>:             response.setRemark(<span class=\"string\">\"Pull Callback Exception, \"</span> + RemotingHelper.exceptionSimpleDesc(e));\n<span class=\"number\">108</span>:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n<span class=\"number\">109</span>:             <span class=\"keyword\">return</span>;\n<span class=\"number\">110</span>:         }\n<span class=\"number\">111</span>:     };\n<span class=\"number\">112</span>: \n<span class=\"number\">113</span>:     <span class=\"comment\">// 拉取消息</span>\n<span class=\"number\">114</span>:     pullConsumer.pullBlockIfNotFound(mq, <span class=\"keyword\">null</span>, offset, maxNums, pullCallback);\n<span class=\"number\">115</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n<span class=\"number\">116</span>: }\n</code></pre>\n<h1 id=\"5-Filtersrv-高可用\"><a href=\"#5-Filtersrv-高可用\" class=\"headerlink\" title=\"5. Filtersrv 高可用\"></a>5. Filtersrv 高可用</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/02.png\" alt=\"Filtersrv过可用\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/filtersrv\">http://www.yunai.me/RocketMQ/filtersrv</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. Filtersrv 注册到 Broker</a></li>\n<li><a href=\"#\">3. 过滤类</a><ul>\n<li><a href=\"#\">3.1 Consumer 订阅时设置 过滤类代码</a></li>\n<li><a href=\"#\">3.2 Consumer 上传 过滤类代码</a></li>\n<li><a href=\"#\">3.3 Filter 编译 过滤类代码</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4. 过滤消息</a><ul>\n<li><a href=\"#\">4.1 Consumer 从 Filtersrv 拉取消息</a></li>\n<li><a href=\"#\">4.2 Filtersrv 从 Broker 拉取消息</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5. Filtersrv 高可用</a></li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><code>Filtersrv</code> ，负责<strong>自定义规则</strong>过滤 <code>Consumer</code> 从 <code>Broker</code> 拉取的消息。</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png\" alt=\"Filtersrv.png\"></p>\n<p>为什么 <code>Broker</code> 不提供过滤消息的功能呢？我们来看看官方的说法：</p>\n<blockquote>\n<ul>\n<li>Broker 端消息过滤<br>在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。 缺点是增加了 Broker 的负担，实现相对复杂。<br>(1). 淘宝 Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。<br>(2). 淘宝 RocketMQ 支持按照简单的 Message Tag 过滤，也支持按照 Message Header、body 进行过滤。<br>(3). CORBA Notification 规范中也支持灵活的语法表达式过滤。  </li>\n<li>Consumer 端消息过滤<br>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 Consumer 端。</li>\n</ul>\n</blockquote>\n<p><strong>就是在这种考虑下，<code>Filtersrv</code> 出现了。减少了 <code>Broker</code> 的负担，又减少了 <code>Consumer</code> 接收无用的消息。当然缺点也是有的，多了一层 <code>Filtersrv</code> 网络开销。</strong></p>\n<h1 id=\"2-Filtersrv-注册到-Broker\"><a href=\"#2-Filtersrv-注册到-Broker\" class=\"headerlink\" title=\"2. Filtersrv 注册到 Broker\"></a>2. Filtersrv 注册到 Broker</h1><ul>\n<li>🦅 一个 <code>Filtersrv</code> <strong>只</strong>对应一个 <code>Broker</code>。</li>\n<li>🦅 一个 <code>Broker</code> 可以对应<strong>多个</strong> <code>Filtersrv</code>。<strong><code>Filtersrv</code> 的高可用通过启动多个 <code>Filtersrv</code> 实现</strong>。</li>\n<li>🦅 <code>Filtersrv</code> 注册失败时，主动<strong>退出关闭</strong>。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FiltersrvController.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// 固定间隔注册到Broker</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:             FiltersrvController.<span class=\"keyword\">this</span>.registerFilterServerToBroker();</div><div class=\"line\"><span class=\"number\">11</span>:         &#125;</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;, <span class=\"number\">15</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS); <span class=\"comment\">// TODO edit by 芋艿：initialDelay时间太短，可能导致初始化失败。从3=》15</span></div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>: <span class=\"comment\">/**</span></div><div class=\"line\">18:  * 注册Filtersrv 到 Broker</div><div class=\"line\">19:  * ！！！如果注册失败，关闭Filtersrv</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerFilterServerToBroker</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">23</span>:         RegisterFilterServerResponseHeader responseHeader =</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.filterServerOuterAPI.registerFilterServerToBroker(</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"keyword\">this</span>.filtersrvConfig.getConnectWhichBroker(), <span class=\"keyword\">this</span>.localAddr());</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">this</span>.defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getPullAPIWrapper()</div><div class=\"line\"><span class=\"number\">27</span>:             .setDefaultBrokerId(responseHeader.getBrokerId());</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.brokerName) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">this</span>.brokerName = responseHeader.getBrokerName();</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:         log.info(<span class=\"string\">\"register filter server&lt;&#123;&#125;&gt; to broker&lt;&#123;&#125;&gt; OK, Return: &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.localAddr(),</div><div class=\"line\"><span class=\"number\">35</span>:             <span class=\"keyword\">this</span>.filtersrvConfig.getConnectWhichBroker(),</div><div class=\"line\"><span class=\"number\">36</span>:             responseHeader.getBrokerName(),</div><div class=\"line\"><span class=\"number\">37</span>:             responseHeader.getBrokerId());</div><div class=\"line\"><span class=\"number\">38</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:         log.warn(<span class=\"string\">\"register filter server Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>:         log.warn(<span class=\"string\">\"access broker failed, kill oneself\"</span>);</div><div class=\"line\"><span class=\"number\">42</span>:         System.exit(-<span class=\"number\">1</span>); <span class=\"comment\">// 异常退出</span></div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-过滤类\"><a href=\"#3-过滤类\" class=\"headerlink\" title=\"3. 过滤类\"></a>3. 过滤类</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/03.png\" alt=\"Filtersrv过滤类\"></p>\n<h2 id=\"3-1-Consumer-订阅时设置-过滤类代码\"><a href=\"#3-1-Consumer-订阅时设置-过滤类代码\" class=\"headerlink\" title=\"3.1 Consumer 订阅时设置 过滤类代码\"></a>3.1 Consumer 订阅时设置 过滤类代码</h2><ul>\n<li>🦅 <code>Consumer</code> 针对每个 <code>Topic</code> 可以订阅不同的 <code>过滤类代码</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQPushConsumer.java】</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">3</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(String topic, String fullClassName, String filterClassSource)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"><span class=\"number\">4</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.subscribe(topic, fullClassName, filterClassSource);</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-2-Consumer-上传-过滤类代码\"><a href=\"#3-2-Consumer-上传-过滤类代码\" class=\"headerlink\" title=\"3.2 Consumer 上传 过滤类代码\"></a>3.2 Consumer 上传 过滤类代码</h2><ul>\n<li>🦅 <code>Consumer</code> 心跳注册到 <code>Broker</code> 的同时，上传 <code>过滤类代码</code> 到 <code>Broker</code> 对应的<strong>所有</strong> <code>Filtersrv</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【MQClientInstance.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 发送心跳到Broker，上传过滤类源码到Filtersrv</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendHeartbeatToAllBrokerWithLock</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lockHeartbeat.tryLock()) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.sendHeartbeatToAllBroker();</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">this</span>.uploadFilterClassSource();</div><div class=\"line\"><span class=\"number\">10</span>:         &#125; <span class=\"keyword\">catch</span> (<span class=\"keyword\">final</span> Exception e) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             log.error(<span class=\"string\">\"sendHeartbeatToAllBroker exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">12</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.lockHeartbeat.unlock();</div><div class=\"line\"><span class=\"number\">14</span>:         &#125;</div><div class=\"line\"><span class=\"number\">15</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         log.warn(<span class=\"string\">\"lock heartBeat, but failed.\"</span>);</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>: <span class=\"comment\">/**</span></div><div class=\"line\">21:  * 上传过滤类到Filtersrv</div><div class=\"line\">22:  */</div><div class=\"line\"><span class=\"number\">23</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">uploadFilterClassSource</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">24</span>:     Iterator&lt;Entry&lt;String, MQConsumerInner&gt;&gt; it = <span class=\"keyword\">this</span>.consumerTable.entrySet().iterator();</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"><span class=\"number\">26</span>:         Entry&lt;String, MQConsumerInner&gt; next = it.next();</div><div class=\"line\"><span class=\"number\">27</span>:         MQConsumerInner consumer = next.getValue();</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (ConsumeType.CONSUME_PASSIVELY == consumer.consumeType()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             Set&lt;SubscriptionData&gt; subscriptions = consumer.subscriptions();</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">for</span> (SubscriptionData sub : subscriptions) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">if</span> (sub.isClassFilterMode() &amp;&amp; sub.getFilterClassSource() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                     <span class=\"keyword\">final</span> String consumerGroup = consumer.groupName();</div><div class=\"line\"><span class=\"number\">33</span>:                     <span class=\"keyword\">final</span> String className = sub.getSubString();</div><div class=\"line\"><span class=\"number\">34</span>:                     <span class=\"keyword\">final</span> String topic = sub.getTopic();</div><div class=\"line\"><span class=\"number\">35</span>:                     <span class=\"keyword\">final</span> String filterClassSource = sub.getFilterClassSource();</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                         <span class=\"keyword\">this</span>.uploadFilterClassToAllFilterServer(consumerGroup, className, topic, filterClassSource);</div><div class=\"line\"><span class=\"number\">38</span>:                     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:                         log.error(<span class=\"string\">\"uploadFilterClassToAllFilterServer Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">40</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">41</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">42</span>:             &#125;</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"3-3-Filter-编译-过滤类代码\"><a href=\"#3-3-Filter-编译-过滤类代码\" class=\"headerlink\" title=\"3.3 Filter 编译 过滤类代码\"></a>3.3 Filter 编译 过滤类代码</h2><ul>\n<li>🦅 <code>Filtersrv</code> 处理 <code>Consumer</code> 上传的 <code>过滤类代码</code>，并进行<strong>编译</strong>使用。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【FilterClassManager.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 注册过滤类</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> consumerGroup 消费分组</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> className 过滤类名</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> classCRC 过滤类源码CRC</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> filterSourceBinary 过滤类源码</div><div class=\"line\">10:  * <span class=\"doctag\">@return</span> 是否注册成功</div><div class=\"line\">11:  */</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">registerFilterClass</span><span class=\"params\">(<span class=\"keyword\">final</span> String consumerGroup, <span class=\"keyword\">final</span> String topic,</span></span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">final</span> String className, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> classCRC, <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] filterSourceBinary) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> String key = buildKey(consumerGroup, topic);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 判断是否要注册新的过滤类</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">boolean</span> registerNew = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">17</span>:     FilterClassInfo filterClassInfoPrev = <span class=\"keyword\">this</span>.filterClassTable.get(key);</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == filterClassInfoPrev) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         registerNew = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">if</span> (filterClassInfoPrev.getClassCRC() != classCRC &amp;&amp; classCRC != <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 类有变化</span></div><div class=\"line\"><span class=\"number\">23</span>:                 registerNew = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">24</span>:             &#125;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">// 注册新的过滤类</span></div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">if</span> (registerNew) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.compileLock) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             filterClassInfoPrev = <span class=\"keyword\">this</span>.filterClassTable.get(key);</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != filterClassInfoPrev &amp;&amp; filterClassInfoPrev.getClassCRC() == classCRC) &#123;</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 FilterClassInfo filterClassInfoNew = <span class=\"keyword\">new</span> FilterClassInfo();</div><div class=\"line\"><span class=\"number\">36</span>:                 filterClassInfoNew.setClassName(className);</div><div class=\"line\"><span class=\"number\">37</span>:                 filterClassInfoNew.setClassCRC(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">38</span>:                 filterClassInfoNew.setMessageFilter(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.filtersrvController.getFiltersrvConfig().isClientUploadFilterClassEnable()) &#123;</div><div class=\"line\"><span class=\"number\">41</span>:                     String javaSource = <span class=\"keyword\">new</span> String(filterSourceBinary, MixAll.DEFAULT_CHARSET);</div><div class=\"line\"><span class=\"number\">42</span>:                     <span class=\"comment\">// 编译新的过滤类</span></div><div class=\"line\"><span class=\"number\">43</span>:                     Class&lt;?&gt; newClass = DynaCode.compileAndLoadClass(className, javaSource);</div><div class=\"line\"><span class=\"number\">44</span>:                     <span class=\"comment\">// 创建新的过滤类对象</span></div><div class=\"line\"><span class=\"number\">45</span>:                     Object newInstance = newClass.newInstance();</div><div class=\"line\"><span class=\"number\">46</span>:                     filterClassInfoNew.setMessageFilter((MessageFilter) newInstance);</div><div class=\"line\"><span class=\"number\">47</span>:                     filterClassInfoNew.setClassCRC(classCRC);</div><div class=\"line\"><span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">49</span>: </div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.filterClassTable.put(key, filterClassInfoNew);</div><div class=\"line\"><span class=\"number\">51</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                 String info = String.format(<span class=\"string\">\"FilterServer, registerFilterClass Exception, consumerGroup: %s topic: %s className: %s\"</span>,</div><div class=\"line\"><span class=\"number\">53</span>:                             consumerGroup, topic, className);</div><div class=\"line\"><span class=\"number\">54</span>:                 log.error(info, e);</div><div class=\"line\"><span class=\"number\">55</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">56</span>:             &#125;</div><div class=\"line\"><span class=\"number\">57</span>:         &#125;</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">61</span>: &#125;</div></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"4-过滤消息\"><a href=\"#4-过滤消息\" class=\"headerlink\" title=\"4. 过滤消息\"></a>4. 过滤消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/Filtersrv.png\" alt=\"Filtersrv.png\"></p>\n<h2 id=\"4-1-Consumer-从-Filtersrv-拉取消息\"><a href=\"#4-1-Consumer-从-Filtersrv-拉取消息\" class=\"headerlink\" title=\"4.1 Consumer 从 Filtersrv 拉取消息\"></a>4.1 Consumer 从 Filtersrv 拉取消息</h2><ul>\n<li>🦅 <code>Consumer</code> 拉取 <strong>使用过滤类方式订阅</strong> 的消费消息时，从 <code>Broker</code> 对应的 <code>Filtersrv</code> 列表<strong>随机</strong>选择一个拉取消息。<strong>如果选择不到 <code>Filtersrv</code>，则无法拉取消息。因此，<code>Filtersrv</code> 一定要做高可用</strong>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【PullAPIWrapper.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 3:  * 拉取消息核心方法</div><div class=\"line\"> 4:  *</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> mq 消息嘟列</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> subExpression 订阅表达式</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> subVersion 订阅版本号</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> offset 拉取队列开始位置</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> maxNums 批量拉 取消息数量</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> sysFlag 拉取系统标识</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> commitOffset 提交消费进度</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> brokerSuspendMaxTimeMillis broker挂起请求最大时间</div><div class=\"line\">13:  * <span class=\"doctag\">@param</span> timeoutMillis 请求broker超时时间</div><div class=\"line\">14:  * <span class=\"doctag\">@param</span> communicationMode 通讯模式</div><div class=\"line\">15:  * <span class=\"doctag\">@param</span> pullCallback 拉取回调</div><div class=\"line\">16:  * <span class=\"doctag\">@return</span> 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。</div><div class=\"line\">17:  * <span class=\"doctag\">@throws</span> MQClientException 当寻找不到 broker 时，或发生其他client异常</div><div class=\"line\">18:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">19:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。</div><div class=\"line\">20:  * <span class=\"doctag\">@throws</span> InterruptedException 当发生中断异常时</div><div class=\"line\">21:  */</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"function\"><span class=\"keyword\">protected</span> PullResult <span class=\"title\">pullKernelImpl</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">final</span> MessageQueue mq,</div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">final</span> String subExpression,</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> subVersion,</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset,</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxNums,</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sysFlag,</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> commitOffset,</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerSuspendMaxTimeMillis,</div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode,</div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback</div><div class=\"line\"><span class=\"number\">34</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"comment\">// // ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"comment\">// 请求拉取消息</span></div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"comment\">// ....(省略代码)</span></div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"comment\">// 若订阅topic使用过滤类，使用filtersrv获取消息</span></div><div class=\"line\"><span class=\"number\">40</span>:         String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:         PullResult pullResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(</div><div class=\"line\"><span class=\"number\">46</span>:             brokerAddr,</div><div class=\"line\"><span class=\"number\">47</span>:             requestHeader,</div><div class=\"line\"><span class=\"number\">48</span>:             timeoutMillis,</div><div class=\"line\"><span class=\"number\">49</span>:             communicationMode,</div><div class=\"line\"><span class=\"number\">50</span>:             pullCallback);</div><div class=\"line\"><span class=\"number\">51</span>: </div><div class=\"line\"><span class=\"number\">52</span>:         <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">53</span>:     &#125;</div><div class=\"line\"><span class=\"number\">54</span>: </div><div class=\"line\"><span class=\"number\">55</span>:     <span class=\"comment\">// Broker信息不存在，则抛出异常</span></div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>: <span class=\"comment\">/**</span></div><div class=\"line\">60:  * 计算filtersrv地址。如果有多个filtersrv，随机选择一个。</div><div class=\"line\">61:  *</div><div class=\"line\">62:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\">63:  * <span class=\"doctag\">@param</span> brokerAddr broker地址</div><div class=\"line\">64:  * <span class=\"doctag\">@return</span> filtersrv地址</div><div class=\"line\">65:  * <span class=\"doctag\">@throws</span> MQClientException 当filtersrv不存在时</div><div class=\"line\">66:  */</div><div class=\"line\"><span class=\"number\">67</span>: <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">computPullFromWhichFilterServer</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> String brokerAddr)</span></span></div><div class=\"line\">68:     <span class=\"keyword\">throws</span> MQClientException &#123;</div><div class=\"line\"><span class=\"number\">69</span>:     ConcurrentHashMap&lt;String, TopicRouteData&gt; topicRouteTable = <span class=\"keyword\">this</span>.mQClientFactory.getTopicRouteTable();</div><div class=\"line\"><span class=\"number\">70</span>:     <span class=\"keyword\">if</span> (topicRouteTable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">71</span>:         TopicRouteData topicRouteData = topicRouteTable.get(topic);</div><div class=\"line\"><span class=\"number\">72</span>:         List&lt;String&gt; list = topicRouteData.getFilterServerTable().get(brokerAddr);</div><div class=\"line\"><span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (list != <span class=\"keyword\">null</span> &amp;&amp; !list.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:             <span class=\"keyword\">return</span> list.get(randomNum() % list.size());</div><div class=\"line\"><span class=\"number\">75</span>:         &#125;</div><div class=\"line\"><span class=\"number\">76</span>:     &#125;</div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"Find Filter Server Failed, Broker Addr: \"</span> + brokerAddr + <span class=\"string\">\" topic: \"</span></div><div class=\"line\"><span class=\"number\">78</span>:         + topic, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">79</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"4-2-Filtersrv-从-Broker-拉取消息\"><a href=\"#4-2-Filtersrv-从-Broker-拉取消息\" class=\"headerlink\" title=\"4.2 Filtersrv 从 Broker 拉取消息\"></a>4.2 Filtersrv 从 Broker 拉取消息</h2><ul>\n<li>🦅 <code>Filtersrv</code> 拉取消息后，会建议 <code>Consumer</code> 向 <code>Broker主节点</code> 拉取消息。</li>\n<li>🦅 <code>Filtersrv</code> 可以理解成一个 <code>Consumer</code>，向 <code>Broker</code> 拉取消息时，实际使用的 <code>DefaultMQPullConsumer.java</code> 的方法和逻辑。</li>\n</ul>\n<pre><code class=\"Java\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultRequestProcessor.java】</span>\n  <span class=\"number\">2</span>: <span class=\"comment\">/**\n  3:  * 拉取消息\n  4:  *\n  5:  * <span class=\"doctag\">@param</span> ctx 拉取消息context\n  6:  * <span class=\"doctag\">@param</span> request 拉取消息请求\n  7:  * <span class=\"doctag\">@return</span> 响应\n  8:  * <span class=\"doctag\">@throws</span> Exception 当发生异常时\n  9:  */</span>\n <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">pullMessageForward</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span> <span class=\"keyword\">throws</span> Exception </span>{\n <span class=\"number\">11</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> PullMessageRequestHeader requestHeader =\n <span class=\"number\">14</span>:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n <span class=\"number\">15</span>: \n <span class=\"number\">16</span>:     <span class=\"keyword\">final</span> FilterContext filterContext = <span class=\"keyword\">new</span> FilterContext();\n <span class=\"number\">17</span>:     filterContext.setConsumerGroup(requestHeader.getConsumerGroup());\n <span class=\"number\">18</span>: \n <span class=\"number\">19</span>:     response.setOpaque(request.getOpaque());\n <span class=\"number\">20</span>: \n <span class=\"number\">21</span>:     DefaultMQPullConsumer pullConsumer = <span class=\"keyword\">this</span>.filtersrvController.getDefaultMQPullConsumer();\n <span class=\"number\">22</span>: \n <span class=\"number\">23</span>:     <span class=\"comment\">// 校验Topic过滤类是否完整</span>\n <span class=\"number\">24</span>:     <span class=\"keyword\">final</span> FilterClassInfo findFilterClass = <span class=\"keyword\">this</span>.filtersrvController.getFilterClassManager().findFilterClass(requestHeader.getConsumerGroup(), requestHeader.getTopic());\n <span class=\"number\">25</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findFilterClass) {\n <span class=\"number\">26</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">27</span>:         response.setRemark(<span class=\"string\">\"Find Filter class failed, not registered\"</span>);\n <span class=\"number\">28</span>:         <span class=\"keyword\">return</span> response;\n <span class=\"number\">29</span>:     }\n <span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findFilterClass.getMessageFilter()) {\n <span class=\"number\">31</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">32</span>:         response.setRemark(<span class=\"string\">\"Find Filter class failed, registered but no class\"</span>);\n <span class=\"number\">33</span>:         <span class=\"keyword\">return</span> response;\n <span class=\"number\">34</span>:     }\n <span class=\"number\">35</span>: \n <span class=\"number\">36</span>:     <span class=\"comment\">// 设置下次请求从 Broker主节点。</span>\n <span class=\"number\">37</span>:     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n <span class=\"number\">38</span>: \n <span class=\"number\">39</span>:     MessageQueue mq = <span class=\"keyword\">new</span> MessageQueue();\n <span class=\"number\">40</span>:     mq.setTopic(requestHeader.getTopic());\n <span class=\"number\">41</span>:     mq.setQueueId(requestHeader.getQueueId());\n <span class=\"number\">42</span>:     mq.setBrokerName(<span class=\"keyword\">this</span>.filtersrvController.getBrokerName());\n <span class=\"number\">43</span>:     <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();\n <span class=\"number\">44</span>:     <span class=\"keyword\">int</span> maxNums = requestHeader.getMaxMsgNums();\n <span class=\"number\">45</span>: \n <span class=\"number\">46</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback = <span class=\"keyword\">new</span> PullCallback() {\n <span class=\"number\">47</span>: \n <span class=\"number\">48</span>:         <span class=\"meta\">@Override</span>\n <span class=\"number\">49</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(PullResult pullResult)</span> </span>{\n <span class=\"number\">50</span>:             responseHeader.setMaxOffset(pullResult.getMaxOffset());\n <span class=\"number\">51</span>:             responseHeader.setMinOffset(pullResult.getMinOffset());\n <span class=\"number\">52</span>:             responseHeader.setNextBeginOffset(pullResult.getNextBeginOffset());\n <span class=\"number\">53</span>:             response.setRemark(<span class=\"keyword\">null</span>);\n <span class=\"number\">54</span>: \n <span class=\"number\">55</span>:             <span class=\"keyword\">switch</span> (pullResult.getPullStatus()) {\n <span class=\"number\">56</span>:                 <span class=\"keyword\">case</span> FOUND:\n <span class=\"number\">57</span>:                     response.setCode(ResponseCode.SUCCESS);\n <span class=\"number\">58</span>: \n <span class=\"number\">59</span>:                     List&lt;MessageExt&gt; msgListOK = <span class=\"keyword\">new</span> ArrayList&lt;MessageExt&gt;();\n <span class=\"number\">60</span>:                     <span class=\"keyword\">try</span> {\n <span class=\"number\">61</span>:                         <span class=\"keyword\">for</span> (MessageExt msg : pullResult.getMsgFoundList()) {\n <span class=\"number\">62</span>:                             <span class=\"comment\">// 使用过滤类过滤消息</span>\n <span class=\"number\">63</span>:                             <span class=\"keyword\">boolean</span> match = findFilterClass.getMessageFilter().match(msg, filterContext);\n <span class=\"number\">64</span>:                             <span class=\"keyword\">if</span> (match) {\n <span class=\"number\">65</span>:                                 msgListOK.add(msg);\n <span class=\"number\">66</span>:                             }\n <span class=\"number\">67</span>:                         }\n <span class=\"number\">68</span>: \n <span class=\"number\">69</span>:                         <span class=\"keyword\">if</span> (!msgListOK.isEmpty()) {\n <span class=\"number\">70</span>:                             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, msgListOK);\n <span class=\"number\">71</span>:                             <span class=\"keyword\">return</span>;\n <span class=\"number\">72</span>:                         } <span class=\"keyword\">else</span> {\n <span class=\"number\">73</span>:                             response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n <span class=\"number\">74</span>:                         }\n <span class=\"number\">75</span>:                     } <span class=\"keyword\">catch</span> (Throwable e) {\n <span class=\"number\">76</span>:                         <span class=\"keyword\">final</span> String error =\n <span class=\"number\">77</span>:                             String.format(<span class=\"string\">\"do Message Filter Exception, ConsumerGroup: %s Topic: %s \"</span>,\n <span class=\"number\">78</span>:                                 requestHeader.getConsumerGroup(), requestHeader.getTopic());\n <span class=\"number\">79</span>:                         log.error(error, e);\n <span class=\"number\">80</span>: \n <span class=\"number\">81</span>:                         response.setCode(ResponseCode.SYSTEM_ERROR);\n <span class=\"number\">82</span>:                         response.setRemark(error + RemotingHelper.exceptionSimpleDesc(e));\n <span class=\"number\">83</span>:                         returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n <span class=\"number\">84</span>:                         <span class=\"keyword\">return</span>;\n <span class=\"number\">85</span>:                     }\n <span class=\"number\">86</span>: \n <span class=\"number\">87</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">88</span>:                 <span class=\"keyword\">case</span> NO_MATCHED_MSG:\n <span class=\"number\">89</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n <span class=\"number\">90</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">91</span>:                 <span class=\"keyword\">case</span> NO_NEW_MSG:\n <span class=\"number\">92</span>:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n <span class=\"number\">93</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">94</span>:                 <span class=\"keyword\">case</span> OFFSET_ILLEGAL:\n <span class=\"number\">95</span>:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n <span class=\"number\">96</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">97</span>:                 <span class=\"keyword\">default</span>:\n <span class=\"number\">98</span>:                     <span class=\"keyword\">break</span>;\n <span class=\"number\">99</span>:             }\n<span class=\"number\">100</span>: \n<span class=\"number\">101</span>:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n<span class=\"number\">102</span>:         }\n<span class=\"number\">103</span>: \n<span class=\"number\">104</span>:         <span class=\"meta\">@Override</span>\n<span class=\"number\">105</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>{\n<span class=\"number\">106</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);\n<span class=\"number\">107</span>:             response.setRemark(<span class=\"string\">\"Pull Callback Exception, \"</span> + RemotingHelper.exceptionSimpleDesc(e));\n<span class=\"number\">108</span>:             returnResponse(requestHeader.getConsumerGroup(), requestHeader.getTopic(), ctx, response, <span class=\"keyword\">null</span>);\n<span class=\"number\">109</span>:             <span class=\"keyword\">return</span>;\n<span class=\"number\">110</span>:         }\n<span class=\"number\">111</span>:     };\n<span class=\"number\">112</span>: \n<span class=\"number\">113</span>:     <span class=\"comment\">// 拉取消息</span>\n<span class=\"number\">114</span>:     pullConsumer.pullBlockIfNotFound(mq, <span class=\"keyword\">null</span>, offset, maxNums, pullCallback);\n<span class=\"number\">115</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n<span class=\"number\">116</span>: }\n</code></pre>\n<h1 id=\"5-Filtersrv-高可用\"><a href=\"#5-Filtersrv-高可用\" class=\"headerlink\" title=\"5. Filtersrv 高可用\"></a>5. Filtersrv 高可用</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_17/02.png\" alt=\"Filtersrv过可用\"></p>\n"},{"title":"RocketMQ 源码分析 —— 事务消息","date":"2017-05-20T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-transaction](http://www.yunai.me/RocketMQ/message-transaction)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 事务消息发送](#)\n\t- [2.1 Producer 发送事务消息](#)\n\t- [2.2 Broker 处理结束事务请求](#)\n\t- [2.3 Broker 生成 ConsumeQueue](#)\n- [3. 事务消息回查](#)\n\t- [3.1 Broker 发起【事务消息回查】](#)\n\t\t- [3.1.1 官方V3.1.4：基于文件系统](#)\n\t\t\t- [3.1.1.1 存储消息到 CommitLog](#)\n\t\t\t- [3.1.1.2 写【事务消息】状态存储（TranStateTable）](#)\n\t\t\t- [3.1.1.3 【事务消息】回查](#)\n\t\t\t- [3.1.1.4 初始化【事务消息】状态存储（TranStateTable）](#)\n\t\t\t- [3.1.1.5 补充](#)\n\t\t- [3.1.2 官方V4.0.0：基于数据库](#)\n\t- [3.2 Producer 接收【事务消息回查】](#)\n\n# 1. 概述\n\n**必须必须必须** 前置阅读内容：\n\n* [《事务消息（阿里云）》](https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7)\n\n# 2. 事务消息发送\n\n## 2.1 Producer 发送事务消息\n\n* 活动图如下（结合 `核心代码` 理解）：\n\n![Producer发送事务消息](http://www.yunai.me/images/RocketMQ/2017_05_21/03.png)\n\n* 实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: /**\n  3:  * 发送事务消息\n  4:  *\n  5:  * @param msg 消息\n  6:  * @param tranExecuter 【本地事务】执行器\n  7:  * @param arg 【本地事务】执行器参数\n  8:  * @return 事务发送结果\n  9:  * @throws MQClientException 当 Client 发生异常时\n 10:  */\n 11: public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter tranExecuter, final Object arg)\n 12:     throws MQClientException {\n 13:     if (null == tranExecuter) {\n 14:         throw new MQClientException(\"tranExecutor is null\", null);\n 15:     }\n 16:     Validators.checkMessage(msg, this.defaultMQProducer);\n 17: \n 18:     // 发送【Half消息】\n 19:     SendResult sendResult;\n 20:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, \"true\");\n 21:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());\n 22:     try {\n 23:         sendResult = this.send(msg);\n 24:     } catch (Exception e) {\n 25:         throw new MQClientException(\"send message Exception\", e);\n 26:     }\n 27: \n 28:     // 处理发送【Half消息】结果\n 29:     LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;\n 30:     Throwable localException = null;\n 31:     switch (sendResult.getSendStatus()) {\n 32:         // 发送【Half消息】成功，执行【本地事务】逻辑\n 33:         case SEND_OK: {\n 34:             try {\n 35:                 if (sendResult.getTransactionId() != null) { // 事务编号。目前开源版本暂时没用到，猜想ONS在使用。\n 36:                     msg.putUserProperty(\"__transactionId__\", sendResult.getTransactionId());\n 37:                 }\n 38: \n 39:                 // 执行【本地事务】逻辑\n 40:                 localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);\n 41:                 if (null == localTransactionState) {\n 42:                     localTransactionState = LocalTransactionState.UNKNOW;\n 43:                 }\n 44: \n 45:                 if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {\n 46:                     log.info(\"executeLocalTransactionBranch return {}\", localTransactionState);\n 47:                     log.info(msg.toString());\n 48:                 }\n 49:             } catch (Throwable e) {\n 50:                 log.info(\"executeLocalTransactionBranch exception\", e);\n 51:                 log.info(msg.toString());\n 52:                 localException = e;\n 53:             }\n 54:         }\n 55:         break;\n 56:         // 发送【Half消息】失败，标记【本地事务】状态为回滚\n 57:         case FLUSH_DISK_TIMEOUT:\n 58:         case FLUSH_SLAVE_TIMEOUT:\n 59:         case SLAVE_NOT_AVAILABLE:\n 60:             localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;\n 61:             break;\n 62:         default:\n 63:             break;\n 64:     }\n 65: \n 66:     // 结束事务：提交消息 COMMIT / ROLLBACK\n 67:     try {\n 68:         this.endTransaction(sendResult, localTransactionState, localException);\n 69:     } catch (Exception e) {\n 70:         log.warn(\"local transaction execute \" + localTransactionState + \", but end broker transaction failed\", e);\n 71:     }\n 72: \n 73:     // 返回【事务发送结果】\n 74:     TransactionSendResult transactionSendResult = new TransactionSendResult();\n 75:     transactionSendResult.setSendStatus(sendResult.getSendStatus());\n 76:     transactionSendResult.setMessageQueue(sendResult.getMessageQueue());\n 77:     transactionSendResult.setMsgId(sendResult.getMsgId());\n 78:     transactionSendResult.setQueueOffset(sendResult.getQueueOffset());\n 79:     transactionSendResult.setTransactionId(sendResult.getTransactionId());\n 80:     transactionSendResult.setLocalTransactionState(localTransactionState);\n 81:     return transactionSendResult;\n 82: }\n 83: \n 84: /**\n 85:  * 结束事务：提交消息 COMMIT / ROLLBACK\n 86:  *\n 87:  * @param sendResult 发送【Half消息】结果\n 88:  * @param localTransactionState 【本地事务】状态\n 89:  * @param localException 执行【本地事务】逻辑产生的异常\n 90:  * @throws RemotingException 当远程调用发生异常时\n 91:  * @throws MQBrokerException 当 Broker 发生异常时\n 92:  * @throws InterruptedException 当线程中断时\n 93:  * @throws UnknownHostException 当解码消息编号失败是\n 94:  */\n 95: public void endTransaction(//\n 96:     final SendResult sendResult, //\n 97:     final LocalTransactionState localTransactionState, //\n 98:     final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {\n 99:     // 解码消息编号\n100:     final MessageId id;\n101:     if (sendResult.getOffsetMsgId() != null) {\n102:         id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());\n103:     } else {\n104:         id = MessageDecoder.decodeMessageId(sendResult.getMsgId());\n105:     }\n106: \n107:     // 创建请求\n108:     String transactionId = sendResult.getTransactionId();\n109:     final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());\n110:     EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();\n111:     requestHeader.setTransactionId(transactionId);\n112:     requestHeader.setCommitLogOffset(id.getOffset());\n113:     switch (localTransactionState) {\n114:         case COMMIT_MESSAGE:\n115:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);\n116:             break;\n117:         case ROLLBACK_MESSAGE:\n118:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);\n119:             break;\n120:         case UNKNOW:\n121:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);\n122:             break;\n123:         default:\n124:             break;\n125:     }\n126:     requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n127:     requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());\n128:     requestHeader.setMsgId(sendResult.getMsgId());\n129:     String remark = localException != null ? (\"executeLocalTransactionBranch exception: \" + localException.toString()) : null;\n130: \n131:     // 提交消息 COMMIT / ROLLBACK。！！！通信方式为：Oneway！！！\n132:     this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout());\n133: }\n```\n\n## 2.2 Broker 处理结束事务请求\n\n* 🦅 查询请求的消息，进行**提交 / 回滚**。实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【EndTransactionProcessor.java】\n  2: public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {\n  3:     final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n  4:     final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);\n  5: \n  6:     // 省略代码 =》打印日志（只处理 COMMIT / ROLLBACK）\n  7: \n  8:     // 查询提交的消息\n  9:     final MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getCommitLogOffset());\n 10:     if (msgExt != null) {\n 11:         // 省略代码 =》校验消息\n 12: \n 13:         // 生成消息\n 14:         MessageExtBrokerInner msgInner = this.endMessageTransaction(msgExt);\n 15:         msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));\n 16:         msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());\n 17:         msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());\n 18:         msgInner.setStoreTimestamp(msgExt.getStoreTimestamp());\n 19:         if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {\n 20:             msgInner.setBody(null);\n 21:         }\n 22: \n 23:         // 存储生成消息\n 24:         final MessageStore messageStore = this.brokerController.getMessageStore();\n 25:         final PutMessageResult putMessageResult = messageStore.putMessage(msgInner);\n 26: \n 27:         // 处理存储结果\n 28:         if (putMessageResult != null) {\n 29:             switch (putMessageResult.getPutMessageStatus()) {\n 30:                 // Success\n 31:                 case PUT_OK:\n 32:                 case FLUSH_DISK_TIMEOUT:\n 33:                 case FLUSH_SLAVE_TIMEOUT:\n 34:                 case SLAVE_NOT_AVAILABLE:\n 35:                     response.setCode(ResponseCode.SUCCESS);\n 36:                     response.setRemark(null);\n 37:                     break;\n 38:                 // Failed\n 39:                 case CREATE_MAPEDFILE_FAILED:\n 40:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 41:                     response.setRemark(\"create maped file failed.\");\n 42:                     break;\n 43:                 case MESSAGE_ILLEGAL:\n 44:                 case PROPERTIES_SIZE_EXCEEDED:\n 45:                     response.setCode(ResponseCode.MESSAGE_ILLEGAL);\n 46:                     response.setRemark(\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\");\n 47:                     break;\n 48:                 case SERVICE_NOT_AVAILABLE:\n 49:                     response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n 50:                     response.setRemark(\"service not available now.\");\n 51:                     break;\n 52:                 case OS_PAGECACHE_BUSY:\n 53:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 54:                     response.setRemark(\"OS page cache busy, please try another machine\");\n 55:                     break;\n 56:                 case UNKNOWN_ERROR:\n 57:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 58:                     response.setRemark(\"UNKNOWN_ERROR\");\n 59:                     break;\n 60:                 default:\n 61:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 62:                     response.setRemark(\"UNKNOWN_ERROR DEFAULT\");\n 63:                     break;\n 64:             }\n 65: \n 66:             return response;\n 67:         } else {\n 68:             response.setCode(ResponseCode.SYSTEM_ERROR);\n 69:             response.setRemark(\"store putMessage return null\");\n 70:         }\n 71:     } else {\n 72:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 73:         response.setRemark(\"find prepared transaction message failed\");\n 74:         return response;\n 75:     }\n 76: \n 77:     return response;\n 78: }\n```\n\n## 2.3 Broker 生成 ConsumeQueue\n\n* 🦅 事务消息，提交（`COMMIT`）后才生成 `ConsumeQueue`。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMessageStore.java】\n  2: public void doDispatch(DispatchRequest req) {\n  3:     // 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n  4:     final int tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());\n  5:     switch (tranType) {\n  6:         case MessageSysFlag.TRANSACTION_NOT_TYPE: // 非事务消息\n  7:         case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // 事务消息COMMIT\n  8:             DefaultMessageStore.this.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),\n  9:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());\n 10:             break;\n 11:         case MessageSysFlag.TRANSACTION_PREPARED_TYPE: // 事务消息PREPARED\n 12:         case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: // 事务消息ROLLBACK\n 13:             break;\n 14:     }\n 15:     // 省略代码 =》 建立 索引信息 到 IndexFile\n 16: }\n```\n\n# 3. 事务消息回查\n\n* 【事务消息回查】功能曾经开源过，目前（V4.0.0）暂未开源。如下是该功能的开源情况：\n\n| 版本 | 【事务消息回查】 | |\n| --- | --- | --- |\n| 官方V3.0.4 ~ V3.1.4 | 基于 文件系统 实现 | 已开源 |\n| 官方V3.1.5 ~ V4.0.0 | 基于 数据库 实现 | 未完全开源 |\n\n我们来看看两种情况下是怎么实现的。\n\n## 3.1 Broker 发起【事务消息回查】\n\n### 3.1.1 官方V3.1.4：基于文件系统\n\n> 仓库地址：https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4\n\n相较于普通消息，【事务消息】多依赖如下三个组件：\n\n* **TransactionStateService** ：事务状态服务，负责对【事务消息】进行管理，包括存储与更新事务消息状态、回查事务消息状态等等。\n* **TranStateTable** ：【事务消息】状态存储。基于 `MappedFileQueue` 实现，默认存储路径为 `~/store/transaction/statetable`，每条【事务消息】状态存储结构如下：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | offset | CommitLog 物理存储位置 | Long | 8 |\n| 2 | size | 消息长度 | Int | 4 |\n| 3 | timestamp | 消息存储时间，单位：秒 | Int | 4 |\n| 4 | producerGroupHash | producerGroup 求 HashCode | Int | 4 |\n| 5 | state | 事务状态 | Int | 4 |\n\n* **TranRedoLog** ：`TranStateTable` 重放日志，每次**写操作** `TranStateTable` 记录重放日志。当 `Broker` 异常关闭时，使用 `TranRedoLog` 恢复 `TranStateTable`。基于 `ConsumeQueue` 实现，`Topic` 为 `TRANSACTION_REDOLOG_TOPIC_XXXX`，默认存储路径为 `~/store/transaction/redolog`。\n\n-------\n\n简单手绘逻辑图如下😈：\n\n![Broker_V3.1.4_基于文件系统](http://www.yunai.me/images/RocketMQ/2017_05_21/01.jpeg)\n\n#### 3.1.1.1 存储消息到 CommitLog\n\n* 🦅存储【half消息】到 `CommitLog` 时，消息队列位置（`queueOffset`）使用 `TranStateTable` 最大物理位置（可写入物理位置）。这样，消息可以索引到自己对应的 `TranStateTable` 的位置和记录。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultAppendMessageCallback.java】\n  2: class DefaultAppendMessageCallback implements AppendMessageCallback {\n  3:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer,  final int maxBlank, final Object msg) {\n  4:         // ...省略代码\n  5: \n  6:         // 事务消息需要特殊处理 \n  7:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());\n  8:         switch (tranType) {\n  9:         case MessageSysFlag.TransactionPreparedType: // 消息队列位置（queueOffset）使用 TranStateTable 最大物理位置（可写入物理位置） \n 10:             queueOffset = CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().get();\n 11:             break;\n 12:         case MessageSysFlag.TransactionRollbackType:\n 13:             queueOffset = msgInner.getQueueOffset();\n 14:             break;\n 15:         case MessageSysFlag.TransactionNotType:\n 16:         case MessageSysFlag.TransactionCommitType:\n 17:         default:\n 18:             break;\n 19:         }\n 20: \n 21:         // ...省略代码\n 22: \n 23:         switch (tranType) {\n 24:         case MessageSysFlag.TransactionPreparedType:\n 25:             // 更新 TranStateTable 最大物理位置（可写入物理位置） \n 26:             CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().incrementAndGet();\n 27:             break;\n 28:         case MessageSysFlag.TransactionRollbackType:\n 29:             break;\n 30:         case MessageSysFlag.TransactionNotType:\n 31:         case MessageSysFlag.TransactionCommitType:\n 32:             // 更新下一次的ConsumeQueue信息\n 33:             CommitLog.this.topicQueueTable.put(key, ++queueOffset);\n 34:             break;\n 35:         default:\n 36:             break;\n 37:         }\n 38: \n 39:         // 返回结果\n 40:         return result;\n 41:     }\n 42: }\n```\n\n#### 3.1.1.2 写【事务消息】状态存储（TranStateTable）\n\n* 🦅处理【Half消息】时，新增【事务消息】状态存储（`TranStateTable`）。\n* 🦅处理【Commit / Rollback消息】时，更新 【事务消息】状态存储（`TranStateTable`） COMMIT / ROLLBACK。\n* 🦅每次**写操作【**事务消息】状态存储（`TranStateTable`），记录重放日志（`TranRedoLog`）。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DispatchMessageService.java】\n  2: private void doDispatch() {\n  3:     if (!this.requestsRead.isEmpty()) {\n  4:         for (DispatchRequest req : this.requestsRead) {\n  5: \n  6:             // ...省略代码\n  7: \n  8:             // 2、写【事务消息】状态存储（TranStateTable）\n  9:             if (req.getProducerGroup() != null) {\n 10:                 switch (tranType) {\n 11:                 case MessageSysFlag.TransactionNotType:\n 12:                     break;\n 13:                 case MessageSysFlag.TransactionPreparedType:\n 14:                     // 新增 【事务消息】状态存储（TranStateTable）\n 15:                     DefaultMessageStore.this.getTransactionStateService().appendPreparedTransaction(\n 16:                         req.getCommitLogOffset(), req.getMsgSize(), (int) (req.getStoreTimestamp() / 1000), req.getProducerGroup().hashCode());\n 17:                     break;\n 18:                 case MessageSysFlag.TransactionCommitType:\n 19:                 case MessageSysFlag.TransactionRollbackType:\n 20:                     // 更新 【事务消息】状态存储（TranStateTable） COMMIT / ROLLBACK\n 21:                     DefaultMessageStore.this.getTransactionStateService().updateTransactionState(\n 22:                         req.getTranStateTableOffset(), req.getPreparedTransactionOffset(), req.getProducerGroup().hashCode(), tranType);\n 23:                     break;\n 24:                 }\n 25:             }\n 26:             // 3、记录 TranRedoLog\n 27:             switch (tranType) {\n 28:             case MessageSysFlag.TransactionNotType:\n 29:                 break;\n 30:             case MessageSysFlag.TransactionPreparedType:\n 31:                 // 记录 TranRedoLog\n 32:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(\n 33:                         req.getCommitLogOffset(), req.getMsgSize(), TransactionStateService.PreparedMessageTagsCode,\n 34:                         req.getStoreTimestamp(), 0L);\n 35:                 break;\n 36:             case MessageSysFlag.TransactionCommitType:\n 37:             case MessageSysFlag.TransactionRollbackType:\n 38:                 // 记录 TranRedoLog\n 39:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(\n 40:                         req.getCommitLogOffset(), req.getMsgSize(), req.getPreparedTransactionOffset(),\n 41:                         req.getStoreTimestamp(), 0L);\n 42:                 break;\n 43:             }\n 44:         }\n 45: \n 46:         // ...省略代码\n 47:     }\n 48: }\n 49: // ⬇️⬇️⬇️【TransactionStateService.java】\n 50: /**\n 51:  * 新增事务状态\n 52:  *\n 53:  * @param clOffset commitLog 物理位置\n 54:  * @param size 消息长度\n 55:  * @param timestamp 消息存储时间\n 56:  * @param groupHashCode groupHashCode\n 57:  * @return 是否成功\n 58:  */\n 59: public boolean appendPreparedTransaction(//\n 60:         final long clOffset,//\n 61:         final int size,//\n 62:         final int timestamp,//\n 63:         final int groupHashCode//\n 64: ) {\n 65:     MapedFile mapedFile = this.tranStateTable.getLastMapedFile();\n 66:     if (null == mapedFile) {\n 67:         log.error(\"appendPreparedTransaction: create mapedfile error.\");\n 68:         return false;\n 69:     }\n 70: \n 71:     // 首次创建，加入定时任务中\n 72:     if (0 == mapedFile.getWrotePostion()) {\n 73:         this.addTimerTask(mapedFile);\n 74:     }\n 75: \n 76:     this.byteBufferAppend.position(0);\n 77:     this.byteBufferAppend.limit(TSStoreUnitSize);\n 78: \n 79:     // Commit Log Offset\n 80:     this.byteBufferAppend.putLong(clOffset);\n 81:     // Message Size\n 82:     this.byteBufferAppend.putInt(size);\n 83:     // Timestamp\n 84:     this.byteBufferAppend.putInt(timestamp);\n 85:     // Producer Group Hashcode\n 86:     this.byteBufferAppend.putInt(groupHashCode);\n 87:     // Transaction State\n 88:     this.byteBufferAppend.putInt(MessageSysFlag.TransactionPreparedType);\n 89: \n 90:     return mapedFile.appendMessage(this.byteBufferAppend.array());\n 91: }\n 92: \n 93: /**\n 94:  * 更新事务状态\n 95:  *\n 96:  * @param tsOffset tranStateTable 物理位置\n 97:  * @param clOffset commitLog 物理位置\n 98:  * @param groupHashCode groupHashCode\n 99:  * @param state 事务状态\n100:  * @return 是否成功\n101:  */\n102: public boolean updateTransactionState(\n103:         final long tsOffset,\n104:         final long clOffset,\n105:         final int groupHashCode,\n106:         final int state) {\n107:     SelectMapedBufferResult selectMapedBufferResult = this.findTransactionBuffer(tsOffset);\n108:     if (selectMapedBufferResult != null) {\n109:         try {\n110: \n111:             // ....省略代码：校验是否能够更新\n112: \n113:             // 更新事务状态\n114:             selectMapedBufferResult.getByteBuffer().putInt(TS_STATE_POS, state);\n115:         }\n116:         catch (Exception e) {\n117:             log.error(\"updateTransactionState exception\", e);\n118:         }\n119:         finally {\n120:             selectMapedBufferResult.release();\n121:         }\n122:     }\n123: \n124:     return false;\n125: }\n```\n\n#### 3.1.1.3 【事务消息】回查\n\n* 🦅`TranStateTable` 每个 `MappedFile` 都对应一个 `Timer`。`Timer` 固定周期（默认：60s）遍历 `MappedFile`，查找【half消息】，向 `Producer` 发起【事务消息】回查请求。【事务消息】回查结果的逻辑不在此处进行，在 [CommitLog dispatch](#3112-写事务消息状态存储transtatetable)时执行。\n\n实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【TransactionStateService.java】\n  2: /**\n  3:  * 初始化定时任务\n  4:  */\n  5: private void initTimerTask() {\n  6:     //\n  7:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();\n  8:     for (MapedFile mf : mapedFiles) {\n  9:         this.addTimerTask(mf);\n 10:     }\n 11: }\n 12: \n 13: /**\n 14:  * 每个文件初始化定时任务\n 15:  * @param mf 文件\n 16:  */\n 17: private void addTimerTask(final MapedFile mf) {\n 18:     this.timer.scheduleAtFixedRate(new TimerTask() {\n 19:         private final MapedFile mapedFile = mf;\n 20:         private final TransactionCheckExecuter transactionCheckExecuter = TransactionStateService.this.defaultMessageStore.getTransactionCheckExecuter();\n 21:         private final long checkTransactionMessageAtleastInterval = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()\n 22:                     .getCheckTransactionMessageAtleastInterval();\n 23:         private final boolean slave = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE;\n 24: \n 25:         @Override\n 26:         public void run() {\n 27:             // Slave不需要回查事务状态\n 28:             if (slave) {\n 29:                 return;\n 30:             }\n 31:             // Check功能是否开启\n 32:             if (!TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()\n 33:                 .isCheckTransactionMessageEnable()) {\n 34:                 return;\n 35:             }\n 36: \n 37:             try {\n 38:                 SelectMapedBufferResult selectMapedBufferResult = mapedFile.selectMapedBuffer(0);\n 39:                 if (selectMapedBufferResult != null) {\n 40:                     long preparedMessageCountInThisMapedFile = 0; // 回查的【half消息】数量\n 41:                     int i = 0;\n 42:                     try {\n 43:                         // 循环每条【事务消息】状态，对【half消息】进行回查\n 44:                         for (; i < selectMapedBufferResult.getSize(); i += TSStoreUnitSize) {\n 45:                             selectMapedBufferResult.getByteBuffer().position(i);\n 46: \n 47:                             // Commit Log Offset\n 48:                             long clOffset = selectMapedBufferResult.getByteBuffer().getLong();\n 49:                             // Message Size\n 50:                             int msgSize = selectMapedBufferResult.getByteBuffer().getInt();\n 51:                             // Timestamp\n 52:                             int timestamp = selectMapedBufferResult.getByteBuffer().getInt();\n 53:                             // Producer Group Hashcode\n 54:                             int groupHashCode = selectMapedBufferResult.getByteBuffer().getInt();\n 55:                             // Transaction State\n 56:                             int tranType = selectMapedBufferResult.getByteBuffer().getInt();\n 57: \n 58:                             // 已经提交或者回滚的消息跳过\n 59:                             if (tranType != MessageSysFlag.TransactionPreparedType) {\n 60:                                 continue;\n 61:                             }\n 62: \n 63:                             // 遇到时间不符合最小轮询间隔，终止\n 64:                             long timestampLong = timestamp * 1000;\n 65:                             long diff = System.currentTimeMillis() - timestampLong;\n 66:                             if (diff < checkTransactionMessageAtleastInterval) {\n 67:                                 break;\n 68:                             }\n 69: \n 70:                             preparedMessageCountInThisMapedFile++;\n 71: \n 72:                             // 回查Producer\n 73:                             try {\n 74:                                 this.transactionCheckExecuter.gotoCheck(groupHashCode, getTranStateOffset(i), clOffset, msgSize);\n 75:                             } catch (Exception e) {\n 76:                                 tranlog.warn(\"gotoCheck Exception\", e);\n 77:                             }\n 78:                         }\n 79: \n 80:                         // 无回查的【half消息】数量，且遍历完，则终止定时任务\n 81:                         if (0 == preparedMessageCountInThisMapedFile //\n 82:                                 && i == mapedFile.getFileSize()) {\n 83:                             tranlog.info(\"remove the transaction timer task, because no prepared message in this mapedfile[{}]\", mapedFile.getFileName());\n 84:                             this.cancel();\n 85:                         }\n 86:                     } finally {\n 87:                         selectMapedBufferResult.release();\n 88:                     }\n 89: \n 90:                     tranlog.info(\"the transaction timer task execute over in this period, {} Prepared Message: {} Check Progress: {}/{}\", mapedFile.getFileName(),//\n 91:                             preparedMessageCountInThisMapedFile, i / TSStoreUnitSize, mapedFile.getFileSize() / TSStoreUnitSize);\n 92:                 } else if (mapedFile.isFull()) {\n 93:                     tranlog.info(\"the mapedfile[{}] maybe deleted, cancel check transaction timer task\", mapedFile.getFileName());\n 94:                     this.cancel();\n 95:                     return;\n 96:                 }\n 97:             } catch (Exception e) {\n 98:                 log.error(\"check transaction timer task Exception\", e);\n 99:             }\n100:         }\n101: \n102: \n103:         private long getTranStateOffset(final long currentIndex) {\n104:             long offset = (this.mapedFile.getFileFromOffset() + currentIndex) / TransactionStateService.TSStoreUnitSize;\n105:             return offset;\n106:         }\n107:     }, 1000 * 60, this.defaultMessageStore.getMessageStoreConfig().getCheckTransactionMessageTimerInterval());\n108: }\n109: \n110: // 【DefaultTransactionCheckExecuter.java】\n111: @Override\n112: public void gotoCheck(int producerGroupHashCode, long tranStateTableOffset, long commitLogOffset,\n113:         int msgSize) {\n114:     // 第一步、查询Producer\n115:     final ClientChannelInfo clientChannelInfo = this.brokerController.getProducerManager().pickProducerChannelRandomly(producerGroupHashCode);\n116:     if (null == clientChannelInfo) {\n117:         log.warn(\"check a producer transaction state, but not find any channel of this group[{}]\", producerGroupHashCode);\n118:         return;\n119:     }\n120: \n121:     // 第二步、查询消息\n122:     SelectMapedBufferResult selectMapedBufferResult = this.brokerController.getMessageStore().selectOneMessageByOffset(commitLogOffset, msgSize);\n123:     if (null == selectMapedBufferResult) {\n124:         log.warn(\"check a producer transaction state, but not find message by commitLogOffset: {}, msgSize: \", commitLogOffset, msgSize);\n125:         return;\n126:     }\n127: \n128:     // 第三步、向Producer发起请求\n129:     final CheckTransactionStateRequestHeader requestHeader = new CheckTransactionStateRequestHeader();\n130:     requestHeader.setCommitLogOffset(commitLogOffset);\n131:     requestHeader.setTranStateTableOffset(tranStateTableOffset);\n132:     this.brokerController.getBroker2Client().checkProducerTransactionState(clientChannelInfo.getChannel(), requestHeader, selectMapedBufferResult);\n133: }\n```\n\n#### 3.1.1.4 初始化【事务消息】状态存储（TranStateTable）\n\n* 🦅根据最后 Broker 关闭是否正常，会有不同的初始化方式。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【TransactionStateService.java】\n  2: /**\n  3:  * 初始化 TranRedoLog\n  4:  * @param lastExitOK 是否正常退出\n  5:  */\n  6: public void recoverStateTable(final boolean lastExitOK) {\n  7:     if (lastExitOK) {\n  8:         this.recoverStateTableNormal();\n  9:     } else {\n 10:         // 第一步，删除State Table\n 11:         this.tranStateTable.destroy();\n 12:         // 第二步，通过RedoLog全量恢复StateTable\n 13:         this.recreateStateTable();\n 14:     }\n 15: }\n 16: \n 17: /**\n 18:  * 扫描 TranRedoLog 重建 StateTable\n 19:  */\n 20: private void recreateStateTable() {\n 21:     this.tranStateTable = new MapedFileQueue(StorePathConfigHelper.getTranStateTableStorePath(defaultMessageStore\n 22:                 .getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore\n 23:                 .getMessageStoreConfig().getTranStateTableMapedFileSize(), null);\n 24: \n 25:     final TreeSet<Long> preparedItemSet = new TreeSet<Long>();\n 26: \n 27:     // 第一步，从头扫描RedoLog\n 28:     final long minOffset = this.tranRedoLog.getMinOffsetInQuque();\n 29:     long processOffset = minOffset;\n 30:     while (true) {\n 31:         SelectMapedBufferResult bufferConsumeQueue = this.tranRedoLog.getIndexBuffer(processOffset);\n 32:         if (bufferConsumeQueue != null) {\n 33:             try {\n 34:                 long i = 0;\n 35:                 for (; i < bufferConsumeQueue.getSize(); i += ConsumeQueue.CQStoreUnitSize) {\n 36:                     long offsetMsg = bufferConsumeQueue.getByteBuffer().getLong();\n 37:                     int sizeMsg = bufferConsumeQueue.getByteBuffer().getInt();\n 38:                     long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();\n 39: \n 40:                     if (TransactionStateService.PreparedMessageTagsCode == tagsCode) { // Prepared\n 41:                         preparedItemSet.add(offsetMsg);\n 42:                     } else { // Commit/Rollback\n 43:                         preparedItemSet.remove(tagsCode);\n 44:                     }\n 45:                 }\n 46: \n 47:                 processOffset += i;\n 48:             } finally { // 必须释放资源\n 49:                 bufferConsumeQueue.release();\n 50:             }\n 51:         } else {\n 52:             break;\n 53:         }\n 54:     }\n 55:     log.info(\"scan transaction redolog over, End offset: {},  Prepared Transaction Count: {}\", processOffset, preparedItemSet.size());\n 56: \n 57:     // 第二步，重建StateTable\n 58:     Iterator<Long> it = preparedItemSet.iterator();\n 59:     while (it.hasNext()) {\n 60:         Long offset = it.next();\n 61:         MessageExt msgExt = this.defaultMessageStore.lookMessageByOffset(offset);\n 62:         if (msgExt != null) {\n 63:             this.appendPreparedTransaction(msgExt.getCommitLogOffset(), msgExt.getStoreSize(),\n 64:                 (int) (msgExt.getStoreTimestamp() / 1000),\n 65:                 msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP).hashCode());\n 66:             this.tranStateTableOffset.incrementAndGet();\n 67:         }\n 68:     }\n 69: }\n 70: \n 71: /**\n 72:  * 加载（解析）TranStateTable 的 MappedFile\n 73:  * 1. 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position\n 74:  * 2. 设置 TanStateTable 最大物理位置（可写入位置）\n 75:  */\n 76: private void recoverStateTableNormal() {\n 77:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();\n 78:     if (!mapedFiles.isEmpty()) {\n 79:         // 从倒数第三个文件开始恢复\n 80:         int index = mapedFiles.size() - 3;\n 81:         if (index < 0) {\n 82:             index = 0;\n 83:         }\n 84: \n 85:         int mapedFileSizeLogics = this.tranStateTable.getMapedFileSize();\n 86:         MapedFile mapedFile = mapedFiles.get(index);\n 87:         ByteBuffer byteBuffer = mapedFile.sliceByteBuffer();\n 88:         long processOffset = mapedFile.getFileFromOffset();\n 89:         long mapedFileOffset = 0;\n 90:         while (true) {\n 91:             for (int i = 0; i < mapedFileSizeLogics; i += TSStoreUnitSize) {\n 92: \n 93:                 final long clOffset_read = byteBuffer.getLong();\n 94:                 final int size_read = byteBuffer.getInt();\n 95:                 final int timestamp_read = byteBuffer.getInt();\n 96:                 final int groupHashCode_read = byteBuffer.getInt();\n 97:                 final int state_read = byteBuffer.getInt();\n 98: \n 99:                 boolean stateOK = false;\n100:                 switch (state_read) {\n101:                 case MessageSysFlag.TransactionPreparedType:\n102:                 case MessageSysFlag.TransactionCommitType:\n103:                 case MessageSysFlag.TransactionRollbackType:\n104:                     stateOK = true;\n105:                     break;\n106:                 default:\n107:                     break;\n108:                 }\n109: \n110:                 // 说明当前存储单元有效\n111:                 if (clOffset_read >= 0 && size_read > 0 && stateOK) {\n112:                     mapedFileOffset = i + TSStoreUnitSize;\n113:                 } else {\n114:                     log.info(\"recover current transaction state table file over,  \" + mapedFile.getFileName() + \" \"\n115:                             + clOffset_read + \" \" + size_read + \" \" + timestamp_read);\n116:                     break;\n117:                 }\n118:             }\n119: \n120:             // 走到文件末尾，切换至下一个文件\n121:             if (mapedFileOffset == mapedFileSizeLogics) {\n122:                 index++;\n123:                 if (index >= mapedFiles.size()) { // 循环while结束\n124:                     log.info(\"recover last transaction state table file over, last maped file \" + mapedFile.getFileName());\n125:                     break;\n126:                 } else { // 切换下一个文件\n127:                     mapedFile = mapedFiles.get(index);\n128:                     byteBuffer = mapedFile.sliceByteBuffer();\n129:                     processOffset = mapedFile.getFileFromOffset();\n130:                     mapedFileOffset = 0;\n131:                     log.info(\"recover next transaction state table file, \" + mapedFile.getFileName());\n132:                 }\n133:             } else {\n134:                 log.info(\"recover current transaction state table queue over \" + mapedFile.getFileName() + \" \" + (processOffset + mapedFileOffset));\n135:                 break;\n136:             }\n137:         }\n138: \n139:         // 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position\n140:         processOffset += mapedFileOffset;\n141:         this.tranStateTable.truncateDirtyFiles(processOffset);\n142: \n143:         // 设置 TanStateTable 最大物理位置（可写入位置）\n144:         this.tranStateTableOffset.set(this.tranStateTable.getMaxOffset() / TSStoreUnitSize);\n145:         log.info(\"recover normal over, transaction state table max offset: {}\", this.tranStateTableOffset.get());\n146:     }\n147: }\n```\n\n#### 3.1.1.5 补充\n\n* 为什么 V3.1.5 开始，使用 数据库 实现【事务状态】的存储？如下是来自官方文档的说明，可能是一部分原因：\n\n> RocketMQ 这种实现事务方式，没有通过 KV 存储做，而是通过 Offset 方式，存在一个显著缺陷，即通过 Offset 更改数据，会令系统的脏页过多，需要特别关注。\n\n### 3.1.2 官方V4.0.0：基于数据库\n\n> 仓库地址：https://github.com/apache/incubator-rocketmq\n\n官方V4.0.0 暂时未**完全**开源【事务消息回查】功能，**So 我们需要进行一些猜想，可能不一定正确😈**。\n\n😆我们来对比【官方V3.1.4：基于文件】的实现。\n\n* TransactionRecord ：记录每条【事务消息】。类似 `TranStateTable`。\n\n| TranStateTable | TransactionRecord |  |\n| --- | --- | --- |\n| offset | offset |  |\n| producerGroupHash | producerGroup |  |\n| size | 无 | 非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。 |\n| timestamp | 无 | 非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。 |\n| state | 无 | 非必须字段： 事务开始，增加记录；事务结束，删除记录。|\n\n另外，数据库本身保证了数据存储的可靠性，无需 `TranRedoLog`。\n\n-------\n\n简单手绘逻辑图如下😈：\n\n![Broker_V4.0.0_基于数据库](http://www.yunai.me/images/RocketMQ/2017_05_21/02.jpeg)\n\n## 3.2 Producer 接收【事务消息回查】\n\n* 顺序图如下：\n\n![Producer接收【事务消息回查】](http://www.yunai.me/images/RocketMQ/2017_05_21/04.png)\n\n* 核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: /**\n  3:  * 检查【事务状态】状态\n  4:  *\n  5:  * @param addr broker地址\n  6:  * @param msg 消息\n  7:  * @param header 请求\n  8:  */\n  9: @Override\n 10: public void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) {\n 11:     Runnable request = new Runnable() {\n 12:         private final String brokerAddr = addr;\n 13:         private final MessageExt message = msg;\n 14:         private final CheckTransactionStateRequestHeader checkRequestHeader = header;\n 15:         private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup();\n 16: \n 17:         @Override\n 18:         public void run() {\n 19:             TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener();\n 20:             if (transactionCheckListener != null) {\n 21:                 // 获取事务执行状态\n 22:                 LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;\n 23:                 Throwable exception = null;\n 24:                 try {\n 25:                     localTransactionState = transactionCheckListener.checkLocalTransactionState(message);\n 26:                 } catch (Throwable e) {\n 27:                     log.error(\"Broker call checkTransactionState, but checkLocalTransactionState exception\", e);\n 28:                     exception = e;\n 29:                 }\n 30: \n 31:                 // 处理事务结果，提交消息 COMMIT / ROLLBACK\n 32:                 this.processTransactionState(//\n 33:                     localTransactionState, //\n 34:                     group, //\n 35:                     exception);\n 36:             } else {\n 37:                 log.warn(\"checkTransactionState, pick transactionCheckListener by group[{}] failed\", group);\n 38:             }\n 39:         }\n 40: \n 41:         /**\n 42:          * 处理事务结果，提交消息 COMMIT / ROLLBACK\n 43:          *\n 44:          * @param localTransactionState 【本地事务】状态\n 45:          * @param producerGroup producerGroup\n 46:          * @param exception 检查【本地事务】状态发生的异常\n 47:          */\n 48:         private void processTransactionState(//\n 49:             final LocalTransactionState localTransactionState, //\n 50:             final String producerGroup, //\n 51:             final Throwable exception) {\n 52:             final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader();\n 53:             thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());\n 54:             thisHeader.setProducerGroup(producerGroup);\n 55:             thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());\n 56:             thisHeader.setFromTransactionCheck(true);\n 57: \n 58:             // 设置消息编号\n 59:             String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);\n 60:             if (uniqueKey == null) {\n 61:                 uniqueKey = message.getMsgId();\n 62:             }\n 63:             thisHeader.setMsgId(uniqueKey);\n 64: \n 65:             thisHeader.setTransactionId(checkRequestHeader.getTransactionId());\n 66:             switch (localTransactionState) {\n 67:                 case COMMIT_MESSAGE:\n 68:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);\n 69:                     break;\n 70:                 case ROLLBACK_MESSAGE:\n 71:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);\n 72:                     log.warn(\"when broker check, client rollback this transaction, {}\", thisHeader);\n 73:                     break;\n 74:                 case UNKNOW:\n 75:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);\n 76:                     log.warn(\"when broker check, client does not know this transaction state, {}\", thisHeader);\n 77:                     break;\n 78:                 default:\n 79:                     break;\n 80:             }\n 81: \n 82:             String remark = null;\n 83:             if (exception != null) {\n 84:                 remark = \"checkLocalTransactionState Exception: \" + RemotingHelper.exceptionSimpleDesc(exception);\n 85:             }\n 86: \n 87:             try {\n 88:                 // 提交消息 COMMIT / ROLLBACK\n 89:                 DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,\n 90:                     3000);\n 91:             } catch (Exception e) {\n 92:                 log.error(\"endTransactionOneway exception\", e);\n 93:             }\n 94:         }\n 95:     };\n 96: \n 97:     // 提交执行\n 98:     this.checkExecutor.submit(request);\n 99: }\n100: \n101: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n102: /**\n103:  * 【事务消息回查】检查监听器\n104:  */\n105: public interface TransactionCheckListener {\n106: \n107:     /**\n108:      * 获取（检查）【本地事务】状态\n109:      *\n110:      * @param msg 消息\n111:      * @return 事务状态\n112:      */\n113:     LocalTransactionState checkLocalTransactionState(final MessageExt msg);\n114: \n115: }\n```\n\n","source":"_posts/RocketMQ/2017_05_21_RocketMQ源码分析——事务消息.md","raw":"title: RocketMQ 源码分析 —— 事务消息\ndate: 2017-05-21\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-transaction\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-transaction](http://www.yunai.me/RocketMQ/message-transaction)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1. 概述](#)\n- [2. 事务消息发送](#)\n\t- [2.1 Producer 发送事务消息](#)\n\t- [2.2 Broker 处理结束事务请求](#)\n\t- [2.3 Broker 生成 ConsumeQueue](#)\n- [3. 事务消息回查](#)\n\t- [3.1 Broker 发起【事务消息回查】](#)\n\t\t- [3.1.1 官方V3.1.4：基于文件系统](#)\n\t\t\t- [3.1.1.1 存储消息到 CommitLog](#)\n\t\t\t- [3.1.1.2 写【事务消息】状态存储（TranStateTable）](#)\n\t\t\t- [3.1.1.3 【事务消息】回查](#)\n\t\t\t- [3.1.1.4 初始化【事务消息】状态存储（TranStateTable）](#)\n\t\t\t- [3.1.1.5 补充](#)\n\t\t- [3.1.2 官方V4.0.0：基于数据库](#)\n\t- [3.2 Producer 接收【事务消息回查】](#)\n\n# 1. 概述\n\n**必须必须必须** 前置阅读内容：\n\n* [《事务消息（阿里云）》](https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7)\n\n# 2. 事务消息发送\n\n## 2.1 Producer 发送事务消息\n\n* 活动图如下（结合 `核心代码` 理解）：\n\n![Producer发送事务消息](http://www.yunai.me/images/RocketMQ/2017_05_21/03.png)\n\n* 实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: /**\n  3:  * 发送事务消息\n  4:  *\n  5:  * @param msg 消息\n  6:  * @param tranExecuter 【本地事务】执行器\n  7:  * @param arg 【本地事务】执行器参数\n  8:  * @return 事务发送结果\n  9:  * @throws MQClientException 当 Client 发生异常时\n 10:  */\n 11: public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter tranExecuter, final Object arg)\n 12:     throws MQClientException {\n 13:     if (null == tranExecuter) {\n 14:         throw new MQClientException(\"tranExecutor is null\", null);\n 15:     }\n 16:     Validators.checkMessage(msg, this.defaultMQProducer);\n 17: \n 18:     // 发送【Half消息】\n 19:     SendResult sendResult;\n 20:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, \"true\");\n 21:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());\n 22:     try {\n 23:         sendResult = this.send(msg);\n 24:     } catch (Exception e) {\n 25:         throw new MQClientException(\"send message Exception\", e);\n 26:     }\n 27: \n 28:     // 处理发送【Half消息】结果\n 29:     LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;\n 30:     Throwable localException = null;\n 31:     switch (sendResult.getSendStatus()) {\n 32:         // 发送【Half消息】成功，执行【本地事务】逻辑\n 33:         case SEND_OK: {\n 34:             try {\n 35:                 if (sendResult.getTransactionId() != null) { // 事务编号。目前开源版本暂时没用到，猜想ONS在使用。\n 36:                     msg.putUserProperty(\"__transactionId__\", sendResult.getTransactionId());\n 37:                 }\n 38: \n 39:                 // 执行【本地事务】逻辑\n 40:                 localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);\n 41:                 if (null == localTransactionState) {\n 42:                     localTransactionState = LocalTransactionState.UNKNOW;\n 43:                 }\n 44: \n 45:                 if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {\n 46:                     log.info(\"executeLocalTransactionBranch return {}\", localTransactionState);\n 47:                     log.info(msg.toString());\n 48:                 }\n 49:             } catch (Throwable e) {\n 50:                 log.info(\"executeLocalTransactionBranch exception\", e);\n 51:                 log.info(msg.toString());\n 52:                 localException = e;\n 53:             }\n 54:         }\n 55:         break;\n 56:         // 发送【Half消息】失败，标记【本地事务】状态为回滚\n 57:         case FLUSH_DISK_TIMEOUT:\n 58:         case FLUSH_SLAVE_TIMEOUT:\n 59:         case SLAVE_NOT_AVAILABLE:\n 60:             localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;\n 61:             break;\n 62:         default:\n 63:             break;\n 64:     }\n 65: \n 66:     // 结束事务：提交消息 COMMIT / ROLLBACK\n 67:     try {\n 68:         this.endTransaction(sendResult, localTransactionState, localException);\n 69:     } catch (Exception e) {\n 70:         log.warn(\"local transaction execute \" + localTransactionState + \", but end broker transaction failed\", e);\n 71:     }\n 72: \n 73:     // 返回【事务发送结果】\n 74:     TransactionSendResult transactionSendResult = new TransactionSendResult();\n 75:     transactionSendResult.setSendStatus(sendResult.getSendStatus());\n 76:     transactionSendResult.setMessageQueue(sendResult.getMessageQueue());\n 77:     transactionSendResult.setMsgId(sendResult.getMsgId());\n 78:     transactionSendResult.setQueueOffset(sendResult.getQueueOffset());\n 79:     transactionSendResult.setTransactionId(sendResult.getTransactionId());\n 80:     transactionSendResult.setLocalTransactionState(localTransactionState);\n 81:     return transactionSendResult;\n 82: }\n 83: \n 84: /**\n 85:  * 结束事务：提交消息 COMMIT / ROLLBACK\n 86:  *\n 87:  * @param sendResult 发送【Half消息】结果\n 88:  * @param localTransactionState 【本地事务】状态\n 89:  * @param localException 执行【本地事务】逻辑产生的异常\n 90:  * @throws RemotingException 当远程调用发生异常时\n 91:  * @throws MQBrokerException 当 Broker 发生异常时\n 92:  * @throws InterruptedException 当线程中断时\n 93:  * @throws UnknownHostException 当解码消息编号失败是\n 94:  */\n 95: public void endTransaction(//\n 96:     final SendResult sendResult, //\n 97:     final LocalTransactionState localTransactionState, //\n 98:     final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException {\n 99:     // 解码消息编号\n100:     final MessageId id;\n101:     if (sendResult.getOffsetMsgId() != null) {\n102:         id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());\n103:     } else {\n104:         id = MessageDecoder.decodeMessageId(sendResult.getMsgId());\n105:     }\n106: \n107:     // 创建请求\n108:     String transactionId = sendResult.getTransactionId();\n109:     final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());\n110:     EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();\n111:     requestHeader.setTransactionId(transactionId);\n112:     requestHeader.setCommitLogOffset(id.getOffset());\n113:     switch (localTransactionState) {\n114:         case COMMIT_MESSAGE:\n115:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);\n116:             break;\n117:         case ROLLBACK_MESSAGE:\n118:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);\n119:             break;\n120:         case UNKNOW:\n121:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);\n122:             break;\n123:         default:\n124:             break;\n125:     }\n126:     requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());\n127:     requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());\n128:     requestHeader.setMsgId(sendResult.getMsgId());\n129:     String remark = localException != null ? (\"executeLocalTransactionBranch exception: \" + localException.toString()) : null;\n130: \n131:     // 提交消息 COMMIT / ROLLBACK。！！！通信方式为：Oneway！！！\n132:     this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout());\n133: }\n```\n\n## 2.2 Broker 处理结束事务请求\n\n* 🦅 查询请求的消息，进行**提交 / 回滚**。实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【EndTransactionProcessor.java】\n  2: public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {\n  3:     final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n  4:     final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);\n  5: \n  6:     // 省略代码 =》打印日志（只处理 COMMIT / ROLLBACK）\n  7: \n  8:     // 查询提交的消息\n  9:     final MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getCommitLogOffset());\n 10:     if (msgExt != null) {\n 11:         // 省略代码 =》校验消息\n 12: \n 13:         // 生成消息\n 14:         MessageExtBrokerInner msgInner = this.endMessageTransaction(msgExt);\n 15:         msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));\n 16:         msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());\n 17:         msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());\n 18:         msgInner.setStoreTimestamp(msgExt.getStoreTimestamp());\n 19:         if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {\n 20:             msgInner.setBody(null);\n 21:         }\n 22: \n 23:         // 存储生成消息\n 24:         final MessageStore messageStore = this.brokerController.getMessageStore();\n 25:         final PutMessageResult putMessageResult = messageStore.putMessage(msgInner);\n 26: \n 27:         // 处理存储结果\n 28:         if (putMessageResult != null) {\n 29:             switch (putMessageResult.getPutMessageStatus()) {\n 30:                 // Success\n 31:                 case PUT_OK:\n 32:                 case FLUSH_DISK_TIMEOUT:\n 33:                 case FLUSH_SLAVE_TIMEOUT:\n 34:                 case SLAVE_NOT_AVAILABLE:\n 35:                     response.setCode(ResponseCode.SUCCESS);\n 36:                     response.setRemark(null);\n 37:                     break;\n 38:                 // Failed\n 39:                 case CREATE_MAPEDFILE_FAILED:\n 40:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 41:                     response.setRemark(\"create maped file failed.\");\n 42:                     break;\n 43:                 case MESSAGE_ILLEGAL:\n 44:                 case PROPERTIES_SIZE_EXCEEDED:\n 45:                     response.setCode(ResponseCode.MESSAGE_ILLEGAL);\n 46:                     response.setRemark(\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\");\n 47:                     break;\n 48:                 case SERVICE_NOT_AVAILABLE:\n 49:                     response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);\n 50:                     response.setRemark(\"service not available now.\");\n 51:                     break;\n 52:                 case OS_PAGECACHE_BUSY:\n 53:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 54:                     response.setRemark(\"OS page cache busy, please try another machine\");\n 55:                     break;\n 56:                 case UNKNOWN_ERROR:\n 57:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 58:                     response.setRemark(\"UNKNOWN_ERROR\");\n 59:                     break;\n 60:                 default:\n 61:                     response.setCode(ResponseCode.SYSTEM_ERROR);\n 62:                     response.setRemark(\"UNKNOWN_ERROR DEFAULT\");\n 63:                     break;\n 64:             }\n 65: \n 66:             return response;\n 67:         } else {\n 68:             response.setCode(ResponseCode.SYSTEM_ERROR);\n 69:             response.setRemark(\"store putMessage return null\");\n 70:         }\n 71:     } else {\n 72:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 73:         response.setRemark(\"find prepared transaction message failed\");\n 74:         return response;\n 75:     }\n 76: \n 77:     return response;\n 78: }\n```\n\n## 2.3 Broker 生成 ConsumeQueue\n\n* 🦅 事务消息，提交（`COMMIT`）后才生成 `ConsumeQueue`。\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMessageStore.java】\n  2: public void doDispatch(DispatchRequest req) {\n  3:     // 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n  4:     final int tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());\n  5:     switch (tranType) {\n  6:         case MessageSysFlag.TRANSACTION_NOT_TYPE: // 非事务消息\n  7:         case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // 事务消息COMMIT\n  8:             DefaultMessageStore.this.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),\n  9:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());\n 10:             break;\n 11:         case MessageSysFlag.TRANSACTION_PREPARED_TYPE: // 事务消息PREPARED\n 12:         case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: // 事务消息ROLLBACK\n 13:             break;\n 14:     }\n 15:     // 省略代码 =》 建立 索引信息 到 IndexFile\n 16: }\n```\n\n# 3. 事务消息回查\n\n* 【事务消息回查】功能曾经开源过，目前（V4.0.0）暂未开源。如下是该功能的开源情况：\n\n| 版本 | 【事务消息回查】 | |\n| --- | --- | --- |\n| 官方V3.0.4 ~ V3.1.4 | 基于 文件系统 实现 | 已开源 |\n| 官方V3.1.5 ~ V4.0.0 | 基于 数据库 实现 | 未完全开源 |\n\n我们来看看两种情况下是怎么实现的。\n\n## 3.1 Broker 发起【事务消息回查】\n\n### 3.1.1 官方V3.1.4：基于文件系统\n\n> 仓库地址：https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4\n\n相较于普通消息，【事务消息】多依赖如下三个组件：\n\n* **TransactionStateService** ：事务状态服务，负责对【事务消息】进行管理，包括存储与更新事务消息状态、回查事务消息状态等等。\n* **TranStateTable** ：【事务消息】状态存储。基于 `MappedFileQueue` 实现，默认存储路径为 `~/store/transaction/statetable`，每条【事务消息】状态存储结构如下：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | offset | CommitLog 物理存储位置 | Long | 8 |\n| 2 | size | 消息长度 | Int | 4 |\n| 3 | timestamp | 消息存储时间，单位：秒 | Int | 4 |\n| 4 | producerGroupHash | producerGroup 求 HashCode | Int | 4 |\n| 5 | state | 事务状态 | Int | 4 |\n\n* **TranRedoLog** ：`TranStateTable` 重放日志，每次**写操作** `TranStateTable` 记录重放日志。当 `Broker` 异常关闭时，使用 `TranRedoLog` 恢复 `TranStateTable`。基于 `ConsumeQueue` 实现，`Topic` 为 `TRANSACTION_REDOLOG_TOPIC_XXXX`，默认存储路径为 `~/store/transaction/redolog`。\n\n-------\n\n简单手绘逻辑图如下😈：\n\n![Broker_V3.1.4_基于文件系统](http://www.yunai.me/images/RocketMQ/2017_05_21/01.jpeg)\n\n#### 3.1.1.1 存储消息到 CommitLog\n\n* 🦅存储【half消息】到 `CommitLog` 时，消息队列位置（`queueOffset`）使用 `TranStateTable` 最大物理位置（可写入物理位置）。这样，消息可以索引到自己对应的 `TranStateTable` 的位置和记录。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultAppendMessageCallback.java】\n  2: class DefaultAppendMessageCallback implements AppendMessageCallback {\n  3:     public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer,  final int maxBlank, final Object msg) {\n  4:         // ...省略代码\n  5: \n  6:         // 事务消息需要特殊处理 \n  7:         final int tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());\n  8:         switch (tranType) {\n  9:         case MessageSysFlag.TransactionPreparedType: // 消息队列位置（queueOffset）使用 TranStateTable 最大物理位置（可写入物理位置） \n 10:             queueOffset = CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().get();\n 11:             break;\n 12:         case MessageSysFlag.TransactionRollbackType:\n 13:             queueOffset = msgInner.getQueueOffset();\n 14:             break;\n 15:         case MessageSysFlag.TransactionNotType:\n 16:         case MessageSysFlag.TransactionCommitType:\n 17:         default:\n 18:             break;\n 19:         }\n 20: \n 21:         // ...省略代码\n 22: \n 23:         switch (tranType) {\n 24:         case MessageSysFlag.TransactionPreparedType:\n 25:             // 更新 TranStateTable 最大物理位置（可写入物理位置） \n 26:             CommitLog.this.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().incrementAndGet();\n 27:             break;\n 28:         case MessageSysFlag.TransactionRollbackType:\n 29:             break;\n 30:         case MessageSysFlag.TransactionNotType:\n 31:         case MessageSysFlag.TransactionCommitType:\n 32:             // 更新下一次的ConsumeQueue信息\n 33:             CommitLog.this.topicQueueTable.put(key, ++queueOffset);\n 34:             break;\n 35:         default:\n 36:             break;\n 37:         }\n 38: \n 39:         // 返回结果\n 40:         return result;\n 41:     }\n 42: }\n```\n\n#### 3.1.1.2 写【事务消息】状态存储（TranStateTable）\n\n* 🦅处理【Half消息】时，新增【事务消息】状态存储（`TranStateTable`）。\n* 🦅处理【Commit / Rollback消息】时，更新 【事务消息】状态存储（`TranStateTable`） COMMIT / ROLLBACK。\n* 🦅每次**写操作【**事务消息】状态存储（`TranStateTable`），记录重放日志（`TranRedoLog`）。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DispatchMessageService.java】\n  2: private void doDispatch() {\n  3:     if (!this.requestsRead.isEmpty()) {\n  4:         for (DispatchRequest req : this.requestsRead) {\n  5: \n  6:             // ...省略代码\n  7: \n  8:             // 2、写【事务消息】状态存储（TranStateTable）\n  9:             if (req.getProducerGroup() != null) {\n 10:                 switch (tranType) {\n 11:                 case MessageSysFlag.TransactionNotType:\n 12:                     break;\n 13:                 case MessageSysFlag.TransactionPreparedType:\n 14:                     // 新增 【事务消息】状态存储（TranStateTable）\n 15:                     DefaultMessageStore.this.getTransactionStateService().appendPreparedTransaction(\n 16:                         req.getCommitLogOffset(), req.getMsgSize(), (int) (req.getStoreTimestamp() / 1000), req.getProducerGroup().hashCode());\n 17:                     break;\n 18:                 case MessageSysFlag.TransactionCommitType:\n 19:                 case MessageSysFlag.TransactionRollbackType:\n 20:                     // 更新 【事务消息】状态存储（TranStateTable） COMMIT / ROLLBACK\n 21:                     DefaultMessageStore.this.getTransactionStateService().updateTransactionState(\n 22:                         req.getTranStateTableOffset(), req.getPreparedTransactionOffset(), req.getProducerGroup().hashCode(), tranType);\n 23:                     break;\n 24:                 }\n 25:             }\n 26:             // 3、记录 TranRedoLog\n 27:             switch (tranType) {\n 28:             case MessageSysFlag.TransactionNotType:\n 29:                 break;\n 30:             case MessageSysFlag.TransactionPreparedType:\n 31:                 // 记录 TranRedoLog\n 32:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(\n 33:                         req.getCommitLogOffset(), req.getMsgSize(), TransactionStateService.PreparedMessageTagsCode,\n 34:                         req.getStoreTimestamp(), 0L);\n 35:                 break;\n 36:             case MessageSysFlag.TransactionCommitType:\n 37:             case MessageSysFlag.TransactionRollbackType:\n 38:                 // 记录 TranRedoLog\n 39:                 DefaultMessageStore.this.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(\n 40:                         req.getCommitLogOffset(), req.getMsgSize(), req.getPreparedTransactionOffset(),\n 41:                         req.getStoreTimestamp(), 0L);\n 42:                 break;\n 43:             }\n 44:         }\n 45: \n 46:         // ...省略代码\n 47:     }\n 48: }\n 49: // ⬇️⬇️⬇️【TransactionStateService.java】\n 50: /**\n 51:  * 新增事务状态\n 52:  *\n 53:  * @param clOffset commitLog 物理位置\n 54:  * @param size 消息长度\n 55:  * @param timestamp 消息存储时间\n 56:  * @param groupHashCode groupHashCode\n 57:  * @return 是否成功\n 58:  */\n 59: public boolean appendPreparedTransaction(//\n 60:         final long clOffset,//\n 61:         final int size,//\n 62:         final int timestamp,//\n 63:         final int groupHashCode//\n 64: ) {\n 65:     MapedFile mapedFile = this.tranStateTable.getLastMapedFile();\n 66:     if (null == mapedFile) {\n 67:         log.error(\"appendPreparedTransaction: create mapedfile error.\");\n 68:         return false;\n 69:     }\n 70: \n 71:     // 首次创建，加入定时任务中\n 72:     if (0 == mapedFile.getWrotePostion()) {\n 73:         this.addTimerTask(mapedFile);\n 74:     }\n 75: \n 76:     this.byteBufferAppend.position(0);\n 77:     this.byteBufferAppend.limit(TSStoreUnitSize);\n 78: \n 79:     // Commit Log Offset\n 80:     this.byteBufferAppend.putLong(clOffset);\n 81:     // Message Size\n 82:     this.byteBufferAppend.putInt(size);\n 83:     // Timestamp\n 84:     this.byteBufferAppend.putInt(timestamp);\n 85:     // Producer Group Hashcode\n 86:     this.byteBufferAppend.putInt(groupHashCode);\n 87:     // Transaction State\n 88:     this.byteBufferAppend.putInt(MessageSysFlag.TransactionPreparedType);\n 89: \n 90:     return mapedFile.appendMessage(this.byteBufferAppend.array());\n 91: }\n 92: \n 93: /**\n 94:  * 更新事务状态\n 95:  *\n 96:  * @param tsOffset tranStateTable 物理位置\n 97:  * @param clOffset commitLog 物理位置\n 98:  * @param groupHashCode groupHashCode\n 99:  * @param state 事务状态\n100:  * @return 是否成功\n101:  */\n102: public boolean updateTransactionState(\n103:         final long tsOffset,\n104:         final long clOffset,\n105:         final int groupHashCode,\n106:         final int state) {\n107:     SelectMapedBufferResult selectMapedBufferResult = this.findTransactionBuffer(tsOffset);\n108:     if (selectMapedBufferResult != null) {\n109:         try {\n110: \n111:             // ....省略代码：校验是否能够更新\n112: \n113:             // 更新事务状态\n114:             selectMapedBufferResult.getByteBuffer().putInt(TS_STATE_POS, state);\n115:         }\n116:         catch (Exception e) {\n117:             log.error(\"updateTransactionState exception\", e);\n118:         }\n119:         finally {\n120:             selectMapedBufferResult.release();\n121:         }\n122:     }\n123: \n124:     return false;\n125: }\n```\n\n#### 3.1.1.3 【事务消息】回查\n\n* 🦅`TranStateTable` 每个 `MappedFile` 都对应一个 `Timer`。`Timer` 固定周期（默认：60s）遍历 `MappedFile`，查找【half消息】，向 `Producer` 发起【事务消息】回查请求。【事务消息】回查结果的逻辑不在此处进行，在 [CommitLog dispatch](#3112-写事务消息状态存储transtatetable)时执行。\n\n实现代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【TransactionStateService.java】\n  2: /**\n  3:  * 初始化定时任务\n  4:  */\n  5: private void initTimerTask() {\n  6:     //\n  7:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();\n  8:     for (MapedFile mf : mapedFiles) {\n  9:         this.addTimerTask(mf);\n 10:     }\n 11: }\n 12: \n 13: /**\n 14:  * 每个文件初始化定时任务\n 15:  * @param mf 文件\n 16:  */\n 17: private void addTimerTask(final MapedFile mf) {\n 18:     this.timer.scheduleAtFixedRate(new TimerTask() {\n 19:         private final MapedFile mapedFile = mf;\n 20:         private final TransactionCheckExecuter transactionCheckExecuter = TransactionStateService.this.defaultMessageStore.getTransactionCheckExecuter();\n 21:         private final long checkTransactionMessageAtleastInterval = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()\n 22:                     .getCheckTransactionMessageAtleastInterval();\n 23:         private final boolean slave = TransactionStateService.this.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE;\n 24: \n 25:         @Override\n 26:         public void run() {\n 27:             // Slave不需要回查事务状态\n 28:             if (slave) {\n 29:                 return;\n 30:             }\n 31:             // Check功能是否开启\n 32:             if (!TransactionStateService.this.defaultMessageStore.getMessageStoreConfig()\n 33:                 .isCheckTransactionMessageEnable()) {\n 34:                 return;\n 35:             }\n 36: \n 37:             try {\n 38:                 SelectMapedBufferResult selectMapedBufferResult = mapedFile.selectMapedBuffer(0);\n 39:                 if (selectMapedBufferResult != null) {\n 40:                     long preparedMessageCountInThisMapedFile = 0; // 回查的【half消息】数量\n 41:                     int i = 0;\n 42:                     try {\n 43:                         // 循环每条【事务消息】状态，对【half消息】进行回查\n 44:                         for (; i < selectMapedBufferResult.getSize(); i += TSStoreUnitSize) {\n 45:                             selectMapedBufferResult.getByteBuffer().position(i);\n 46: \n 47:                             // Commit Log Offset\n 48:                             long clOffset = selectMapedBufferResult.getByteBuffer().getLong();\n 49:                             // Message Size\n 50:                             int msgSize = selectMapedBufferResult.getByteBuffer().getInt();\n 51:                             // Timestamp\n 52:                             int timestamp = selectMapedBufferResult.getByteBuffer().getInt();\n 53:                             // Producer Group Hashcode\n 54:                             int groupHashCode = selectMapedBufferResult.getByteBuffer().getInt();\n 55:                             // Transaction State\n 56:                             int tranType = selectMapedBufferResult.getByteBuffer().getInt();\n 57: \n 58:                             // 已经提交或者回滚的消息跳过\n 59:                             if (tranType != MessageSysFlag.TransactionPreparedType) {\n 60:                                 continue;\n 61:                             }\n 62: \n 63:                             // 遇到时间不符合最小轮询间隔，终止\n 64:                             long timestampLong = timestamp * 1000;\n 65:                             long diff = System.currentTimeMillis() - timestampLong;\n 66:                             if (diff < checkTransactionMessageAtleastInterval) {\n 67:                                 break;\n 68:                             }\n 69: \n 70:                             preparedMessageCountInThisMapedFile++;\n 71: \n 72:                             // 回查Producer\n 73:                             try {\n 74:                                 this.transactionCheckExecuter.gotoCheck(groupHashCode, getTranStateOffset(i), clOffset, msgSize);\n 75:                             } catch (Exception e) {\n 76:                                 tranlog.warn(\"gotoCheck Exception\", e);\n 77:                             }\n 78:                         }\n 79: \n 80:                         // 无回查的【half消息】数量，且遍历完，则终止定时任务\n 81:                         if (0 == preparedMessageCountInThisMapedFile //\n 82:                                 && i == mapedFile.getFileSize()) {\n 83:                             tranlog.info(\"remove the transaction timer task, because no prepared message in this mapedfile[{}]\", mapedFile.getFileName());\n 84:                             this.cancel();\n 85:                         }\n 86:                     } finally {\n 87:                         selectMapedBufferResult.release();\n 88:                     }\n 89: \n 90:                     tranlog.info(\"the transaction timer task execute over in this period, {} Prepared Message: {} Check Progress: {}/{}\", mapedFile.getFileName(),//\n 91:                             preparedMessageCountInThisMapedFile, i / TSStoreUnitSize, mapedFile.getFileSize() / TSStoreUnitSize);\n 92:                 } else if (mapedFile.isFull()) {\n 93:                     tranlog.info(\"the mapedfile[{}] maybe deleted, cancel check transaction timer task\", mapedFile.getFileName());\n 94:                     this.cancel();\n 95:                     return;\n 96:                 }\n 97:             } catch (Exception e) {\n 98:                 log.error(\"check transaction timer task Exception\", e);\n 99:             }\n100:         }\n101: \n102: \n103:         private long getTranStateOffset(final long currentIndex) {\n104:             long offset = (this.mapedFile.getFileFromOffset() + currentIndex) / TransactionStateService.TSStoreUnitSize;\n105:             return offset;\n106:         }\n107:     }, 1000 * 60, this.defaultMessageStore.getMessageStoreConfig().getCheckTransactionMessageTimerInterval());\n108: }\n109: \n110: // 【DefaultTransactionCheckExecuter.java】\n111: @Override\n112: public void gotoCheck(int producerGroupHashCode, long tranStateTableOffset, long commitLogOffset,\n113:         int msgSize) {\n114:     // 第一步、查询Producer\n115:     final ClientChannelInfo clientChannelInfo = this.brokerController.getProducerManager().pickProducerChannelRandomly(producerGroupHashCode);\n116:     if (null == clientChannelInfo) {\n117:         log.warn(\"check a producer transaction state, but not find any channel of this group[{}]\", producerGroupHashCode);\n118:         return;\n119:     }\n120: \n121:     // 第二步、查询消息\n122:     SelectMapedBufferResult selectMapedBufferResult = this.brokerController.getMessageStore().selectOneMessageByOffset(commitLogOffset, msgSize);\n123:     if (null == selectMapedBufferResult) {\n124:         log.warn(\"check a producer transaction state, but not find message by commitLogOffset: {}, msgSize: \", commitLogOffset, msgSize);\n125:         return;\n126:     }\n127: \n128:     // 第三步、向Producer发起请求\n129:     final CheckTransactionStateRequestHeader requestHeader = new CheckTransactionStateRequestHeader();\n130:     requestHeader.setCommitLogOffset(commitLogOffset);\n131:     requestHeader.setTranStateTableOffset(tranStateTableOffset);\n132:     this.brokerController.getBroker2Client().checkProducerTransactionState(clientChannelInfo.getChannel(), requestHeader, selectMapedBufferResult);\n133: }\n```\n\n#### 3.1.1.4 初始化【事务消息】状态存储（TranStateTable）\n\n* 🦅根据最后 Broker 关闭是否正常，会有不同的初始化方式。\n\n核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【TransactionStateService.java】\n  2: /**\n  3:  * 初始化 TranRedoLog\n  4:  * @param lastExitOK 是否正常退出\n  5:  */\n  6: public void recoverStateTable(final boolean lastExitOK) {\n  7:     if (lastExitOK) {\n  8:         this.recoverStateTableNormal();\n  9:     } else {\n 10:         // 第一步，删除State Table\n 11:         this.tranStateTable.destroy();\n 12:         // 第二步，通过RedoLog全量恢复StateTable\n 13:         this.recreateStateTable();\n 14:     }\n 15: }\n 16: \n 17: /**\n 18:  * 扫描 TranRedoLog 重建 StateTable\n 19:  */\n 20: private void recreateStateTable() {\n 21:     this.tranStateTable = new MapedFileQueue(StorePathConfigHelper.getTranStateTableStorePath(defaultMessageStore\n 22:                 .getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore\n 23:                 .getMessageStoreConfig().getTranStateTableMapedFileSize(), null);\n 24: \n 25:     final TreeSet<Long> preparedItemSet = new TreeSet<Long>();\n 26: \n 27:     // 第一步，从头扫描RedoLog\n 28:     final long minOffset = this.tranRedoLog.getMinOffsetInQuque();\n 29:     long processOffset = minOffset;\n 30:     while (true) {\n 31:         SelectMapedBufferResult bufferConsumeQueue = this.tranRedoLog.getIndexBuffer(processOffset);\n 32:         if (bufferConsumeQueue != null) {\n 33:             try {\n 34:                 long i = 0;\n 35:                 for (; i < bufferConsumeQueue.getSize(); i += ConsumeQueue.CQStoreUnitSize) {\n 36:                     long offsetMsg = bufferConsumeQueue.getByteBuffer().getLong();\n 37:                     int sizeMsg = bufferConsumeQueue.getByteBuffer().getInt();\n 38:                     long tagsCode = bufferConsumeQueue.getByteBuffer().getLong();\n 39: \n 40:                     if (TransactionStateService.PreparedMessageTagsCode == tagsCode) { // Prepared\n 41:                         preparedItemSet.add(offsetMsg);\n 42:                     } else { // Commit/Rollback\n 43:                         preparedItemSet.remove(tagsCode);\n 44:                     }\n 45:                 }\n 46: \n 47:                 processOffset += i;\n 48:             } finally { // 必须释放资源\n 49:                 bufferConsumeQueue.release();\n 50:             }\n 51:         } else {\n 52:             break;\n 53:         }\n 54:     }\n 55:     log.info(\"scan transaction redolog over, End offset: {},  Prepared Transaction Count: {}\", processOffset, preparedItemSet.size());\n 56: \n 57:     // 第二步，重建StateTable\n 58:     Iterator<Long> it = preparedItemSet.iterator();\n 59:     while (it.hasNext()) {\n 60:         Long offset = it.next();\n 61:         MessageExt msgExt = this.defaultMessageStore.lookMessageByOffset(offset);\n 62:         if (msgExt != null) {\n 63:             this.appendPreparedTransaction(msgExt.getCommitLogOffset(), msgExt.getStoreSize(),\n 64:                 (int) (msgExt.getStoreTimestamp() / 1000),\n 65:                 msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP).hashCode());\n 66:             this.tranStateTableOffset.incrementAndGet();\n 67:         }\n 68:     }\n 69: }\n 70: \n 71: /**\n 72:  * 加载（解析）TranStateTable 的 MappedFile\n 73:  * 1. 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position\n 74:  * 2. 设置 TanStateTable 最大物理位置（可写入位置）\n 75:  */\n 76: private void recoverStateTableNormal() {\n 77:     final List<MapedFile> mapedFiles = this.tranStateTable.getMapedFiles();\n 78:     if (!mapedFiles.isEmpty()) {\n 79:         // 从倒数第三个文件开始恢复\n 80:         int index = mapedFiles.size() - 3;\n 81:         if (index < 0) {\n 82:             index = 0;\n 83:         }\n 84: \n 85:         int mapedFileSizeLogics = this.tranStateTable.getMapedFileSize();\n 86:         MapedFile mapedFile = mapedFiles.get(index);\n 87:         ByteBuffer byteBuffer = mapedFile.sliceByteBuffer();\n 88:         long processOffset = mapedFile.getFileFromOffset();\n 89:         long mapedFileOffset = 0;\n 90:         while (true) {\n 91:             for (int i = 0; i < mapedFileSizeLogics; i += TSStoreUnitSize) {\n 92: \n 93:                 final long clOffset_read = byteBuffer.getLong();\n 94:                 final int size_read = byteBuffer.getInt();\n 95:                 final int timestamp_read = byteBuffer.getInt();\n 96:                 final int groupHashCode_read = byteBuffer.getInt();\n 97:                 final int state_read = byteBuffer.getInt();\n 98: \n 99:                 boolean stateOK = false;\n100:                 switch (state_read) {\n101:                 case MessageSysFlag.TransactionPreparedType:\n102:                 case MessageSysFlag.TransactionCommitType:\n103:                 case MessageSysFlag.TransactionRollbackType:\n104:                     stateOK = true;\n105:                     break;\n106:                 default:\n107:                     break;\n108:                 }\n109: \n110:                 // 说明当前存储单元有效\n111:                 if (clOffset_read >= 0 && size_read > 0 && stateOK) {\n112:                     mapedFileOffset = i + TSStoreUnitSize;\n113:                 } else {\n114:                     log.info(\"recover current transaction state table file over,  \" + mapedFile.getFileName() + \" \"\n115:                             + clOffset_read + \" \" + size_read + \" \" + timestamp_read);\n116:                     break;\n117:                 }\n118:             }\n119: \n120:             // 走到文件末尾，切换至下一个文件\n121:             if (mapedFileOffset == mapedFileSizeLogics) {\n122:                 index++;\n123:                 if (index >= mapedFiles.size()) { // 循环while结束\n124:                     log.info(\"recover last transaction state table file over, last maped file \" + mapedFile.getFileName());\n125:                     break;\n126:                 } else { // 切换下一个文件\n127:                     mapedFile = mapedFiles.get(index);\n128:                     byteBuffer = mapedFile.sliceByteBuffer();\n129:                     processOffset = mapedFile.getFileFromOffset();\n130:                     mapedFileOffset = 0;\n131:                     log.info(\"recover next transaction state table file, \" + mapedFile.getFileName());\n132:                 }\n133:             } else {\n134:                 log.info(\"recover current transaction state table queue over \" + mapedFile.getFileName() + \" \" + (processOffset + mapedFileOffset));\n135:                 break;\n136:             }\n137:         }\n138: \n139:         // 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position\n140:         processOffset += mapedFileOffset;\n141:         this.tranStateTable.truncateDirtyFiles(processOffset);\n142: \n143:         // 设置 TanStateTable 最大物理位置（可写入位置）\n144:         this.tranStateTableOffset.set(this.tranStateTable.getMaxOffset() / TSStoreUnitSize);\n145:         log.info(\"recover normal over, transaction state table max offset: {}\", this.tranStateTableOffset.get());\n146:     }\n147: }\n```\n\n#### 3.1.1.5 补充\n\n* 为什么 V3.1.5 开始，使用 数据库 实现【事务状态】的存储？如下是来自官方文档的说明，可能是一部分原因：\n\n> RocketMQ 这种实现事务方式，没有通过 KV 存储做，而是通过 Offset 方式，存在一个显著缺陷，即通过 Offset 更改数据，会令系统的脏页过多，需要特别关注。\n\n### 3.1.2 官方V4.0.0：基于数据库\n\n> 仓库地址：https://github.com/apache/incubator-rocketmq\n\n官方V4.0.0 暂时未**完全**开源【事务消息回查】功能，**So 我们需要进行一些猜想，可能不一定正确😈**。\n\n😆我们来对比【官方V3.1.4：基于文件】的实现。\n\n* TransactionRecord ：记录每条【事务消息】。类似 `TranStateTable`。\n\n| TranStateTable | TransactionRecord |  |\n| --- | --- | --- |\n| offset | offset |  |\n| producerGroupHash | producerGroup |  |\n| size | 无 | 非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。 |\n| timestamp | 无 | 非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。 |\n| state | 无 | 非必须字段： 事务开始，增加记录；事务结束，删除记录。|\n\n另外，数据库本身保证了数据存储的可靠性，无需 `TranRedoLog`。\n\n-------\n\n简单手绘逻辑图如下😈：\n\n![Broker_V4.0.0_基于数据库](http://www.yunai.me/images/RocketMQ/2017_05_21/02.jpeg)\n\n## 3.2 Producer 接收【事务消息回查】\n\n* 顺序图如下：\n\n![Producer接收【事务消息回查】](http://www.yunai.me/images/RocketMQ/2017_05_21/04.png)\n\n* 核心代码如下：\n\n```Java\n  1: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n  2: /**\n  3:  * 检查【事务状态】状态\n  4:  *\n  5:  * @param addr broker地址\n  6:  * @param msg 消息\n  7:  * @param header 请求\n  8:  */\n  9: @Override\n 10: public void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) {\n 11:     Runnable request = new Runnable() {\n 12:         private final String brokerAddr = addr;\n 13:         private final MessageExt message = msg;\n 14:         private final CheckTransactionStateRequestHeader checkRequestHeader = header;\n 15:         private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup();\n 16: \n 17:         @Override\n 18:         public void run() {\n 19:             TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener();\n 20:             if (transactionCheckListener != null) {\n 21:                 // 获取事务执行状态\n 22:                 LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;\n 23:                 Throwable exception = null;\n 24:                 try {\n 25:                     localTransactionState = transactionCheckListener.checkLocalTransactionState(message);\n 26:                 } catch (Throwable e) {\n 27:                     log.error(\"Broker call checkTransactionState, but checkLocalTransactionState exception\", e);\n 28:                     exception = e;\n 29:                 }\n 30: \n 31:                 // 处理事务结果，提交消息 COMMIT / ROLLBACK\n 32:                 this.processTransactionState(//\n 33:                     localTransactionState, //\n 34:                     group, //\n 35:                     exception);\n 36:             } else {\n 37:                 log.warn(\"checkTransactionState, pick transactionCheckListener by group[{}] failed\", group);\n 38:             }\n 39:         }\n 40: \n 41:         /**\n 42:          * 处理事务结果，提交消息 COMMIT / ROLLBACK\n 43:          *\n 44:          * @param localTransactionState 【本地事务】状态\n 45:          * @param producerGroup producerGroup\n 46:          * @param exception 检查【本地事务】状态发生的异常\n 47:          */\n 48:         private void processTransactionState(//\n 49:             final LocalTransactionState localTransactionState, //\n 50:             final String producerGroup, //\n 51:             final Throwable exception) {\n 52:             final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader();\n 53:             thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());\n 54:             thisHeader.setProducerGroup(producerGroup);\n 55:             thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());\n 56:             thisHeader.setFromTransactionCheck(true);\n 57: \n 58:             // 设置消息编号\n 59:             String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);\n 60:             if (uniqueKey == null) {\n 61:                 uniqueKey = message.getMsgId();\n 62:             }\n 63:             thisHeader.setMsgId(uniqueKey);\n 64: \n 65:             thisHeader.setTransactionId(checkRequestHeader.getTransactionId());\n 66:             switch (localTransactionState) {\n 67:                 case COMMIT_MESSAGE:\n 68:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);\n 69:                     break;\n 70:                 case ROLLBACK_MESSAGE:\n 71:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);\n 72:                     log.warn(\"when broker check, client rollback this transaction, {}\", thisHeader);\n 73:                     break;\n 74:                 case UNKNOW:\n 75:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);\n 76:                     log.warn(\"when broker check, client does not know this transaction state, {}\", thisHeader);\n 77:                     break;\n 78:                 default:\n 79:                     break;\n 80:             }\n 81: \n 82:             String remark = null;\n 83:             if (exception != null) {\n 84:                 remark = \"checkLocalTransactionState Exception: \" + RemotingHelper.exceptionSimpleDesc(exception);\n 85:             }\n 86: \n 87:             try {\n 88:                 // 提交消息 COMMIT / ROLLBACK\n 89:                 DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,\n 90:                     3000);\n 91:             } catch (Exception e) {\n 92:                 log.error(\"endTransactionOneway exception\", e);\n 93:             }\n 94:         }\n 95:     };\n 96: \n 97:     // 提交执行\n 98:     this.checkExecutor.submit(request);\n 99: }\n100: \n101: // ⬇️⬇️⬇️【DefaultMQProducerImpl.java】\n102: /**\n103:  * 【事务消息回查】检查监听器\n104:  */\n105: public interface TransactionCheckListener {\n106: \n107:     /**\n108:      * 获取（检查）【本地事务】状态\n109:      *\n110:      * @param msg 消息\n111:      * @return 事务状态\n112:      */\n113:     LocalTransactionState checkLocalTransactionState(final MessageExt msg);\n114: \n115: }\n```\n\n","slug":"RocketMQ/message-transaction","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzak0013ag5d98qf1fmo","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-transaction\">http://www.yunai.me/RocketMQ/message-transaction</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 事务消息发送</a><ul>\n<li><a href=\"#\">2.1 Producer 发送事务消息</a></li>\n<li><a href=\"#\">2.2 Broker 处理结束事务请求</a></li>\n<li><a href=\"#\">2.3 Broker 生成 ConsumeQueue</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 事务消息回查</a><ul>\n<li><a href=\"#\">3.1 Broker 发起【事务消息回查】</a><ul>\n<li><a href=\"#\">3.1.1 官方V3.1.4：基于文件系统</a><ul>\n<li><a href=\"#\">3.1.1.1 存储消息到 CommitLog</a></li>\n<li><a href=\"#\">3.1.1.2 写【事务消息】状态存储（TranStateTable）</a></li>\n<li><a href=\"#\">3.1.1.3 【事务消息】回查</a></li>\n<li><a href=\"#\">3.1.1.4 初始化【事务消息】状态存储（TranStateTable）</a></li>\n<li><a href=\"#\">3.1.1.5 补充</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.1.2 官方V4.0.0：基于数据库</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.2 Producer 接收【事务消息回查】</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>必须必须必须</strong> 前置阅读内容：</p>\n<ul>\n<li><a href=\"https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《事务消息（阿里云）》</a></li>\n</ul>\n<h1 id=\"2-事务消息发送\"><a href=\"#2-事务消息发送\" class=\"headerlink\" title=\"2. 事务消息发送\"></a>2. 事务消息发送</h1><h2 id=\"2-1-Producer-发送事务消息\"><a href=\"#2-1-Producer-发送事务消息\" class=\"headerlink\" title=\"2.1 Producer 发送事务消息\"></a>2.1 Producer 发送事务消息</h2><ul>\n<li>活动图如下（结合 <code>核心代码</code> 理解）：</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/03.png\" alt=\"Producer发送事务消息\"></p>\n<ul>\n<li>实现代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 发送事务消息</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> tranExecuter 【本地事务】执行器</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> arg 【本地事务】执行器参数</div><div class=\"line\">  8:  * <span class=\"doctag\">@return</span> 事务发送结果</div><div class=\"line\">  9:  * <span class=\"doctag\">@throws</span> MQClientException 当 Client 发生异常时</div><div class=\"line\"> 10:  */</div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> TransactionSendResult <span class=\"title\">sendMessageInTransaction</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg, <span class=\"keyword\">final</span> LocalTransactionExecuter tranExecuter, <span class=\"keyword\">final</span> Object arg)</span></span></div><div class=\"line\"> 12:     <span class=\"keyword\">throws</span> MQClientException &#123;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == tranExecuter) &#123;</div><div class=\"line\"> <span class=\"number\">14</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"tranExecutor is null\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">15</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">16</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"> <span class=\"number\">17</span>: </div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"comment\">// 发送【Half消息】</span></div><div class=\"line\"> <span class=\"number\">19</span>:     SendResult sendResult;</div><div class=\"line\"> <span class=\"number\">20</span>:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class=\"string\">\"true\"</span>);</div><div class=\"line\"> <span class=\"number\">21</span>:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:         sendResult = <span class=\"keyword\">this</span>.send(msg);</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"send message Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">27</span>: </div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"comment\">// 处理发送【Half消息】结果</span></div><div class=\"line\"> <span class=\"number\">29</span>:     LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">30</span>:     Throwable localException = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"keyword\">switch</span> (sendResult.getSendStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"comment\">// 发送【Half消息】成功，执行【本地事务】逻辑</span></div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">case</span> SEND_OK: &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">if</span> (sendResult.getTransactionId() != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 事务编号。目前开源版本暂时没用到，猜想ONS在使用。</span></div><div class=\"line\"> <span class=\"number\">36</span>:                     msg.putUserProperty(<span class=\"string\">\"__transactionId__\"</span>, sendResult.getTransactionId());</div><div class=\"line\"> <span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"comment\">// 执行【本地事务】逻辑</span></div><div class=\"line\"> <span class=\"number\">40</span>:                 localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);</div><div class=\"line\"> <span class=\"number\">41</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == localTransactionState) &#123;</div><div class=\"line\"> <span class=\"number\">42</span>:                     localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:                 <span class=\"keyword\">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</div><div class=\"line\"> <span class=\"number\">46</span>:                     log.info(<span class=\"string\">\"executeLocalTransactionBranch return &#123;&#125;\"</span>, localTransactionState);</div><div class=\"line\"> <span class=\"number\">47</span>:                     log.info(msg.toString());</div><div class=\"line\"> <span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:                 log.info(<span class=\"string\">\"executeLocalTransactionBranch exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">51</span>:                 log.info(msg.toString());</div><div class=\"line\"> <span class=\"number\">52</span>:                 localException = e;</div><div class=\"line\"> <span class=\"number\">53</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:         <span class=\"comment\">// 发送【Half消息】失败，标记【本地事务】状态为回滚</span></div><div class=\"line\"> <span class=\"number\">57</span>:         <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"> <span class=\"number\">59</span>:         <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"> <span class=\"number\">60</span>:             localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</div><div class=\"line\"> <span class=\"number\">61</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">64</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"comment\">// 结束事务：提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">67</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:         <span class=\"keyword\">this</span>.endTransaction(sendResult, localTransactionState, localException);</div><div class=\"line\"> <span class=\"number\">69</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">70</span>:         log.warn(<span class=\"string\">\"local transaction execute \"</span> + localTransactionState + <span class=\"string\">\", but end broker transaction failed\"</span>, e);</div><div class=\"line\"> <span class=\"number\">71</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:     <span class=\"comment\">// 返回【事务发送结果】</span></div><div class=\"line\"> <span class=\"number\">74</span>:     TransactionSendResult transactionSendResult = <span class=\"keyword\">new</span> TransactionSendResult();</div><div class=\"line\"> <span class=\"number\">75</span>:     transactionSendResult.setSendStatus(sendResult.getSendStatus());</div><div class=\"line\"> <span class=\"number\">76</span>:     transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">77</span>:     transactionSendResult.setMsgId(sendResult.getMsgId());</div><div class=\"line\"> <span class=\"number\">78</span>:     transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</div><div class=\"line\"> <span class=\"number\">79</span>:     transactionSendResult.setTransactionId(sendResult.getTransactionId());</div><div class=\"line\"> <span class=\"number\">80</span>:     transactionSendResult.setLocalTransactionState(localTransactionState);</div><div class=\"line\"> <span class=\"number\">81</span>:     <span class=\"keyword\">return</span> transactionSendResult;</div><div class=\"line\"> <span class=\"number\">82</span>: &#125;</div><div class=\"line\"> <span class=\"number\">83</span>: </div><div class=\"line\"> <span class=\"number\">84</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 85:  * 结束事务：提交消息 COMMIT / ROLLBACK</div><div class=\"line\"> 86:  *</div><div class=\"line\"> 87:  * <span class=\"doctag\">@param</span> sendResult 发送【Half消息】结果</div><div class=\"line\"> 88:  * <span class=\"doctag\">@param</span> localTransactionState 【本地事务】状态</div><div class=\"line\"> 89:  * <span class=\"doctag\">@param</span> localException 执行【本地事务】逻辑产生的异常</div><div class=\"line\"> 90:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\"> 91:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 Broker 发生异常时</div><div class=\"line\"> 92:  * <span class=\"doctag\">@throws</span> InterruptedException 当线程中断时</div><div class=\"line\"> 93:  * <span class=\"doctag\">@throws</span> UnknownHostException 当解码消息编号失败是</div><div class=\"line\"> 94:  */</div><div class=\"line\"> <span class=\"number\">95</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endTransaction</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">96</span>:     <span class=\"keyword\">final</span> SendResult sendResult, //</div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"keyword\">final</span> LocalTransactionState localTransactionState, //</div><div class=\"line\"> <span class=\"number\">98</span>:     <span class=\"keyword\">final</span> Throwable localException) <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:     <span class=\"comment\">// 解码消息编号</span></div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">final</span> MessageId id;</div><div class=\"line\"><span class=\"number\">101</span>:     <span class=\"keyword\">if</span> (sendResult.getOffsetMsgId() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">102</span>:         id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</div><div class=\"line\"><span class=\"number\">103</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">104</span>:         id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</div><div class=\"line\"><span class=\"number\">105</span>:     &#125;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"comment\">// 创建请求</span></div><div class=\"line\"><span class=\"number\">108</span>:     String transactionId = sendResult.getTransactionId();</div><div class=\"line\"><span class=\"number\">109</span>:     <span class=\"keyword\">final</span> String brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</div><div class=\"line\"><span class=\"number\">110</span>:     EndTransactionRequestHeader requestHeader = <span class=\"keyword\">new</span> EndTransactionRequestHeader();</div><div class=\"line\"><span class=\"number\">111</span>:     requestHeader.setTransactionId(transactionId);</div><div class=\"line\"><span class=\"number\">112</span>:     requestHeader.setCommitLogOffset(id.getOffset());</div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"keyword\">switch</span> (localTransactionState) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"keyword\">case</span> COMMIT_MESSAGE:</div><div class=\"line\"><span class=\"number\">115</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</div><div class=\"line\"><span class=\"number\">116</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">case</span> ROLLBACK_MESSAGE:</div><div class=\"line\"><span class=\"number\">118</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</div><div class=\"line\"><span class=\"number\">119</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"keyword\">case</span> UNKNOW:</div><div class=\"line\"><span class=\"number\">121</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</div><div class=\"line\"><span class=\"number\">122</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">125</span>:     &#125;</div><div class=\"line\"><span class=\"number\">126</span>:     requestHeader.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"><span class=\"number\">127</span>:     requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</div><div class=\"line\"><span class=\"number\">128</span>:     requestHeader.setMsgId(sendResult.getMsgId());</div><div class=\"line\"><span class=\"number\">129</span>:     String remark = localException != <span class=\"keyword\">null</span> ? (<span class=\"string\">\"executeLocalTransactionBranch exception: \"</span> + localException.toString()) : <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:     <span class=\"comment\">// 提交消息 COMMIT / ROLLBACK。！！！通信方式为：Oneway！！！</span></div><div class=\"line\"><span class=\"number\">132</span>:     <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, <span class=\"keyword\">this</span>.defaultMQProducer.getSendMsgTimeout());</div><div class=\"line\"><span class=\"number\">133</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-Broker-处理结束事务请求\"><a href=\"#2-2-Broker-处理结束事务请求\" class=\"headerlink\" title=\"2.2 Broker 处理结束事务请求\"></a>2.2 Broker 处理结束事务请求</h2><ul>\n<li>🦅 查询请求的消息，进行<strong>提交 / 回滚</strong>。实现代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【EndTransactionProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 省略代码 =》打印日志（只处理 COMMIT / ROLLBACK）</span></div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// 查询提交的消息</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> MessageExt msgExt = <span class=\"keyword\">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// 省略代码 =》校验消息</span></div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"comment\">// 生成消息</span></div><div class=\"line\"><span class=\"number\">14</span>:         MessageExtBrokerInner msgInner = <span class=\"keyword\">this</span>.endMessageTransaction(msgExt);</div><div class=\"line\"><span class=\"number\">15</span>:         msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</div><div class=\"line\"><span class=\"number\">16</span>:         msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</div><div class=\"line\"><span class=\"number\">17</span>:         msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">18</span>:         msgInner.setStoreTimestamp(msgExt.getStoreTimestamp());</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             msgInner.setBody(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">21</span>:         &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"comment\">// 存储生成消息</span></div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">final</span> MessageStore messageStore = <span class=\"keyword\">this</span>.brokerController.getMessageStore();</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">final</span> PutMessageResult putMessageResult = messageStore.putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"comment\">// 处理存储结果</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"comment\">// Success</span></div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">35</span>:                     response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">36</span>:                     response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">37</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"comment\">// Failed</span></div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">case</span> CREATE_MAPEDFILE_FAILED:</div><div class=\"line\"><span class=\"number\">40</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">41</span>:                     response.setRemark(<span class=\"string\">\"create maped file failed.\"</span>);</div><div class=\"line\"><span class=\"number\">42</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"keyword\">case</span> MESSAGE_ILLEGAL:</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"><span class=\"number\">45</span>:                     response.setCode(ResponseCode.MESSAGE_ILLEGAL);</div><div class=\"line\"><span class=\"number\">46</span>:                     response.setRemark(<span class=\"string\">\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\"</span>);</div><div class=\"line\"><span class=\"number\">47</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">case</span> SERVICE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">49</span>:                     response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">50</span>:                     response.setRemark(<span class=\"string\">\"service not available now.\"</span>);</div><div class=\"line\"><span class=\"number\">51</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">52</span>:                 <span class=\"keyword\">case</span> OS_PAGECACHE_BUSY:</div><div class=\"line\"><span class=\"number\">53</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">54</span>:                     response.setRemark(<span class=\"string\">\"OS page cache busy, please try another machine\"</span>);</div><div class=\"line\"><span class=\"number\">55</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"><span class=\"number\">57</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">58</span>:                     response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR\"</span>);</div><div class=\"line\"><span class=\"number\">59</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">60</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">61</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">62</span>:                     response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR DEFAULT\"</span>);</div><div class=\"line\"><span class=\"number\">63</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">64</span>:             &#125;</div><div class=\"line\"><span class=\"number\">65</span>: </div><div class=\"line\"><span class=\"number\">66</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">67</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">68</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">69</span>:             response.setRemark(<span class=\"string\">\"store putMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">70</span>:         &#125;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">72</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">73</span>:         response.setRemark(<span class=\"string\">\"find prepared transaction message failed\"</span>);</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Broker-生成-ConsumeQueue\"><a href=\"#2-3-Broker-生成-ConsumeQueue\" class=\"headerlink\" title=\"2.3 Broker 生成 ConsumeQueue\"></a>2.3 Broker 生成 ConsumeQueue</h2><ul>\n<li>🦅 事务消息，提交（<code>COMMIT</code>）后才生成 <code>ConsumeQueue</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMessageStore.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: <span class=\"comment\">// 非事务消息</span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: <span class=\"comment\">// 事务消息COMMIT</span></div><div class=\"line\"> <span class=\"number\">8</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),</div><div class=\"line\"> <span class=\"number\">9</span>:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE: <span class=\"comment\">// 事务消息PREPARED</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: <span class=\"comment\">// 事务消息ROLLBACK</span></div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:     &#125;</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 省略代码 =》 建立 索引信息 到 IndexFile</span></div><div class=\"line\"><span class=\"number\">16</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-事务消息回查\"><a href=\"#3-事务消息回查\" class=\"headerlink\" title=\"3. 事务消息回查\"></a>3. 事务消息回查</h1><ul>\n<li>【事务消息回查】功能曾经开源过，目前（V4.0.0）暂未开源。如下是该功能的开源情况：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>【事务消息回查】</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>官方V3.0.4 ~ V3.1.4</td>\n<td>基于 文件系统 实现</td>\n<td>已开源</td>\n</tr>\n<tr>\n<td>官方V3.1.5 ~ V4.0.0</td>\n<td>基于 数据库 实现</td>\n<td>未完全开源</td>\n</tr>\n</tbody>\n</table>\n<p>我们来看看两种情况下是怎么实现的。</p>\n<h2 id=\"3-1-Broker-发起【事务消息回查】\"><a href=\"#3-1-Broker-发起【事务消息回查】\" class=\"headerlink\" title=\"3.1 Broker 发起【事务消息回查】\"></a>3.1 Broker 发起【事务消息回查】</h2><h3 id=\"3-1-1-官方V3-1-4：基于文件系统\"><a href=\"#3-1-1-官方V3-1-4：基于文件系统\" class=\"headerlink\" title=\"3.1.1 官方V3.1.4：基于文件系统\"></a>3.1.1 官方V3.1.4：基于文件系统</h3><blockquote>\n<p>仓库地址：<a href=\"https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4</a></p>\n</blockquote>\n<p>相较于普通消息，【事务消息】多依赖如下三个组件：</p>\n<ul>\n<li><strong>TransactionStateService</strong> ：事务状态服务，负责对【事务消息】进行管理，包括存储与更新事务消息状态、回查事务消息状态等等。</li>\n<li><strong>TranStateTable</strong> ：【事务消息】状态存储。基于 <code>MappedFileQueue</code> 实现，默认存储路径为 <code>~/store/transaction/statetable</code>，每条【事务消息】状态存储结构如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">offset</td>\n<td style=\"text-align:left\">CommitLog 物理存储位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">消息长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">timestamp</td>\n<td style=\"text-align:left\">消息存储时间，单位：秒</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">producerGroupHash</td>\n<td style=\"text-align:left\">producerGroup 求 HashCode</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">state</td>\n<td style=\"text-align:left\">事务状态</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>TranRedoLog</strong> ：<code>TranStateTable</code> 重放日志，每次<strong>写操作</strong> <code>TranStateTable</code> 记录重放日志。当 <code>Broker</code> 异常关闭时，使用 <code>TranRedoLog</code> 恢复 <code>TranStateTable</code>。基于 <code>ConsumeQueue</code> 实现，<code>Topic</code> 为 <code>TRANSACTION_REDOLOG_TOPIC_XXXX</code>，默认存储路径为 <code>~/store/transaction/redolog</code>。</li>\n</ul>\n<hr>\n<p>简单手绘逻辑图如下😈：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/01.jpeg\" alt=\"Broker_V3.1.4_基于文件系统\"></p>\n<h4 id=\"3-1-1-1-存储消息到-CommitLog\"><a href=\"#3-1-1-1-存储消息到-CommitLog\" class=\"headerlink\" title=\"3.1.1.1 存储消息到 CommitLog\"></a>3.1.1.1 存储消息到 CommitLog</h4><ul>\n<li>🦅存储【half消息】到 <code>CommitLog</code> 时，消息队列位置（<code>queueOffset</code>）使用 <code>TranStateTable</code> 最大物理位置（可写入物理位置）。这样，消息可以索引到自己对应的 <code>TranStateTable</code> 的位置和记录。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultAppendMessageCallback.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAppendMessageCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AppendMessageCallback</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">doAppend</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> fileFromOffset, <span class=\"keyword\">final</span> ByteBuffer byteBuffer,  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxBlank, <span class=\"keyword\">final</span> Object msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"comment\">// 事务消息需要特殊处理 </span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType: <span class=\"comment\">// 消息队列位置（queueOffset）使用 TranStateTable 最大物理位置（可写入物理位置） </span></div><div class=\"line\"><span class=\"number\">10</span>:             queueOffset = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().get();</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">13</span>:             queueOffset = msgInner.getQueueOffset();</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// 更新 TranStateTable 最大物理位置（可写入物理位置） </span></div><div class=\"line\"><span class=\"number\">26</span>:             CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().incrementAndGet();</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"comment\">// 更新下一次的ConsumeQueue信息</span></div><div class=\"line\"><span class=\"number\">33</span>:             CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, ++queueOffset);</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"comment\">// 返回结果</span></div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-2-写【事务消息】状态存储（TranStateTable）\"><a href=\"#3-1-1-2-写【事务消息】状态存储（TranStateTable）\" class=\"headerlink\" title=\"3.1.1.2 写【事务消息】状态存储（TranStateTable）\"></a>3.1.1.2 写【事务消息】状态存储（TranStateTable）</h4><ul>\n<li>🦅处理【Half消息】时，新增【事务消息】状态存储（<code>TranStateTable</code>）。</li>\n<li>🦅处理【Commit / Rollback消息】时，更新 【事务消息】状态存储（<code>TranStateTable</code>） COMMIT / ROLLBACK。</li>\n<li>🦅每次<strong>写操作【</strong>事务消息】状态存储（<code>TranStateTable</code>），记录重放日志（<code>TranRedoLog</code>）。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DispatchMessageService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:         <span class=\"keyword\">for</span> (DispatchRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\">  <span class=\"number\">5</span>: </div><div class=\"line\">  <span class=\"number\">6</span>:             <span class=\"comment\">// ...省略代码</span></div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"comment\">// 2、写【事务消息】状态存储（TranStateTable）</span></div><div class=\"line\">  <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (req.getProducerGroup() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:                 <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"> <span class=\"number\">12</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">13</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"> <span class=\"number\">14</span>:                     <span class=\"comment\">// 新增 【事务消息】状态存储（TranStateTable）</span></div><div class=\"line\"> <span class=\"number\">15</span>:                     DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().appendPreparedTransaction(</div><div class=\"line\"> <span class=\"number\">16</span>:                         req.getCommitLogOffset(), req.getMsgSize(), (<span class=\"keyword\">int</span>) (req.getStoreTimestamp() / <span class=\"number\">1000</span>), req.getProducerGroup().hashCode());</div><div class=\"line\"> <span class=\"number\">17</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"> <span class=\"number\">19</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"> <span class=\"number\">20</span>:                     <span class=\"comment\">// 更新 【事务消息】状态存储（TranStateTable） COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">21</span>:                     DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().updateTransactionState(</div><div class=\"line\"> <span class=\"number\">22</span>:                         req.getTranStateTableOffset(), req.getPreparedTransactionOffset(), req.getProducerGroup().hashCode(), tranType);</div><div class=\"line\"> <span class=\"number\">23</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">25</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">26</span>:             <span class=\"comment\">// 3、记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(</div><div class=\"line\"> <span class=\"number\">33</span>:                         req.getCommitLogOffset(), req.getMsgSize(), TransactionStateService.PreparedMessageTagsCode,</div><div class=\"line\"> <span class=\"number\">34</span>:                         req.getStoreTimestamp(), <span class=\"number\">0L</span>);</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">36</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"> <span class=\"number\">38</span>:                 <span class=\"comment\">// 记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">39</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(</div><div class=\"line\"> <span class=\"number\">40</span>:                         req.getCommitLogOffset(), req.getMsgSize(), req.getPreparedTransactionOffset(),</div><div class=\"line\"> <span class=\"number\">41</span>:                         req.getStoreTimestamp(), <span class=\"number\">0L</span>);</div><div class=\"line\"> <span class=\"number\">42</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">43</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">44</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"> <span class=\"number\">47</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>: &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\"> <span class=\"number\">50</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 51:  * 新增事务状态</div><div class=\"line\"> 52:  *</div><div class=\"line\"> 53:  * <span class=\"doctag\">@param</span> clOffset commitLog 物理位置</div><div class=\"line\"> 54:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\"> 55:  * <span class=\"doctag\">@param</span> timestamp 消息存储时间</div><div class=\"line\"> 56:  * <span class=\"doctag\">@param</span> groupHashCode groupHashCode</div><div class=\"line\"> 57:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\"> 58:  */</div><div class=\"line\"> <span class=\"number\">59</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">appendPreparedTransaction</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">60</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset,//</div><div class=\"line\"> <span class=\"number\">61</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size,//</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timestamp,//</div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode//</div><div class=\"line\"> <span class=\"number\">64</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:     MapedFile mapedFile = <span class=\"keyword\">this</span>.tranStateTable.getLastMapedFile();</div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mapedFile) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:         log.error(<span class=\"string\">\"appendPreparedTransaction: create mapedfile error.\"</span>);</div><div class=\"line\"> <span class=\"number\">68</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:     <span class=\"comment\">// 首次创建，加入定时任务中</span></div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == mapedFile.getWrotePostion()) &#123;</div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">this</span>.addTimerTask(mapedFile);</div><div class=\"line\"> <span class=\"number\">74</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">75</span>: </div><div class=\"line\"> <span class=\"number\">76</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">77</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.limit(TSStoreUnitSize);</div><div class=\"line\"> <span class=\"number\">78</span>: </div><div class=\"line\"> <span class=\"number\">79</span>:     <span class=\"comment\">// Commit Log Offset</span></div><div class=\"line\"> <span class=\"number\">80</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putLong(clOffset);</div><div class=\"line\"> <span class=\"number\">81</span>:     <span class=\"comment\">// Message Size</span></div><div class=\"line\"> <span class=\"number\">82</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(size);</div><div class=\"line\"> <span class=\"number\">83</span>:     <span class=\"comment\">// Timestamp</span></div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(timestamp);</div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"comment\">// Producer Group Hashcode</span></div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(groupHashCode);</div><div class=\"line\"> <span class=\"number\">87</span>:     <span class=\"comment\">// Transaction State</span></div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(MessageSysFlag.TransactionPreparedType);</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:     <span class=\"keyword\">return</span> mapedFile.appendMessage(<span class=\"keyword\">this</span>.byteBufferAppend.array());</div><div class=\"line\"> <span class=\"number\">91</span>: &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 94:  * 更新事务状态</div><div class=\"line\"> 95:  *</div><div class=\"line\"> 96:  * <span class=\"doctag\">@param</span> tsOffset tranStateTable 物理位置</div><div class=\"line\"> 97:  * <span class=\"doctag\">@param</span> clOffset commitLog 物理位置</div><div class=\"line\"> 98:  * <span class=\"doctag\">@param</span> groupHashCode groupHashCode</div><div class=\"line\"> 99:  * <span class=\"doctag\">@param</span> state 事务状态</div><div class=\"line\">100:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">101:  */</div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateTransactionState</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tsOffset,</div><div class=\"line\"><span class=\"number\">104</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset,</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode,</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> state) &#123;</div><div class=\"line\"><span class=\"number\">107</span>:     SelectMapedBufferResult selectMapedBufferResult = <span class=\"keyword\">this</span>.findTransactionBuffer(tsOffset);</div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"keyword\">if</span> (selectMapedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:             <span class=\"comment\">// ....省略代码：校验是否能够更新</span></div><div class=\"line\"><span class=\"number\">112</span>: </div><div class=\"line\"><span class=\"number\">113</span>:             <span class=\"comment\">// 更新事务状态</span></div><div class=\"line\"><span class=\"number\">114</span>:             selectMapedBufferResult.getByteBuffer().putInt(TS_STATE_POS, state);</div><div class=\"line\"><span class=\"number\">115</span>:         &#125;</div><div class=\"line\"><span class=\"number\">116</span>:         <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">117</span>:             log.error(<span class=\"string\">\"updateTransactionState exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">118</span>:         &#125;</div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">120</span>:             selectMapedBufferResult.release();</div><div class=\"line\"><span class=\"number\">121</span>:         &#125;</div><div class=\"line\"><span class=\"number\">122</span>:     &#125;</div><div class=\"line\"><span class=\"number\">123</span>: </div><div class=\"line\"><span class=\"number\">124</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">125</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-3-【事务消息】回查\"><a href=\"#3-1-1-3-【事务消息】回查\" class=\"headerlink\" title=\"3.1.1.3 【事务消息】回查\"></a>3.1.1.3 【事务消息】回查</h4><ul>\n<li>🦅<code>TranStateTable</code> 每个 <code>MappedFile</code> 都对应一个 <code>Timer</code>。<code>Timer</code> 固定周期（默认：60s）遍历 <code>MappedFile</code>，查找【half消息】，向 <code>Producer</code> 发起【事务消息】回查请求。【事务消息】回查结果的逻辑不在此处进行，在 <a href=\"#3112-写事务消息状态存储transtatetable\">CommitLog dispatch</a>时执行。</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 初始化定时任务</div><div class=\"line\">  4:  */</div><div class=\"line\">  <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initTimerTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> List&lt;MapedFile&gt; mapedFiles = <span class=\"keyword\">this</span>.tranStateTable.getMapedFiles();</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"keyword\">for</span> (MapedFile mf : mapedFiles) &#123;</div><div class=\"line\">  <span class=\"number\">9</span>:         <span class=\"keyword\">this</span>.addTimerTask(mf);</div><div class=\"line\"> <span class=\"number\">10</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">11</span>: &#125;</div><div class=\"line\"> <span class=\"number\">12</span>: </div><div class=\"line\"> <span class=\"number\">13</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 14:  * 每个文件初始化定时任务</div><div class=\"line\"> 15:  * <span class=\"doctag\">@param</span> mf 文件</div><div class=\"line\"> 16:  */</div><div class=\"line\"> <span class=\"number\">17</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTimerTask</span><span class=\"params\">(<span class=\"keyword\">final</span> MapedFile mf)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">this</span>.timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MapedFile mapedFile = mf;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TransactionCheckExecuter transactionCheckExecuter = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionCheckExecuter();</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> checkTransactionMessageAtleastInterval = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig()</div><div class=\"line\"> <span class=\"number\">22</span>:                     .getCheckTransactionMessageAtleastInterval();</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> slave = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">26</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"comment\">// Slave不需要回查事务状态</span></div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">if</span> (slave) &#123;</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">31</span>:             <span class=\"comment\">// Check功能是否开启</span></div><div class=\"line\"> <span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (!TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig()</div><div class=\"line\"> <span class=\"number\">33</span>:                 .isCheckTransactionMessageEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">35</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 SelectMapedBufferResult selectMapedBufferResult = mapedFile.selectMapedBuffer(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (selectMapedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">long</span> preparedMessageCountInThisMapedFile = <span class=\"number\">0</span>; <span class=\"comment\">// 回查的【half消息】数量</span></div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                         <span class=\"comment\">// 循环每条【事务消息】状态，对【half消息】进行回查</span></div><div class=\"line\"> <span class=\"number\">44</span>:                         <span class=\"keyword\">for</span> (; i &lt; selectMapedBufferResult.getSize(); i += TSStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">45</span>:                             selectMapedBufferResult.getByteBuffer().position(i);</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:                             <span class=\"comment\">// Commit Log Offset</span></div><div class=\"line\"> <span class=\"number\">48</span>:                             <span class=\"keyword\">long</span> clOffset = selectMapedBufferResult.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">49</span>:                             <span class=\"comment\">// Message Size</span></div><div class=\"line\"> <span class=\"number\">50</span>:                             <span class=\"keyword\">int</span> msgSize = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">51</span>:                             <span class=\"comment\">// Timestamp</span></div><div class=\"line\"> <span class=\"number\">52</span>:                             <span class=\"keyword\">int</span> timestamp = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">53</span>:                             <span class=\"comment\">// Producer Group Hashcode</span></div><div class=\"line\"> <span class=\"number\">54</span>:                             <span class=\"keyword\">int</span> groupHashCode = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">55</span>:                             <span class=\"comment\">// Transaction State</span></div><div class=\"line\"> <span class=\"number\">56</span>:                             <span class=\"keyword\">int</span> tranType = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:                             <span class=\"comment\">// 已经提交或者回滚的消息跳过</span></div><div class=\"line\"> <span class=\"number\">59</span>:                             <span class=\"keyword\">if</span> (tranType != MessageSysFlag.TransactionPreparedType) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:                             <span class=\"comment\">// 遇到时间不符合最小轮询间隔，终止</span></div><div class=\"line\"> <span class=\"number\">64</span>:                             <span class=\"keyword\">long</span> timestampLong = timestamp * <span class=\"number\">1000</span>;</div><div class=\"line\"> <span class=\"number\">65</span>:                             <span class=\"keyword\">long</span> diff = System.currentTimeMillis() - timestampLong;</div><div class=\"line\"> <span class=\"number\">66</span>:                             <span class=\"keyword\">if</span> (diff &lt; checkTransactionMessageAtleastInterval) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">68</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:                             preparedMessageCountInThisMapedFile++;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:                             <span class=\"comment\">// 回查Producer</span></div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                                 <span class=\"keyword\">this</span>.transactionCheckExecuter.gotoCheck(groupHashCode, getTranStateOffset(i), clOffset, msgSize);</div><div class=\"line\"> <span class=\"number\">75</span>:                             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                                 tranlog.warn(<span class=\"string\">\"gotoCheck Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">77</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>:                         <span class=\"comment\">// 无回查的【half消息】数量，且遍历完，则终止定时任务</span></div><div class=\"line\"> <span class=\"number\">81</span>:                         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == preparedMessageCountInThisMapedFile <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">82</span>:                                 &amp;&amp; i == mapedFile.getFileSize()) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:                             tranlog.info(<span class=\"string\">\"remove the transaction timer task, because no prepared message in this mapedfile[&#123;&#125;]\"</span>, mapedFile.getFileName());</div><div class=\"line\"> <span class=\"number\">84</span>:                             <span class=\"keyword\">this</span>.cancel();</div><div class=\"line\"> <span class=\"number\">85</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:                     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:                         selectMapedBufferResult.release();</div><div class=\"line\"> <span class=\"number\">88</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:                     tranlog.info(<span class=\"string\">\"the transaction timer task execute over in this period, &#123;&#125; Prepared Message: &#123;&#125; Check Progress: &#123;&#125;/&#123;&#125;\"</span>, mapedFile.getFileName(),<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">91</span>:                             preparedMessageCountInThisMapedFile, i / TSStoreUnitSize, mapedFile.getFileSize() / TSStoreUnitSize);</div><div class=\"line\"> <span class=\"number\">92</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mapedFile.isFull()) &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:                     tranlog.info(<span class=\"string\">\"the mapedfile[&#123;&#125;] maybe deleted, cancel check transaction timer task\"</span>, mapedFile.getFileName());</div><div class=\"line\"> <span class=\"number\">94</span>:                     <span class=\"keyword\">this</span>.cancel();</div><div class=\"line\"> <span class=\"number\">95</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">96</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 log.error(<span class=\"string\">\"check transaction timer task Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">99</span>:             &#125;</div><div class=\"line\"><span class=\"number\">100</span>:         &#125;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">getTranStateOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentIndex)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">104</span>:             <span class=\"keyword\">long</span> offset = (<span class=\"keyword\">this</span>.mapedFile.getFileFromOffset() + currentIndex) / TransactionStateService.TSStoreUnitSize;</div><div class=\"line\"><span class=\"number\">105</span>:             <span class=\"keyword\">return</span> offset;</div><div class=\"line\"><span class=\"number\">106</span>:         &#125;</div><div class=\"line\"><span class=\"number\">107</span>:     &#125;, <span class=\"number\">1000</span> * <span class=\"number\">60</span>, <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCheckTransactionMessageTimerInterval());</div><div class=\"line\"><span class=\"number\">108</span>: &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>: <span class=\"comment\">// 【DefaultTransactionCheckExecuter.java】</span></div><div class=\"line\"><span class=\"number\">111</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">112</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotoCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> producerGroupHashCode, <span class=\"keyword\">long</span> tranStateTableOffset, <span class=\"keyword\">long</span> commitLogOffset,</span></span></div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"keyword\">int</span> msgSize) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:     <span class=\"comment\">// 第一步、查询Producer</span></div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"keyword\">final</span> ClientChannelInfo clientChannelInfo = <span class=\"keyword\">this</span>.brokerController.getProducerManager().pickProducerChannelRandomly(producerGroupHashCode);</div><div class=\"line\"><span class=\"number\">116</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == clientChannelInfo) &#123;</div><div class=\"line\"><span class=\"number\">117</span>:         log.warn(<span class=\"string\">\"check a producer transaction state, but not find any channel of this group[&#123;&#125;]\"</span>, producerGroupHashCode);</div><div class=\"line\"><span class=\"number\">118</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"comment\">// 第二步、查询消息</span></div><div class=\"line\"><span class=\"number\">122</span>:     SelectMapedBufferResult selectMapedBufferResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().selectOneMessageByOffset(commitLogOffset, msgSize);</div><div class=\"line\"><span class=\"number\">123</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == selectMapedBufferResult) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:         log.warn(<span class=\"string\">\"check a producer transaction state, but not find message by commitLogOffset: &#123;&#125;, msgSize: \"</span>, commitLogOffset, msgSize);</div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">126</span>:     &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// 第三步、向Producer发起请求</span></div><div class=\"line\"><span class=\"number\">129</span>:     <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader requestHeader = <span class=\"keyword\">new</span> CheckTransactionStateRequestHeader();</div><div class=\"line\"><span class=\"number\">130</span>:     requestHeader.setCommitLogOffset(commitLogOffset);</div><div class=\"line\"><span class=\"number\">131</span>:     requestHeader.setTranStateTableOffset(tranStateTableOffset);</div><div class=\"line\"><span class=\"number\">132</span>:     <span class=\"keyword\">this</span>.brokerController.getBroker2Client().checkProducerTransactionState(clientChannelInfo.getChannel(), requestHeader, selectMapedBufferResult);</div><div class=\"line\"><span class=\"number\">133</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-4-初始化【事务消息】状态存储（TranStateTable）\"><a href=\"#3-1-1-4-初始化【事务消息】状态存储（TranStateTable）\" class=\"headerlink\" title=\"3.1.1.4 初始化【事务消息】状态存储（TranStateTable）\"></a>3.1.1.4 初始化【事务消息】状态存储（TranStateTable）</h4><ul>\n<li>🦅根据最后 Broker 关闭是否正常，会有不同的初始化方式。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 初始化 TranRedoLog</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> lastExitOK 是否正常退出</div><div class=\"line\">  5:  */</div><div class=\"line\">  <span class=\"number\">6</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recoverStateTable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastExitOK)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (lastExitOK) &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:         <span class=\"keyword\">this</span>.recoverStateTableNormal();</div><div class=\"line\">  <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:         <span class=\"comment\">// 第一步，删除State Table</span></div><div class=\"line\"> <span class=\"number\">11</span>:         <span class=\"keyword\">this</span>.tranStateTable.destroy();</div><div class=\"line\"> <span class=\"number\">12</span>:         <span class=\"comment\">// 第二步，通过RedoLog全量恢复StateTable</span></div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.recreateStateTable();</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: &#125;</div><div class=\"line\"> <span class=\"number\">16</span>: </div><div class=\"line\"> <span class=\"number\">17</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 18:  * 扫描 TranRedoLog 重建 StateTable</div><div class=\"line\"> 19:  */</div><div class=\"line\"> <span class=\"number\">20</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recreateStateTable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">this</span>.tranStateTable = <span class=\"keyword\">new</span> MapedFileQueue(StorePathConfigHelper.getTranStateTableStorePath(defaultMessageStore</div><div class=\"line\"> <span class=\"number\">22</span>:                 .getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore</div><div class=\"line\"> <span class=\"number\">23</span>:                 .getMessageStoreConfig().getTranStateTableMapedFileSize(), <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">final</span> TreeSet&lt;Long&gt; preparedItemSet = <span class=\"keyword\">new</span> TreeSet&lt;Long&gt;();</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">// 第一步，从头扫描RedoLog</span></div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> minOffset = <span class=\"keyword\">this</span>.tranRedoLog.getMinOffsetInQuque();</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">long</span> processOffset = minOffset;</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"> <span class=\"number\">31</span>:         SelectMapedBufferResult bufferConsumeQueue = <span class=\"keyword\">this</span>.tranRedoLog.getIndexBuffer(processOffset);</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (bufferConsumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">33</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize(); i += ConsumeQueue.CQStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">36</span>:                     <span class=\"keyword\">long</span> offsetMsg = bufferConsumeQueue.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">37</span>:                     <span class=\"keyword\">int</span> sizeMsg = bufferConsumeQueue.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">38</span>:                     <span class=\"keyword\">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">if</span> (TransactionStateService.PreparedMessageTagsCode == tagsCode) &#123; <span class=\"comment\">// Prepared</span></div><div class=\"line\"> <span class=\"number\">41</span>:                         preparedItemSet.add(offsetMsg);</div><div class=\"line\"> <span class=\"number\">42</span>:                     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// Commit/Rollback</span></div><div class=\"line\"> <span class=\"number\">43</span>:                         preparedItemSet.remove(tagsCode);</div><div class=\"line\"> <span class=\"number\">44</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">45</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:                 processOffset += i;</div><div class=\"line\"> <span class=\"number\">48</span>:             &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// 必须释放资源</span></div><div class=\"line\"> <span class=\"number\">49</span>:                 bufferConsumeQueue.release();</div><div class=\"line\"> <span class=\"number\">50</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">51</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">53</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:     log.info(<span class=\"string\">\"scan transaction redolog over, End offset: &#123;&#125;,  Prepared Transaction Count: &#123;&#125;\"</span>, processOffset, preparedItemSet.size());</div><div class=\"line\"> <span class=\"number\">56</span>: </div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"comment\">// 第二步，重建StateTable</span></div><div class=\"line\"> <span class=\"number\">58</span>:     Iterator&lt;Long&gt; it = preparedItemSet.iterator();</div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:         Long offset = it.next();</div><div class=\"line\"> <span class=\"number\">61</span>:         MessageExt msgExt = <span class=\"keyword\">this</span>.defaultMessageStore.lookMessageByOffset(offset);</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"keyword\">this</span>.appendPreparedTransaction(msgExt.getCommitLogOffset(), msgExt.getStoreSize(),</div><div class=\"line\"> <span class=\"number\">64</span>:                 (<span class=\"keyword\">int</span>) (msgExt.getStoreTimestamp() / <span class=\"number\">1000</span>),</div><div class=\"line\"> <span class=\"number\">65</span>:                 msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP).hashCode());</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">this</span>.tranStateTableOffset.incrementAndGet();</div><div class=\"line\"> <span class=\"number\">67</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 72:  * 加载（解析）TranStateTable 的 MappedFile</div><div class=\"line\"> 73:  * 1. 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position</div><div class=\"line\"> 74:  * 2. 设置 TanStateTable 最大物理位置（可写入位置）</div><div class=\"line\"> 75:  */</div><div class=\"line\"> <span class=\"number\">76</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recoverStateTableNormal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">77</span>:     <span class=\"keyword\">final</span> List&lt;MapedFile&gt; mapedFiles = <span class=\"keyword\">this</span>.tranStateTable.getMapedFiles();</div><div class=\"line\"> <span class=\"number\">78</span>:     <span class=\"keyword\">if</span> (!mapedFiles.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"comment\">// 从倒数第三个文件开始恢复</span></div><div class=\"line\"> <span class=\"number\">80</span>:         <span class=\"keyword\">int</span> index = mapedFiles.size() - <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"number\">81</span>:         <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>:             index = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>: </div><div class=\"line\"> <span class=\"number\">85</span>:         <span class=\"keyword\">int</span> mapedFileSizeLogics = <span class=\"keyword\">this</span>.tranStateTable.getMapedFileSize();</div><div class=\"line\"> <span class=\"number\">86</span>:         MapedFile mapedFile = mapedFiles.get(index);</div><div class=\"line\"> <span class=\"number\">87</span>:         ByteBuffer byteBuffer = mapedFile.sliceByteBuffer();</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">long</span> processOffset = mapedFile.getFileFromOffset();</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">long</span> mapedFileOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mapedFileSizeLogics; i += TSStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset_read = byteBuffer.getLong();</div><div class=\"line\"> <span class=\"number\">94</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">95</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timestamp_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">96</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">97</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> state_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:                 <span class=\"keyword\">boolean</span> stateOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">switch</span> (state_read) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"><span class=\"number\">102</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">103</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">104</span>:                     stateOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">105</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">107</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">108</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                 <span class=\"comment\">// 说明当前存储单元有效</span></div><div class=\"line\"><span class=\"number\">111</span>:                 <span class=\"keyword\">if</span> (clOffset_read &gt;= <span class=\"number\">0</span> &amp;&amp; size_read &gt; <span class=\"number\">0</span> &amp;&amp; stateOK) &#123;</div><div class=\"line\"><span class=\"number\">112</span>:                     mapedFileOffset = i + TSStoreUnitSize;</div><div class=\"line\"><span class=\"number\">113</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">114</span>:                     log.info(<span class=\"string\">\"recover current transaction state table file over,  \"</span> + mapedFile.getFileName() + <span class=\"string\">\" \"</span></div><div class=\"line\"><span class=\"number\">115</span>:                             + clOffset_read + <span class=\"string\">\" \"</span> + size_read + <span class=\"string\">\" \"</span> + timestamp_read);</div><div class=\"line\"><span class=\"number\">116</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">118</span>:             &#125;</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:             <span class=\"comment\">// 走到文件末尾，切换至下一个文件</span></div><div class=\"line\"><span class=\"number\">121</span>:             <span class=\"keyword\">if</span> (mapedFileOffset == mapedFileSizeLogics) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:                 index++;</div><div class=\"line\"><span class=\"number\">123</span>:                 <span class=\"keyword\">if</span> (index &gt;= mapedFiles.size()) &#123; <span class=\"comment\">// 循环while结束</span></div><div class=\"line\"><span class=\"number\">124</span>:                     log.info(<span class=\"string\">\"recover last transaction state table file over, last maped file \"</span> + mapedFile.getFileName());</div><div class=\"line\"><span class=\"number\">125</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">126</span>:                 &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 切换下一个文件</span></div><div class=\"line\"><span class=\"number\">127</span>:                     mapedFile = mapedFiles.get(index);</div><div class=\"line\"><span class=\"number\">128</span>:                     byteBuffer = mapedFile.sliceByteBuffer();</div><div class=\"line\"><span class=\"number\">129</span>:                     processOffset = mapedFile.getFileFromOffset();</div><div class=\"line\"><span class=\"number\">130</span>:                     mapedFileOffset = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">131</span>:                     log.info(<span class=\"string\">\"recover next transaction state table file, \"</span> + mapedFile.getFileName());</div><div class=\"line\"><span class=\"number\">132</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">133</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">134</span>:                 log.info(<span class=\"string\">\"recover current transaction state table queue over \"</span> + mapedFile.getFileName() + <span class=\"string\">\" \"</span> + (processOffset + mapedFileOffset));</div><div class=\"line\"><span class=\"number\">135</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">136</span>:             &#125;</div><div class=\"line\"><span class=\"number\">137</span>:         &#125;</div><div class=\"line\"><span class=\"number\">138</span>: </div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"comment\">// 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position</span></div><div class=\"line\"><span class=\"number\">140</span>:         processOffset += mapedFileOffset;</div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">this</span>.tranStateTable.truncateDirtyFiles(processOffset);</div><div class=\"line\"><span class=\"number\">142</span>: </div><div class=\"line\"><span class=\"number\">143</span>:         <span class=\"comment\">// 设置 TanStateTable 最大物理位置（可写入位置）</span></div><div class=\"line\"><span class=\"number\">144</span>:         <span class=\"keyword\">this</span>.tranStateTableOffset.set(<span class=\"keyword\">this</span>.tranStateTable.getMaxOffset() / TSStoreUnitSize);</div><div class=\"line\"><span class=\"number\">145</span>:         log.info(<span class=\"string\">\"recover normal over, transaction state table max offset: &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.tranStateTableOffset.get());</div><div class=\"line\"><span class=\"number\">146</span>:     &#125;</div><div class=\"line\"><span class=\"number\">147</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-5-补充\"><a href=\"#3-1-1-5-补充\" class=\"headerlink\" title=\"3.1.1.5 补充\"></a>3.1.1.5 补充</h4><ul>\n<li>为什么 V3.1.5 开始，使用 数据库 实现【事务状态】的存储？如下是来自官方文档的说明，可能是一部分原因：</li>\n</ul>\n<blockquote>\n<p>RocketMQ 这种实现事务方式，没有通过 KV 存储做，而是通过 Offset 方式，存在一个显著缺陷，即通过 Offset 更改数据，会令系统的脏页过多，需要特别关注。</p>\n</blockquote>\n<h3 id=\"3-1-2-官方V4-0-0：基于数据库\"><a href=\"#3-1-2-官方V4-0-0：基于数据库\" class=\"headerlink\" title=\"3.1.2 官方V4.0.0：基于数据库\"></a>3.1.2 官方V4.0.0：基于数据库</h3><blockquote>\n<p>仓库地址：<a href=\"https://github.com/apache/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/apache/incubator-rocketmq</a></p>\n</blockquote>\n<p>官方V4.0.0 暂时未<strong>完全</strong>开源【事务消息回查】功能，<strong>So 我们需要进行一些猜想，可能不一定正确😈</strong>。</p>\n<p>😆我们来对比【官方V3.1.4：基于文件】的实现。</p>\n<ul>\n<li>TransactionRecord ：记录每条【事务消息】。类似 <code>TranStateTable</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>TranStateTable</th>\n<th>TransactionRecord</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>offset</td>\n<td>offset</td>\n<td></td>\n</tr>\n<tr>\n<td>producerGroupHash</td>\n<td>producerGroup</td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>无</td>\n<td>非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>无</td>\n<td>非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。</td>\n</tr>\n<tr>\n<td>state</td>\n<td>无</td>\n<td>非必须字段： 事务开始，增加记录；事务结束，删除记录。</td>\n</tr>\n</tbody>\n</table>\n<p>另外，数据库本身保证了数据存储的可靠性，无需 <code>TranRedoLog</code>。</p>\n<hr>\n<p>简单手绘逻辑图如下😈：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/02.jpeg\" alt=\"Broker_V4.0.0_基于数据库\"></p>\n<h2 id=\"3-2-Producer-接收【事务消息回查】\"><a href=\"#3-2-Producer-接收【事务消息回查】\" class=\"headerlink\" title=\"3.2 Producer 接收【事务消息回查】\"></a>3.2 Producer 接收【事务消息回查】</h2><ul>\n<li>顺序图如下：</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/04.png\" alt=\"Producer接收【事务消息回查】\"></p>\n<ul>\n<li>核心代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 检查【事务状态】状态</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> addr broker地址</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> header 请求</div><div class=\"line\">  8:  */</div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkTransactionState</span><span class=\"params\">(<span class=\"keyword\">final</span> String addr, <span class=\"keyword\">final</span> MessageExt msg, <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader header)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">11</span>:     Runnable request = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String brokerAddr = addr;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageExt message = msg;</div><div class=\"line\"> <span class=\"number\">14</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader checkRequestHeader = header;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String group = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup();</div><div class=\"line\"> <span class=\"number\">16</span>: </div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.checkListener();</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (transactionCheckListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:                 <span class=\"comment\">// 获取事务执行状态</span></div><div class=\"line\"> <span class=\"number\">22</span>:                 LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">23</span>:                 Throwable exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                     localTransactionState = transactionCheckListener.checkLocalTransactionState(message);</div><div class=\"line\"> <span class=\"number\">26</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:                     log.error(<span class=\"string\">\"Broker call checkTransactionState, but checkLocalTransactionState exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">28</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 处理事务结果，提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 <span class=\"keyword\">this</span>.processTransactionState(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">33</span>:                     localTransactionState, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">34</span>:                     group, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     exception);</div><div class=\"line\"> <span class=\"number\">36</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                 log.warn(<span class=\"string\">\"checkTransactionState, pick transactionCheckListener by group[&#123;&#125;] failed\"</span>, group);</div><div class=\"line\"> <span class=\"number\">38</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">39</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:         <span class=\"comment\">/**</span></div><div class=\"line\"> 42:          * 处理事务结果，提交消息 COMMIT / ROLLBACK</div><div class=\"line\"> 43:          *</div><div class=\"line\"> 44:          * <span class=\"doctag\">@param</span> localTransactionState 【本地事务】状态</div><div class=\"line\"> 45:          * <span class=\"doctag\">@param</span> producerGroup producerGroup</div><div class=\"line\"> 46:          * <span class=\"doctag\">@param</span> exception 检查【本地事务】状态发生的异常</div><div class=\"line\"> 47:          */</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processTransactionState</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">49</span>:             <span class=\"keyword\">final</span> LocalTransactionState localTransactionState, //</div><div class=\"line\"> <span class=\"number\">50</span>:             <span class=\"keyword\">final</span> String producerGroup, //</div><div class=\"line\"> <span class=\"number\">51</span>:             <span class=\"keyword\">final</span> Throwable exception) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">final</span> EndTransactionRequestHeader thisHeader = <span class=\"keyword\">new</span> EndTransactionRequestHeader();</div><div class=\"line\"> <span class=\"number\">53</span>:             thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());</div><div class=\"line\"> <span class=\"number\">54</span>:             thisHeader.setProducerGroup(producerGroup);</div><div class=\"line\"> <span class=\"number\">55</span>:             thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());</div><div class=\"line\"> <span class=\"number\">56</span>:             thisHeader.setFromTransactionCheck(<span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"comment\">// 设置消息编号</span></div><div class=\"line\"> <span class=\"number\">59</span>:             String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"keyword\">if</span> (uniqueKey == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">61</span>:                 uniqueKey = message.getMsgId();</div><div class=\"line\"> <span class=\"number\">62</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">63</span>:             thisHeader.setMsgId(uniqueKey);</div><div class=\"line\"> <span class=\"number\">64</span>: </div><div class=\"line\"> <span class=\"number\">65</span>:             thisHeader.setTransactionId(checkRequestHeader.getTransactionId());</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">switch</span> (localTransactionState) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                 <span class=\"keyword\">case</span> COMMIT_MESSAGE:</div><div class=\"line\"> <span class=\"number\">68</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                 <span class=\"keyword\">case</span> ROLLBACK_MESSAGE:</div><div class=\"line\"> <span class=\"number\">71</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</div><div class=\"line\"> <span class=\"number\">72</span>:                     log.warn(<span class=\"string\">\"when broker check, client rollback this transaction, &#123;&#125;\"</span>, thisHeader);</div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">case</span> UNKNOW:</div><div class=\"line\"> <span class=\"number\">75</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</div><div class=\"line\"> <span class=\"number\">76</span>:                     log.warn(<span class=\"string\">\"when broker check, client does not know this transaction state, &#123;&#125;\"</span>, thisHeader);</div><div class=\"line\"> <span class=\"number\">77</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">79</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:             String remark = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:             <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:                 remark = <span class=\"string\">\"checkLocalTransactionState Exception: \"</span> + RemotingHelper.exceptionSimpleDesc(exception);</div><div class=\"line\"> <span class=\"number\">85</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">86</span>: </div><div class=\"line\"> <span class=\"number\">87</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">88</span>:                 <span class=\"comment\">// 提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">89</span>:                 DefaultMQProducerImpl.<span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,</div><div class=\"line\"> <span class=\"number\">90</span>:                     <span class=\"number\">3000</span>);</div><div class=\"line\"> <span class=\"number\">91</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:                 log.error(<span class=\"string\">\"endTransactionOneway exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">93</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">94</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">95</span>:     &#125;;</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"comment\">// 提交执行</span></div><div class=\"line\"> <span class=\"number\">98</span>:     <span class=\"keyword\">this</span>.checkExecutor.submit(request);</div><div class=\"line\"> <span class=\"number\">99</span>: &#125;</div><div class=\"line\"><span class=\"number\">100</span>: </div><div class=\"line\"><span class=\"number\">101</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"comment\">/**</span></div><div class=\"line\">103:  * 【事务消息回查】检查监听器</div><div class=\"line\">104:  */</div><div class=\"line\"><span class=\"number\">105</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionCheckListener</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">108:      * 获取（检查）【本地事务】状态</div><div class=\"line\">109:      *</div><div class=\"line\">110:      * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">111:      * <span class=\"doctag\">@return</span> 事务状态</div><div class=\"line\">112:      */</div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"function\">LocalTransactionState <span class=\"title\">checkLocalTransactionState</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExt msg)</span></span>;</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>: &#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-transaction\">http://www.yunai.me/RocketMQ/message-transaction</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1. 概述</a></li>\n<li><a href=\"#\">2. 事务消息发送</a><ul>\n<li><a href=\"#\">2.1 Producer 发送事务消息</a></li>\n<li><a href=\"#\">2.2 Broker 处理结束事务请求</a></li>\n<li><a href=\"#\">2.3 Broker 生成 ConsumeQueue</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3. 事务消息回查</a><ul>\n<li><a href=\"#\">3.1 Broker 发起【事务消息回查】</a><ul>\n<li><a href=\"#\">3.1.1 官方V3.1.4：基于文件系统</a><ul>\n<li><a href=\"#\">3.1.1.1 存储消息到 CommitLog</a></li>\n<li><a href=\"#\">3.1.1.2 写【事务消息】状态存储（TranStateTable）</a></li>\n<li><a href=\"#\">3.1.1.3 【事务消息】回查</a></li>\n<li><a href=\"#\">3.1.1.4 初始化【事务消息】状态存储（TranStateTable）</a></li>\n<li><a href=\"#\">3.1.1.5 补充</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.1.2 官方V4.0.0：基于数据库</a></li>\n</ul>\n</li>\n<li><a href=\"#\">3.2 Producer 接收【事务消息回查】</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p><strong>必须必须必须</strong> 前置阅读内容：</p>\n<ul>\n<li><a href=\"https://help.aliyun.com/document_detail/43348.html?spm=5176.doc43490.6.566.Zd5Bl7\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">《事务消息（阿里云）》</a></li>\n</ul>\n<h1 id=\"2-事务消息发送\"><a href=\"#2-事务消息发送\" class=\"headerlink\" title=\"2. 事务消息发送\"></a>2. 事务消息发送</h1><h2 id=\"2-1-Producer-发送事务消息\"><a href=\"#2-1-Producer-发送事务消息\" class=\"headerlink\" title=\"2.1 Producer 发送事务消息\"></a>2.1 Producer 发送事务消息</h2><ul>\n<li>活动图如下（结合 <code>核心代码</code> 理解）：</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/03.png\" alt=\"Producer发送事务消息\"></p>\n<ul>\n<li>实现代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 发送事务消息</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> tranExecuter 【本地事务】执行器</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> arg 【本地事务】执行器参数</div><div class=\"line\">  8:  * <span class=\"doctag\">@return</span> 事务发送结果</div><div class=\"line\">  9:  * <span class=\"doctag\">@throws</span> MQClientException 当 Client 发生异常时</div><div class=\"line\"> 10:  */</div><div class=\"line\"> <span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> TransactionSendResult <span class=\"title\">sendMessageInTransaction</span><span class=\"params\">(<span class=\"keyword\">final</span> Message msg, <span class=\"keyword\">final</span> LocalTransactionExecuter tranExecuter, <span class=\"keyword\">final</span> Object arg)</span></span></div><div class=\"line\"> 12:     <span class=\"keyword\">throws</span> MQClientException &#123;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == tranExecuter) &#123;</div><div class=\"line\"> <span class=\"number\">14</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"tranExecutor is null\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">15</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">16</span>:     Validators.checkMessage(msg, <span class=\"keyword\">this</span>.defaultMQProducer);</div><div class=\"line\"> <span class=\"number\">17</span>: </div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"comment\">// 发送【Half消息】</span></div><div class=\"line\"> <span class=\"number\">19</span>:     SendResult sendResult;</div><div class=\"line\"> <span class=\"number\">20</span>:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class=\"string\">\"true\"</span>);</div><div class=\"line\"> <span class=\"number\">21</span>:     MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:         sendResult = <span class=\"keyword\">this</span>.send(msg);</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"send message Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">26</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">27</span>: </div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"comment\">// 处理发送【Half消息】结果</span></div><div class=\"line\"> <span class=\"number\">29</span>:     LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">30</span>:     Throwable localException = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"keyword\">switch</span> (sendResult.getSendStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"comment\">// 发送【Half消息】成功，执行【本地事务】逻辑</span></div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">case</span> SEND_OK: &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">if</span> (sendResult.getTransactionId() != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 事务编号。目前开源版本暂时没用到，猜想ONS在使用。</span></div><div class=\"line\"> <span class=\"number\">36</span>:                     msg.putUserProperty(<span class=\"string\">\"__transactionId__\"</span>, sendResult.getTransactionId());</div><div class=\"line\"> <span class=\"number\">37</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"comment\">// 执行【本地事务】逻辑</span></div><div class=\"line\"> <span class=\"number\">40</span>:                 localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);</div><div class=\"line\"> <span class=\"number\">41</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == localTransactionState) &#123;</div><div class=\"line\"> <span class=\"number\">42</span>:                     localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:                 <span class=\"keyword\">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</div><div class=\"line\"> <span class=\"number\">46</span>:                     log.info(<span class=\"string\">\"executeLocalTransactionBranch return &#123;&#125;\"</span>, localTransactionState);</div><div class=\"line\"> <span class=\"number\">47</span>:                     log.info(msg.toString());</div><div class=\"line\"> <span class=\"number\">48</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">49</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:                 log.info(<span class=\"string\">\"executeLocalTransactionBranch exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">51</span>:                 log.info(msg.toString());</div><div class=\"line\"> <span class=\"number\">52</span>:                 localException = e;</div><div class=\"line\"> <span class=\"number\">53</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:         <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:         <span class=\"comment\">// 发送【Half消息】失败，标记【本地事务】状态为回滚</span></div><div class=\"line\"> <span class=\"number\">57</span>:         <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"> <span class=\"number\">58</span>:         <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"> <span class=\"number\">59</span>:         <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"> <span class=\"number\">60</span>:             localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</div><div class=\"line\"> <span class=\"number\">61</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">64</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"comment\">// 结束事务：提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">67</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:         <span class=\"keyword\">this</span>.endTransaction(sendResult, localTransactionState, localException);</div><div class=\"line\"> <span class=\"number\">69</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">70</span>:         log.warn(<span class=\"string\">\"local transaction execute \"</span> + localTransactionState + <span class=\"string\">\", but end broker transaction failed\"</span>, e);</div><div class=\"line\"> <span class=\"number\">71</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">72</span>: </div><div class=\"line\"> <span class=\"number\">73</span>:     <span class=\"comment\">// 返回【事务发送结果】</span></div><div class=\"line\"> <span class=\"number\">74</span>:     TransactionSendResult transactionSendResult = <span class=\"keyword\">new</span> TransactionSendResult();</div><div class=\"line\"> <span class=\"number\">75</span>:     transactionSendResult.setSendStatus(sendResult.getSendStatus());</div><div class=\"line\"> <span class=\"number\">76</span>:     transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">77</span>:     transactionSendResult.setMsgId(sendResult.getMsgId());</div><div class=\"line\"> <span class=\"number\">78</span>:     transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</div><div class=\"line\"> <span class=\"number\">79</span>:     transactionSendResult.setTransactionId(sendResult.getTransactionId());</div><div class=\"line\"> <span class=\"number\">80</span>:     transactionSendResult.setLocalTransactionState(localTransactionState);</div><div class=\"line\"> <span class=\"number\">81</span>:     <span class=\"keyword\">return</span> transactionSendResult;</div><div class=\"line\"> <span class=\"number\">82</span>: &#125;</div><div class=\"line\"> <span class=\"number\">83</span>: </div><div class=\"line\"> <span class=\"number\">84</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 85:  * 结束事务：提交消息 COMMIT / ROLLBACK</div><div class=\"line\"> 86:  *</div><div class=\"line\"> 87:  * <span class=\"doctag\">@param</span> sendResult 发送【Half消息】结果</div><div class=\"line\"> 88:  * <span class=\"doctag\">@param</span> localTransactionState 【本地事务】状态</div><div class=\"line\"> 89:  * <span class=\"doctag\">@param</span> localException 执行【本地事务】逻辑产生的异常</div><div class=\"line\"> 90:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\"> 91:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 Broker 发生异常时</div><div class=\"line\"> 92:  * <span class=\"doctag\">@throws</span> InterruptedException 当线程中断时</div><div class=\"line\"> 93:  * <span class=\"doctag\">@throws</span> UnknownHostException 当解码消息编号失败是</div><div class=\"line\"> 94:  */</div><div class=\"line\"> <span class=\"number\">95</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">endTransaction</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">96</span>:     <span class=\"keyword\">final</span> SendResult sendResult, //</div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"keyword\">final</span> LocalTransactionState localTransactionState, //</div><div class=\"line\"> <span class=\"number\">98</span>:     <span class=\"keyword\">final</span> Throwable localException) <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException &#123;</div><div class=\"line\"> <span class=\"number\">99</span>:     <span class=\"comment\">// 解码消息编号</span></div><div class=\"line\"><span class=\"number\">100</span>:     <span class=\"keyword\">final</span> MessageId id;</div><div class=\"line\"><span class=\"number\">101</span>:     <span class=\"keyword\">if</span> (sendResult.getOffsetMsgId() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">102</span>:         id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</div><div class=\"line\"><span class=\"number\">103</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">104</span>:         id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</div><div class=\"line\"><span class=\"number\">105</span>:     &#125;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"comment\">// 创建请求</span></div><div class=\"line\"><span class=\"number\">108</span>:     String transactionId = sendResult.getTransactionId();</div><div class=\"line\"><span class=\"number\">109</span>:     <span class=\"keyword\">final</span> String brokerAddr = <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</div><div class=\"line\"><span class=\"number\">110</span>:     EndTransactionRequestHeader requestHeader = <span class=\"keyword\">new</span> EndTransactionRequestHeader();</div><div class=\"line\"><span class=\"number\">111</span>:     requestHeader.setTransactionId(transactionId);</div><div class=\"line\"><span class=\"number\">112</span>:     requestHeader.setCommitLogOffset(id.getOffset());</div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"keyword\">switch</span> (localTransactionState) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:         <span class=\"keyword\">case</span> COMMIT_MESSAGE:</div><div class=\"line\"><span class=\"number\">115</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</div><div class=\"line\"><span class=\"number\">116</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">117</span>:         <span class=\"keyword\">case</span> ROLLBACK_MESSAGE:</div><div class=\"line\"><span class=\"number\">118</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</div><div class=\"line\"><span class=\"number\">119</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">120</span>:         <span class=\"keyword\">case</span> UNKNOW:</div><div class=\"line\"><span class=\"number\">121</span>:             requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</div><div class=\"line\"><span class=\"number\">122</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">124</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">125</span>:     &#125;</div><div class=\"line\"><span class=\"number\">126</span>:     requestHeader.setProducerGroup(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup());</div><div class=\"line\"><span class=\"number\">127</span>:     requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</div><div class=\"line\"><span class=\"number\">128</span>:     requestHeader.setMsgId(sendResult.getMsgId());</div><div class=\"line\"><span class=\"number\">129</span>:     String remark = localException != <span class=\"keyword\">null</span> ? (<span class=\"string\">\"executeLocalTransactionBranch exception: \"</span> + localException.toString()) : <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">130</span>: </div><div class=\"line\"><span class=\"number\">131</span>:     <span class=\"comment\">// 提交消息 COMMIT / ROLLBACK。！！！通信方式为：Oneway！！！</span></div><div class=\"line\"><span class=\"number\">132</span>:     <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, <span class=\"keyword\">this</span>.defaultMQProducer.getSendMsgTimeout());</div><div class=\"line\"><span class=\"number\">133</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-2-Broker-处理结束事务请求\"><a href=\"#2-2-Broker-处理结束事务请求\" class=\"headerlink\" title=\"2.2 Broker 处理结束事务请求\"></a>2.2 Broker 处理结束事务请求</h2><ul>\n<li>🦅 查询请求的消息，进行<strong>提交 / 回滚</strong>。实现代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【EndTransactionProcessor.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 省略代码 =》打印日志（只处理 COMMIT / ROLLBACK）</span></div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// 查询提交的消息</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> MessageExt msgExt = <span class=\"keyword\">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// 省略代码 =》校验消息</span></div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"comment\">// 生成消息</span></div><div class=\"line\"><span class=\"number\">14</span>:         MessageExtBrokerInner msgInner = <span class=\"keyword\">this</span>.endMessageTransaction(msgExt);</div><div class=\"line\"><span class=\"number\">15</span>:         msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</div><div class=\"line\"><span class=\"number\">16</span>:         msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</div><div class=\"line\"><span class=\"number\">17</span>:         msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">18</span>:         msgInner.setStoreTimestamp(msgExt.getStoreTimestamp());</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             msgInner.setBody(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">21</span>:         &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"comment\">// 存储生成消息</span></div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">final</span> MessageStore messageStore = <span class=\"keyword\">this</span>.brokerController.getMessageStore();</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">final</span> PutMessageResult putMessageResult = messageStore.putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"comment\">// 处理存储结果</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"comment\">// Success</span></div><div class=\"line\"><span class=\"number\">31</span>:                 <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">case</span> FLUSH_DISK_TIMEOUT:</div><div class=\"line\"><span class=\"number\">33</span>:                 <span class=\"keyword\">case</span> FLUSH_SLAVE_TIMEOUT:</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">case</span> SLAVE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">35</span>:                     response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">36</span>:                     response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">37</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"comment\">// Failed</span></div><div class=\"line\"><span class=\"number\">39</span>:                 <span class=\"keyword\">case</span> CREATE_MAPEDFILE_FAILED:</div><div class=\"line\"><span class=\"number\">40</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">41</span>:                     response.setRemark(<span class=\"string\">\"create maped file failed.\"</span>);</div><div class=\"line\"><span class=\"number\">42</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">43</span>:                 <span class=\"keyword\">case</span> MESSAGE_ILLEGAL:</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">case</span> PROPERTIES_SIZE_EXCEEDED:</div><div class=\"line\"><span class=\"number\">45</span>:                     response.setCode(ResponseCode.MESSAGE_ILLEGAL);</div><div class=\"line\"><span class=\"number\">46</span>:                     response.setRemark(<span class=\"string\">\"the message is illegal, maybe msg body or properties length not matched. msg body length limit 128k, msg properties length limit 32k.\"</span>);</div><div class=\"line\"><span class=\"number\">47</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">case</span> SERVICE_NOT_AVAILABLE:</div><div class=\"line\"><span class=\"number\">49</span>:                     response.setCode(ResponseCode.SERVICE_NOT_AVAILABLE);</div><div class=\"line\"><span class=\"number\">50</span>:                     response.setRemark(<span class=\"string\">\"service not available now.\"</span>);</div><div class=\"line\"><span class=\"number\">51</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">52</span>:                 <span class=\"keyword\">case</span> OS_PAGECACHE_BUSY:</div><div class=\"line\"><span class=\"number\">53</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">54</span>:                     response.setRemark(<span class=\"string\">\"OS page cache busy, please try another machine\"</span>);</div><div class=\"line\"><span class=\"number\">55</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">case</span> UNKNOWN_ERROR:</div><div class=\"line\"><span class=\"number\">57</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">58</span>:                     response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR\"</span>);</div><div class=\"line\"><span class=\"number\">59</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">60</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">61</span>:                     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">62</span>:                     response.setRemark(<span class=\"string\">\"UNKNOWN_ERROR DEFAULT\"</span>);</div><div class=\"line\"><span class=\"number\">63</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">64</span>:             &#125;</div><div class=\"line\"><span class=\"number\">65</span>: </div><div class=\"line\"><span class=\"number\">66</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">67</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">68</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">69</span>:             response.setRemark(<span class=\"string\">\"store putMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">70</span>:         &#125;</div><div class=\"line\"><span class=\"number\">71</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">72</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">73</span>:         response.setRemark(<span class=\"string\">\"find prepared transaction message failed\"</span>);</div><div class=\"line\"><span class=\"number\">74</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Broker-生成-ConsumeQueue\"><a href=\"#2-3-Broker-生成-ConsumeQueue\" class=\"headerlink\" title=\"2.3 Broker 生成 ConsumeQueue\"></a>2.3 Broker 生成 ConsumeQueue</h2><ul>\n<li>🦅 事务消息，提交（<code>COMMIT</code>）后才生成 <code>ConsumeQueue</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMessageStore.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE: <span class=\"comment\">// 非事务消息</span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE: <span class=\"comment\">// 事务消息COMMIT</span></div><div class=\"line\"> <span class=\"number\">8</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),</div><div class=\"line\"> <span class=\"number\">9</span>:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE: <span class=\"comment\">// 事务消息PREPARED</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: <span class=\"comment\">// 事务消息ROLLBACK</span></div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">14</span>:     &#125;</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 省略代码 =》 建立 索引信息 到 IndexFile</span></div><div class=\"line\"><span class=\"number\">16</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"3-事务消息回查\"><a href=\"#3-事务消息回查\" class=\"headerlink\" title=\"3. 事务消息回查\"></a>3. 事务消息回查</h1><ul>\n<li>【事务消息回查】功能曾经开源过，目前（V4.0.0）暂未开源。如下是该功能的开源情况：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>版本</th>\n<th>【事务消息回查】</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>官方V3.0.4 ~ V3.1.4</td>\n<td>基于 文件系统 实现</td>\n<td>已开源</td>\n</tr>\n<tr>\n<td>官方V3.1.5 ~ V4.0.0</td>\n<td>基于 数据库 实现</td>\n<td>未完全开源</td>\n</tr>\n</tbody>\n</table>\n<p>我们来看看两种情况下是怎么实现的。</p>\n<h2 id=\"3-1-Broker-发起【事务消息回查】\"><a href=\"#3-1-Broker-发起【事务消息回查】\" class=\"headerlink\" title=\"3.1 Broker 发起【事务消息回查】\"></a>3.1 Broker 发起【事务消息回查】</h2><h3 id=\"3-1-1-官方V3-1-4：基于文件系统\"><a href=\"#3-1-1-官方V3-1-4：基于文件系统\" class=\"headerlink\" title=\"3.1.1 官方V3.1.4：基于文件系统\"></a>3.1.1 官方V3.1.4：基于文件系统</h3><blockquote>\n<p>仓库地址：<a href=\"https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/rocketmq-3.1.9/tree/release_3.1.4</a></p>\n</blockquote>\n<p>相较于普通消息，【事务消息】多依赖如下三个组件：</p>\n<ul>\n<li><strong>TransactionStateService</strong> ：事务状态服务，负责对【事务消息】进行管理，包括存储与更新事务消息状态、回查事务消息状态等等。</li>\n<li><strong>TranStateTable</strong> ：【事务消息】状态存储。基于 <code>MappedFileQueue</code> 实现，默认存储路径为 <code>~/store/transaction/statetable</code>，每条【事务消息】状态存储结构如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">offset</td>\n<td style=\"text-align:left\">CommitLog 物理存储位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">消息长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">timestamp</td>\n<td style=\"text-align:left\">消息存储时间，单位：秒</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">producerGroupHash</td>\n<td style=\"text-align:left\">producerGroup 求 HashCode</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">state</td>\n<td style=\"text-align:left\">事务状态</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>TranRedoLog</strong> ：<code>TranStateTable</code> 重放日志，每次<strong>写操作</strong> <code>TranStateTable</code> 记录重放日志。当 <code>Broker</code> 异常关闭时，使用 <code>TranRedoLog</code> 恢复 <code>TranStateTable</code>。基于 <code>ConsumeQueue</code> 实现，<code>Topic</code> 为 <code>TRANSACTION_REDOLOG_TOPIC_XXXX</code>，默认存储路径为 <code>~/store/transaction/redolog</code>。</li>\n</ul>\n<hr>\n<p>简单手绘逻辑图如下😈：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/01.jpeg\" alt=\"Broker_V3.1.4_基于文件系统\"></p>\n<h4 id=\"3-1-1-1-存储消息到-CommitLog\"><a href=\"#3-1-1-1-存储消息到-CommitLog\" class=\"headerlink\" title=\"3.1.1.1 存储消息到 CommitLog\"></a>3.1.1.1 存储消息到 CommitLog</h4><ul>\n<li>🦅存储【half消息】到 <code>CommitLog</code> 时，消息队列位置（<code>queueOffset</code>）使用 <code>TranStateTable</code> 最大物理位置（可写入物理位置）。这样，消息可以索引到自己对应的 <code>TranStateTable</code> 的位置和记录。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultAppendMessageCallback.java】</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAppendMessageCallback</span> <span class=\"keyword\">implements</span> <span class=\"title\">AppendMessageCallback</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"function\"><span class=\"keyword\">public</span> AppendMessageResult <span class=\"title\">doAppend</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> fileFromOffset, <span class=\"keyword\">final</span> ByteBuffer byteBuffer,  <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxBlank, <span class=\"keyword\">final</span> Object msg)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"comment\">// 事务消息需要特殊处理 </span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType: <span class=\"comment\">// 消息队列位置（queueOffset）使用 TranStateTable 最大物理位置（可写入物理位置） </span></div><div class=\"line\"><span class=\"number\">10</span>:             queueOffset = CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().get();</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">13</span>:             queueOffset = msgInner.getQueueOffset();</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>: </div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:         <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// 更新 TranStateTable 最大物理位置（可写入物理位置） </span></div><div class=\"line\"><span class=\"number\">26</span>:             CommitLog.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionStateService().getTranStateTableOffset().incrementAndGet();</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"comment\">// 更新下一次的ConsumeQueue信息</span></div><div class=\"line\"><span class=\"number\">33</span>:             CommitLog.<span class=\"keyword\">this</span>.topicQueueTable.put(key, ++queueOffset);</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>: </div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"comment\">// 返回结果</span></div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-2-写【事务消息】状态存储（TranStateTable）\"><a href=\"#3-1-1-2-写【事务消息】状态存储（TranStateTable）\" class=\"headerlink\" title=\"3.1.1.2 写【事务消息】状态存储（TranStateTable）\"></a>3.1.1.2 写【事务消息】状态存储（TranStateTable）</h4><ul>\n<li>🦅处理【Half消息】时，新增【事务消息】状态存储（<code>TranStateTable</code>）。</li>\n<li>🦅处理【Commit / Rollback消息】时，更新 【事务消息】状态存储（<code>TranStateTable</code>） COMMIT / ROLLBACK。</li>\n<li>🦅每次<strong>写操作【</strong>事务消息】状态存储（<code>TranStateTable</code>），记录重放日志（<code>TranRedoLog</code>）。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DispatchMessageService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.requestsRead.isEmpty()) &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:         <span class=\"keyword\">for</span> (DispatchRequest req : <span class=\"keyword\">this</span>.requestsRead) &#123;</div><div class=\"line\">  <span class=\"number\">5</span>: </div><div class=\"line\">  <span class=\"number\">6</span>:             <span class=\"comment\">// ...省略代码</span></div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:             <span class=\"comment\">// 2、写【事务消息】状态存储（TranStateTable）</span></div><div class=\"line\">  <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (req.getProducerGroup() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:                 <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"> <span class=\"number\">12</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">13</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"> <span class=\"number\">14</span>:                     <span class=\"comment\">// 新增 【事务消息】状态存储（TranStateTable）</span></div><div class=\"line\"> <span class=\"number\">15</span>:                     DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().appendPreparedTransaction(</div><div class=\"line\"> <span class=\"number\">16</span>:                         req.getCommitLogOffset(), req.getMsgSize(), (<span class=\"keyword\">int</span>) (req.getStoreTimestamp() / <span class=\"number\">1000</span>), req.getProducerGroup().hashCode());</div><div class=\"line\"> <span class=\"number\">17</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"> <span class=\"number\">19</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"> <span class=\"number\">20</span>:                     <span class=\"comment\">// 更新 【事务消息】状态存储（TranStateTable） COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">21</span>:                     DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().updateTransactionState(</div><div class=\"line\"> <span class=\"number\">22</span>:                         req.getTranStateTableOffset(), req.getPreparedTransactionOffset(), req.getProducerGroup().hashCode(), tranType);</div><div class=\"line\"> <span class=\"number\">23</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">25</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">26</span>:             <span class=\"comment\">// 3、记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionNotType:</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(</div><div class=\"line\"> <span class=\"number\">33</span>:                         req.getCommitLogOffset(), req.getMsgSize(), TransactionStateService.PreparedMessageTagsCode,</div><div class=\"line\"> <span class=\"number\">34</span>:                         req.getStoreTimestamp(), <span class=\"number\">0L</span>);</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">36</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"> <span class=\"number\">38</span>:                 <span class=\"comment\">// 记录 TranRedoLog</span></div><div class=\"line\"> <span class=\"number\">39</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getTransactionStateService().getTranRedoLog().putMessagePostionInfoWrapper(</div><div class=\"line\"> <span class=\"number\">40</span>:                         req.getCommitLogOffset(), req.getMsgSize(), req.getPreparedTransactionOffset(),</div><div class=\"line\"> <span class=\"number\">41</span>:                         req.getStoreTimestamp(), <span class=\"number\">0L</span>);</div><div class=\"line\"> <span class=\"number\">42</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">43</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">44</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"comment\">// ...省略代码</span></div><div class=\"line\"> <span class=\"number\">47</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>: &#125;</div><div class=\"line\"> <span class=\"number\">49</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\"> <span class=\"number\">50</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 51:  * 新增事务状态</div><div class=\"line\"> 52:  *</div><div class=\"line\"> 53:  * <span class=\"doctag\">@param</span> clOffset commitLog 物理位置</div><div class=\"line\"> 54:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\"> 55:  * <span class=\"doctag\">@param</span> timestamp 消息存储时间</div><div class=\"line\"> 56:  * <span class=\"doctag\">@param</span> groupHashCode groupHashCode</div><div class=\"line\"> 57:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\"> 58:  */</div><div class=\"line\"> <span class=\"number\">59</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">appendPreparedTransaction</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">60</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset,//</div><div class=\"line\"> <span class=\"number\">61</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size,//</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timestamp,//</div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode//</div><div class=\"line\"> <span class=\"number\">64</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:     MapedFile mapedFile = <span class=\"keyword\">this</span>.tranStateTable.getLastMapedFile();</div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mapedFile) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:         log.error(<span class=\"string\">\"appendPreparedTransaction: create mapedfile error.\"</span>);</div><div class=\"line\"> <span class=\"number\">68</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:     <span class=\"comment\">// 首次创建，加入定时任务中</span></div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == mapedFile.getWrotePostion()) &#123;</div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">this</span>.addTimerTask(mapedFile);</div><div class=\"line\"> <span class=\"number\">74</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">75</span>: </div><div class=\"line\"> <span class=\"number\">76</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.position(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">77</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.limit(TSStoreUnitSize);</div><div class=\"line\"> <span class=\"number\">78</span>: </div><div class=\"line\"> <span class=\"number\">79</span>:     <span class=\"comment\">// Commit Log Offset</span></div><div class=\"line\"> <span class=\"number\">80</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putLong(clOffset);</div><div class=\"line\"> <span class=\"number\">81</span>:     <span class=\"comment\">// Message Size</span></div><div class=\"line\"> <span class=\"number\">82</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(size);</div><div class=\"line\"> <span class=\"number\">83</span>:     <span class=\"comment\">// Timestamp</span></div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(timestamp);</div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"comment\">// Producer Group Hashcode</span></div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(groupHashCode);</div><div class=\"line\"> <span class=\"number\">87</span>:     <span class=\"comment\">// Transaction State</span></div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"keyword\">this</span>.byteBufferAppend.putInt(MessageSysFlag.TransactionPreparedType);</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:     <span class=\"keyword\">return</span> mapedFile.appendMessage(<span class=\"keyword\">this</span>.byteBufferAppend.array());</div><div class=\"line\"> <span class=\"number\">91</span>: &#125;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 94:  * 更新事务状态</div><div class=\"line\"> 95:  *</div><div class=\"line\"> 96:  * <span class=\"doctag\">@param</span> tsOffset tranStateTable 物理位置</div><div class=\"line\"> 97:  * <span class=\"doctag\">@param</span> clOffset commitLog 物理位置</div><div class=\"line\"> 98:  * <span class=\"doctag\">@param</span> groupHashCode groupHashCode</div><div class=\"line\"> 99:  * <span class=\"doctag\">@param</span> state 事务状态</div><div class=\"line\">100:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">101:  */</div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateTransactionState</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tsOffset,</div><div class=\"line\"><span class=\"number\">104</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset,</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode,</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> state) &#123;</div><div class=\"line\"><span class=\"number\">107</span>:     SelectMapedBufferResult selectMapedBufferResult = <span class=\"keyword\">this</span>.findTransactionBuffer(tsOffset);</div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"keyword\">if</span> (selectMapedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">110</span>: </div><div class=\"line\"><span class=\"number\">111</span>:             <span class=\"comment\">// ....省略代码：校验是否能够更新</span></div><div class=\"line\"><span class=\"number\">112</span>: </div><div class=\"line\"><span class=\"number\">113</span>:             <span class=\"comment\">// 更新事务状态</span></div><div class=\"line\"><span class=\"number\">114</span>:             selectMapedBufferResult.getByteBuffer().putInt(TS_STATE_POS, state);</div><div class=\"line\"><span class=\"number\">115</span>:         &#125;</div><div class=\"line\"><span class=\"number\">116</span>:         <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">117</span>:             log.error(<span class=\"string\">\"updateTransactionState exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">118</span>:         &#125;</div><div class=\"line\"><span class=\"number\">119</span>:         <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">120</span>:             selectMapedBufferResult.release();</div><div class=\"line\"><span class=\"number\">121</span>:         &#125;</div><div class=\"line\"><span class=\"number\">122</span>:     &#125;</div><div class=\"line\"><span class=\"number\">123</span>: </div><div class=\"line\"><span class=\"number\">124</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">125</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-3-【事务消息】回查\"><a href=\"#3-1-1-3-【事务消息】回查\" class=\"headerlink\" title=\"3.1.1.3 【事务消息】回查\"></a>3.1.1.3 【事务消息】回查</h4><ul>\n<li>🦅<code>TranStateTable</code> 每个 <code>MappedFile</code> 都对应一个 <code>Timer</code>。<code>Timer</code> 固定周期（默认：60s）遍历 <code>MappedFile</code>，查找【half消息】，向 <code>Producer</code> 发起【事务消息】回查请求。【事务消息】回查结果的逻辑不在此处进行，在 <a href=\"#3112-写事务消息状态存储transtatetable\">CommitLog dispatch</a>时执行。</li>\n</ul>\n<p>实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 初始化定时任务</div><div class=\"line\">  4:  */</div><div class=\"line\">  <span class=\"number\">5</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initTimerTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"comment\">//</span></div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> List&lt;MapedFile&gt; mapedFiles = <span class=\"keyword\">this</span>.tranStateTable.getMapedFiles();</div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"keyword\">for</span> (MapedFile mf : mapedFiles) &#123;</div><div class=\"line\">  <span class=\"number\">9</span>:         <span class=\"keyword\">this</span>.addTimerTask(mf);</div><div class=\"line\"> <span class=\"number\">10</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">11</span>: &#125;</div><div class=\"line\"> <span class=\"number\">12</span>: </div><div class=\"line\"> <span class=\"number\">13</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 14:  * 每个文件初始化定时任务</div><div class=\"line\"> 15:  * <span class=\"doctag\">@param</span> mf 文件</div><div class=\"line\"> 16:  */</div><div class=\"line\"> <span class=\"number\">17</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addTimerTask</span><span class=\"params\">(<span class=\"keyword\">final</span> MapedFile mf)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:     <span class=\"keyword\">this</span>.timer.scheduleAtFixedRate(<span class=\"keyword\">new</span> TimerTask() &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MapedFile mapedFile = mf;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TransactionCheckExecuter transactionCheckExecuter = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getTransactionCheckExecuter();</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> checkTransactionMessageAtleastInterval = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig()</div><div class=\"line\"> <span class=\"number\">22</span>:                     .getCheckTransactionMessageAtleastInterval();</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> slave = TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">26</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"comment\">// Slave不需要回查事务状态</span></div><div class=\"line\"> <span class=\"number\">28</span>:             <span class=\"keyword\">if</span> (slave) &#123;</div><div class=\"line\"> <span class=\"number\">29</span>:                 <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">31</span>:             <span class=\"comment\">// Check功能是否开启</span></div><div class=\"line\"> <span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (!TransactionStateService.<span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig()</div><div class=\"line\"> <span class=\"number\">33</span>:                 .isCheckTransactionMessageEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">35</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">36</span>: </div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 SelectMapedBufferResult selectMapedBufferResult = mapedFile.selectMapedBuffer(<span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">39</span>:                 <span class=\"keyword\">if</span> (selectMapedBufferResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">long</span> preparedMessageCountInThisMapedFile = <span class=\"number\">0</span>; <span class=\"comment\">// 回查的【half消息】数量</span></div><div class=\"line\"> <span class=\"number\">41</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">42</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                         <span class=\"comment\">// 循环每条【事务消息】状态，对【half消息】进行回查</span></div><div class=\"line\"> <span class=\"number\">44</span>:                         <span class=\"keyword\">for</span> (; i &lt; selectMapedBufferResult.getSize(); i += TSStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">45</span>:                             selectMapedBufferResult.getByteBuffer().position(i);</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:                             <span class=\"comment\">// Commit Log Offset</span></div><div class=\"line\"> <span class=\"number\">48</span>:                             <span class=\"keyword\">long</span> clOffset = selectMapedBufferResult.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">49</span>:                             <span class=\"comment\">// Message Size</span></div><div class=\"line\"> <span class=\"number\">50</span>:                             <span class=\"keyword\">int</span> msgSize = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">51</span>:                             <span class=\"comment\">// Timestamp</span></div><div class=\"line\"> <span class=\"number\">52</span>:                             <span class=\"keyword\">int</span> timestamp = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">53</span>:                             <span class=\"comment\">// Producer Group Hashcode</span></div><div class=\"line\"> <span class=\"number\">54</span>:                             <span class=\"keyword\">int</span> groupHashCode = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">55</span>:                             <span class=\"comment\">// Transaction State</span></div><div class=\"line\"> <span class=\"number\">56</span>:                             <span class=\"keyword\">int</span> tranType = selectMapedBufferResult.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:                             <span class=\"comment\">// 已经提交或者回滚的消息跳过</span></div><div class=\"line\"> <span class=\"number\">59</span>:                             <span class=\"keyword\">if</span> (tranType != MessageSysFlag.TransactionPreparedType) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">61</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:                             <span class=\"comment\">// 遇到时间不符合最小轮询间隔，终止</span></div><div class=\"line\"> <span class=\"number\">64</span>:                             <span class=\"keyword\">long</span> timestampLong = timestamp * <span class=\"number\">1000</span>;</div><div class=\"line\"> <span class=\"number\">65</span>:                             <span class=\"keyword\">long</span> diff = System.currentTimeMillis() - timestampLong;</div><div class=\"line\"> <span class=\"number\">66</span>:                             <span class=\"keyword\">if</span> (diff &lt; checkTransactionMessageAtleastInterval) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">68</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: </div><div class=\"line\"> <span class=\"number\">70</span>:                             preparedMessageCountInThisMapedFile++;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:                             <span class=\"comment\">// 回查Producer</span></div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                                 <span class=\"keyword\">this</span>.transactionCheckExecuter.gotoCheck(groupHashCode, getTranStateOffset(i), clOffset, msgSize);</div><div class=\"line\"> <span class=\"number\">75</span>:                             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                                 tranlog.warn(<span class=\"string\">\"gotoCheck Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">77</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>:                         <span class=\"comment\">// 无回查的【half消息】数量，且遍历完，则终止定时任务</span></div><div class=\"line\"> <span class=\"number\">81</span>:                         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == preparedMessageCountInThisMapedFile <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">82</span>:                                 &amp;&amp; i == mapedFile.getFileSize()) &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:                             tranlog.info(<span class=\"string\">\"remove the transaction timer task, because no prepared message in this mapedfile[&#123;&#125;]\"</span>, mapedFile.getFileName());</div><div class=\"line\"> <span class=\"number\">84</span>:                             <span class=\"keyword\">this</span>.cancel();</div><div class=\"line\"> <span class=\"number\">85</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:                     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:                         selectMapedBufferResult.release();</div><div class=\"line\"> <span class=\"number\">88</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">89</span>: </div><div class=\"line\"> <span class=\"number\">90</span>:                     tranlog.info(<span class=\"string\">\"the transaction timer task execute over in this period, &#123;&#125; Prepared Message: &#123;&#125; Check Progress: &#123;&#125;/&#123;&#125;\"</span>, mapedFile.getFileName(),<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">91</span>:                             preparedMessageCountInThisMapedFile, i / TSStoreUnitSize, mapedFile.getFileSize() / TSStoreUnitSize);</div><div class=\"line\"> <span class=\"number\">92</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mapedFile.isFull()) &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:                     tranlog.info(<span class=\"string\">\"the mapedfile[&#123;&#125;] maybe deleted, cancel check transaction timer task\"</span>, mapedFile.getFileName());</div><div class=\"line\"> <span class=\"number\">94</span>:                     <span class=\"keyword\">this</span>.cancel();</div><div class=\"line\"> <span class=\"number\">95</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">96</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 log.error(<span class=\"string\">\"check transaction timer task Exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">99</span>:             &#125;</div><div class=\"line\"><span class=\"number\">100</span>:         &#125;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">getTranStateOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> currentIndex)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">104</span>:             <span class=\"keyword\">long</span> offset = (<span class=\"keyword\">this</span>.mapedFile.getFileFromOffset() + currentIndex) / TransactionStateService.TSStoreUnitSize;</div><div class=\"line\"><span class=\"number\">105</span>:             <span class=\"keyword\">return</span> offset;</div><div class=\"line\"><span class=\"number\">106</span>:         &#125;</div><div class=\"line\"><span class=\"number\">107</span>:     &#125;, <span class=\"number\">1000</span> * <span class=\"number\">60</span>, <span class=\"keyword\">this</span>.defaultMessageStore.getMessageStoreConfig().getCheckTransactionMessageTimerInterval());</div><div class=\"line\"><span class=\"number\">108</span>: &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>: <span class=\"comment\">// 【DefaultTransactionCheckExecuter.java】</span></div><div class=\"line\"><span class=\"number\">111</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">112</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotoCheck</span><span class=\"params\">(<span class=\"keyword\">int</span> producerGroupHashCode, <span class=\"keyword\">long</span> tranStateTableOffset, <span class=\"keyword\">long</span> commitLogOffset,</span></span></div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"keyword\">int</span> msgSize) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:     <span class=\"comment\">// 第一步、查询Producer</span></div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"keyword\">final</span> ClientChannelInfo clientChannelInfo = <span class=\"keyword\">this</span>.brokerController.getProducerManager().pickProducerChannelRandomly(producerGroupHashCode);</div><div class=\"line\"><span class=\"number\">116</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == clientChannelInfo) &#123;</div><div class=\"line\"><span class=\"number\">117</span>:         log.warn(<span class=\"string\">\"check a producer transaction state, but not find any channel of this group[&#123;&#125;]\"</span>, producerGroupHashCode);</div><div class=\"line\"><span class=\"number\">118</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"comment\">// 第二步、查询消息</span></div><div class=\"line\"><span class=\"number\">122</span>:     SelectMapedBufferResult selectMapedBufferResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().selectOneMessageByOffset(commitLogOffset, msgSize);</div><div class=\"line\"><span class=\"number\">123</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == selectMapedBufferResult) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:         log.warn(<span class=\"string\">\"check a producer transaction state, but not find message by commitLogOffset: &#123;&#125;, msgSize: \"</span>, commitLogOffset, msgSize);</div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">126</span>:     &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// 第三步、向Producer发起请求</span></div><div class=\"line\"><span class=\"number\">129</span>:     <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader requestHeader = <span class=\"keyword\">new</span> CheckTransactionStateRequestHeader();</div><div class=\"line\"><span class=\"number\">130</span>:     requestHeader.setCommitLogOffset(commitLogOffset);</div><div class=\"line\"><span class=\"number\">131</span>:     requestHeader.setTranStateTableOffset(tranStateTableOffset);</div><div class=\"line\"><span class=\"number\">132</span>:     <span class=\"keyword\">this</span>.brokerController.getBroker2Client().checkProducerTransactionState(clientChannelInfo.getChannel(), requestHeader, selectMapedBufferResult);</div><div class=\"line\"><span class=\"number\">133</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-4-初始化【事务消息】状态存储（TranStateTable）\"><a href=\"#3-1-1-4-初始化【事务消息】状态存储（TranStateTable）\" class=\"headerlink\" title=\"3.1.1.4 初始化【事务消息】状态存储（TranStateTable）\"></a>3.1.1.4 初始化【事务消息】状态存储（TranStateTable）</h4><ul>\n<li>🦅根据最后 Broker 关闭是否正常，会有不同的初始化方式。</li>\n</ul>\n<p>核心代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【TransactionStateService.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 初始化 TranRedoLog</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> lastExitOK 是否正常退出</div><div class=\"line\">  5:  */</div><div class=\"line\">  <span class=\"number\">6</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">recoverStateTable</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> lastExitOK)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (lastExitOK) &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:         <span class=\"keyword\">this</span>.recoverStateTableNormal();</div><div class=\"line\">  <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">10</span>:         <span class=\"comment\">// 第一步，删除State Table</span></div><div class=\"line\"> <span class=\"number\">11</span>:         <span class=\"keyword\">this</span>.tranStateTable.destroy();</div><div class=\"line\"> <span class=\"number\">12</span>:         <span class=\"comment\">// 第二步，通过RedoLog全量恢复StateTable</span></div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.recreateStateTable();</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: &#125;</div><div class=\"line\"> <span class=\"number\">16</span>: </div><div class=\"line\"> <span class=\"number\">17</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 18:  * 扫描 TranRedoLog 重建 StateTable</div><div class=\"line\"> 19:  */</div><div class=\"line\"> <span class=\"number\">20</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recreateStateTable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">this</span>.tranStateTable = <span class=\"keyword\">new</span> MapedFileQueue(StorePathConfigHelper.getTranStateTableStorePath(defaultMessageStore</div><div class=\"line\"> <span class=\"number\">22</span>:                 .getMessageStoreConfig().getStorePathRootDir()), defaultMessageStore</div><div class=\"line\"> <span class=\"number\">23</span>:                 .getMessageStoreConfig().getTranStateTableMapedFileSize(), <span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">final</span> TreeSet&lt;Long&gt; preparedItemSet = <span class=\"keyword\">new</span> TreeSet&lt;Long&gt;();</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">// 第一步，从头扫描RedoLog</span></div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> minOffset = <span class=\"keyword\">this</span>.tranRedoLog.getMinOffsetInQuque();</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">long</span> processOffset = minOffset;</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"> <span class=\"number\">31</span>:         SelectMapedBufferResult bufferConsumeQueue = <span class=\"keyword\">this</span>.tranRedoLog.getIndexBuffer(processOffset);</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (bufferConsumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">33</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:                 <span class=\"keyword\">long</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize(); i += ConsumeQueue.CQStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">36</span>:                     <span class=\"keyword\">long</span> offsetMsg = bufferConsumeQueue.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">37</span>:                     <span class=\"keyword\">int</span> sizeMsg = bufferConsumeQueue.getByteBuffer().getInt();</div><div class=\"line\"> <span class=\"number\">38</span>:                     <span class=\"keyword\">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:                     <span class=\"keyword\">if</span> (TransactionStateService.PreparedMessageTagsCode == tagsCode) &#123; <span class=\"comment\">// Prepared</span></div><div class=\"line\"> <span class=\"number\">41</span>:                         preparedItemSet.add(offsetMsg);</div><div class=\"line\"> <span class=\"number\">42</span>:                     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// Commit/Rollback</span></div><div class=\"line\"> <span class=\"number\">43</span>:                         preparedItemSet.remove(tagsCode);</div><div class=\"line\"> <span class=\"number\">44</span>:                     &#125;</div><div class=\"line\"> <span class=\"number\">45</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">46</span>: </div><div class=\"line\"> <span class=\"number\">47</span>:                 processOffset += i;</div><div class=\"line\"> <span class=\"number\">48</span>:             &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// 必须释放资源</span></div><div class=\"line\"> <span class=\"number\">49</span>:                 bufferConsumeQueue.release();</div><div class=\"line\"> <span class=\"number\">50</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">51</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">53</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:     log.info(<span class=\"string\">\"scan transaction redolog over, End offset: &#123;&#125;,  Prepared Transaction Count: &#123;&#125;\"</span>, processOffset, preparedItemSet.size());</div><div class=\"line\"> <span class=\"number\">56</span>: </div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"comment\">// 第二步，重建StateTable</span></div><div class=\"line\"> <span class=\"number\">58</span>:     Iterator&lt;Long&gt; it = preparedItemSet.iterator();</div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:         Long offset = it.next();</div><div class=\"line\"> <span class=\"number\">61</span>:         MessageExt msgExt = <span class=\"keyword\">this</span>.defaultMessageStore.lookMessageByOffset(offset);</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">if</span> (msgExt != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:             <span class=\"keyword\">this</span>.appendPreparedTransaction(msgExt.getCommitLogOffset(), msgExt.getStoreSize(),</div><div class=\"line\"> <span class=\"number\">64</span>:                 (<span class=\"keyword\">int</span>) (msgExt.getStoreTimestamp() / <span class=\"number\">1000</span>),</div><div class=\"line\"> <span class=\"number\">65</span>:                 msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP).hashCode());</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">this</span>.tranStateTableOffset.incrementAndGet();</div><div class=\"line\"> <span class=\"number\">67</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">69</span>: &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 72:  * 加载（解析）TranStateTable 的 MappedFile</div><div class=\"line\"> 73:  * 1. 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position</div><div class=\"line\"> 74:  * 2. 设置 TanStateTable 最大物理位置（可写入位置）</div><div class=\"line\"> 75:  */</div><div class=\"line\"> <span class=\"number\">76</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">recoverStateTableNormal</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">77</span>:     <span class=\"keyword\">final</span> List&lt;MapedFile&gt; mapedFiles = <span class=\"keyword\">this</span>.tranStateTable.getMapedFiles();</div><div class=\"line\"> <span class=\"number\">78</span>:     <span class=\"keyword\">if</span> (!mapedFiles.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"comment\">// 从倒数第三个文件开始恢复</span></div><div class=\"line\"> <span class=\"number\">80</span>:         <span class=\"keyword\">int</span> index = mapedFiles.size() - <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"number\">81</span>:         <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>:             index = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>: </div><div class=\"line\"> <span class=\"number\">85</span>:         <span class=\"keyword\">int</span> mapedFileSizeLogics = <span class=\"keyword\">this</span>.tranStateTable.getMapedFileSize();</div><div class=\"line\"> <span class=\"number\">86</span>:         MapedFile mapedFile = mapedFiles.get(index);</div><div class=\"line\"> <span class=\"number\">87</span>:         ByteBuffer byteBuffer = mapedFile.sliceByteBuffer();</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">long</span> processOffset = mapedFile.getFileFromOffset();</div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">long</span> mapedFileOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mapedFileSizeLogics; i += TSStoreUnitSize) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> clOffset_read = byteBuffer.getLong();</div><div class=\"line\"> <span class=\"number\">94</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">95</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timestamp_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">96</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> groupHashCode_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">97</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> state_read = byteBuffer.getInt();</div><div class=\"line\"> <span class=\"number\">98</span>: </div><div class=\"line\"> <span class=\"number\">99</span>:                 <span class=\"keyword\">boolean</span> stateOK = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">switch</span> (state_read) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionPreparedType:</div><div class=\"line\"><span class=\"number\">102</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionCommitType:</div><div class=\"line\"><span class=\"number\">103</span>:                 <span class=\"keyword\">case</span> MessageSysFlag.TransactionRollbackType:</div><div class=\"line\"><span class=\"number\">104</span>:                     stateOK = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">105</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">107</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">108</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                 <span class=\"comment\">// 说明当前存储单元有效</span></div><div class=\"line\"><span class=\"number\">111</span>:                 <span class=\"keyword\">if</span> (clOffset_read &gt;= <span class=\"number\">0</span> &amp;&amp; size_read &gt; <span class=\"number\">0</span> &amp;&amp; stateOK) &#123;</div><div class=\"line\"><span class=\"number\">112</span>:                     mapedFileOffset = i + TSStoreUnitSize;</div><div class=\"line\"><span class=\"number\">113</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">114</span>:                     log.info(<span class=\"string\">\"recover current transaction state table file over,  \"</span> + mapedFile.getFileName() + <span class=\"string\">\" \"</span></div><div class=\"line\"><span class=\"number\">115</span>:                             + clOffset_read + <span class=\"string\">\" \"</span> + size_read + <span class=\"string\">\" \"</span> + timestamp_read);</div><div class=\"line\"><span class=\"number\">116</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">118</span>:             &#125;</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:             <span class=\"comment\">// 走到文件末尾，切换至下一个文件</span></div><div class=\"line\"><span class=\"number\">121</span>:             <span class=\"keyword\">if</span> (mapedFileOffset == mapedFileSizeLogics) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:                 index++;</div><div class=\"line\"><span class=\"number\">123</span>:                 <span class=\"keyword\">if</span> (index &gt;= mapedFiles.size()) &#123; <span class=\"comment\">// 循环while结束</span></div><div class=\"line\"><span class=\"number\">124</span>:                     log.info(<span class=\"string\">\"recover last transaction state table file over, last maped file \"</span> + mapedFile.getFileName());</div><div class=\"line\"><span class=\"number\">125</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">126</span>:                 &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 切换下一个文件</span></div><div class=\"line\"><span class=\"number\">127</span>:                     mapedFile = mapedFiles.get(index);</div><div class=\"line\"><span class=\"number\">128</span>:                     byteBuffer = mapedFile.sliceByteBuffer();</div><div class=\"line\"><span class=\"number\">129</span>:                     processOffset = mapedFile.getFileFromOffset();</div><div class=\"line\"><span class=\"number\">130</span>:                     mapedFileOffset = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">131</span>:                     log.info(<span class=\"string\">\"recover next transaction state table file, \"</span> + mapedFile.getFileName());</div><div class=\"line\"><span class=\"number\">132</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">133</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">134</span>:                 log.info(<span class=\"string\">\"recover current transaction state table queue over \"</span> + mapedFile.getFileName() + <span class=\"string\">\" \"</span> + (processOffset + mapedFileOffset));</div><div class=\"line\"><span class=\"number\">135</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">136</span>:             &#125;</div><div class=\"line\"><span class=\"number\">137</span>:         &#125;</div><div class=\"line\"><span class=\"number\">138</span>: </div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"comment\">// 清理多余 MappedFile，设置最后一个 MappedFile的写入位置(position</span></div><div class=\"line\"><span class=\"number\">140</span>:         processOffset += mapedFileOffset;</div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">this</span>.tranStateTable.truncateDirtyFiles(processOffset);</div><div class=\"line\"><span class=\"number\">142</span>: </div><div class=\"line\"><span class=\"number\">143</span>:         <span class=\"comment\">// 设置 TanStateTable 最大物理位置（可写入位置）</span></div><div class=\"line\"><span class=\"number\">144</span>:         <span class=\"keyword\">this</span>.tranStateTableOffset.set(<span class=\"keyword\">this</span>.tranStateTable.getMaxOffset() / TSStoreUnitSize);</div><div class=\"line\"><span class=\"number\">145</span>:         log.info(<span class=\"string\">\"recover normal over, transaction state table max offset: &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.tranStateTableOffset.get());</div><div class=\"line\"><span class=\"number\">146</span>:     &#125;</div><div class=\"line\"><span class=\"number\">147</span>: &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-1-1-5-补充\"><a href=\"#3-1-1-5-补充\" class=\"headerlink\" title=\"3.1.1.5 补充\"></a>3.1.1.5 补充</h4><ul>\n<li>为什么 V3.1.5 开始，使用 数据库 实现【事务状态】的存储？如下是来自官方文档的说明，可能是一部分原因：</li>\n</ul>\n<blockquote>\n<p>RocketMQ 这种实现事务方式，没有通过 KV 存储做，而是通过 Offset 方式，存在一个显著缺陷，即通过 Offset 更改数据，会令系统的脏页过多，需要特别关注。</p>\n</blockquote>\n<h3 id=\"3-1-2-官方V4-0-0：基于数据库\"><a href=\"#3-1-2-官方V4-0-0：基于数据库\" class=\"headerlink\" title=\"3.1.2 官方V4.0.0：基于数据库\"></a>3.1.2 官方V4.0.0：基于数据库</h3><blockquote>\n<p>仓库地址：<a href=\"https://github.com/apache/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/apache/incubator-rocketmq</a></p>\n</blockquote>\n<p>官方V4.0.0 暂时未<strong>完全</strong>开源【事务消息回查】功能，<strong>So 我们需要进行一些猜想，可能不一定正确😈</strong>。</p>\n<p>😆我们来对比【官方V3.1.4：基于文件】的实现。</p>\n<ul>\n<li>TransactionRecord ：记录每条【事务消息】。类似 <code>TranStateTable</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>TranStateTable</th>\n<th>TransactionRecord</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>offset</td>\n<td>offset</td>\n<td></td>\n</tr>\n<tr>\n<td>producerGroupHash</td>\n<td>producerGroup</td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>无</td>\n<td>非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。</td>\n</tr>\n<tr>\n<td>timestamp</td>\n<td>无</td>\n<td>非必须字段：【事务消息】回查时，使用 offset 读取 CommitLog 获得。</td>\n</tr>\n<tr>\n<td>state</td>\n<td>无</td>\n<td>非必须字段： 事务开始，增加记录；事务结束，删除记录。</td>\n</tr>\n</tbody>\n</table>\n<p>另外，数据库本身保证了数据存储的可靠性，无需 <code>TranRedoLog</code>。</p>\n<hr>\n<p>简单手绘逻辑图如下😈：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/02.jpeg\" alt=\"Broker_V4.0.0_基于数据库\"></p>\n<h2 id=\"3-2-Producer-接收【事务消息回查】\"><a href=\"#3-2-Producer-接收【事务消息回查】\" class=\"headerlink\" title=\"3.2 Producer 接收【事务消息回查】\"></a>3.2 Producer 接收【事务消息回查】</h2><ul>\n<li>顺序图如下：</li>\n</ul>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_21/04.png\" alt=\"Producer接收【事务消息回查】\"></p>\n<ul>\n<li>核心代码如下：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\">  <span class=\"number\">2</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  3:  * 检查【事务状态】状态</div><div class=\"line\">  4:  *</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> addr broker地址</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> header 请求</div><div class=\"line\">  8:  */</div><div class=\"line\">  <span class=\"number\">9</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkTransactionState</span><span class=\"params\">(<span class=\"keyword\">final</span> String addr, <span class=\"keyword\">final</span> MessageExt msg, <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader header)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">11</span>:     Runnable request = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String brokerAddr = addr;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageExt message = msg;</div><div class=\"line\"> <span class=\"number\">14</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CheckTransactionStateRequestHeader checkRequestHeader = header;</div><div class=\"line\"> <span class=\"number\">15</span>:         <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String group = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup();</div><div class=\"line\"> <span class=\"number\">16</span>: </div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.<span class=\"keyword\">this</span>.checkListener();</div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (transactionCheckListener != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:                 <span class=\"comment\">// 获取事务执行状态</span></div><div class=\"line\"> <span class=\"number\">22</span>:                 LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</div><div class=\"line\"> <span class=\"number\">23</span>:                 Throwable exception = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">24</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                     localTransactionState = transactionCheckListener.checkLocalTransactionState(message);</div><div class=\"line\"> <span class=\"number\">26</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">27</span>:                     log.error(<span class=\"string\">\"Broker call checkTransactionState, but checkLocalTransactionState exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">28</span>:                     exception = e;</div><div class=\"line\"> <span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">30</span>: </div><div class=\"line\"> <span class=\"number\">31</span>:                 <span class=\"comment\">// 处理事务结果，提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">32</span>:                 <span class=\"keyword\">this</span>.processTransactionState(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">33</span>:                     localTransactionState, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">34</span>:                     group, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">35</span>:                     exception);</div><div class=\"line\"> <span class=\"number\">36</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                 log.warn(<span class=\"string\">\"checkTransactionState, pick transactionCheckListener by group[&#123;&#125;] failed\"</span>, group);</div><div class=\"line\"> <span class=\"number\">38</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">39</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">40</span>: </div><div class=\"line\"> <span class=\"number\">41</span>:         <span class=\"comment\">/**</span></div><div class=\"line\"> 42:          * 处理事务结果，提交消息 COMMIT / ROLLBACK</div><div class=\"line\"> 43:          *</div><div class=\"line\"> 44:          * <span class=\"doctag\">@param</span> localTransactionState 【本地事务】状态</div><div class=\"line\"> 45:          * <span class=\"doctag\">@param</span> producerGroup producerGroup</div><div class=\"line\"> 46:          * <span class=\"doctag\">@param</span> exception 检查【本地事务】状态发生的异常</div><div class=\"line\"> 47:          */</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processTransactionState</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">49</span>:             <span class=\"keyword\">final</span> LocalTransactionState localTransactionState, //</div><div class=\"line\"> <span class=\"number\">50</span>:             <span class=\"keyword\">final</span> String producerGroup, //</div><div class=\"line\"> <span class=\"number\">51</span>:             <span class=\"keyword\">final</span> Throwable exception) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">final</span> EndTransactionRequestHeader thisHeader = <span class=\"keyword\">new</span> EndTransactionRequestHeader();</div><div class=\"line\"> <span class=\"number\">53</span>:             thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());</div><div class=\"line\"> <span class=\"number\">54</span>:             thisHeader.setProducerGroup(producerGroup);</div><div class=\"line\"> <span class=\"number\">55</span>:             thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());</div><div class=\"line\"> <span class=\"number\">56</span>:             thisHeader.setFromTransactionCheck(<span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:             <span class=\"comment\">// 设置消息编号</span></div><div class=\"line\"> <span class=\"number\">59</span>:             String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"keyword\">if</span> (uniqueKey == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">61</span>:                 uniqueKey = message.getMsgId();</div><div class=\"line\"> <span class=\"number\">62</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">63</span>:             thisHeader.setMsgId(uniqueKey);</div><div class=\"line\"> <span class=\"number\">64</span>: </div><div class=\"line\"> <span class=\"number\">65</span>:             thisHeader.setTransactionId(checkRequestHeader.getTransactionId());</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">switch</span> (localTransactionState) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                 <span class=\"keyword\">case</span> COMMIT_MESSAGE:</div><div class=\"line\"> <span class=\"number\">68</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                 <span class=\"keyword\">case</span> ROLLBACK_MESSAGE:</div><div class=\"line\"> <span class=\"number\">71</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</div><div class=\"line\"> <span class=\"number\">72</span>:                     log.warn(<span class=\"string\">\"when broker check, client rollback this transaction, &#123;&#125;\"</span>, thisHeader);</div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">case</span> UNKNOW:</div><div class=\"line\"> <span class=\"number\">75</span>:                     thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</div><div class=\"line\"> <span class=\"number\">76</span>:                     log.warn(<span class=\"string\">\"when broker check, client does not know this transaction state, &#123;&#125;\"</span>, thisHeader);</div><div class=\"line\"> <span class=\"number\">77</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">79</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:             String remark = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:             <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:                 remark = <span class=\"string\">\"checkLocalTransactionState Exception: \"</span> + RemotingHelper.exceptionSimpleDesc(exception);</div><div class=\"line\"> <span class=\"number\">85</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">86</span>: </div><div class=\"line\"> <span class=\"number\">87</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">88</span>:                 <span class=\"comment\">// 提交消息 COMMIT / ROLLBACK</span></div><div class=\"line\"> <span class=\"number\">89</span>:                 DefaultMQProducerImpl.<span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,</div><div class=\"line\"> <span class=\"number\">90</span>:                     <span class=\"number\">3000</span>);</div><div class=\"line\"> <span class=\"number\">91</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:                 log.error(<span class=\"string\">\"endTransactionOneway exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">93</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">94</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">95</span>:     &#125;;</div><div class=\"line\"> <span class=\"number\">96</span>: </div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"comment\">// 提交执行</span></div><div class=\"line\"> <span class=\"number\">98</span>:     <span class=\"keyword\">this</span>.checkExecutor.submit(request);</div><div class=\"line\"> <span class=\"number\">99</span>: &#125;</div><div class=\"line\"><span class=\"number\">100</span>: </div><div class=\"line\"><span class=\"number\">101</span>: <span class=\"comment\">// ⬇️⬇️⬇️【DefaultMQProducerImpl.java】</span></div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"comment\">/**</span></div><div class=\"line\">103:  * 【事务消息回查】检查监听器</div><div class=\"line\">104:  */</div><div class=\"line\"><span class=\"number\">105</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TransactionCheckListener</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">108:      * 获取（检查）【本地事务】状态</div><div class=\"line\">109:      *</div><div class=\"line\">110:      * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\">111:      * <span class=\"doctag\">@return</span> 事务状态</div><div class=\"line\">112:      */</div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"function\">LocalTransactionState <span class=\"title\">checkLocalTransactionState</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageExt msg)</span></span>;</div><div class=\"line\"><span class=\"number\">114</span>: </div><div class=\"line\"><span class=\"number\">115</span>: &#125;</div></pre></td></tr></table></figure>\n"},{"title":"RocketMQ 源码分析 —— Message 拉取与消费（上）","date":"2017-05-03T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-pull-and-consume-first/](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、ConsumeQueue 结构](#)\n- [3、ConsumeQueue 存储](#)\n\t- [ReputMessageService](#)\n\t\t- [DefaultMessageStore#doDispatch(...)](#)\n\t\t- [ConsumeQueue#putMessagePositionInfoWrapper(...)](#)\n\t- [FlushConsumeQueueService](#)\n- [4、Broker 提供[拉取消息]接口](#)\n\t- [PullMessageRequestHeader](#)\n\t- [PullMessageProcessor#processRequest(...)](#)\n\t- [MessageStore#getMessage(...)](#)\n\t- [DefaultMessageFilter#isMessageMatched(...)](#)\n\t- [PullRequestHoldService](#)\n\t- [PullMessageProcessor#executeRequestWhenWakeup(...)](#)\n- [5、Broker 提供[更新消费进度]接口](#)\n\t- [BrokerController#initialize(...)](#)\n\t- [ConfigManager](#)\n\t\t- [MixAll#string2File(...)](#)\n\t- [ConsumerOffsetManager](#)\n- [6、Broker 提供[发回消息]接口](#)\n\t- [SendMessageProcessor#consumerSendMsgBack(...)](#)\n- [7、结尾](#)\n\n# 1、概述\n\n本章主要解析 **消费** 逻辑涉及到的源码。\n因为篇幅较长，分成上下两篇：\n\n1. 上篇：`Broker` 相关源码。\n2. 下篇：`Consumer` 相关源码。\n\n*本文即是上篇。*\n\n-------\n\nok，先看第一张关于消费逻辑的图：\n\n> ![消费逻辑图](http://www.yunai.me/images/RocketMQ/2017_05_04/13.png)\n\n再看消费逻辑精简的顺序图（实际情况会略有差别）：\n\n> ![Consumer&Broker消费精简图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/04.png)\n\n# 2、ConsumeQueue 结构\n\n`ConsumeQueue`、`MappedFileQueue`、`MappedFile` 的关系如下：\n\n> ![ConsumeQueue、MappedFileQueue、MappedFile的关系](http://www.yunai.me/images/RocketMQ/2017_05_04/03.png)\n`ConsumeQueue` : `MappedFileQueue` : `MappedFile` = 1 : 1 : N。\n\n反应到系统文件如下：\n\n```bash\nYunai-MacdeMacBook-Pro-2:consumequeue yunai$ pwd\n/Users/yunai/store/consumequeue\nYunai-MacdeMacBook-Pro-2:consumequeue yunai$ cd TopicRead3/\nYunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ ls -ls\ntotal 0\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:52 0\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 1\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 2\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 3\nYunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ cd 0/\nYunai-MacdeMacBook-Pro-2:0 yunai$ ls -ls\ntotal 11720\n11720 -rw-r--r--  1 yunai  staff  6000000  4 27 21:55 00000000000000000000\n```\n\n-------\n\n`ConsumeQueue`、`MappedFileQueue`、`MappedFile` 的定义如下：\n\n* `MappedFile` ：00000000000000000000等文件。\n* `MappedFileQueue` ：`MappedFile` 所在的文件夹，对 `MappedFile` 进行封装成文件队列，对上层提供可无限使用的文件容量。\n    * 每个 `MappedFile` 统一文件大小。\n    * 文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 `ConsumeQueue` 里默认为 6000000B。\n* `ConsumeQueue` ：针对 `MappedFileQueue` 的封装使用。\n    * `Store : ConsumeQueue = ConcurrentHashMap<String/* topic */, ConcurrentHashMap<Integer/* queueId */, ConsumeQueue>>`。\n\n`ConsumeQueue` 存储在 `MappedFile` 的内容**必须**大小是 20B( `ConsumeQueue.CQ_STORE_UNIT_SIZE` )，有两种内容类型：\n\n1. `MESSAGE_POSITION_INFO` ：消息位置信息。\n2. `BLANK` : 文件前置空白占位。当历史 `Message` 被删除时，需要用 `BLANK`占位被删除的消息。\n\n`MESSAGE_POSITION_INFO` 在 `ConsumeQueue` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | offset | 消息 `CommitLog` 存储位置 | Long | 8 |\n| 2 | size | 消息长度 | Int | 4 |\n| 3 | tagsCode | 消息tagsCode | Long | 8 |\n\n`BLANK` 在 `ConsumeQueue` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | | 0 | Long | 8 |\n| 2 | | Integer.MAX_VALUE | Int | 4 |\n| 3 | | 0 | Long | 8 |\n\n# 3、ConsumeQueue 存储\n\n![CommitLog重放ConsumeQueue图](http://www.yunai.me/images/RocketMQ/2017_05_04/02.png)\n\n主要有两个组件：\n\n* `ReputMessageService` ：write ConsumeQueue。\n* `FlushConsumeQueueService` ：flush ConsumeQueue。\n\n## ReputMessageService\n\n![ReputMessageService顺序图](http://www.yunai.me/images/RocketMQ/2017_05_04/12.png)\n\n```Java\n  1: class ReputMessageService extends ServiceThread {\n  2: \n  3:     /**\n  4:      * 开始重放消息的CommitLog物理位置\n  5:      */\n  6:     private volatile long reputFromOffset = 0;\n  7: \n  8:     public long getReputFromOffset() {\n  9:         return reputFromOffset;\n 10:     }\n 11: \n 12:     public void setReputFromOffset(long reputFromOffset) {\n 13:         this.reputFromOffset = reputFromOffset;\n 14:     }\n 15: \n 16:     @Override\n 17:     public void shutdown() {\n 18:         for (int i = 0; i < 50 && this.isCommitLogAvailable(); i++) {\n 19:             try {\n 20:                 Thread.sleep(100);\n 21:             } catch (InterruptedException ignored) {\n 22:             }\n 23:         }\n 24: \n 25:         if (this.isCommitLogAvailable()) {\n 26:             log.warn(\"shutdown ReputMessageService, but commitlog have not finish to be dispatched, CL: {} reputFromOffset: {}\",\n 27:                 DefaultMessageStore.this.commitLog.getMaxOffset(), this.reputFromOffset);\n 28:         }\n 29: \n 30:         super.shutdown();\n 31:     }\n 32: \n 33:     /**\n 34:      * 剩余需要重放消息字节数\n 35:      *\n 36:      * @return 字节数\n 37:      */\n 38:     public long behind() {\n 39:         return DefaultMessageStore.this.commitLog.getMaxOffset() - this.reputFromOffset;\n 40:     }\n 41: \n 42:     /**\n 43:      * 是否commitLog需要重放消息\n 44:      *\n 45:      * @return 是否\n 46:      */\n 47:     private boolean isCommitLogAvailable() {\n 48:         return this.reputFromOffset < DefaultMessageStore.this.commitLog.getMaxOffset();\n 49:     }\n 50: \n 51:     private void doReput() {\n 52:         for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) {\n 53: \n 54:             // TODO 疑问：这个是啥\n 55:             if (DefaultMessageStore.this.getMessageStoreConfig().isDuplicationEnable() //\n 56:                 && this.reputFromOffset >= DefaultMessageStore.this.getConfirmOffset()) {\n 57:                 break;\n 58:             }\n 59: \n 60:             // 获取从reputFromOffset开始的commitLog对应的MappeFile对应的MappedByteBuffer\n 61:             SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset);\n 62:             if (result != null) {\n 63:                 try {\n 64:                     this.reputFromOffset = result.getStartOffset();\n 65: \n 66:                     // 遍历MappedByteBuffer\n 67:                     for (int readSize = 0; readSize < result.getSize() && doNext; ) {\n 68:                         // 生成重放消息重放调度请求\n 69:                         DispatchRequest dispatchRequest = DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false);\n 70:                         int size = dispatchRequest.getMsgSize(); // 消息长度\n 71:                         // 根据请求的结果处理\n 72:                         if (dispatchRequest.isSuccess()) { // 读取成功\n 73:                             if (size > 0) { // 读取Message\n 74:                                 DefaultMessageStore.this.doDispatch(dispatchRequest);\n 75:                                 // 通知有新消息\n 76:                                 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole()\n 77:                                     && DefaultMessageStore.this.brokerConfig.isLongPollingEnable()) {\n 78:                                     DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(),\n 79:                                         dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1,\n 80:                                         dispatchRequest.getTagsCode());\n 81:                                 }\n 82:                                 // FIXED BUG By shijia\n 83:                                 this.reputFromOffset += size;\n 84:                                 readSize += size;\n 85:                                 // 统计\n 86:                                 if (DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) {\n 87:                                     DefaultMessageStore.this.storeStatsService\n 88:                                         .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();\n 89:                                     DefaultMessageStore.this.storeStatsService\n 90:                                         .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())\n 91:                                         .addAndGet(dispatchRequest.getMsgSize());\n 92:                                 }\n 93:                             } else if (size == 0) { // 读取到MappedFile文件尾\n 94:                                 this.reputFromOffset = DefaultMessageStore.this.commitLog.rollNextFile(this.reputFromOffset);\n 95:                                 readSize = result.getSize();\n 96:                             }\n 97:                         } else if (!dispatchRequest.isSuccess()) { // 读取失败\n 98:                             if (size > 0) { // 读取到Message却不是Message\n 99:                                 log.error(\"[BUG]read total count not equals msg total size. reputFromOffset={}\", reputFromOffset);\n100:                                 this.reputFromOffset += size;\n101:                             } else { // 读取到Blank却不是Blank\n102:                                 doNext = false;\n103:                                 if (DefaultMessageStore.this.brokerConfig.getBrokerId() == MixAll.MASTER_ID) {\n104:                                     log.error(\"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: {}\",\n105:                                         this.reputFromOffset);\n106: \n107:                                     this.reputFromOffset += result.getSize() - readSize;\n108:                                 }\n109:                             }\n110:                         }\n111:                     }\n112:                 } finally {\n113:                     result.release();\n114:                 }\n115:             } else {\n116:                 doNext = false;\n117:             }\n118:         }\n119:     }\n120: \n121:     @Override\n122:     public void run() {\n123:         DefaultMessageStore.log.info(this.getServiceName() + \" service started\");\n124: \n125:         while (!this.isStopped()) {\n126:             try {\n127:                 Thread.sleep(1);\n128:                 this.doReput();\n129:             } catch (Exception e) {\n130:                 DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n131:             }\n132:         }\n133: \n134:         DefaultMessageStore.log.info(this.getServiceName() + \" service end\");\n135:     }\n136: \n137:     @Override\n138:     public String getServiceName() {\n139:         return ReputMessageService.class.getSimpleName();\n140:     }\n141: \n142: }\n```\n\n* 说明：重放消息线程服务。\n    * 该服务不断生成 消息位置信息 到 消费队列(ConsumeQueue)\n    * 该服务不断生成 消息索引 到 索引文件(IndexFile)    \n* ![ReputMessageService用例图](http://www.yunai.me/images/RocketMQ/2017_05_04/11.png)\n    * 第 61 行 ：获取 `reputFromOffset` 开始的 `CommitLog` 对应的 `MappedFile` 对应的 `MappedByteBuffer`。\n    * 第 67 行 ：遍历 `MappedByteBuffer`。\n    * 第 69 行 ：生成重放消息重放调度请求 (`DispatchRequest`) 。请求里主要包含一条消息 (`Message`) 或者 文件尾 (`BLANK`) 的基本信息。\n    * 第 72 至 96 行 ：请求是有效请求，进行逻辑处理。\n        * 第 75 至 81 行 ：当 `Broker` 是主节点 && `Broker` 开启的是长轮询，通知消费队列有新的消息。`NotifyMessageArrivingListener` 会 调用 `PullRequestHoldService#notifyMessageArriving(...)` 方法，详细解析见：[PullRequestHoldService](#pullrequestholdservice)\n    * 第 73 至 92 行 ：请求对应的是 `Message`，进行调度，生成 `ConsumeQueue` 和 `IndexFile` 对应的内容。详细解析见：\n    * 第 93 至 96 行 ：请求对应的是 `Blank`，即文件尾，跳转指向下一个 `MappedFile`。\n    * 第 97 至 110 行 ：请求是无效请求。出现该情况，基本是一个**BUG**。\n* 第 127 至 128 行 ：每 1ms 循环执行重放逻辑。\n* 第 18 至 30 行 ：`shutdown`时，多次 `sleep(100)` 直到 `CommitLog` 回放到最新位置。恩，如果未回放完，会输出警告日志。\n\n### DefaultMessageStore#doDispatch(...)\n\n```Java\n  1: /**\n  2:  * 执行调度请求\n  3:  * 1. 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n  4:  * 2. 建立 索引信息 到 IndexFile\n  5:  *\n  6:  * @param req 调度请求\n  7:  */\n  8: public void doDispatch(DispatchRequest req) {\n  9:     // 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n 10:     final int tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());\n 11:     switch (tranType) {\n 12:         case MessageSysFlag.TRANSACTION_NOT_TYPE:\n 13:         case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n 14:             DefaultMessageStore.this.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),\n 15:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());\n 16:             break;\n 17:         case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n 18:         case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n 19:             break;\n 20:     }\n 21:     // 建立 索引信息 到 IndexFile\n 22:     if (DefaultMessageStore.this.getMessageStoreConfig().isMessageIndexEnable()) {\n 23:         DefaultMessageStore.this.indexService.buildIndex(req);\n 24:     }\n 25: }\n 26: \n 27: /**\n 28:  * 建立 消息位置信息 到 ConsumeQueue\n 29:  *\n 30:  * @param topic 主题\n 31:  * @param queueId 队列编号\n 32:  * @param offset commitLog存储位置\n 33:  * @param size 消息长度\n 34:  * @param tagsCode 消息tagsCode\n 35:  * @param storeTimestamp 存储时间\n 36:  * @param logicOffset 队列位置\n 37:  */\n 38: public void putMessagePositionInfo(String topic, int queueId, long offset, int size, long tagsCode, long storeTimestamp,\n 39:     long logicOffset) {\n 40:     ConsumeQueue cq = this.findConsumeQueue(topic, queueId);\n 41:     cq.putMessagePositionInfoWrapper(offset, size, tagsCode, storeTimestamp, logicOffset);\n 42: }\n```\n\n### ConsumeQueue#putMessagePositionInfoWrapper(...)\n\n```Java\n  1: /**\n  2:  * 添加位置信息封装\n  3:  *\n  4:  * @param offset commitLog存储位置\n  5:  * @param size 消息长度\n  6:  * @param tagsCode 消息tagsCode\n  7:  * @param storeTimestamp 消息存储时间\n  8:  * @param logicOffset 队列位置\n  9:  */\n 10: public void putMessagePositionInfoWrapper(long offset, int size, long tagsCode, long storeTimestamp,\n 11:     long logicOffset) {\n 12:     final int maxRetries = 30;\n 13:     boolean canWrite = this.defaultMessageStore.getRunningFlags().isWriteable();\n 14:     // 多次循环写，直到成功\n 15:     for (int i = 0; i < maxRetries && canWrite; i++) {\n 16:         // 调用添加位置信息\n 17:         boolean result = this.putMessagePositionInfo(offset, size, tagsCode, logicOffset);\n 18:         if (result) {\n 19:             // 添加成功，使用消息存储时间 作为 存储check point。\n 20:             this.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(storeTimestamp);\n 21:             return;\n 22:         } else {\n 23:             // XXX: warn and notify me\n 24:             log.warn(\"[BUG]put commit log position info to \" + topic + \":\" + queueId + \" \" + offset\n 25:                 + \" failed, retry \" + i + \" times\");\n 26: \n 27:             try {\n 28:                 Thread.sleep(1000);\n 29:             } catch (InterruptedException e) {\n 30:                 log.warn(\"\", e);\n 31:             }\n 32:         }\n 33:     }\n 34: \n 35:     // XXX: warn and notify me 设置异常不可写入\n 36:     log.error(\"[BUG]consume queue can not write, {} {}\", this.topic, this.queueId);\n 37:     this.defaultMessageStore.getRunningFlags().makeLogicsQueueError();\n 38: }\n 39: \n 40: /**\n 41:  * 添加位置信息，并返回添加是否成功\n 42:  *\n 43:  * @param offset commitLog存储位置\n 44:  * @param size 消息长度\n 45:  * @param tagsCode 消息tagsCode\n 46:  * @param cqOffset 队列位置\n 47:  * @return 是否成功\n 48:  */\n 49: private boolean putMessagePositionInfo(final long offset, final int size, final long tagsCode,\n 50:     final long cqOffset) {\n 51:     // 如果已经重放过，直接返回成功\n 52:     if (offset <= this.maxPhysicOffset) {\n 53:         return true;\n 54:     }\n 55:     // 写入位置信息到byteBuffer\n 56:     this.byteBufferIndex.flip();\n 57:     this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);\n 58:     this.byteBufferIndex.putLong(offset);\n 59:     this.byteBufferIndex.putInt(size);\n 60:     this.byteBufferIndex.putLong(tagsCode);\n 61:     // 计算consumeQueue存储位置，并获得对应的MappedFile\n 62:     final long expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;\n 63:     MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset);\n 64:     if (mappedFile != null) {\n 65:         // 当是ConsumeQueue第一个MappedFile && 队列位置非第一个 && MappedFile未写入内容，则填充前置空白占位\n 66:         if (mappedFile.isFirstCreateInQueue() && cqOffset != 0 && mappedFile.getWrotePosition() == 0) { // TODO 疑问：为啥这个操作。目前能够想象到的是，一些老的消息很久没发送，突然发送，这个时候刚好满足。\n 67:             this.minLogicOffset = expectLogicOffset;\n 68:             this.mappedFileQueue.setFlushedWhere(expectLogicOffset);\n 69:             this.mappedFileQueue.setCommittedWhere(expectLogicOffset);\n 70:             this.fillPreBlank(mappedFile, expectLogicOffset);\n 71:             log.info(\"fill pre blank space \" + mappedFile.getFileName() + \" \" + expectLogicOffset + \" \"\n 72:                 + mappedFile.getWrotePosition());\n 73:         }\n 74:         // 校验consumeQueue存储位置是否合法。TODO 如果不合法，继续写入会不会有问题？\n 75:         if (cqOffset != 0) {\n 76:             long currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();\n 77:             if (expectLogicOffset != currentLogicOffset) {\n 78:                 LOG_ERROR.warn(\n 79:                     \"[BUG]logic queue order maybe wrong, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\",\n 80:                     expectLogicOffset,\n 81:                     currentLogicOffset,\n 82:                     this.topic,\n 83:                     this.queueId,\n 84:                     expectLogicOffset - currentLogicOffset\n 85:                 );\n 86:             }\n 87:         }\n 88:         // 设置commitLog重放消息到ConsumeQueue位置。\n 89:         this.maxPhysicOffset = offset;\n 90:         // 插入mappedFile\n 91:         return mappedFile.appendMessage(this.byteBufferIndex.array());\n 92:     }\n 93:     return false;\n 94: }\n 95: \n 96: /**\n 97:  * 填充前置空白占位\n 98:  *\n 99:  * @param mappedFile MappedFile\n100:  * @param untilWhere consumeQueue存储位置\n101:  */\n102: private void fillPreBlank(final MappedFile mappedFile, final long untilWhere) {\n103:     // 写入前置空白占位到byteBuffer\n104:     ByteBuffer byteBuffer = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);\n105:     byteBuffer.putLong(0L);\n106:     byteBuffer.putInt(Integer.MAX_VALUE);\n107:     byteBuffer.putLong(0L);\n108:     // 循环填空\n109:     int until = (int) (untilWhere % this.mappedFileQueue.getMappedFileSize());\n110:     for (int i = 0; i < until; i += CQ_STORE_UNIT_SIZE) {\n111:         mappedFile.appendMessage(byteBuffer.array());\n112:     }\n113: }\n```\n\n* `#putMessagePositionInfoWrapper(...)` 说明 ：添加位置信息到 `ConsumeQueue` 的封装，实际需要调用 `#putMessagePositionInfo(...)` 方法。\n    * 第 13 行 ：判断 `ConsumeQueue` 是否允许写入。当发生Bug时，不允许写入。\n    * 第 17 行 ：调用 `#putMessagePositionInfo(...)` 方法，添加位置信息。\n    * 第 18 至 21 行 ：添加成功，使用消息存储时间 作为 存储检查点。`StoreCheckpoint` 的详细解析见：[Store初始化与关闭](http://www.yunai.me/RocketMQ/store-init-and-shutdown/)。\n    * 第 22 至 32 行 ：添加失败，目前基本可以认为是BUG。\n    * 第 35 至 37 行 ：写入失败时，标记 `ConsumeQueue` 写入异常，不允许继续写入。\n* `#putMessagePositionInfo(...)` 说明 ：添加位置信息到 `ConsumeQueue`，并返回添加是否成功。\n    * 第 51 至 54 行 ：如果 `offset`(存储位置) 小于等于  `maxPhysicOffset`(`CommitLog` 消息重放到 `ConsumeQueue` 最大的 `CommitLog` 存储位置)，表示已经重放过，此时，不再重复写入，直接返回写入成功。\n    * 第 55 至 60 行 ：写 位置信息到byteBuffer。\n    * 第 62 至 63 行 ：计算 `ConsumeQueue`存储位置，并获得对应的MappedFile。\n    * 第 65 至 73 行 ：当 `MappedFile` 是 `ConsumeQueue` 当前第一个文件 && `MappedFile` 未写入内容 && 重放消息队列位置大于0，则需要进行 `MappedFile` 填充前置  `BLANK`。\n       * *这块比较有疑问，什么场景下会需要。猜测产生的原因：一个 `Topic` 长期无消息产生，突然N天后进行发送，`Topic` 对应的历史消息以及和消费队列数据已经被清理，新生成的`MappedFile`需要前置占位。*\n    * 第 74 至 87 行 ：校验 `ConsumeQueue` 存储位置是否合法，不合法则输出日志。\n        * *这块比较有疑问，如果计算出来的存储位置不合法，不返回添加失败，继续进行添加位置信息，会不会有问题？？？*\n    * 第 89 行 ：设置 `CommitLog` 重放消息到 `ConsumeQueue` 的最大位置。\n    * 第 91 行 ：插入消息位置到 `MappedFile`。\n\n## FlushConsumeQueueService\n\n```Java\n  1: class FlushConsumeQueueService extends ServiceThread {\n  2:     private static final int RETRY_TIMES_OVER = 3;\n  3:     /**\n  4:      * 最后flush时间戳\n  5:      */\n  6:     private long lastFlushTimestamp = 0;\n  7: \n  8:     private void doFlush(int retryTimes) {\n  9:         int flushConsumeQueueLeastPages = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueLeastPages();\n 10: \n 11:         // retryTimes == RETRY_TIMES_OVER时，进行强制flush。主要用于shutdown时。\n 12:         if (retryTimes == RETRY_TIMES_OVER) {\n 13:             flushConsumeQueueLeastPages = 0;\n 14:         }\n 15:         // 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush\n 16:         long logicsMsgTimestamp = 0;\n 17:         int flushConsumeQueueThoroughInterval = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval();\n 18:         long currentTimeMillis = System.currentTimeMillis();\n 19:         if (currentTimeMillis >= (this.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) {\n 20:             this.lastFlushTimestamp = currentTimeMillis;\n 21:             flushConsumeQueueLeastPages = 0;\n 22:             logicsMsgTimestamp = DefaultMessageStore.this.getStoreCheckpoint().getLogicsMsgTimestamp();\n 23:         }\n 24:         // flush消费队列\n 25:         ConcurrentHashMap<String, ConcurrentHashMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable;\n 26:         for (ConcurrentHashMap<Integer, ConsumeQueue> maps : tables.values()) {\n 27:             for (ConsumeQueue cq : maps.values()) {\n 28:                 boolean result = false;\n 29:                 for (int i = 0; i < retryTimes && !result; i++) {\n 30:                     result = cq.flush(flushConsumeQueueLeastPages);\n 31:                 }\n 32:             }\n 33:         }\n 34:         // flush 存储 check point\n 35:         if (0 == flushConsumeQueueLeastPages) {\n 36:             if (logicsMsgTimestamp > 0) {\n 37:                 DefaultMessageStore.this.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp);\n 38:             }\n 39:             DefaultMessageStore.this.getStoreCheckpoint().flush();\n 40:         }\n 41:     }\n 42: \n 43:     public void run() {\n 44:         DefaultMessageStore.log.info(this.getServiceName() + \" service started\");\n 45: \n 46:         while (!this.isStopped()) {\n 47:             try {\n 48:                 int interval = DefaultMessageStore.this.getMessageStoreConfig().getFlushIntervalConsumeQueue();\n 49:                 this.waitForRunning(interval);\n 50:                 this.doFlush(1);\n 51:             } catch (Exception e) {\n 52:                 DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n 53:             }\n 54:         }\n 55: \n 56:         this.doFlush(RETRY_TIMES_OVER);\n 57: \n 58:         DefaultMessageStore.log.info(this.getServiceName() + \" service end\");\n 59:     }\n 60: \n 61:     @Override\n 62:     public String getServiceName() {\n 63:         return FlushConsumeQueueService.class.getSimpleName();\n 64:     }\n 65: \n 66:     @Override\n 67:     public long getJointime() {\n 68:         return 1000 * 60;\n 69:     }\n 70: }\n```\n\n* 说明 ：flush `ConsumeQueue`(消费队列) 线程服务。\n* 第 11 至 14 行 ：当 `retryTimes == RETRY_TIMES_OVER` 时，进行强制flush。用于 `shutdown` 时。\n* 第 15 至 23 行 ：每 flushConsumeQueueThoroughInterval 周期，执行一次 flush 。因为不是每次循环到都能满足 flushConsumeQueueLeastPages 大小，因此，需要一定周期进行一次强制 flush 。当然，不能每次循环都去执行强制 flush，这样性能较差。\n* 第 24 至 33 行 ：flush `ConsumeQueue`(消费队列)。\n    * flush 逻辑：[MappedFile#落盘](http://www.yunai.me/RocketMQ/message-store/#MappedFile-落盘)。\n* 第 34 至 40 行 ：flush `StoreCheckpoint`。`StoreCheckpoint` 的详细解析见：[Store初始化与关闭](http://www.yunai.me/RocketMQ/store-init-and-shutdown/)。\n* 第 43 至 59 行 ：每 1000ms 执行一次 `flush`。如果 wakeup() 时，则会立即进行一次 `flush`。目前，暂时不存在 wakeup() 的调用。\n\n# 4、Broker 提供[拉取消息]接口\n\n## PullMessageRequestHeader\n\n```Java\n  1: public class PullMessageRequestHeader implements CommandCustomHeader {\n  2:     /**\n  3:      * 消费者分组\n  4:      */\n  5:     @CFNotNull\n  6:     private String consumerGroup;\n  7:     /**\n  8:      * Topic\n  9:      */\n 10:     @CFNotNull\n 11:     private String topic;\n 12:     /**\n 13:      * 队列编号\n 14:      */\n 15:     @CFNotNull\n 16:     private Integer queueId;\n 17:     /**\n 18:      * 队列开始位置\n 19:      */\n 20:     @CFNotNull\n 21:     private Long queueOffset;\n 22:     /**\n 23:      * 消息数量\n 24:      */\n 25:     @CFNotNull\n 26:     private Integer maxMsgNums;\n 27:     /**\n 28:      * 系统标识\n 29:      */\n 30:     @CFNotNull\n 31:     private Integer sysFlag;\n 32:     /**\n 33:      * 提交消费进度位置\n 34:      */\n 35:     @CFNotNull\n 36:     private Long commitOffset;\n 37:     /**\n 38:      * 挂起超时时间\n 39:      */\n 40:     @CFNotNull\n 41:     private Long suspendTimeoutMillis;\n 42:     /**\n 43:      * 订阅表达式\n 44:      */\n 45:     @CFNullable\n 46:     private String subscription;\n 47:     /**\n 48:      * 订阅版本号\n 49:      */\n 50:     @CFNotNull\n 51:     private Long subVersion;\n 52: }\n```\n\n* 说明：拉取消息请求Header\n* topic +  queueId + queueOffset + maxMsgNums\n* sysFlag ：系统标识。\n    * 第 0 位 `FLAG_COMMIT_OFFSET` ：标记请求提交消费进度位置，和 `commitOffset` 配合。\n    * 第 1 位 `FLAG_SUSPEND` ：标记请求是否挂起请求，和 `suspendTimeoutMillis` 配合。当拉取不到消息时， `Broker` 会挂起请求，直到有消息。最大挂起时间：`suspendTimeoutMillis` 毫秒。\n    * 第 2 位 `FLAG_SUBSCRIPTION` ：是否过滤订阅表达式，和 `subscription` 配置。\n* subVersion ：订阅版本号。请求时，如果版本号不对，则无法拉取到消息，需要重新获取订阅信息，使用最新的订阅版本号。\n\n## PullMessageProcessor#processRequest(...)\n\n```Java\n  1: private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend)\n  2:     throws RemotingCommandException {\n  3:     RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n  4:     final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n  5:     final PullMessageRequestHeader requestHeader =\n  6:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n  7: \n  8:     response.setOpaque(request.getOpaque());\n  9: \n 10:     if (LOG.isDebugEnabled()) {\n 11:         LOG.debug(\"receive PullMessage request command, {}\", request);\n 12:     }\n 13: \n 14:     // 校验 broker 是否可读\n 15:     if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n 16:         response.setCode(ResponseCode.NO_PERMISSION);\n 17:         response.setRemark(String.format(\"the broker[%s] pulling message is forbidden\", this.brokerController.getBrokerConfig().getBrokerIP1()));\n 18:         return response;\n 19:     }\n 20: \n 21:     // 校验 consumer分组配置 是否存在\n 22:     SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n 23:     if (null == subscriptionGroupConfig) {\n 24:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 25:         response.setRemark(String.format(\"subscription group [%s] does not exist, %s\", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n 26:         return response;\n 27:     }\n 28:     // 校验 consumer分组配置 是否可消费\n 29:     if (!subscriptionGroupConfig.isConsumeEnable()) {\n 30:         response.setCode(ResponseCode.NO_PERMISSION);\n 31:         response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n 32:         return response;\n 33:     }\n 34: \n 35:     final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); // 是否挂起请求，当没有消息时\n 36:     final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); // 是否提交消费进度\n 37:     final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); // 是否过滤订阅表达式(subscription)\n 38:     final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0; // 挂起请求超时时长\n 39: \n 40:     // 校验 topic配置 存在\n 41:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 42:     if (null == topicConfig) {\n 43:         LOG.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));\n 44:         response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n 45:         response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n 46:         return response;\n 47:     }\n 48:     // 校验 topic配置 权限可读\n 49:     if (!PermName.isReadable(topicConfig.getPerm())) {\n 50:         response.setCode(ResponseCode.NO_PERMISSION);\n 51:         response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] pulling message is forbidden\");\n 52:         return response;\n 53:     }\n 54:     // 校验 读取队列 在 topic配置 队列范围内\n 55:     if (requestHeader.getQueueId() < 0 || requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n 56:         String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\",\n 57:                 requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());\n 58:         LOG.warn(errorInfo);\n 59:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 60:         response.setRemark(errorInfo);\n 61:         return response;\n 62:     }\n 63: \n 64:     // 校验 订阅关系\n 65:     SubscriptionData subscriptionData;\n 66:     if (hasSubscriptionFlag) {\n 67:         try {\n 68:             subscriptionData = FilterAPI.buildSubscriptionData(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n 69:                 requestHeader.getSubscription());\n 70:         } catch (Exception e) {\n 71:             LOG.warn(\"Parse the consumer's subscription[{}] failed, group: {}\", requestHeader.getSubscription(), //\n 72:                     requestHeader.getConsumerGroup());\n 73:             response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n 74:             response.setRemark(\"parse the consumer's subscription failed\");\n 75:             return response;\n 76:         }\n 77:     } else {\n 78:         // 校验 消费分组信息 是否存在\n 79:         ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());\n 80:         if (null == consumerGroupInfo) {\n 81:             LOG.warn(\"The consumer's group info not exist, group: {}\", requestHeader.getConsumerGroup());\n 82:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);\n 83:             response.setRemark(\"the consumer's group info not exist\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));\n 84:             return response;\n 85:         }\n 86:         // 校验 消费分组信息 消息模型是否匹配\n 87:         if (!subscriptionGroupConfig.isConsumeBroadcastEnable() //\n 88:             && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) {\n 89:             response.setCode(ResponseCode.NO_PERMISSION);\n 90:             response.setRemark(\"the consumer group[\" + requestHeader.getConsumerGroup() + \"] can not consume by broadcast way\");\n 91:             return response;\n 92:         }\n 93: \n 94:         // 校验 订阅信息 是否存在\n 95:         subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());\n 96:         if (null == subscriptionData) {\n 97:             LOG.warn(\"The consumer's subscription not exist, group: {}, topic:{}\", requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 98:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);\n 99:             response.setRemark(\"the consumer's subscription not exist\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));\n100:             return response;\n101:         }\n102:         // 校验 订阅信息版本 是否合法\n103:         if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) {\n104:             LOG.warn(\"The broker's subscription is not latest, group: {} {}\", requestHeader.getConsumerGroup(),\n105:                     subscriptionData.getSubString());\n106:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);\n107:             response.setRemark(\"the consumer's subscription not latest\");\n108:             return response;\n109:         }\n110:     }\n111: \n112:     // 获取消息\n113:     final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n114:             requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), subscriptionData);\n115:     if (getMessageResult != null) {\n116:         response.setRemark(getMessageResult.getStatus().name());\n117:         responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());\n118:         responseHeader.setMinOffset(getMessageResult.getMinOffset());\n119:         responseHeader.setMaxOffset(getMessageResult.getMaxOffset());\n120: \n121:         // TODO 待读\n122:         // 计算建议读取brokerId\n123:         if (getMessageResult.isSuggestPullingFromSlave()) {\n124:             responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());\n125:         } else {\n126:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n127:         }\n128: \n129:         switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) {\n130:             case ASYNC_MASTER:\n131:             case SYNC_MASTER:\n132:                 break;\n133:             case SLAVE:\n134:                 if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) { // 从节点不允许读取，告诉consumer读取主节点。\n135:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n136:                     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n137:                 }\n138:                 break;\n139:         }\n140: \n141:         if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) {\n142:             // consume too slow ,redirect to another machine\n143:             if (getMessageResult.isSuggestPullingFromSlave()) {\n144:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());\n145:             }\n146:             // consume ok\n147:             else {\n148:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());\n149:             }\n150:         } else {\n151:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n152:         }\n153: \n154:         switch (getMessageResult.getStatus()) {\n155:             case FOUND:\n156:                 response.setCode(ResponseCode.SUCCESS);\n157:                 break;\n158:             case MESSAGE_WAS_REMOVING:\n159:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n160:                 break;\n161:             case NO_MATCHED_LOGIC_QUEUE:\n162:             case NO_MESSAGE_IN_QUEUE:\n163:                 if (0 != requestHeader.getQueueOffset()) {\n164:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n165: \n166:                     // XXX: warn and notify me\n167:                     LOG.info(\"the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}\", //\n168:                         requestHeader.getQueueOffset(), //\n169:                         getMessageResult.getNextBeginOffset(), //\n170:                         requestHeader.getTopic(), //\n171:                         requestHeader.getQueueId(), //\n172:                         requestHeader.getConsumerGroup()//\n173:                     );\n174:                 } else {\n175:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n176:                 }\n177:                 break;\n178:             case NO_MATCHED_MESSAGE:\n179:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n180:                 break;\n181:             case OFFSET_FOUND_NULL:\n182:                 response.setCode(ResponseCode.PULL_NOT_FOUND);\n183:                 break;\n184:             case OFFSET_OVERFLOW_BADLY:\n185:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n186:                 // XXX: warn and notify me\n187:                 LOG.info(\"The request offset:{} over flow badly, broker max offset:{} , consumer: {}\", requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());\n188:                 break;\n189:             case OFFSET_OVERFLOW_ONE:\n190:                 response.setCode(ResponseCode.PULL_NOT_FOUND);\n191:                 break;\n192:             case OFFSET_TOO_SMALL:\n193:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n194:                 LOG.info(\"The request offset is too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}\",\n195:                     requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),\n196:                     getMessageResult.getMinOffset(), channel.remoteAddress());\n197:                 break;\n198:             default:\n199:                 assert false;\n200:                 break;\n201:         }\n202: \n203:         // hook：before\n204:         if (this.hasConsumeMessageHook()) {\n205:             ConsumeMessageContext context = new ConsumeMessageContext();\n206:             context.setConsumerGroup(requestHeader.getConsumerGroup());\n207:             context.setTopic(requestHeader.getTopic());\n208:             context.setQueueId(requestHeader.getQueueId());\n209: \n210:             String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);\n211: \n212:             switch (response.getCode()) {\n213:                 case ResponseCode.SUCCESS:\n214:                     int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();\n215:                     int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;\n216: \n217:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);\n218:                     context.setCommercialRcvTimes(incValue);\n219:                     context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());\n220:                     context.setCommercialOwner(owner);\n221: \n222:                     break;\n223:                 case ResponseCode.PULL_NOT_FOUND:\n224:                     if (!brokerAllowSuspend) {\n225: \n226:                         context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);\n227:                         context.setCommercialRcvTimes(1);\n228:                         context.setCommercialOwner(owner);\n229: \n230:                     }\n231:                     break;\n232:                 case ResponseCode.PULL_RETRY_IMMEDIATELY:\n233:                 case ResponseCode.PULL_OFFSET_MOVED:\n234:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);\n235:                     context.setCommercialRcvTimes(1);\n236:                     context.setCommercialOwner(owner);\n237:                     break;\n238:                 default:\n239:                     assert false;\n240:                     break;\n241:             }\n242: \n243:             this.executeConsumeMessageHookBefore(context);\n244:         }\n245: \n246:         switch (response.getCode()) {\n247:             case ResponseCode.SUCCESS:\n248: \n249:                 this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n250:                     getMessageResult.getMessageCount());\n251:                 this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n252:                     getMessageResult.getBufferTotalSize());\n253:                 this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());\n254:                 // 读取消息\n255:                 if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) { // 内存中\n256:                     final long beginTimeMills = this.brokerController.getMessageStore().now();\n257: \n258:                     final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());\n259: \n260:                     this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n261:                         requestHeader.getTopic(), requestHeader.getQueueId(),\n262:                         (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n263:                     response.setBody(r);\n264:                 } else { // zero-copy\n265:                     try {\n266:                         FileRegion fileRegion = new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);\n267:                         channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {\n268:                             @Override\n269:                             public void operationComplete(ChannelFuture future) throws Exception {\n270:                                 getMessageResult.release();\n271:                                 if (!future.isSuccess()) {\n272:                                     LOG.error(\"Fail to transfer messages from page cache to {}\", channel.remoteAddress(), future.cause());\n273:                                 }\n274:                             }\n275:                         });\n276:                     } catch (Throwable e) {\n277:                         LOG.error(\"Error occurred when transferring messages from page cache\", e);\n278:                         getMessageResult.release();\n279:                     }\n280: \n281:                     response = null;\n282:                 }\n283:                 break;\n284:             case ResponseCode.PULL_NOT_FOUND:\n285:                 // 消息未查询到 && broker允许挂起请求 && 请求允许挂起\n286:                 if (brokerAllowSuspend && hasSuspendFlag) {\n287:                     long pollingTimeMills = suspendTimeoutMillisLong;\n288:                     if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n289:                         pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();\n290:                     }\n291: \n292:                     String topic = requestHeader.getTopic();\n293:                     long offset = requestHeader.getQueueOffset();\n294:                     int queueId = requestHeader.getQueueId();\n295:                     PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,\n296:                         this.brokerController.getMessageStore().now(), offset, subscriptionData);\n297:                     this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);\n298:                     response = null;\n299:                     break;\n300:                 }\n301: \n302:             case ResponseCode.PULL_RETRY_IMMEDIATELY:\n303:                 break;\n304:             case ResponseCode.PULL_OFFSET_MOVED:\n305:                 if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE\n306:                     || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) { // TODO 待博客补充\n307:                     MessageQueue mq = new MessageQueue();\n308:                     mq.setTopic(requestHeader.getTopic());\n309:                     mq.setQueueId(requestHeader.getQueueId());\n310:                     mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());\n311: \n312:                     OffsetMovedEvent event = new OffsetMovedEvent();\n313:                     event.setConsumerGroup(requestHeader.getConsumerGroup());\n314:                     event.setMessageQueue(mq);\n315:                     event.setOffsetRequest(requestHeader.getQueueOffset());\n316:                     event.setOffsetNew(getMessageResult.getNextBeginOffset());\n317:                     this.generateOffsetMovedEvent(event);\n318:                     LOG.warn(\n319:                         \"PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}\",\n320:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),\n321:                         responseHeader.getSuggestWhichBrokerId());\n322:                 } else {\n323:                     responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());\n324:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n325:                     LOG.warn(\"PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}\",\n326:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),\n327:                         responseHeader.getSuggestWhichBrokerId());\n328:                 }\n329: \n330:                 break;\n331:             default:\n332:                 assert false;\n333:         }\n334:     } else {\n335:         response.setCode(ResponseCode.SYSTEM_ERROR);\n336:         response.setRemark(\"store getMessage return null\");\n337:     }\n338: \n339:     // 请求要求持久化进度 && broker非主，进行持久化进度。\n340:     boolean storeOffsetEnable = brokerAllowSuspend;\n341:     storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag;\n342:     storeOffsetEnable = storeOffsetEnable && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;\n343:     if (storeOffsetEnable) {\n344:         this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),\n345:             requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());\n346:     }\n347:     return response;\n348: }\n```\n\n* 说明：处理拉取消息请求，返回响应。\n* 第 14 至 19 行 ：校验 `Broker` 是否可读。\n* 第 21 至 33 行 ：校验 `SubscriptionGroupConfig`(订阅分组配置) 是否存在 && 可以消费。\n* 第 35 至 38 行 ：处理 `PullMessageRequestHeader.sysFlag` 对应的标志位。\n* 第 40 至 62 行 ：校验 `TopicConfig`(主题配置) 是否存在 && 可读 && 队列编号正确。\n* 第 64 至 110 行 ：校验 `SubscriptionData`(订阅信息) 是否正确。\n* 第 113 行 ：调用 `MessageStore#getMessage(...)` 获取 `GetMessageResult`(消息)。详细解析见：[MessageStore#getMessage(...)](#messagestoregetmessage)。\n* 第 122 至 152 行 ：计算建议拉取消息 `brokerId` 。\n* 第 154 至 201 行 ：![PullMessageProcessor拉取消息状态图](http://www.yunai.me/images/RocketMQ/2017_05_04/08.png)\n* 第 204 至 244 行 ：`Hook` 逻辑，`#executeConsumeMessageHookBefore(...)` 。\n* 第 247 至 283 行 ：拉取消息成功，即拉取到消息。\n    * 第 255 至 263 行 ：方式一 ：调用 `readGetMessageResult(...)` 获取消息内容到堆内内存，设置到 响应`body`。\n    * 第 265 至 281 行 ：方式二 ：基于 `zero-copy` 实现，直接响应，无需堆内内存，性能更优。*TODO ：此处等对zero-copy有研究，再补充一些*。\n* 第 284 至 300 行 ：拉取不到消息，当满足条件 (`Broker` 允许挂起 && 请求要求挂起)，执行挂起请求。详细解析见：[PullRequestHoldService](#pullrequestholdservice)。\n* 第 304 至 328 行 ：*TODO ：此处等对`tools`模块研究后再补充*。\n* 第 339 至 346 ：持久化消费进度，当满足 (`Broker` 非主 && 请求要求持久化进度)。详细解析见：[更新消费进度](#3broker-提供更新消费进度接口)。\n\n## MessageStore#getMessage(...)\n\n```Java\n  1: /**\n  2:  * 获取消息结果\n  3:  *\n  4:  * @param group 消费分组\n  5:  * @param topic 主题\n  6:  * @param queueId 队列编号\n  7:  * @param offset 队列位置\n  8:  * @param maxMsgNums 消息数量\n  9:  * @param subscriptionData 订阅信息\n 10:  * @return 消息结果\n 11:  */\n 12: public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums,\n 13:     final SubscriptionData subscriptionData) {\n 14:     // 是否关闭\n 15:     if (this.shutdown) {\n 16:         log.warn(\"message store has shutdown, so getMessage is forbidden\");\n 17:         return null;\n 18:     }\n 19:     // 是否可读\n 20:     if (!this.runningFlags.isReadable()) {\n 21:         log.warn(\"message store is not readable, so getMessage is forbidden \" + this.runningFlags.getFlagBits());\n 22:         return null;\n 23:     }\n 24: \n 25:     long beginTime = this.getSystemClock().now();\n 26: \n 27:     GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;\n 28:     long nextBeginOffset = offset;\n 29:     long minOffset = 0;\n 30:     long maxOffset = 0;\n 31: \n 32:     GetMessageResult getResult = new GetMessageResult();\n 33: \n 34:     final long maxOffsetPy = this.commitLog.getMaxOffset();\n 35: \n 36:     // 获取消费队列\n 37:     ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);\n 38:     if (consumeQueue != null) {\n 39:         minOffset = consumeQueue.getMinOffsetInQueue(); // 消费队列 最小队列编号\n 40:         maxOffset = consumeQueue.getMaxOffsetInQueue(); // 消费队列 最大队列编号\n 41: \n 42:         // 判断 队列位置(offset)\n 43:         if (maxOffset == 0) { // 消费队列无消息\n 44:             status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;\n 45:             nextBeginOffset = nextOffsetCorrection(offset, 0);\n 46:         } else if (offset < minOffset) { // 查询offset 太小\n 47:             status = GetMessageStatus.OFFSET_TOO_SMALL;\n 48:             nextBeginOffset = nextOffsetCorrection(offset, minOffset);\n 49:         } else if (offset == maxOffset) { // 查询offset 超过 消费队列 一个位置\n 50:             status = GetMessageStatus.OFFSET_OVERFLOW_ONE;\n 51:             nextBeginOffset = nextOffsetCorrection(offset, offset);\n 52:         } else if (offset > maxOffset) { // 查询offset 超过 消费队列 太多(大于一个位置)\n 53:             status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;\n 54:             if (0 == minOffset) { // TODO blog 这里是？？为啥0 == minOffset做了特殊判断\n 55:                 nextBeginOffset = nextOffsetCorrection(offset, minOffset);\n 56:             } else {\n 57:                 nextBeginOffset = nextOffsetCorrection(offset, maxOffset);\n 58:             }\n 59:         } else {\n 60:             // 获得 映射Buffer结果(MappedFile)\n 61:             SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);\n 62:             if (bufferConsumeQueue != null) {\n 63:                 try {\n 64:                     status = GetMessageStatus.NO_MATCHED_MESSAGE;\n 65: \n 66:                     long nextPhyFileStartOffset = Long.MIN_VALUE; // commitLog下一个文件(MappedFile)对应的开始offset。\n 67:                     long maxPhyOffsetPulling = 0; // 消息物理位置拉取到的最大offset\n 68: \n 69:                     int i = 0;\n 70:                     final int maxFilterMessageCount = 16000;\n 71:                     final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded();\n 72:                     // 循环获取 消息位置信息\n 73:                     for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n 74:                         long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); // 消息物理位置offset\n 75:                         int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); // 消息长度\n 76:                         long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); // 消息tagsCode\n 77:                         // 设置消息物理位置拉取到的最大offset\n 78:                         maxPhyOffsetPulling = offsetPy;\n 79:                         // 当 offsetPy 小于 nextPhyFileStartOffset 时，意味着对应的 Message 已经移除，所以直接continue，直到可读取的Message。\n 80:                         if (nextPhyFileStartOffset != Long.MIN_VALUE) {\n 81:                             if (offsetPy < nextPhyFileStartOffset)\n 82:                                 continue;\n 83:                         }\n 84:                         // 校验 commitLog 是否需要硬盘，无法全部放在内存\n 85:                         boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);\n 86:                         // 是否已经获得足够消息\n 87:                         if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),\n 88:                             isInDisk)) {\n 89:                             break;\n 90:                         }\n 91:                         // 判断消息是否符合条件\n 92:                         if (this.messageFilter.isMessageMatched(subscriptionData, tagsCode)) {\n 93:                             // 从commitLog获取对应消息ByteBuffer\n 94:                             SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);\n 95:                             if (selectResult != null) {\n 96:                                 this.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();\n 97:                                 getResult.addMessage(selectResult);\n 98:                                 status = GetMessageStatus.FOUND;\n 99:                                 nextPhyFileStartOffset = Long.MIN_VALUE;\n100:                             } else {\n101:                                 // 从commitLog无法读取到消息，说明该消息对应的文件（MappedFile）已经删除，计算下一个MappedFile的起始位置\n102:                                 if (getResult.getBufferTotalSize() == 0) {\n103:                                     status = GetMessageStatus.MESSAGE_WAS_REMOVING;\n104:                                 }\n105:                                 nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);\n106:                             }\n107:                         } else {\n108:                             if (getResult.getBufferTotalSize() == 0) {\n109:                                 status = GetMessageStatus.NO_MATCHED_MESSAGE;\n110:                             }\n111: \n112:                             if (log.isDebugEnabled()) {\n113:                                 log.debug(\"message type not matched, client: \" + subscriptionData + \" server: \" + tagsCode);\n114:                             }\n115:                         }\n116:                     }\n117:                     // 统计剩余可拉取消息字节数\n118:                     if (diskFallRecorded) {\n119:                         long fallBehind = maxOffsetPy - maxPhyOffsetPulling;\n120:                         brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);\n121:                     }\n122:                     // 计算下次拉取消息的消息队列编号\n123:                     nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n124:                     // 根据剩余可拉取消息字节数与内存判断是否建议读取从节点\n125:                     long diff = maxOffsetPy - maxPhyOffsetPulling;\n126:                     long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE\n127:                             * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));\n128:                     getResult.setSuggestPullingFromSlave(diff > memory);\n129:                 } finally {\n130:                     bufferConsumeQueue.release();\n131:                 }\n132:             } else {\n133:                 status = GetMessageStatus.OFFSET_FOUND_NULL;\n134:                 nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));\n135:                 log.warn(\"consumer request topic: \" + topic + \"offset: \" + offset + \" minOffset: \" + minOffset + \" maxOffset: \"\n136:                     + maxOffset + \", but access logic queue failed.\");\n137:             }\n138:         }\n139:     } else {\n140:         status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;\n141:         nextBeginOffset = nextOffsetCorrection(offset, 0);\n142:     }\n143:     // 统计\n144:     if (GetMessageStatus.FOUND == status) {\n145:         this.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();\n146:     } else {\n147:         this.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();\n148:     }\n149:     long eclipseTime = this.getSystemClock().now() - beginTime;\n150:     this.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);\n151:     // 设置返回结果\n152:     getResult.setStatus(status);\n153:     getResult.setNextBeginOffset(nextBeginOffset);\n154:     getResult.setMaxOffset(maxOffset);\n155:     getResult.setMinOffset(minOffset);\n156:     return getResult;\n157: }\n158: \n159: /**\n160:  * 根据 主题 + 队列编号 获取 消费队列\n161:  *\n162:  * @param topic 主题\n163:  * @param queueId 队列编号\n164:  * @return 消费队列\n165:  */\n166: public ConsumeQueue findConsumeQueue(String topic, int queueId) {\n167:     // 获取 topic 对应的 所有消费队列\n168:     ConcurrentHashMap<Integer, ConsumeQueue> map = consumeQueueTable.get(topic);\n169:     if (null == map) {\n170:         ConcurrentHashMap<Integer, ConsumeQueue> newMap = new ConcurrentHashMap<>(128);\n171:         ConcurrentHashMap<Integer, ConsumeQueue> oldMap = consumeQueueTable.putIfAbsent(topic, newMap);\n172:         if (oldMap != null) {\n173:             map = oldMap;\n174:         } else {\n175:             map = newMap;\n176:         }\n177:     }\n178:     // 获取 queueId 对应的 消费队列\n179:     ConsumeQueue logic = map.get(queueId);\n180:     if (null == logic) {\n181:         ConsumeQueue newLogic = new ConsumeQueue(//\n182:             topic, //\n183:             queueId, //\n184:             StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()), //\n185:             this.getMessageStoreConfig().getMapedFileSizeConsumeQueue(), //\n186:             this);\n187:         ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);\n188:         if (oldLogic != null) {\n189:             logic = oldLogic;\n190:         } else {\n191:             logic = newLogic;\n192:         }\n193:     }\n194: \n195:     return logic;\n196: }\n197: \n198: /**\n199:  * 下一个获取队列offset修正\n200:  * 修正条件：主节点 或者 从节点开启校验offset开关\n201:  *\n202:  * @param oldOffset 老队列offset\n203:  * @param newOffset 新队列offset\n204:  * @return 修正后的队列offset\n205:  */\n206: private long nextOffsetCorrection(long oldOffset, long newOffset) {\n207:     long nextOffset = oldOffset;\n208:     if (this.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || this.getMessageStoreConfig().isOffsetCheckInSlave()) {\n209:         nextOffset = newOffset;\n210:     }\n211:     return nextOffset;\n212: }\n213: \n214: /**\n215:  * 校验 commitLog 是否需要硬盘，无法全部放在内存\n216:  *\n217:  * @param offsetPy commitLog 指定offset\n218:  * @param maxOffsetPy commitLog 最大offset\n219:  * @return 是否需要硬盘\n220:  */\n221: private boolean checkInDiskByCommitOffset(long offsetPy, long maxOffsetPy) {\n222:     long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));\n223:     return (maxOffsetPy - offsetPy) > memory;\n224: }\n225: \n226: /**\n227:  * 判断获取消息是否已经满\n228:  *\n229:  * @param sizePy 字节数\n230:  * @param maxMsgNums 最大消息数\n231:  * @param bufferTotal 目前已经计算字节数\n232:  * @param messageTotal 目前已经计算消息数\n233:  * @param isInDisk 是否在硬盘中\n234:  * @return 是否已满\n235:  */\n236: private boolean isTheBatchFull(int sizePy, int maxMsgNums, int bufferTotal, int messageTotal, boolean isInDisk) {\n237:     if (0 == bufferTotal || 0 == messageTotal) {\n238:         return false;\n239:     }\n240:     // 消息数量已经满足请求数量(maxMsgNums)\n241:     if ((messageTotal + 1) >= maxMsgNums) {\n242:         return true;\n243:     }\n244:     // 根据消息存储配置的最大传输字节数、最大传输消息数是否已满\n245:     if (isInDisk) {\n246:         if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInDisk()) {\n247:             return true;\n248:         }\n249: \n250:         if ((messageTotal + 1) > this.messageStoreConfig.getMaxTransferCountOnMessageInDisk()) {\n251:             return true;\n252:         }\n253:     } else {\n254:         if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInMemory()) {\n255:             return true;\n256:         }\n257: \n258:         if ((messageTotal + 1) > this.messageStoreConfig.getMaxTransferCountOnMessageInMemory()) {\n259:             return true;\n260:         }\n261:     }\n262: \n263:     return false;\n264: }\n```\n\n* 说明 ：根据 消息分组(`group`) + 主题(`Topic`) + 队列编号(`queueId`) + 队列位置(`offset`) + 订阅信息(`subscriptionData`) 获取 指定条数(`maxMsgNums`) 消息(`Message`)。\n* 第 14 至 18 行 ：判断 `Store` 是否处于关闭状态，若关闭，则无法获取消息。\n* 第 19 至 23 行 ：判断当前运行状态是否可读，若不可读，则无法获取消息。\n* 第 37 行 ：根据 主题(`Topic`) + 队列编号(`queueId`) 获取 消息队列(`ConsumeQueue`)。\n    * `#findConsumeQueue(...)` ：第 159 至 196 行。\n* 第 43 至 58 行 ：各种队列位置(`offset`) 无法读取消息，并针对对应的情况，计算下一次 `Client` 队列拉取位置。\n    * 第 43 至 45 行 ：消息队列无消息。\n    * 第 46 至 48 行 ：查询的消息队列位置（`offset`） 太小。\n    * 第 49 至 51 行 ：查询的消息队列位置（`offset`） 恰好等于 消息队列最大的队列位置。该情况是正常现象，相当于查询最新的消息。\n    * 第 52 至 58 行 ：查询的消息队列位置（`offset`） 超过过多。\n    * `#nextOffsetCorrection(...)` ：第 198 至 212 行。\n* 第 61 行 ：根据 消费队列位置(`offset`) 获取 对应的`MappedFile`。\n* 第 72 至 128 行 ：**循环**获取 `消息位置信息`。\n    * 第 74 至 76 行 ：读取每一个 `消息位置信息`。\n    * 第 79 至 83 行 ：当 `offsetPy` 小于 `nextPhyFileStartOffset` 时，意味着对\n应的 `Message` 已经移除，所以直接continue，直到可读取的 `Message`。\n    * 第 84 至 90 行 ：判断是否已经获得足够的消息。\n        * `#checkInDiskByCommitOffset(...)` ：第 214 至 224 行。\n        * `#isTheBatchFull(...)` ：第 226 至 264 行。\n* 第 92 行 ：判断消息是否符合条件。详细解析见：[DefaultMessageFilter#isMessageMatched(...)](defaultmessagefilterismessagematched)。\n* 第 94 行 ：从 `CommitLog` 获取对应 消息的`MappedByteBuffer`。\n* 第 95 至 99 行 ：获取 `消息MappedByteBuffer` 成功。\n* 第 100 至 106 行 ：获取 `消息MappedByteBuffer` 失败。从 `CommitLog` 无法读取到消息，说明 该消息对应的文件(`MappedFile`) 已经删除，此时计算下一个`MappedFile`的起始位置。**该逻辑需要配合（第 79 至 83 行）一起理解。**\n* 第 117 至 120 行 ：统计剩余可拉取消息字节数。\n* 第 123 行 ：计算下次拉取消息的消息队列编号。\n* 第 124 至 128 行 ：根据剩余可拉取消息字节数与内存判断是否建议读取从节点。\n* 第 130 行 ：释放 `bufferConsumeQueue` 对 `MappedFile` 的指向。此处 `MappedFile` 是 `ConsumeQueue` 里的文件，不是 `CommitLog` 下的文件。\n* 第 133 至 136 行 ：获得消费队列位置(`offset`) 获取 对应的`MappedFile` 为**空**，计算`ConsumeQueue` 从 `offset` 开始的下一个 `MappedFile` 对应的位置。\n* 第 143 至 150 行 ：记录统计信息：消耗时间、拉取到消息/未拉取到消息次数。\n* 第 151 至 156 行 ：设置返回结果并返回。 \n\n## DefaultMessageFilter#isMessageMatched(...)\n\n```Java\n  1: public class DefaultMessageFilter implements MessageFilter {\n  2: \n  3:     @Override\n  4:     public boolean isMessageMatched(SubscriptionData subscriptionData, Long tagsCode) {\n  5:         // 消息tagsCode 空\n  6:         if (tagsCode == null) {\n  7:             return true;\n  8:         }\n  9:         // 订阅数据 空\n 10:         if (null == subscriptionData) {\n 11:             return true;\n 12:         }\n 13:         // classFilter\n 14:         if (subscriptionData.isClassFilterMode())\n 15:             return true;\n 16:         // 订阅表达式 全匹配\n 17:         if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) {\n 18:             return true;\n 19:         }\n 20:         // 订阅数据code数组 是否包含 消息tagsCode\n 21:         return subscriptionData.getCodeSet().contains(tagsCode.intValue());\n 22:     }\n 23: \n 24: }\n```\n\n* 说明 ：消息过滤器默认实现。\n\n## PullRequestHoldService\n\n```Java\n  1: public class PullRequestHoldService extends ServiceThread {\n  2: \n  3:     private static final Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n  4: \n  5:     private static final String TOPIC_QUEUEID_SEPARATOR = \"@\";\n  6: \n  7:     private final BrokerController brokerController;\n  8: \n  9:     private final SystemClock systemClock = new SystemClock();\n 10:     /**\n 11:      * 消息过滤器\n 12:      */\n 13:     private final MessageFilter messageFilter = new DefaultMessageFilter();\n 14:     /**\n 15:      * 拉取消息请求集合\n 16:      */\n 17:     private ConcurrentHashMap<String/* topic@queueId */, ManyPullRequest> pullRequestTable =\n 18:             new ConcurrentHashMap<>(1024);\n 19: \n 20:     public PullRequestHoldService(final BrokerController brokerController) {\n 21:         this.brokerController = brokerController;\n 22:     }\n 23: \n 24:     /**\n 25:      * 添加拉取消息挂起请求\n 26:      *\n 27:      * @param topic 主题\n 28:      * @param queueId 队列编号\n 29:      * @param pullRequest 拉取消息请求\n 30:      */\n 31:     public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) {\n 32:         String key = this.buildKey(topic, queueId);\n 33:         ManyPullRequest mpr = this.pullRequestTable.get(key);\n 34:         if (null == mpr) {\n 35:             mpr = new ManyPullRequest();\n 36:             ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);\n 37:             if (prev != null) {\n 38:                 mpr = prev;\n 39:             }\n 40:         }\n 41: \n 42:         mpr.addPullRequest(pullRequest);\n 43:     }\n 44: \n 45:     /**\n 46:      * 根据 主题 + 队列编号 创建唯一标识\n 47:      *\n 48:      * @param topic 主题\n 49:      * @param queueId 队列编号\n 50:      * @return key\n 51:      */\n 52:     private String buildKey(final String topic, final int queueId) {\n 53:         StringBuilder sb = new StringBuilder();\n 54:         sb.append(topic);\n 55:         sb.append(TOPIC_QUEUEID_SEPARATOR);\n 56:         sb.append(queueId);\n 57:         return sb.toString();\n 58:     }\n 59: \n 60:     @Override\n 61:     public void run() {\n 62:         log.info(\"{} service started\", this.getServiceName());\n 63:         while (!this.isStopped()) {\n 64:             try {\n 65:                 // 根据 长轮训 还是 短轮训 设置不同的等待时间\n 66:                 if (this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n 67:                     this.waitForRunning(5 * 1000);\n 68:                 } else {\n 69:                     this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());\n 70:                 }\n 71:                 // 检查挂起请求是否有需要通知的\n 72:                 long beginLockTimestamp = this.systemClock.now();\n 73:                 this.checkHoldRequest();\n 74:                 long costTime = this.systemClock.now() - beginLockTimestamp;\n 75:                 if (costTime > 5 * 1000) {\n 76:                     log.info(\"[NOTIFYME] check hold request cost {} ms.\", costTime);\n 77:                 }\n 78:             } catch (Throwable e) {\n 79:                 log.warn(this.getServiceName() + \" service has exception. \", e);\n 80:             }\n 81:         }\n 82: \n 83:         log.info(\"{} service end\", this.getServiceName());\n 84:     }\n 85: \n 86:     @Override\n 87:     public String getServiceName() {\n 88:         return PullRequestHoldService.class.getSimpleName();\n 89:     }\n 90: \n 91:     /**\n 92:      * 遍历挂起请求，检查是否有需要通知的请求。\n 93:      */\n 94:     private void checkHoldRequest() {\n 95:         for (String key : this.pullRequestTable.keySet()) {\n 96:             String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);\n 97:             if (2 == kArray.length) {\n 98:                 String topic = kArray[0];\n 99:                 int queueId = Integer.parseInt(kArray[1]);\n100:                 final long offset = this.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);\n101:                 try {\n102:                     this.notifyMessageArriving(topic, queueId, offset);\n103:                 } catch (Throwable e) {\n104:                     log.error(\"check hold request failed. topic={}, queueId={}\", topic, queueId, e);\n105:                 }\n106:             }\n107:         }\n108:     }\n109: \n110:     /**\n111:      * 检查是否有需要通知的请求\n112:      *\n113:      * @param topic 主题\n114:      * @param queueId 队列编号\n115:      * @param maxOffset 消费队列最大offset\n116:      */\n117:     public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset) {\n118:         notifyMessageArriving(topic, queueId, maxOffset, null);\n119:     }\n120: \n121:     /**\n122:      * 检查是否有需要通知的请求\n123:      *\n124:      * @param topic 主题\n125:      * @param queueId 队列编号\n126:      * @param maxOffset 消费队列最大offset\n127:      * @param tagsCode 过滤tagsCode\n128:      */\n129:     public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset, final Long tagsCode) {\n130:         String key = this.buildKey(topic, queueId);\n131:         ManyPullRequest mpr = this.pullRequestTable.get(key);\n132:         if (mpr != null) {\n133:             //\n134:             List<PullRequest> requestList = mpr.cloneListAndClear();\n135:             if (requestList != null) {\n136:                 List<PullRequest> replayList = new ArrayList<>(); // 不符合唤醒的请求数组\n137: \n138:                 for (PullRequest request : requestList) {\n139:                     // 如果 maxOffset 过小，则重新读取一次。\n140:                     long newestOffset = maxOffset;\n141:                     if (newestOffset <= request.getPullFromThisOffset()) {\n142:                         newestOffset = this.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);\n143:                     }\n144:                     // 有新的匹配消息，唤醒请求，即再次拉取消息。\n145:                     if (newestOffset > request.getPullFromThisOffset()) {\n146:                         if (this.messageFilter.isMessageMatched(request.getSubscriptionData(), tagsCode)) {\n147:                             try {\n148:                                 this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),\n149:                                     request.getRequestCommand());\n150:                             } catch (Throwable e) {\n151:                                 log.error(\"execute request when wakeup failed.\", e);\n152:                             }\n153:                             continue;\n154:                         }\n155:                     }\n156:                     // 超过挂起时间，唤醒请求，即再次拉取消息。\n157:                     if (System.currentTimeMillis() >= (request.getSuspendTimestamp() + request.getTimeoutMillis())) {\n158:                         try {\n159:                             this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),\n160:                                 request.getRequestCommand());\n161:                         } catch (Throwable e) {\n162:                             log.error(\"execute request when wakeup failed.\", e);\n163:                         }\n164:                         continue;\n165:                     }\n166:                     // 不符合再次拉取的请求，再次添加回去\n167:                     replayList.add(request);\n168:                 }\n169:                 // 添加回去\n170:                 if (!replayList.isEmpty()) {\n171:                     mpr.addPullRequest(replayList);\n172:                 }\n173:             }\n174:         }\n175:     }\n176: }\n```\n\n* `PullRequestHoldService` 说明 ：拉取消息请求挂起维护线程服务。\n    * 当拉取消息请求获得不了消息时，则会将请求进行挂起，添加到该服务。\n    * 当有符合条件信息时 或 挂起超时时，重新执行获取消息逻辑。\n* `#suspendPullRequest(...)` 说明 ：添加拉取消息挂起请求到集合( `pullRequestTable` )。\n* `#run(...)` 说明 ：**定时**检查挂起请求是否有需要通知重新拉取消息并进行通知。\n    * 第 65 至 70 行 ：根据`长轮训`or`短轮训`设置不同的等待时间。\n    * 第 71 至 77 行 ：检查挂起请求是否有需要通知的。\n* `#checkHoldRequest(...)` 说明 ：遍历挂起请求，检查是否有需要通知的。\n* `#notifyMessageArriving(...)` 说明 ：检查**指定队列**是否有需要通知的请求。\n    * 第 139 至 143 行 ：如果 `maxOffset` 过小，重新获取一次最新的。\n    * 第 144 至 155 行 ：有新的匹配消息，唤醒请求，即再次拉取消息。\n    * 第 156 至 165 行 ：超过挂起时间，唤醒请求，即再次拉取消息。\n    * 第 148 || 159 行 ：唤醒请求，再次拉取消息。原先担心拉取消息时间过长，导致影响整个挂起请求的遍历，后面查看`#executeRequestWhenWakeup(...)`，实际是丢到线程池进行一步的消息拉取，不会有性能上的问题。详细解析见：[PullMessageProcessor#executeRequestWhenWakeup(...)](pullmessageprocessorexecuterequestwhenwakeup)。\n    * 第 166 至 172 行 ：不符合唤醒的请求重新添加到集合(`pullRequestTable`)。\n\n## PullMessageProcessor#executeRequestWhenWakeup(...)\n\n```Java\n  1: public void executeRequestWhenWakeup(final Channel channel, final RemotingCommand request) throws RemotingCommandException {\n  2:     Runnable run = new Runnable() {\n  3:         @Override\n  4:         public void run() {\n  5:             try {\n  6:                 // 调用拉取请求。本次调用，设置不挂起请求。\n  7:                 final RemotingCommand response = PullMessageProcessor.this.processRequest(channel, request, false);\n  8: \n  9:                 if (response != null) {\n 10:                     response.setOpaque(request.getOpaque());\n 11:                     response.markResponseType();\n 12:                     try {\n 13:                         channel.writeAndFlush(response).addListener(new ChannelFutureListener() {\n 14:                             @Override\n 15:                             public void operationComplete(ChannelFuture future) throws Exception {\n 16:                                 if (!future.isSuccess()) {\n 17:                                     LOG.error(\"ProcessRequestWrapper response to {} failed\", future.channel().remoteAddress(), future.cause());\n 18:                                     LOG.error(request.toString());\n 19:                                     LOG.error(response.toString());\n 20:                                 }\n 21:                             }\n 22:                         });\n 23:                     } catch (Throwable e) {\n 24:                         LOG.error(\"ProcessRequestWrapper process request over, but response failed\", e);\n 25:                         LOG.error(request.toString());\n 26:                         LOG.error(response.toString());\n 27:                     }\n 28:                 }\n 29:             } catch (RemotingCommandException e1) {\n 30:                 LOG.error(\"ExecuteRequestWhenWakeup run\", e1);\n 31:             }\n 32:         }\n 33:     };\n 34:     // 提交拉取请求到线程池\n 35:     this.brokerController.getPullMessageExecutor().submit(new RequestTask(run, channel, request));\n 36: }\n```\n\n* 说明 ：执行请求唤醒，即再次拉取消息。该方法调用线程池，因此，不会阻塞。\n* 第 7 行 ：调用拉取消息请求。本次调用，设置即使请求不到消息，也不挂起请求。如果不设置，请求可能被无限挂起，被 `Broker` 无限循环。\n* 第 35 行 ：**提交拉取消息请求到线程池**。\n\n# 5、Broker 提供[更新消费进度]接口\n\n```bash\nYunai-MacdeMacBook-Pro-2:config yunai$ pwd\n/Users/yunai/store/config\nYunai-MacdeMacBook-Pro-2:config yunai$ ls -ls\ntotal 40\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json.bak\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json.bak\n8 -rw-r--r--  1 yunai  staff  1401  4 27 21:51 topics.json\nYunai-MacdeMacBook-Pro-2:config yunai$ cat consumerOffset.json\n{\n\t\"offsetTable\":{\n\t\t\"%RETRY%please_rename_unique_group_name_4@please_rename_unique_group_name_4\":{0:0\n\t\t},\n\t\t\"TopicRead3@please_rename_unique_group_name_4\":{1:5\n\t\t}\n\t}\n}\n```\n\n* `consumerOffset.json` ：消费进度存储文件。\n* `consumerOffset.json.bak` ：消费进度存储文件备份。\n* 每次写入 `consumerOffset.json`，将原内容备份到 `consumerOffset.json.bak`。实现见：[MixAll#string2File(...)](mixallstring2file)。\n\n## BrokerController#initialize(...)\n\n```Java\n  1:this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  2:    @Override\n  3:    public void run() {\n  4:        try {\n  5:            BrokerController.this.consumerOffsetManager.persist();\n  6:        } catch (Throwable e) {\n  7:            log.error(\"schedule persist consumerOffset error.\", e);\n  8:        }\n  9:    }\n 10:}, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);\n```\n\n* 说明 ：每 5s 执行一次持久化逻辑。\n\n## ConfigManager\n\n```Java\n  1: public abstract class ConfigManager {\n  2: private static final Logger PLOG = LoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n  3: \n  4: /**\n  5:  * 编码内容\n  6:  * @return 编码后的内容\n  7:  */\n  8: public abstract String encode();\n  9: \n 10: /**\n 11:  * 加载文件\n 12:  *\n 13:  * @return 加载是否成功\n 14:  */\n 15: public boolean load() {\n 16:     String fileName = null;\n 17:     try {\n 18:         fileName = this.configFilePath();\n 19:         String jsonString = MixAll.file2String(fileName);\n 20:         // 如果内容不存在，则加载备份文件\n 21:         if (null == jsonString || jsonString.length() == 0) {\n 22:             return this.loadBak();\n 23:         } else {\n 24:             this.decode(jsonString);\n 25:             PLOG.info(\"load {} OK\", fileName);\n 26:             return true;\n 27:         }\n 28:     } catch (Exception e) {\n 29:         PLOG.error(\"load \" + fileName + \" Failed, and try to load backup file\", e);\n 30:         return this.loadBak();\n 31:     }\n 32: }\n 33: \n 34: /**\n 35:  * 配置文件地址\n 36:  *\n 37:  * @return 配置文件地址\n 38:  */\n 39: public abstract String configFilePath();\n 40: \n 41: /**\n 42:  * 加载备份文件\n 43:  *\n 44:  * @return 是否成功\n 45:  */\n 46: private boolean loadBak() {\n 47:     String fileName = null;\n 48:     try {\n 49:         fileName = this.configFilePath();\n 50:         String jsonString = MixAll.file2String(fileName + \".bak\");\n 51:         if (jsonString != null && jsonString.length() > 0) {\n 52:             this.decode(jsonString);\n 53:             PLOG.info(\"load \" + fileName + \" OK\");\n 54:             return true;\n 55:         }\n 56:     } catch (Exception e) {\n 57:         PLOG.error(\"load \" + fileName + \" Failed\", e);\n 58:         return false;\n 59:     }\n 60: \n 61:     return true;\n 62: }\n 63: \n 64: /**\n 65:  * 解码内容\n 66:  *\n 67:  * @param jsonString 内容\n 68:  */\n 69: public abstract void decode(final String jsonString);\n 70: \n 71: /**\n 72:  * 持久化\n 73:  */\n 74: public synchronized void persist() {\n 75:     String jsonString = this.encode(true);\n 76:     if (jsonString != null) {\n 77:         String fileName = this.configFilePath();\n 78:         try {\n 79:             MixAll.string2File(jsonString, fileName);\n 80:         } catch (IOException e) {\n 81:             PLOG.error(\"persist file Exception, \" + fileName, e);\n 82:         }\n 83:     }\n 84: }\n 85: \n 86: /**\n 87:  * 编码存储内容\n 88:  *\n 89:  * @param prettyFormat 是否格式化\n 90:  * @return 内容\n 91:  */\n 92: public abstract String encode(final boolean prettyFormat);\n 93: }\n```\n\n### MixAll#string2File(...)\n\n```Java\n  1: /**\n  2:  * 将内容写到文件\n  3:  * 安全写\n  4:  * 1. 写到.tmp文件\n  5:  * 2. 备份准备写入文件到.bak文件\n  6:  * 3. 删除原文件，将.tmp修改成文件\n  7:  *\n  8:  * @param str 内容\n  9:  * @param fileName 文件名\n 10:  * @throws IOException 当IO发生异常时\n 11:  */\n 12: public static void string2File(final String str, final String fileName) throws IOException {\n 13:     // 写到 tmp文件\n 14:     String tmpFile = fileName + \".tmp\";\n 15:     string2FileNotSafe(str, tmpFile);\n 16:     //\n 17:     String bakFile = fileName + \".bak\";\n 18:     String prevContent = file2String(fileName);\n 19:     if (prevContent != null) {\n 20:         string2FileNotSafe(prevContent, bakFile);\n 21:     }\n 22: \n 23:     File file = new File(fileName);\n 24:     file.delete();\n 25: \n 26:     file = new File(tmpFile);\n 27:     file.renameTo(new File(fileName));\n 28: }\n 29: \n 30: /**\n 31:  * 将内容写到文件\n 32:  * 非安全写\n 33:  *\n 34:  * @param str 内容\n 35:  * @param fileName 文件内容\n 36:  * @throws IOException 当IO发生异常时\n 37:  */\n 38: public static void string2FileNotSafe(final String str, final String fileName) throws IOException {\n 39:     File file = new File(fileName);\n 40:     // 创建上级目录\n 41:     File fileParent = file.getParentFile();\n 42:     if (fileParent != null) {\n 43:         fileParent.mkdirs();\n 44:     }\n 45:     // 写内容\n 46:     FileWriter fileWriter = null;\n 47:     try {\n 48:         fileWriter = new FileWriter(file);\n 49:         fileWriter.write(str);\n 50:     } catch (IOException e) {\n 51:         throw e;\n 52:     } finally {\n 53:         if (fileWriter != null) {\n 54:             fileWriter.close();\n 55:         }\n 56:     }\n 57: }\n```\n\n## ConsumerOffsetManager\n\n```Java\n  1: public class ConsumerOffsetManager extends ConfigManager {\n  2:     private static final Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n  3:     private static final String TOPIC_GROUP_SEPARATOR = \"@\";\n  4: \n  5:     /**\n  6:      * 消费进度集合\n  7:      */\n  8:     private ConcurrentHashMap<String/* topic@group */, ConcurrentHashMap<Integer, Long>> offsetTable = new ConcurrentHashMap<>(512);\n  9: \n 10:     private transient BrokerController brokerController;\n 11: \n 12:     public ConsumerOffsetManager() {\n 13:     }\n 14: \n 15:     public ConsumerOffsetManager(BrokerController brokerController) {\n 16:         this.brokerController = brokerController;\n 17:     }\n 18: \n 19:     /**\n 20:      * 提交消费进度\n 21:      *\n 22:      * @param clientHost 提交client地址\n 23:      * @param group 消费分组\n 24:      * @param topic 主题\n 25:      * @param queueId 队列编号\n 26:      * @param offset 进度（队列位置）\n 27:      */\n 28:     public void commitOffset(final String clientHost, final String group, final String topic, final int queueId, final long offset) {\n 29:         // topic@group\n 30:         String key = topic + TOPIC_GROUP_SEPARATOR + group;\n 31:         this.commitOffset(clientHost, key, queueId, offset);\n 32:     }\n 33: \n 34:     /**\n 35:      * 提交消费进度\n 36:      *\n 37:      * @param clientHost 提交client地址\n 38:      * @param key 主题@消费分组\n 39:      * @param queueId 队列编号\n 40:      * @param offset 进度（队列位置）\n 41:      */\n 42:     private void commitOffset(final String clientHost, final String key, final int queueId, final long offset) {\n 43:         ConcurrentHashMap<Integer, Long> map = this.offsetTable.get(key);\n 44:         if (null == map) {\n 45:             map = new ConcurrentHashMap<>(32);\n 46:             map.put(queueId, offset);\n 47:             this.offsetTable.put(key, map);\n 48:         } else {\n 49:             Long storeOffset = map.put(queueId, offset);\n 50:             if (storeOffset != null && offset < storeOffset) {\n 51:                 log.warn(\"[NOTIFYME]update consumer offset less than store. clientHost={}, key={}, queueId={}, requestOffset={}, storeOffset={}\", clientHost, key, queueId, offset, storeOffset);\n 52:             }\n 53:         }\n 54:     }\n 55: \n 56:     public String encode() {\n 57:         return this.encode(false);\n 58:     }\n 59: \n 60:     @Override\n 61:     public String configFilePath() {\n 62:         return BrokerPathConfigHelper.getConsumerOffsetPath(this.brokerController.getMessageStoreConfig().getStorePathRootDir());\n 63:     }\n 64: \n 65:     /**\n 66:      * 解码内容\n 67:      * 格式:JSON\n 68:      *\n 69:      * @param jsonString 内容\n 70:      */\n 71:     @Override\n 72:     public void decode(String jsonString) {\n 73:         if (jsonString != null) {\n 74:             ConsumerOffsetManager obj = RemotingSerializable.fromJson(jsonString, ConsumerOffsetManager.class);\n 75:             if (obj != null) {\n 76:                 this.offsetTable = obj.offsetTable;\n 77:             }\n 78:         }\n 79:     }\n 80: \n 81:     /**\n 82:      * 编码内容\n 83:      * 格式为JSON\n 84:      *\n 85:      * @param prettyFormat 是否格式化\n 86:      * @return 编码后的内容\n 87:      */\n 88:     public String encode(final boolean prettyFormat) {\n 89:         return RemotingSerializable.toJson(this, prettyFormat);\n 90:     }\n 91: \n 92: }\n```\n\n* 说明 ：消费进度管理器。\n\n# 6、Broker 提供[发回消息]接口\n\n大部分逻辑和 [`Broker` 提供[接收消息]接口](http://www.yunai.me/RocketMQ/message-send-and-receive/#3、Broker-接收消息) 类似，可以先看下相关内容。\n\n## SendMessageProcessor#consumerSendMsgBack(...)\n\n```Java\n  1: private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)\n  2:     throws RemotingCommandException {\n  3: \n  4:     // 初始化响应\n  5:     final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n  6:     final ConsumerSendMsgBackRequestHeader requestHeader =\n  7:         (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);\n  8: \n  9:     // hook（独有）\n 10:     if (this.hasConsumeMessageHook() && !UtilAll.isBlank(requestHeader.getOriginMsgId())) {\n 11: \n 12:         ConsumeMessageContext context = new ConsumeMessageContext();\n 13:         context.setConsumerGroup(requestHeader.getGroup());\n 14:         context.setTopic(requestHeader.getOriginTopic());\n 15:         context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);\n 16:         context.setCommercialRcvTimes(1);\n 17:         context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));\n 18: \n 19:         this.executeConsumeMessageHookAfter(context);\n 20:     }\n 21: \n 22:     // 判断消费分组是否存在（独有）\n 23:     SubscriptionGroupConfig subscriptionGroupConfig =\n 24:         this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());\n 25:     if (null == subscriptionGroupConfig) {\n 26:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 27:         response.setRemark(\"subscription group not exist, \" + requestHeader.getGroup() + \" \"\n 28:             + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));\n 29:         return response;\n 30:     }\n 31: \n 32:     // 检查 broker 是否有写入权限\n 33:     if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n 34:         response.setCode(ResponseCode.NO_PERMISSION);\n 35:         response.setRemark(\"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \"] sending message is forbidden\");\n 36:         return response;\n 37:     }\n 38: \n 39:     // 检查 重试队列数 是否大于0（独有）\n 40:     if (subscriptionGroupConfig.getRetryQueueNums() <= 0) {\n 41:         response.setCode(ResponseCode.SUCCESS);\n 42:         response.setRemark(null);\n 43:         return response;\n 44:     }\n 45: \n 46:     // 计算retry Topic\n 47:     String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());\n 48: \n 49:     // 计算队列编号（独有）\n 50:     int queueIdInt = Math.abs(this.random.nextInt() % 99999999) % subscriptionGroupConfig.getRetryQueueNums();\n 51: \n 52:     // 计算sysFlag（独有）\n 53:     int topicSysFlag = 0;\n 54:     if (requestHeader.isUnitMode()) {\n 55:         topicSysFlag = TopicSysFlag.buildSysFlag(false, true);\n 56:     }\n 57: \n 58:     // 获取topicConfig。如果获取不到，则进行创建\n 59:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(//\n 60:         newTopic, //\n 61:         subscriptionGroupConfig.getRetryQueueNums(), //\n 62:         PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);\n 63:     if (null == topicConfig) { // 没有配置\n 64:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 65:         response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n 66:         return response;\n 67:     }\n 68:     if (!PermName.isWriteable(topicConfig.getPerm())) { // 不允许写入\n 69:         response.setCode(ResponseCode.NO_PERMISSION);\n 70:         response.setRemark(String.format(\"the topic[%s] sending message is forbidden\", newTopic));\n 71:         return response;\n 72:     }\n 73: \n 74:     // 查询消息。若不存在，返回异常错误。（独有）\n 75:     MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());\n 76:     if (null == msgExt) {\n 77:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 78:         response.setRemark(\"look message by offset failed, \" + requestHeader.getOffset());\n 79:         return response;\n 80:     }\n 81: \n 82:     // 设置retryTopic到拓展属性（独有）\n 83:     final String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);\n 84:     if (null == retryTopic) {\n 85:         MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());\n 86:     }\n 87: \n 88:     // 设置消息不等待存储完成（独有） TODO 疑问：如果设置成不等待存储，broker设置成同步落盘，岂不是不能批量提交了？\n 89:     msgExt.setWaitStoreMsgOK(false);\n 90: \n 91:     // 处理 delayLevel（独有）。\n 92:     int delayLevel = requestHeader.getDelayLevel();\n 93:     int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 94:     if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 95:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 96:     }\n 97:     if (msgExt.getReconsumeTimes() >= maxReconsumeTimes//\n 98:         || delayLevel < 0) { // 如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)\n 99:         newTopic = MixAll.getDLQTopic(requestHeader.getGroup());\n100:         queueIdInt = Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;\n101: \n102:         topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, //\n103:             DLQ_NUMS_PER_GROUP, //\n104:             PermName.PERM_WRITE, 0\n105:         );\n106:         if (null == topicConfig) {\n107:             response.setCode(ResponseCode.SYSTEM_ERROR);\n108:             response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n109:             return response;\n110:         }\n111:     } else {\n112:         if (0 == delayLevel) {\n113:             delayLevel = 3 + msgExt.getReconsumeTimes();\n114:         }\n115:         msgExt.setDelayTimeLevel(delayLevel);\n116:     }\n117: \n118:     // 创建MessageExtBrokerInner\n119:     MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n120:     msgInner.setTopic(newTopic);\n121:     msgInner.setBody(msgExt.getBody());\n122:     msgInner.setFlag(msgExt.getFlag());\n123:     MessageAccessor.setProperties(msgInner, msgExt.getProperties());\n124:     msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));\n125:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags()));\n126:     msgInner.setQueueId(queueIdInt);\n127:     msgInner.setSysFlag(msgExt.getSysFlag());\n128:     msgInner.setBornTimestamp(msgExt.getBornTimestamp());\n129:     msgInner.setBornHost(msgExt.getBornHost());\n130:     msgInner.setStoreHost(this.getStoreHost());\n131:     msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1);\n132: \n133:     // 设置原始消息编号到拓展字段（独有）\n134:     String originMsgId = MessageAccessor.getOriginMessageId(msgExt);\n135:     MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);\n136: \n137:     // 添加消息\n138:     PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);\n139:     if (putMessageResult != null) {\n140:         switch (putMessageResult.getPutMessageStatus()) {\n141:             case PUT_OK:\n142:                 String backTopic = msgExt.getTopic();\n143:                 String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);\n144:                 if (correctTopic != null) {\n145:                     backTopic = correctTopic;\n146:                 }\n147: \n148:                 this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);\n149: \n150:                 response.setCode(ResponseCode.SUCCESS);\n151:                 response.setRemark(null);\n152: \n153:                 return response;\n154:             default:\n155:                 break;\n156:         }\n157: \n158:         response.setCode(ResponseCode.SYSTEM_ERROR);\n159:         response.setRemark(putMessageResult.getPutMessageStatus().name());\n160:         return response;\n161:     }\n162: \n163:     response.setCode(ResponseCode.SYSTEM_ERROR);\n164:     response.setRemark(\"putMessageResult is null\");\n165:     return response;\n166: }\n```\n\n* 说明 ：当 `Consumer` 消费某条消息失败时，会调用该接口发回消息。`Broker` 会存储发回的消息。这样，下次 `Consumer` 拉取该消息，能够从 `CommitLog` 和 `ConsumeQueue` 顺序读取。\n* [x] 因为大多数逻辑和 **`Broker` 接收普通消息** 很相似，时候 `TODO` 标记成独有的逻辑。\n* 第 4 至 7 行 ：初始化响应。\n* [x] 第 9 至 20 行 ：Hook逻辑。\n* [x] 第22 至 30 行 ：判断消费分组是否存在。\n* 第 32 至 37 行 ：检查 `Broker` 是否有写入权限。\n* [x] 第 39 至 44 行 ：检查重试队列数是否大于0。\n* 第 47 行 ：计算 retry topic。\n* [x] 第 50 行 ：随机分配队列编号，依赖 `retryQueueNums`。\n* [x] 第 52 至 56 行 ：计算 `sysFlag`。\n* 第 58 至 72 行 ：获取 `TopicConfig`。如果不存在，则创建。\n* [x] 第 74 至 80 行 ：查询消息。若不存在，返回异常错误。\n* [x] 第 82 至 86 行 ：设置 `retryTopic` 到消息拓展属性。\n* [x] 第 89 行 ：设置消息不等待存储完成。\n    * 当 `Broker` 刷盘方式为同步，会导致同步落盘不能批量提交，这样会不会存在问题？有知道的同学麻烦告知下。😈。\n* [x] 第 91 至 116 行 ：处理 `delayLevel` 。\n* 第 118 至 131 行 ：创建 `MessageExtBrokerInner` 。\n* [x] 第 133 至 135 行 ：设置原始消息编号到拓展属性。\n* 第 137 至 161 行 ：添加消息。\n\n# 7、结尾\n\n感谢同学们对本文的阅读、收藏、点赞。\n\n😈如果解析存在问题或者表达误解的，表示抱歉。如果方便的话，可以加下 **QQ：7685413**。让我们来一场 1 ：1 交流（搞基）。\n\n再次表示十分感谢。\n\n\n","source":"_posts/RocketMQ/2017_05_04_RocketMQ源码分析——Message拉取与消费（上）.md","raw":"title: RocketMQ 源码分析 —— Message 拉取与消费（上）\ndate: 2017-05-04\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-pull-and-consume-first\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-pull-and-consume-first/](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、ConsumeQueue 结构](#)\n- [3、ConsumeQueue 存储](#)\n\t- [ReputMessageService](#)\n\t\t- [DefaultMessageStore#doDispatch(...)](#)\n\t\t- [ConsumeQueue#putMessagePositionInfoWrapper(...)](#)\n\t- [FlushConsumeQueueService](#)\n- [4、Broker 提供[拉取消息]接口](#)\n\t- [PullMessageRequestHeader](#)\n\t- [PullMessageProcessor#processRequest(...)](#)\n\t- [MessageStore#getMessage(...)](#)\n\t- [DefaultMessageFilter#isMessageMatched(...)](#)\n\t- [PullRequestHoldService](#)\n\t- [PullMessageProcessor#executeRequestWhenWakeup(...)](#)\n- [5、Broker 提供[更新消费进度]接口](#)\n\t- [BrokerController#initialize(...)](#)\n\t- [ConfigManager](#)\n\t\t- [MixAll#string2File(...)](#)\n\t- [ConsumerOffsetManager](#)\n- [6、Broker 提供[发回消息]接口](#)\n\t- [SendMessageProcessor#consumerSendMsgBack(...)](#)\n- [7、结尾](#)\n\n# 1、概述\n\n本章主要解析 **消费** 逻辑涉及到的源码。\n因为篇幅较长，分成上下两篇：\n\n1. 上篇：`Broker` 相关源码。\n2. 下篇：`Consumer` 相关源码。\n\n*本文即是上篇。*\n\n-------\n\nok，先看第一张关于消费逻辑的图：\n\n> ![消费逻辑图](http://www.yunai.me/images/RocketMQ/2017_05_04/13.png)\n\n再看消费逻辑精简的顺序图（实际情况会略有差别）：\n\n> ![Consumer&Broker消费精简图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/04.png)\n\n# 2、ConsumeQueue 结构\n\n`ConsumeQueue`、`MappedFileQueue`、`MappedFile` 的关系如下：\n\n> ![ConsumeQueue、MappedFileQueue、MappedFile的关系](http://www.yunai.me/images/RocketMQ/2017_05_04/03.png)\n`ConsumeQueue` : `MappedFileQueue` : `MappedFile` = 1 : 1 : N。\n\n反应到系统文件如下：\n\n```bash\nYunai-MacdeMacBook-Pro-2:consumequeue yunai$ pwd\n/Users/yunai/store/consumequeue\nYunai-MacdeMacBook-Pro-2:consumequeue yunai$ cd TopicRead3/\nYunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ ls -ls\ntotal 0\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:52 0\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 1\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 2\n0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 3\nYunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ cd 0/\nYunai-MacdeMacBook-Pro-2:0 yunai$ ls -ls\ntotal 11720\n11720 -rw-r--r--  1 yunai  staff  6000000  4 27 21:55 00000000000000000000\n```\n\n-------\n\n`ConsumeQueue`、`MappedFileQueue`、`MappedFile` 的定义如下：\n\n* `MappedFile` ：00000000000000000000等文件。\n* `MappedFileQueue` ：`MappedFile` 所在的文件夹，对 `MappedFile` 进行封装成文件队列，对上层提供可无限使用的文件容量。\n    * 每个 `MappedFile` 统一文件大小。\n    * 文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 `ConsumeQueue` 里默认为 6000000B。\n* `ConsumeQueue` ：针对 `MappedFileQueue` 的封装使用。\n    * `Store : ConsumeQueue = ConcurrentHashMap<String/* topic */, ConcurrentHashMap<Integer/* queueId */, ConsumeQueue>>`。\n\n`ConsumeQueue` 存储在 `MappedFile` 的内容**必须**大小是 20B( `ConsumeQueue.CQ_STORE_UNIT_SIZE` )，有两种内容类型：\n\n1. `MESSAGE_POSITION_INFO` ：消息位置信息。\n2. `BLANK` : 文件前置空白占位。当历史 `Message` 被删除时，需要用 `BLANK`占位被删除的消息。\n\n`MESSAGE_POSITION_INFO` 在 `ConsumeQueue` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | offset | 消息 `CommitLog` 存储位置 | Long | 8 |\n| 2 | size | 消息长度 | Int | 4 |\n| 3 | tagsCode | 消息tagsCode | Long | 8 |\n\n`BLANK` 在 `ConsumeQueue` 存储结构：\n\n| 第几位 | 字段 | 说明 | 数据类型 | 字节数 |\n| :-- | :-- | :-- | :-- | :-- |\n| 1 | | 0 | Long | 8 |\n| 2 | | Integer.MAX_VALUE | Int | 4 |\n| 3 | | 0 | Long | 8 |\n\n# 3、ConsumeQueue 存储\n\n![CommitLog重放ConsumeQueue图](http://www.yunai.me/images/RocketMQ/2017_05_04/02.png)\n\n主要有两个组件：\n\n* `ReputMessageService` ：write ConsumeQueue。\n* `FlushConsumeQueueService` ：flush ConsumeQueue。\n\n## ReputMessageService\n\n![ReputMessageService顺序图](http://www.yunai.me/images/RocketMQ/2017_05_04/12.png)\n\n```Java\n  1: class ReputMessageService extends ServiceThread {\n  2: \n  3:     /**\n  4:      * 开始重放消息的CommitLog物理位置\n  5:      */\n  6:     private volatile long reputFromOffset = 0;\n  7: \n  8:     public long getReputFromOffset() {\n  9:         return reputFromOffset;\n 10:     }\n 11: \n 12:     public void setReputFromOffset(long reputFromOffset) {\n 13:         this.reputFromOffset = reputFromOffset;\n 14:     }\n 15: \n 16:     @Override\n 17:     public void shutdown() {\n 18:         for (int i = 0; i < 50 && this.isCommitLogAvailable(); i++) {\n 19:             try {\n 20:                 Thread.sleep(100);\n 21:             } catch (InterruptedException ignored) {\n 22:             }\n 23:         }\n 24: \n 25:         if (this.isCommitLogAvailable()) {\n 26:             log.warn(\"shutdown ReputMessageService, but commitlog have not finish to be dispatched, CL: {} reputFromOffset: {}\",\n 27:                 DefaultMessageStore.this.commitLog.getMaxOffset(), this.reputFromOffset);\n 28:         }\n 29: \n 30:         super.shutdown();\n 31:     }\n 32: \n 33:     /**\n 34:      * 剩余需要重放消息字节数\n 35:      *\n 36:      * @return 字节数\n 37:      */\n 38:     public long behind() {\n 39:         return DefaultMessageStore.this.commitLog.getMaxOffset() - this.reputFromOffset;\n 40:     }\n 41: \n 42:     /**\n 43:      * 是否commitLog需要重放消息\n 44:      *\n 45:      * @return 是否\n 46:      */\n 47:     private boolean isCommitLogAvailable() {\n 48:         return this.reputFromOffset < DefaultMessageStore.this.commitLog.getMaxOffset();\n 49:     }\n 50: \n 51:     private void doReput() {\n 52:         for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) {\n 53: \n 54:             // TODO 疑问：这个是啥\n 55:             if (DefaultMessageStore.this.getMessageStoreConfig().isDuplicationEnable() //\n 56:                 && this.reputFromOffset >= DefaultMessageStore.this.getConfirmOffset()) {\n 57:                 break;\n 58:             }\n 59: \n 60:             // 获取从reputFromOffset开始的commitLog对应的MappeFile对应的MappedByteBuffer\n 61:             SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset);\n 62:             if (result != null) {\n 63:                 try {\n 64:                     this.reputFromOffset = result.getStartOffset();\n 65: \n 66:                     // 遍历MappedByteBuffer\n 67:                     for (int readSize = 0; readSize < result.getSize() && doNext; ) {\n 68:                         // 生成重放消息重放调度请求\n 69:                         DispatchRequest dispatchRequest = DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false);\n 70:                         int size = dispatchRequest.getMsgSize(); // 消息长度\n 71:                         // 根据请求的结果处理\n 72:                         if (dispatchRequest.isSuccess()) { // 读取成功\n 73:                             if (size > 0) { // 读取Message\n 74:                                 DefaultMessageStore.this.doDispatch(dispatchRequest);\n 75:                                 // 通知有新消息\n 76:                                 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole()\n 77:                                     && DefaultMessageStore.this.brokerConfig.isLongPollingEnable()) {\n 78:                                     DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(),\n 79:                                         dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1,\n 80:                                         dispatchRequest.getTagsCode());\n 81:                                 }\n 82:                                 // FIXED BUG By shijia\n 83:                                 this.reputFromOffset += size;\n 84:                                 readSize += size;\n 85:                                 // 统计\n 86:                                 if (DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) {\n 87:                                     DefaultMessageStore.this.storeStatsService\n 88:                                         .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();\n 89:                                     DefaultMessageStore.this.storeStatsService\n 90:                                         .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())\n 91:                                         .addAndGet(dispatchRequest.getMsgSize());\n 92:                                 }\n 93:                             } else if (size == 0) { // 读取到MappedFile文件尾\n 94:                                 this.reputFromOffset = DefaultMessageStore.this.commitLog.rollNextFile(this.reputFromOffset);\n 95:                                 readSize = result.getSize();\n 96:                             }\n 97:                         } else if (!dispatchRequest.isSuccess()) { // 读取失败\n 98:                             if (size > 0) { // 读取到Message却不是Message\n 99:                                 log.error(\"[BUG]read total count not equals msg total size. reputFromOffset={}\", reputFromOffset);\n100:                                 this.reputFromOffset += size;\n101:                             } else { // 读取到Blank却不是Blank\n102:                                 doNext = false;\n103:                                 if (DefaultMessageStore.this.brokerConfig.getBrokerId() == MixAll.MASTER_ID) {\n104:                                     log.error(\"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: {}\",\n105:                                         this.reputFromOffset);\n106: \n107:                                     this.reputFromOffset += result.getSize() - readSize;\n108:                                 }\n109:                             }\n110:                         }\n111:                     }\n112:                 } finally {\n113:                     result.release();\n114:                 }\n115:             } else {\n116:                 doNext = false;\n117:             }\n118:         }\n119:     }\n120: \n121:     @Override\n122:     public void run() {\n123:         DefaultMessageStore.log.info(this.getServiceName() + \" service started\");\n124: \n125:         while (!this.isStopped()) {\n126:             try {\n127:                 Thread.sleep(1);\n128:                 this.doReput();\n129:             } catch (Exception e) {\n130:                 DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n131:             }\n132:         }\n133: \n134:         DefaultMessageStore.log.info(this.getServiceName() + \" service end\");\n135:     }\n136: \n137:     @Override\n138:     public String getServiceName() {\n139:         return ReputMessageService.class.getSimpleName();\n140:     }\n141: \n142: }\n```\n\n* 说明：重放消息线程服务。\n    * 该服务不断生成 消息位置信息 到 消费队列(ConsumeQueue)\n    * 该服务不断生成 消息索引 到 索引文件(IndexFile)    \n* ![ReputMessageService用例图](http://www.yunai.me/images/RocketMQ/2017_05_04/11.png)\n    * 第 61 行 ：获取 `reputFromOffset` 开始的 `CommitLog` 对应的 `MappedFile` 对应的 `MappedByteBuffer`。\n    * 第 67 行 ：遍历 `MappedByteBuffer`。\n    * 第 69 行 ：生成重放消息重放调度请求 (`DispatchRequest`) 。请求里主要包含一条消息 (`Message`) 或者 文件尾 (`BLANK`) 的基本信息。\n    * 第 72 至 96 行 ：请求是有效请求，进行逻辑处理。\n        * 第 75 至 81 行 ：当 `Broker` 是主节点 && `Broker` 开启的是长轮询，通知消费队列有新的消息。`NotifyMessageArrivingListener` 会 调用 `PullRequestHoldService#notifyMessageArriving(...)` 方法，详细解析见：[PullRequestHoldService](#pullrequestholdservice)\n    * 第 73 至 92 行 ：请求对应的是 `Message`，进行调度，生成 `ConsumeQueue` 和 `IndexFile` 对应的内容。详细解析见：\n    * 第 93 至 96 行 ：请求对应的是 `Blank`，即文件尾，跳转指向下一个 `MappedFile`。\n    * 第 97 至 110 行 ：请求是无效请求。出现该情况，基本是一个**BUG**。\n* 第 127 至 128 行 ：每 1ms 循环执行重放逻辑。\n* 第 18 至 30 行 ：`shutdown`时，多次 `sleep(100)` 直到 `CommitLog` 回放到最新位置。恩，如果未回放完，会输出警告日志。\n\n### DefaultMessageStore#doDispatch(...)\n\n```Java\n  1: /**\n  2:  * 执行调度请求\n  3:  * 1. 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n  4:  * 2. 建立 索引信息 到 IndexFile\n  5:  *\n  6:  * @param req 调度请求\n  7:  */\n  8: public void doDispatch(DispatchRequest req) {\n  9:     // 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue\n 10:     final int tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());\n 11:     switch (tranType) {\n 12:         case MessageSysFlag.TRANSACTION_NOT_TYPE:\n 13:         case MessageSysFlag.TRANSACTION_COMMIT_TYPE:\n 14:             DefaultMessageStore.this.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),\n 15:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());\n 16:             break;\n 17:         case MessageSysFlag.TRANSACTION_PREPARED_TYPE:\n 18:         case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:\n 19:             break;\n 20:     }\n 21:     // 建立 索引信息 到 IndexFile\n 22:     if (DefaultMessageStore.this.getMessageStoreConfig().isMessageIndexEnable()) {\n 23:         DefaultMessageStore.this.indexService.buildIndex(req);\n 24:     }\n 25: }\n 26: \n 27: /**\n 28:  * 建立 消息位置信息 到 ConsumeQueue\n 29:  *\n 30:  * @param topic 主题\n 31:  * @param queueId 队列编号\n 32:  * @param offset commitLog存储位置\n 33:  * @param size 消息长度\n 34:  * @param tagsCode 消息tagsCode\n 35:  * @param storeTimestamp 存储时间\n 36:  * @param logicOffset 队列位置\n 37:  */\n 38: public void putMessagePositionInfo(String topic, int queueId, long offset, int size, long tagsCode, long storeTimestamp,\n 39:     long logicOffset) {\n 40:     ConsumeQueue cq = this.findConsumeQueue(topic, queueId);\n 41:     cq.putMessagePositionInfoWrapper(offset, size, tagsCode, storeTimestamp, logicOffset);\n 42: }\n```\n\n### ConsumeQueue#putMessagePositionInfoWrapper(...)\n\n```Java\n  1: /**\n  2:  * 添加位置信息封装\n  3:  *\n  4:  * @param offset commitLog存储位置\n  5:  * @param size 消息长度\n  6:  * @param tagsCode 消息tagsCode\n  7:  * @param storeTimestamp 消息存储时间\n  8:  * @param logicOffset 队列位置\n  9:  */\n 10: public void putMessagePositionInfoWrapper(long offset, int size, long tagsCode, long storeTimestamp,\n 11:     long logicOffset) {\n 12:     final int maxRetries = 30;\n 13:     boolean canWrite = this.defaultMessageStore.getRunningFlags().isWriteable();\n 14:     // 多次循环写，直到成功\n 15:     for (int i = 0; i < maxRetries && canWrite; i++) {\n 16:         // 调用添加位置信息\n 17:         boolean result = this.putMessagePositionInfo(offset, size, tagsCode, logicOffset);\n 18:         if (result) {\n 19:             // 添加成功，使用消息存储时间 作为 存储check point。\n 20:             this.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(storeTimestamp);\n 21:             return;\n 22:         } else {\n 23:             // XXX: warn and notify me\n 24:             log.warn(\"[BUG]put commit log position info to \" + topic + \":\" + queueId + \" \" + offset\n 25:                 + \" failed, retry \" + i + \" times\");\n 26: \n 27:             try {\n 28:                 Thread.sleep(1000);\n 29:             } catch (InterruptedException e) {\n 30:                 log.warn(\"\", e);\n 31:             }\n 32:         }\n 33:     }\n 34: \n 35:     // XXX: warn and notify me 设置异常不可写入\n 36:     log.error(\"[BUG]consume queue can not write, {} {}\", this.topic, this.queueId);\n 37:     this.defaultMessageStore.getRunningFlags().makeLogicsQueueError();\n 38: }\n 39: \n 40: /**\n 41:  * 添加位置信息，并返回添加是否成功\n 42:  *\n 43:  * @param offset commitLog存储位置\n 44:  * @param size 消息长度\n 45:  * @param tagsCode 消息tagsCode\n 46:  * @param cqOffset 队列位置\n 47:  * @return 是否成功\n 48:  */\n 49: private boolean putMessagePositionInfo(final long offset, final int size, final long tagsCode,\n 50:     final long cqOffset) {\n 51:     // 如果已经重放过，直接返回成功\n 52:     if (offset <= this.maxPhysicOffset) {\n 53:         return true;\n 54:     }\n 55:     // 写入位置信息到byteBuffer\n 56:     this.byteBufferIndex.flip();\n 57:     this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);\n 58:     this.byteBufferIndex.putLong(offset);\n 59:     this.byteBufferIndex.putInt(size);\n 60:     this.byteBufferIndex.putLong(tagsCode);\n 61:     // 计算consumeQueue存储位置，并获得对应的MappedFile\n 62:     final long expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;\n 63:     MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset);\n 64:     if (mappedFile != null) {\n 65:         // 当是ConsumeQueue第一个MappedFile && 队列位置非第一个 && MappedFile未写入内容，则填充前置空白占位\n 66:         if (mappedFile.isFirstCreateInQueue() && cqOffset != 0 && mappedFile.getWrotePosition() == 0) { // TODO 疑问：为啥这个操作。目前能够想象到的是，一些老的消息很久没发送，突然发送，这个时候刚好满足。\n 67:             this.minLogicOffset = expectLogicOffset;\n 68:             this.mappedFileQueue.setFlushedWhere(expectLogicOffset);\n 69:             this.mappedFileQueue.setCommittedWhere(expectLogicOffset);\n 70:             this.fillPreBlank(mappedFile, expectLogicOffset);\n 71:             log.info(\"fill pre blank space \" + mappedFile.getFileName() + \" \" + expectLogicOffset + \" \"\n 72:                 + mappedFile.getWrotePosition());\n 73:         }\n 74:         // 校验consumeQueue存储位置是否合法。TODO 如果不合法，继续写入会不会有问题？\n 75:         if (cqOffset != 0) {\n 76:             long currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();\n 77:             if (expectLogicOffset != currentLogicOffset) {\n 78:                 LOG_ERROR.warn(\n 79:                     \"[BUG]logic queue order maybe wrong, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\",\n 80:                     expectLogicOffset,\n 81:                     currentLogicOffset,\n 82:                     this.topic,\n 83:                     this.queueId,\n 84:                     expectLogicOffset - currentLogicOffset\n 85:                 );\n 86:             }\n 87:         }\n 88:         // 设置commitLog重放消息到ConsumeQueue位置。\n 89:         this.maxPhysicOffset = offset;\n 90:         // 插入mappedFile\n 91:         return mappedFile.appendMessage(this.byteBufferIndex.array());\n 92:     }\n 93:     return false;\n 94: }\n 95: \n 96: /**\n 97:  * 填充前置空白占位\n 98:  *\n 99:  * @param mappedFile MappedFile\n100:  * @param untilWhere consumeQueue存储位置\n101:  */\n102: private void fillPreBlank(final MappedFile mappedFile, final long untilWhere) {\n103:     // 写入前置空白占位到byteBuffer\n104:     ByteBuffer byteBuffer = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);\n105:     byteBuffer.putLong(0L);\n106:     byteBuffer.putInt(Integer.MAX_VALUE);\n107:     byteBuffer.putLong(0L);\n108:     // 循环填空\n109:     int until = (int) (untilWhere % this.mappedFileQueue.getMappedFileSize());\n110:     for (int i = 0; i < until; i += CQ_STORE_UNIT_SIZE) {\n111:         mappedFile.appendMessage(byteBuffer.array());\n112:     }\n113: }\n```\n\n* `#putMessagePositionInfoWrapper(...)` 说明 ：添加位置信息到 `ConsumeQueue` 的封装，实际需要调用 `#putMessagePositionInfo(...)` 方法。\n    * 第 13 行 ：判断 `ConsumeQueue` 是否允许写入。当发生Bug时，不允许写入。\n    * 第 17 行 ：调用 `#putMessagePositionInfo(...)` 方法，添加位置信息。\n    * 第 18 至 21 行 ：添加成功，使用消息存储时间 作为 存储检查点。`StoreCheckpoint` 的详细解析见：[Store初始化与关闭](http://www.yunai.me/RocketMQ/store-init-and-shutdown/)。\n    * 第 22 至 32 行 ：添加失败，目前基本可以认为是BUG。\n    * 第 35 至 37 行 ：写入失败时，标记 `ConsumeQueue` 写入异常，不允许继续写入。\n* `#putMessagePositionInfo(...)` 说明 ：添加位置信息到 `ConsumeQueue`，并返回添加是否成功。\n    * 第 51 至 54 行 ：如果 `offset`(存储位置) 小于等于  `maxPhysicOffset`(`CommitLog` 消息重放到 `ConsumeQueue` 最大的 `CommitLog` 存储位置)，表示已经重放过，此时，不再重复写入，直接返回写入成功。\n    * 第 55 至 60 行 ：写 位置信息到byteBuffer。\n    * 第 62 至 63 行 ：计算 `ConsumeQueue`存储位置，并获得对应的MappedFile。\n    * 第 65 至 73 行 ：当 `MappedFile` 是 `ConsumeQueue` 当前第一个文件 && `MappedFile` 未写入内容 && 重放消息队列位置大于0，则需要进行 `MappedFile` 填充前置  `BLANK`。\n       * *这块比较有疑问，什么场景下会需要。猜测产生的原因：一个 `Topic` 长期无消息产生，突然N天后进行发送，`Topic` 对应的历史消息以及和消费队列数据已经被清理，新生成的`MappedFile`需要前置占位。*\n    * 第 74 至 87 行 ：校验 `ConsumeQueue` 存储位置是否合法，不合法则输出日志。\n        * *这块比较有疑问，如果计算出来的存储位置不合法，不返回添加失败，继续进行添加位置信息，会不会有问题？？？*\n    * 第 89 行 ：设置 `CommitLog` 重放消息到 `ConsumeQueue` 的最大位置。\n    * 第 91 行 ：插入消息位置到 `MappedFile`。\n\n## FlushConsumeQueueService\n\n```Java\n  1: class FlushConsumeQueueService extends ServiceThread {\n  2:     private static final int RETRY_TIMES_OVER = 3;\n  3:     /**\n  4:      * 最后flush时间戳\n  5:      */\n  6:     private long lastFlushTimestamp = 0;\n  7: \n  8:     private void doFlush(int retryTimes) {\n  9:         int flushConsumeQueueLeastPages = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueLeastPages();\n 10: \n 11:         // retryTimes == RETRY_TIMES_OVER时，进行强制flush。主要用于shutdown时。\n 12:         if (retryTimes == RETRY_TIMES_OVER) {\n 13:             flushConsumeQueueLeastPages = 0;\n 14:         }\n 15:         // 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush\n 16:         long logicsMsgTimestamp = 0;\n 17:         int flushConsumeQueueThoroughInterval = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval();\n 18:         long currentTimeMillis = System.currentTimeMillis();\n 19:         if (currentTimeMillis >= (this.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) {\n 20:             this.lastFlushTimestamp = currentTimeMillis;\n 21:             flushConsumeQueueLeastPages = 0;\n 22:             logicsMsgTimestamp = DefaultMessageStore.this.getStoreCheckpoint().getLogicsMsgTimestamp();\n 23:         }\n 24:         // flush消费队列\n 25:         ConcurrentHashMap<String, ConcurrentHashMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable;\n 26:         for (ConcurrentHashMap<Integer, ConsumeQueue> maps : tables.values()) {\n 27:             for (ConsumeQueue cq : maps.values()) {\n 28:                 boolean result = false;\n 29:                 for (int i = 0; i < retryTimes && !result; i++) {\n 30:                     result = cq.flush(flushConsumeQueueLeastPages);\n 31:                 }\n 32:             }\n 33:         }\n 34:         // flush 存储 check point\n 35:         if (0 == flushConsumeQueueLeastPages) {\n 36:             if (logicsMsgTimestamp > 0) {\n 37:                 DefaultMessageStore.this.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp);\n 38:             }\n 39:             DefaultMessageStore.this.getStoreCheckpoint().flush();\n 40:         }\n 41:     }\n 42: \n 43:     public void run() {\n 44:         DefaultMessageStore.log.info(this.getServiceName() + \" service started\");\n 45: \n 46:         while (!this.isStopped()) {\n 47:             try {\n 48:                 int interval = DefaultMessageStore.this.getMessageStoreConfig().getFlushIntervalConsumeQueue();\n 49:                 this.waitForRunning(interval);\n 50:                 this.doFlush(1);\n 51:             } catch (Exception e) {\n 52:                 DefaultMessageStore.log.warn(this.getServiceName() + \" service has exception. \", e);\n 53:             }\n 54:         }\n 55: \n 56:         this.doFlush(RETRY_TIMES_OVER);\n 57: \n 58:         DefaultMessageStore.log.info(this.getServiceName() + \" service end\");\n 59:     }\n 60: \n 61:     @Override\n 62:     public String getServiceName() {\n 63:         return FlushConsumeQueueService.class.getSimpleName();\n 64:     }\n 65: \n 66:     @Override\n 67:     public long getJointime() {\n 68:         return 1000 * 60;\n 69:     }\n 70: }\n```\n\n* 说明 ：flush `ConsumeQueue`(消费队列) 线程服务。\n* 第 11 至 14 行 ：当 `retryTimes == RETRY_TIMES_OVER` 时，进行强制flush。用于 `shutdown` 时。\n* 第 15 至 23 行 ：每 flushConsumeQueueThoroughInterval 周期，执行一次 flush 。因为不是每次循环到都能满足 flushConsumeQueueLeastPages 大小，因此，需要一定周期进行一次强制 flush 。当然，不能每次循环都去执行强制 flush，这样性能较差。\n* 第 24 至 33 行 ：flush `ConsumeQueue`(消费队列)。\n    * flush 逻辑：[MappedFile#落盘](http://www.yunai.me/RocketMQ/message-store/#MappedFile-落盘)。\n* 第 34 至 40 行 ：flush `StoreCheckpoint`。`StoreCheckpoint` 的详细解析见：[Store初始化与关闭](http://www.yunai.me/RocketMQ/store-init-and-shutdown/)。\n* 第 43 至 59 行 ：每 1000ms 执行一次 `flush`。如果 wakeup() 时，则会立即进行一次 `flush`。目前，暂时不存在 wakeup() 的调用。\n\n# 4、Broker 提供[拉取消息]接口\n\n## PullMessageRequestHeader\n\n```Java\n  1: public class PullMessageRequestHeader implements CommandCustomHeader {\n  2:     /**\n  3:      * 消费者分组\n  4:      */\n  5:     @CFNotNull\n  6:     private String consumerGroup;\n  7:     /**\n  8:      * Topic\n  9:      */\n 10:     @CFNotNull\n 11:     private String topic;\n 12:     /**\n 13:      * 队列编号\n 14:      */\n 15:     @CFNotNull\n 16:     private Integer queueId;\n 17:     /**\n 18:      * 队列开始位置\n 19:      */\n 20:     @CFNotNull\n 21:     private Long queueOffset;\n 22:     /**\n 23:      * 消息数量\n 24:      */\n 25:     @CFNotNull\n 26:     private Integer maxMsgNums;\n 27:     /**\n 28:      * 系统标识\n 29:      */\n 30:     @CFNotNull\n 31:     private Integer sysFlag;\n 32:     /**\n 33:      * 提交消费进度位置\n 34:      */\n 35:     @CFNotNull\n 36:     private Long commitOffset;\n 37:     /**\n 38:      * 挂起超时时间\n 39:      */\n 40:     @CFNotNull\n 41:     private Long suspendTimeoutMillis;\n 42:     /**\n 43:      * 订阅表达式\n 44:      */\n 45:     @CFNullable\n 46:     private String subscription;\n 47:     /**\n 48:      * 订阅版本号\n 49:      */\n 50:     @CFNotNull\n 51:     private Long subVersion;\n 52: }\n```\n\n* 说明：拉取消息请求Header\n* topic +  queueId + queueOffset + maxMsgNums\n* sysFlag ：系统标识。\n    * 第 0 位 `FLAG_COMMIT_OFFSET` ：标记请求提交消费进度位置，和 `commitOffset` 配合。\n    * 第 1 位 `FLAG_SUSPEND` ：标记请求是否挂起请求，和 `suspendTimeoutMillis` 配合。当拉取不到消息时， `Broker` 会挂起请求，直到有消息。最大挂起时间：`suspendTimeoutMillis` 毫秒。\n    * 第 2 位 `FLAG_SUBSCRIPTION` ：是否过滤订阅表达式，和 `subscription` 配置。\n* subVersion ：订阅版本号。请求时，如果版本号不对，则无法拉取到消息，需要重新获取订阅信息，使用最新的订阅版本号。\n\n## PullMessageProcessor#processRequest(...)\n\n```Java\n  1: private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend)\n  2:     throws RemotingCommandException {\n  3:     RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);\n  4:     final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();\n  5:     final PullMessageRequestHeader requestHeader =\n  6:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);\n  7: \n  8:     response.setOpaque(request.getOpaque());\n  9: \n 10:     if (LOG.isDebugEnabled()) {\n 11:         LOG.debug(\"receive PullMessage request command, {}\", request);\n 12:     }\n 13: \n 14:     // 校验 broker 是否可读\n 15:     if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n 16:         response.setCode(ResponseCode.NO_PERMISSION);\n 17:         response.setRemark(String.format(\"the broker[%s] pulling message is forbidden\", this.brokerController.getBrokerConfig().getBrokerIP1()));\n 18:         return response;\n 19:     }\n 20: \n 21:     // 校验 consumer分组配置 是否存在\n 22:     SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());\n 23:     if (null == subscriptionGroupConfig) {\n 24:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 25:         response.setRemark(String.format(\"subscription group [%s] does not exist, %s\", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));\n 26:         return response;\n 27:     }\n 28:     // 校验 consumer分组配置 是否可消费\n 29:     if (!subscriptionGroupConfig.isConsumeEnable()) {\n 30:         response.setCode(ResponseCode.NO_PERMISSION);\n 31:         response.setRemark(\"subscription group no permission, \" + requestHeader.getConsumerGroup());\n 32:         return response;\n 33:     }\n 34: \n 35:     final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); // 是否挂起请求，当没有消息时\n 36:     final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); // 是否提交消费进度\n 37:     final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); // 是否过滤订阅表达式(subscription)\n 38:     final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0; // 挂起请求超时时长\n 39: \n 40:     // 校验 topic配置 存在\n 41:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n 42:     if (null == topicConfig) {\n 43:         LOG.error(\"The topic {} not exist, consumer: {} \", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));\n 44:         response.setCode(ResponseCode.TOPIC_NOT_EXIST);\n 45:         response.setRemark(String.format(\"topic[%s] not exist, apply first please! %s\", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));\n 46:         return response;\n 47:     }\n 48:     // 校验 topic配置 权限可读\n 49:     if (!PermName.isReadable(topicConfig.getPerm())) {\n 50:         response.setCode(ResponseCode.NO_PERMISSION);\n 51:         response.setRemark(\"the topic[\" + requestHeader.getTopic() + \"] pulling message is forbidden\");\n 52:         return response;\n 53:     }\n 54:     // 校验 读取队列 在 topic配置 队列范围内\n 55:     if (requestHeader.getQueueId() < 0 || requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) {\n 56:         String errorInfo = String.format(\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\",\n 57:                 requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());\n 58:         LOG.warn(errorInfo);\n 59:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 60:         response.setRemark(errorInfo);\n 61:         return response;\n 62:     }\n 63: \n 64:     // 校验 订阅关系\n 65:     SubscriptionData subscriptionData;\n 66:     if (hasSubscriptionFlag) {\n 67:         try {\n 68:             subscriptionData = FilterAPI.buildSubscriptionData(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n 69:                 requestHeader.getSubscription());\n 70:         } catch (Exception e) {\n 71:             LOG.warn(\"Parse the consumer's subscription[{}] failed, group: {}\", requestHeader.getSubscription(), //\n 72:                     requestHeader.getConsumerGroup());\n 73:             response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);\n 74:             response.setRemark(\"parse the consumer's subscription failed\");\n 75:             return response;\n 76:         }\n 77:     } else {\n 78:         // 校验 消费分组信息 是否存在\n 79:         ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());\n 80:         if (null == consumerGroupInfo) {\n 81:             LOG.warn(\"The consumer's group info not exist, group: {}\", requestHeader.getConsumerGroup());\n 82:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);\n 83:             response.setRemark(\"the consumer's group info not exist\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));\n 84:             return response;\n 85:         }\n 86:         // 校验 消费分组信息 消息模型是否匹配\n 87:         if (!subscriptionGroupConfig.isConsumeBroadcastEnable() //\n 88:             && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) {\n 89:             response.setCode(ResponseCode.NO_PERMISSION);\n 90:             response.setRemark(\"the consumer group[\" + requestHeader.getConsumerGroup() + \"] can not consume by broadcast way\");\n 91:             return response;\n 92:         }\n 93: \n 94:         // 校验 订阅信息 是否存在\n 95:         subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());\n 96:         if (null == subscriptionData) {\n 97:             LOG.warn(\"The consumer's subscription not exist, group: {}, topic:{}\", requestHeader.getConsumerGroup(), requestHeader.getTopic());\n 98:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);\n 99:             response.setRemark(\"the consumer's subscription not exist\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));\n100:             return response;\n101:         }\n102:         // 校验 订阅信息版本 是否合法\n103:         if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) {\n104:             LOG.warn(\"The broker's subscription is not latest, group: {} {}\", requestHeader.getConsumerGroup(),\n105:                     subscriptionData.getSubString());\n106:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);\n107:             response.setRemark(\"the consumer's subscription not latest\");\n108:             return response;\n109:         }\n110:     }\n111: \n112:     // 获取消息\n113:     final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n114:             requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), subscriptionData);\n115:     if (getMessageResult != null) {\n116:         response.setRemark(getMessageResult.getStatus().name());\n117:         responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());\n118:         responseHeader.setMinOffset(getMessageResult.getMinOffset());\n119:         responseHeader.setMaxOffset(getMessageResult.getMaxOffset());\n120: \n121:         // TODO 待读\n122:         // 计算建议读取brokerId\n123:         if (getMessageResult.isSuggestPullingFromSlave()) {\n124:             responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());\n125:         } else {\n126:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n127:         }\n128: \n129:         switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) {\n130:             case ASYNC_MASTER:\n131:             case SYNC_MASTER:\n132:                 break;\n133:             case SLAVE:\n134:                 if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) { // 从节点不允许读取，告诉consumer读取主节点。\n135:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n136:                     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n137:                 }\n138:                 break;\n139:         }\n140: \n141:         if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) {\n142:             // consume too slow ,redirect to another machine\n143:             if (getMessageResult.isSuggestPullingFromSlave()) {\n144:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());\n145:             }\n146:             // consume ok\n147:             else {\n148:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());\n149:             }\n150:         } else {\n151:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);\n152:         }\n153: \n154:         switch (getMessageResult.getStatus()) {\n155:             case FOUND:\n156:                 response.setCode(ResponseCode.SUCCESS);\n157:                 break;\n158:             case MESSAGE_WAS_REMOVING:\n159:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n160:                 break;\n161:             case NO_MATCHED_LOGIC_QUEUE:\n162:             case NO_MESSAGE_IN_QUEUE:\n163:                 if (0 != requestHeader.getQueueOffset()) {\n164:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n165: \n166:                     // XXX: warn and notify me\n167:                     LOG.info(\"the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}\", //\n168:                         requestHeader.getQueueOffset(), //\n169:                         getMessageResult.getNextBeginOffset(), //\n170:                         requestHeader.getTopic(), //\n171:                         requestHeader.getQueueId(), //\n172:                         requestHeader.getConsumerGroup()//\n173:                     );\n174:                 } else {\n175:                     response.setCode(ResponseCode.PULL_NOT_FOUND);\n176:                 }\n177:                 break;\n178:             case NO_MATCHED_MESSAGE:\n179:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n180:                 break;\n181:             case OFFSET_FOUND_NULL:\n182:                 response.setCode(ResponseCode.PULL_NOT_FOUND);\n183:                 break;\n184:             case OFFSET_OVERFLOW_BADLY:\n185:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n186:                 // XXX: warn and notify me\n187:                 LOG.info(\"The request offset:{} over flow badly, broker max offset:{} , consumer: {}\", requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());\n188:                 break;\n189:             case OFFSET_OVERFLOW_ONE:\n190:                 response.setCode(ResponseCode.PULL_NOT_FOUND);\n191:                 break;\n192:             case OFFSET_TOO_SMALL:\n193:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);\n194:                 LOG.info(\"The request offset is too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}\",\n195:                     requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),\n196:                     getMessageResult.getMinOffset(), channel.remoteAddress());\n197:                 break;\n198:             default:\n199:                 assert false;\n200:                 break;\n201:         }\n202: \n203:         // hook：before\n204:         if (this.hasConsumeMessageHook()) {\n205:             ConsumeMessageContext context = new ConsumeMessageContext();\n206:             context.setConsumerGroup(requestHeader.getConsumerGroup());\n207:             context.setTopic(requestHeader.getTopic());\n208:             context.setQueueId(requestHeader.getQueueId());\n209: \n210:             String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);\n211: \n212:             switch (response.getCode()) {\n213:                 case ResponseCode.SUCCESS:\n214:                     int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();\n215:                     int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;\n216: \n217:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);\n218:                     context.setCommercialRcvTimes(incValue);\n219:                     context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());\n220:                     context.setCommercialOwner(owner);\n221: \n222:                     break;\n223:                 case ResponseCode.PULL_NOT_FOUND:\n224:                     if (!brokerAllowSuspend) {\n225: \n226:                         context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);\n227:                         context.setCommercialRcvTimes(1);\n228:                         context.setCommercialOwner(owner);\n229: \n230:                     }\n231:                     break;\n232:                 case ResponseCode.PULL_RETRY_IMMEDIATELY:\n233:                 case ResponseCode.PULL_OFFSET_MOVED:\n234:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);\n235:                     context.setCommercialRcvTimes(1);\n236:                     context.setCommercialOwner(owner);\n237:                     break;\n238:                 default:\n239:                     assert false;\n240:                     break;\n241:             }\n242: \n243:             this.executeConsumeMessageHookBefore(context);\n244:         }\n245: \n246:         switch (response.getCode()) {\n247:             case ResponseCode.SUCCESS:\n248: \n249:                 this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n250:                     getMessageResult.getMessageCount());\n251:                 this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),\n252:                     getMessageResult.getBufferTotalSize());\n253:                 this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());\n254:                 // 读取消息\n255:                 if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) { // 内存中\n256:                     final long beginTimeMills = this.brokerController.getMessageStore().now();\n257: \n258:                     final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());\n259: \n260:                     this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),\n261:                         requestHeader.getTopic(), requestHeader.getQueueId(),\n262:                         (int) (this.brokerController.getMessageStore().now() - beginTimeMills));\n263:                     response.setBody(r);\n264:                 } else { // zero-copy\n265:                     try {\n266:                         FileRegion fileRegion = new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);\n267:                         channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() {\n268:                             @Override\n269:                             public void operationComplete(ChannelFuture future) throws Exception {\n270:                                 getMessageResult.release();\n271:                                 if (!future.isSuccess()) {\n272:                                     LOG.error(\"Fail to transfer messages from page cache to {}\", channel.remoteAddress(), future.cause());\n273:                                 }\n274:                             }\n275:                         });\n276:                     } catch (Throwable e) {\n277:                         LOG.error(\"Error occurred when transferring messages from page cache\", e);\n278:                         getMessageResult.release();\n279:                     }\n280: \n281:                     response = null;\n282:                 }\n283:                 break;\n284:             case ResponseCode.PULL_NOT_FOUND:\n285:                 // 消息未查询到 && broker允许挂起请求 && 请求允许挂起\n286:                 if (brokerAllowSuspend && hasSuspendFlag) {\n287:                     long pollingTimeMills = suspendTimeoutMillisLong;\n288:                     if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n289:                         pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();\n290:                     }\n291: \n292:                     String topic = requestHeader.getTopic();\n293:                     long offset = requestHeader.getQueueOffset();\n294:                     int queueId = requestHeader.getQueueId();\n295:                     PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,\n296:                         this.brokerController.getMessageStore().now(), offset, subscriptionData);\n297:                     this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);\n298:                     response = null;\n299:                     break;\n300:                 }\n301: \n302:             case ResponseCode.PULL_RETRY_IMMEDIATELY:\n303:                 break;\n304:             case ResponseCode.PULL_OFFSET_MOVED:\n305:                 if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE\n306:                     || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) { // TODO 待博客补充\n307:                     MessageQueue mq = new MessageQueue();\n308:                     mq.setTopic(requestHeader.getTopic());\n309:                     mq.setQueueId(requestHeader.getQueueId());\n310:                     mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName());\n311: \n312:                     OffsetMovedEvent event = new OffsetMovedEvent();\n313:                     event.setConsumerGroup(requestHeader.getConsumerGroup());\n314:                     event.setMessageQueue(mq);\n315:                     event.setOffsetRequest(requestHeader.getQueueOffset());\n316:                     event.setOffsetNew(getMessageResult.getNextBeginOffset());\n317:                     this.generateOffsetMovedEvent(event);\n318:                     LOG.warn(\n319:                         \"PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}\",\n320:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),\n321:                         responseHeader.getSuggestWhichBrokerId());\n322:                 } else {\n323:                     responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());\n324:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);\n325:                     LOG.warn(\"PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}\",\n326:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),\n327:                         responseHeader.getSuggestWhichBrokerId());\n328:                 }\n329: \n330:                 break;\n331:             default:\n332:                 assert false;\n333:         }\n334:     } else {\n335:         response.setCode(ResponseCode.SYSTEM_ERROR);\n336:         response.setRemark(\"store getMessage return null\");\n337:     }\n338: \n339:     // 请求要求持久化进度 && broker非主，进行持久化进度。\n340:     boolean storeOffsetEnable = brokerAllowSuspend;\n341:     storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag;\n342:     storeOffsetEnable = storeOffsetEnable && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;\n343:     if (storeOffsetEnable) {\n344:         this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),\n345:             requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());\n346:     }\n347:     return response;\n348: }\n```\n\n* 说明：处理拉取消息请求，返回响应。\n* 第 14 至 19 行 ：校验 `Broker` 是否可读。\n* 第 21 至 33 行 ：校验 `SubscriptionGroupConfig`(订阅分组配置) 是否存在 && 可以消费。\n* 第 35 至 38 行 ：处理 `PullMessageRequestHeader.sysFlag` 对应的标志位。\n* 第 40 至 62 行 ：校验 `TopicConfig`(主题配置) 是否存在 && 可读 && 队列编号正确。\n* 第 64 至 110 行 ：校验 `SubscriptionData`(订阅信息) 是否正确。\n* 第 113 行 ：调用 `MessageStore#getMessage(...)` 获取 `GetMessageResult`(消息)。详细解析见：[MessageStore#getMessage(...)](#messagestoregetmessage)。\n* 第 122 至 152 行 ：计算建议拉取消息 `brokerId` 。\n* 第 154 至 201 行 ：![PullMessageProcessor拉取消息状态图](http://www.yunai.me/images/RocketMQ/2017_05_04/08.png)\n* 第 204 至 244 行 ：`Hook` 逻辑，`#executeConsumeMessageHookBefore(...)` 。\n* 第 247 至 283 行 ：拉取消息成功，即拉取到消息。\n    * 第 255 至 263 行 ：方式一 ：调用 `readGetMessageResult(...)` 获取消息内容到堆内内存，设置到 响应`body`。\n    * 第 265 至 281 行 ：方式二 ：基于 `zero-copy` 实现，直接响应，无需堆内内存，性能更优。*TODO ：此处等对zero-copy有研究，再补充一些*。\n* 第 284 至 300 行 ：拉取不到消息，当满足条件 (`Broker` 允许挂起 && 请求要求挂起)，执行挂起请求。详细解析见：[PullRequestHoldService](#pullrequestholdservice)。\n* 第 304 至 328 行 ：*TODO ：此处等对`tools`模块研究后再补充*。\n* 第 339 至 346 ：持久化消费进度，当满足 (`Broker` 非主 && 请求要求持久化进度)。详细解析见：[更新消费进度](#3broker-提供更新消费进度接口)。\n\n## MessageStore#getMessage(...)\n\n```Java\n  1: /**\n  2:  * 获取消息结果\n  3:  *\n  4:  * @param group 消费分组\n  5:  * @param topic 主题\n  6:  * @param queueId 队列编号\n  7:  * @param offset 队列位置\n  8:  * @param maxMsgNums 消息数量\n  9:  * @param subscriptionData 订阅信息\n 10:  * @return 消息结果\n 11:  */\n 12: public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums,\n 13:     final SubscriptionData subscriptionData) {\n 14:     // 是否关闭\n 15:     if (this.shutdown) {\n 16:         log.warn(\"message store has shutdown, so getMessage is forbidden\");\n 17:         return null;\n 18:     }\n 19:     // 是否可读\n 20:     if (!this.runningFlags.isReadable()) {\n 21:         log.warn(\"message store is not readable, so getMessage is forbidden \" + this.runningFlags.getFlagBits());\n 22:         return null;\n 23:     }\n 24: \n 25:     long beginTime = this.getSystemClock().now();\n 26: \n 27:     GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;\n 28:     long nextBeginOffset = offset;\n 29:     long minOffset = 0;\n 30:     long maxOffset = 0;\n 31: \n 32:     GetMessageResult getResult = new GetMessageResult();\n 33: \n 34:     final long maxOffsetPy = this.commitLog.getMaxOffset();\n 35: \n 36:     // 获取消费队列\n 37:     ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);\n 38:     if (consumeQueue != null) {\n 39:         minOffset = consumeQueue.getMinOffsetInQueue(); // 消费队列 最小队列编号\n 40:         maxOffset = consumeQueue.getMaxOffsetInQueue(); // 消费队列 最大队列编号\n 41: \n 42:         // 判断 队列位置(offset)\n 43:         if (maxOffset == 0) { // 消费队列无消息\n 44:             status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;\n 45:             nextBeginOffset = nextOffsetCorrection(offset, 0);\n 46:         } else if (offset < minOffset) { // 查询offset 太小\n 47:             status = GetMessageStatus.OFFSET_TOO_SMALL;\n 48:             nextBeginOffset = nextOffsetCorrection(offset, minOffset);\n 49:         } else if (offset == maxOffset) { // 查询offset 超过 消费队列 一个位置\n 50:             status = GetMessageStatus.OFFSET_OVERFLOW_ONE;\n 51:             nextBeginOffset = nextOffsetCorrection(offset, offset);\n 52:         } else if (offset > maxOffset) { // 查询offset 超过 消费队列 太多(大于一个位置)\n 53:             status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;\n 54:             if (0 == minOffset) { // TODO blog 这里是？？为啥0 == minOffset做了特殊判断\n 55:                 nextBeginOffset = nextOffsetCorrection(offset, minOffset);\n 56:             } else {\n 57:                 nextBeginOffset = nextOffsetCorrection(offset, maxOffset);\n 58:             }\n 59:         } else {\n 60:             // 获得 映射Buffer结果(MappedFile)\n 61:             SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);\n 62:             if (bufferConsumeQueue != null) {\n 63:                 try {\n 64:                     status = GetMessageStatus.NO_MATCHED_MESSAGE;\n 65: \n 66:                     long nextPhyFileStartOffset = Long.MIN_VALUE; // commitLog下一个文件(MappedFile)对应的开始offset。\n 67:                     long maxPhyOffsetPulling = 0; // 消息物理位置拉取到的最大offset\n 68: \n 69:                     int i = 0;\n 70:                     final int maxFilterMessageCount = 16000;\n 71:                     final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded();\n 72:                     // 循环获取 消息位置信息\n 73:                     for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n 74:                         long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); // 消息物理位置offset\n 75:                         int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); // 消息长度\n 76:                         long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); // 消息tagsCode\n 77:                         // 设置消息物理位置拉取到的最大offset\n 78:                         maxPhyOffsetPulling = offsetPy;\n 79:                         // 当 offsetPy 小于 nextPhyFileStartOffset 时，意味着对应的 Message 已经移除，所以直接continue，直到可读取的Message。\n 80:                         if (nextPhyFileStartOffset != Long.MIN_VALUE) {\n 81:                             if (offsetPy < nextPhyFileStartOffset)\n 82:                                 continue;\n 83:                         }\n 84:                         // 校验 commitLog 是否需要硬盘，无法全部放在内存\n 85:                         boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);\n 86:                         // 是否已经获得足够消息\n 87:                         if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),\n 88:                             isInDisk)) {\n 89:                             break;\n 90:                         }\n 91:                         // 判断消息是否符合条件\n 92:                         if (this.messageFilter.isMessageMatched(subscriptionData, tagsCode)) {\n 93:                             // 从commitLog获取对应消息ByteBuffer\n 94:                             SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);\n 95:                             if (selectResult != null) {\n 96:                                 this.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();\n 97:                                 getResult.addMessage(selectResult);\n 98:                                 status = GetMessageStatus.FOUND;\n 99:                                 nextPhyFileStartOffset = Long.MIN_VALUE;\n100:                             } else {\n101:                                 // 从commitLog无法读取到消息，说明该消息对应的文件（MappedFile）已经删除，计算下一个MappedFile的起始位置\n102:                                 if (getResult.getBufferTotalSize() == 0) {\n103:                                     status = GetMessageStatus.MESSAGE_WAS_REMOVING;\n104:                                 }\n105:                                 nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy);\n106:                             }\n107:                         } else {\n108:                             if (getResult.getBufferTotalSize() == 0) {\n109:                                 status = GetMessageStatus.NO_MATCHED_MESSAGE;\n110:                             }\n111: \n112:                             if (log.isDebugEnabled()) {\n113:                                 log.debug(\"message type not matched, client: \" + subscriptionData + \" server: \" + tagsCode);\n114:                             }\n115:                         }\n116:                     }\n117:                     // 统计剩余可拉取消息字节数\n118:                     if (diskFallRecorded) {\n119:                         long fallBehind = maxOffsetPy - maxPhyOffsetPulling;\n120:                         brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);\n121:                     }\n122:                     // 计算下次拉取消息的消息队列编号\n123:                     nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n124:                     // 根据剩余可拉取消息字节数与内存判断是否建议读取从节点\n125:                     long diff = maxOffsetPy - maxPhyOffsetPulling;\n126:                     long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE\n127:                             * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));\n128:                     getResult.setSuggestPullingFromSlave(diff > memory);\n129:                 } finally {\n130:                     bufferConsumeQueue.release();\n131:                 }\n132:             } else {\n133:                 status = GetMessageStatus.OFFSET_FOUND_NULL;\n134:                 nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));\n135:                 log.warn(\"consumer request topic: \" + topic + \"offset: \" + offset + \" minOffset: \" + minOffset + \" maxOffset: \"\n136:                     + maxOffset + \", but access logic queue failed.\");\n137:             }\n138:         }\n139:     } else {\n140:         status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;\n141:         nextBeginOffset = nextOffsetCorrection(offset, 0);\n142:     }\n143:     // 统计\n144:     if (GetMessageStatus.FOUND == status) {\n145:         this.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();\n146:     } else {\n147:         this.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();\n148:     }\n149:     long eclipseTime = this.getSystemClock().now() - beginTime;\n150:     this.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);\n151:     // 设置返回结果\n152:     getResult.setStatus(status);\n153:     getResult.setNextBeginOffset(nextBeginOffset);\n154:     getResult.setMaxOffset(maxOffset);\n155:     getResult.setMinOffset(minOffset);\n156:     return getResult;\n157: }\n158: \n159: /**\n160:  * 根据 主题 + 队列编号 获取 消费队列\n161:  *\n162:  * @param topic 主题\n163:  * @param queueId 队列编号\n164:  * @return 消费队列\n165:  */\n166: public ConsumeQueue findConsumeQueue(String topic, int queueId) {\n167:     // 获取 topic 对应的 所有消费队列\n168:     ConcurrentHashMap<Integer, ConsumeQueue> map = consumeQueueTable.get(topic);\n169:     if (null == map) {\n170:         ConcurrentHashMap<Integer, ConsumeQueue> newMap = new ConcurrentHashMap<>(128);\n171:         ConcurrentHashMap<Integer, ConsumeQueue> oldMap = consumeQueueTable.putIfAbsent(topic, newMap);\n172:         if (oldMap != null) {\n173:             map = oldMap;\n174:         } else {\n175:             map = newMap;\n176:         }\n177:     }\n178:     // 获取 queueId 对应的 消费队列\n179:     ConsumeQueue logic = map.get(queueId);\n180:     if (null == logic) {\n181:         ConsumeQueue newLogic = new ConsumeQueue(//\n182:             topic, //\n183:             queueId, //\n184:             StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()), //\n185:             this.getMessageStoreConfig().getMapedFileSizeConsumeQueue(), //\n186:             this);\n187:         ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);\n188:         if (oldLogic != null) {\n189:             logic = oldLogic;\n190:         } else {\n191:             logic = newLogic;\n192:         }\n193:     }\n194: \n195:     return logic;\n196: }\n197: \n198: /**\n199:  * 下一个获取队列offset修正\n200:  * 修正条件：主节点 或者 从节点开启校验offset开关\n201:  *\n202:  * @param oldOffset 老队列offset\n203:  * @param newOffset 新队列offset\n204:  * @return 修正后的队列offset\n205:  */\n206: private long nextOffsetCorrection(long oldOffset, long newOffset) {\n207:     long nextOffset = oldOffset;\n208:     if (this.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || this.getMessageStoreConfig().isOffsetCheckInSlave()) {\n209:         nextOffset = newOffset;\n210:     }\n211:     return nextOffset;\n212: }\n213: \n214: /**\n215:  * 校验 commitLog 是否需要硬盘，无法全部放在内存\n216:  *\n217:  * @param offsetPy commitLog 指定offset\n218:  * @param maxOffsetPy commitLog 最大offset\n219:  * @return 是否需要硬盘\n220:  */\n221: private boolean checkInDiskByCommitOffset(long offsetPy, long maxOffsetPy) {\n222:     long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0));\n223:     return (maxOffsetPy - offsetPy) > memory;\n224: }\n225: \n226: /**\n227:  * 判断获取消息是否已经满\n228:  *\n229:  * @param sizePy 字节数\n230:  * @param maxMsgNums 最大消息数\n231:  * @param bufferTotal 目前已经计算字节数\n232:  * @param messageTotal 目前已经计算消息数\n233:  * @param isInDisk 是否在硬盘中\n234:  * @return 是否已满\n235:  */\n236: private boolean isTheBatchFull(int sizePy, int maxMsgNums, int bufferTotal, int messageTotal, boolean isInDisk) {\n237:     if (0 == bufferTotal || 0 == messageTotal) {\n238:         return false;\n239:     }\n240:     // 消息数量已经满足请求数量(maxMsgNums)\n241:     if ((messageTotal + 1) >= maxMsgNums) {\n242:         return true;\n243:     }\n244:     // 根据消息存储配置的最大传输字节数、最大传输消息数是否已满\n245:     if (isInDisk) {\n246:         if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInDisk()) {\n247:             return true;\n248:         }\n249: \n250:         if ((messageTotal + 1) > this.messageStoreConfig.getMaxTransferCountOnMessageInDisk()) {\n251:             return true;\n252:         }\n253:     } else {\n254:         if ((bufferTotal + sizePy) > this.messageStoreConfig.getMaxTransferBytesOnMessageInMemory()) {\n255:             return true;\n256:         }\n257: \n258:         if ((messageTotal + 1) > this.messageStoreConfig.getMaxTransferCountOnMessageInMemory()) {\n259:             return true;\n260:         }\n261:     }\n262: \n263:     return false;\n264: }\n```\n\n* 说明 ：根据 消息分组(`group`) + 主题(`Topic`) + 队列编号(`queueId`) + 队列位置(`offset`) + 订阅信息(`subscriptionData`) 获取 指定条数(`maxMsgNums`) 消息(`Message`)。\n* 第 14 至 18 行 ：判断 `Store` 是否处于关闭状态，若关闭，则无法获取消息。\n* 第 19 至 23 行 ：判断当前运行状态是否可读，若不可读，则无法获取消息。\n* 第 37 行 ：根据 主题(`Topic`) + 队列编号(`queueId`) 获取 消息队列(`ConsumeQueue`)。\n    * `#findConsumeQueue(...)` ：第 159 至 196 行。\n* 第 43 至 58 行 ：各种队列位置(`offset`) 无法读取消息，并针对对应的情况，计算下一次 `Client` 队列拉取位置。\n    * 第 43 至 45 行 ：消息队列无消息。\n    * 第 46 至 48 行 ：查询的消息队列位置（`offset`） 太小。\n    * 第 49 至 51 行 ：查询的消息队列位置（`offset`） 恰好等于 消息队列最大的队列位置。该情况是正常现象，相当于查询最新的消息。\n    * 第 52 至 58 行 ：查询的消息队列位置（`offset`） 超过过多。\n    * `#nextOffsetCorrection(...)` ：第 198 至 212 行。\n* 第 61 行 ：根据 消费队列位置(`offset`) 获取 对应的`MappedFile`。\n* 第 72 至 128 行 ：**循环**获取 `消息位置信息`。\n    * 第 74 至 76 行 ：读取每一个 `消息位置信息`。\n    * 第 79 至 83 行 ：当 `offsetPy` 小于 `nextPhyFileStartOffset` 时，意味着对\n应的 `Message` 已经移除，所以直接continue，直到可读取的 `Message`。\n    * 第 84 至 90 行 ：判断是否已经获得足够的消息。\n        * `#checkInDiskByCommitOffset(...)` ：第 214 至 224 行。\n        * `#isTheBatchFull(...)` ：第 226 至 264 行。\n* 第 92 行 ：判断消息是否符合条件。详细解析见：[DefaultMessageFilter#isMessageMatched(...)](defaultmessagefilterismessagematched)。\n* 第 94 行 ：从 `CommitLog` 获取对应 消息的`MappedByteBuffer`。\n* 第 95 至 99 行 ：获取 `消息MappedByteBuffer` 成功。\n* 第 100 至 106 行 ：获取 `消息MappedByteBuffer` 失败。从 `CommitLog` 无法读取到消息，说明 该消息对应的文件(`MappedFile`) 已经删除，此时计算下一个`MappedFile`的起始位置。**该逻辑需要配合（第 79 至 83 行）一起理解。**\n* 第 117 至 120 行 ：统计剩余可拉取消息字节数。\n* 第 123 行 ：计算下次拉取消息的消息队列编号。\n* 第 124 至 128 行 ：根据剩余可拉取消息字节数与内存判断是否建议读取从节点。\n* 第 130 行 ：释放 `bufferConsumeQueue` 对 `MappedFile` 的指向。此处 `MappedFile` 是 `ConsumeQueue` 里的文件，不是 `CommitLog` 下的文件。\n* 第 133 至 136 行 ：获得消费队列位置(`offset`) 获取 对应的`MappedFile` 为**空**，计算`ConsumeQueue` 从 `offset` 开始的下一个 `MappedFile` 对应的位置。\n* 第 143 至 150 行 ：记录统计信息：消耗时间、拉取到消息/未拉取到消息次数。\n* 第 151 至 156 行 ：设置返回结果并返回。 \n\n## DefaultMessageFilter#isMessageMatched(...)\n\n```Java\n  1: public class DefaultMessageFilter implements MessageFilter {\n  2: \n  3:     @Override\n  4:     public boolean isMessageMatched(SubscriptionData subscriptionData, Long tagsCode) {\n  5:         // 消息tagsCode 空\n  6:         if (tagsCode == null) {\n  7:             return true;\n  8:         }\n  9:         // 订阅数据 空\n 10:         if (null == subscriptionData) {\n 11:             return true;\n 12:         }\n 13:         // classFilter\n 14:         if (subscriptionData.isClassFilterMode())\n 15:             return true;\n 16:         // 订阅表达式 全匹配\n 17:         if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) {\n 18:             return true;\n 19:         }\n 20:         // 订阅数据code数组 是否包含 消息tagsCode\n 21:         return subscriptionData.getCodeSet().contains(tagsCode.intValue());\n 22:     }\n 23: \n 24: }\n```\n\n* 说明 ：消息过滤器默认实现。\n\n## PullRequestHoldService\n\n```Java\n  1: public class PullRequestHoldService extends ServiceThread {\n  2: \n  3:     private static final Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n  4: \n  5:     private static final String TOPIC_QUEUEID_SEPARATOR = \"@\";\n  6: \n  7:     private final BrokerController brokerController;\n  8: \n  9:     private final SystemClock systemClock = new SystemClock();\n 10:     /**\n 11:      * 消息过滤器\n 12:      */\n 13:     private final MessageFilter messageFilter = new DefaultMessageFilter();\n 14:     /**\n 15:      * 拉取消息请求集合\n 16:      */\n 17:     private ConcurrentHashMap<String/* topic@queueId */, ManyPullRequest> pullRequestTable =\n 18:             new ConcurrentHashMap<>(1024);\n 19: \n 20:     public PullRequestHoldService(final BrokerController brokerController) {\n 21:         this.brokerController = brokerController;\n 22:     }\n 23: \n 24:     /**\n 25:      * 添加拉取消息挂起请求\n 26:      *\n 27:      * @param topic 主题\n 28:      * @param queueId 队列编号\n 29:      * @param pullRequest 拉取消息请求\n 30:      */\n 31:     public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) {\n 32:         String key = this.buildKey(topic, queueId);\n 33:         ManyPullRequest mpr = this.pullRequestTable.get(key);\n 34:         if (null == mpr) {\n 35:             mpr = new ManyPullRequest();\n 36:             ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);\n 37:             if (prev != null) {\n 38:                 mpr = prev;\n 39:             }\n 40:         }\n 41: \n 42:         mpr.addPullRequest(pullRequest);\n 43:     }\n 44: \n 45:     /**\n 46:      * 根据 主题 + 队列编号 创建唯一标识\n 47:      *\n 48:      * @param topic 主题\n 49:      * @param queueId 队列编号\n 50:      * @return key\n 51:      */\n 52:     private String buildKey(final String topic, final int queueId) {\n 53:         StringBuilder sb = new StringBuilder();\n 54:         sb.append(topic);\n 55:         sb.append(TOPIC_QUEUEID_SEPARATOR);\n 56:         sb.append(queueId);\n 57:         return sb.toString();\n 58:     }\n 59: \n 60:     @Override\n 61:     public void run() {\n 62:         log.info(\"{} service started\", this.getServiceName());\n 63:         while (!this.isStopped()) {\n 64:             try {\n 65:                 // 根据 长轮训 还是 短轮训 设置不同的等待时间\n 66:                 if (this.brokerController.getBrokerConfig().isLongPollingEnable()) {\n 67:                     this.waitForRunning(5 * 1000);\n 68:                 } else {\n 69:                     this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());\n 70:                 }\n 71:                 // 检查挂起请求是否有需要通知的\n 72:                 long beginLockTimestamp = this.systemClock.now();\n 73:                 this.checkHoldRequest();\n 74:                 long costTime = this.systemClock.now() - beginLockTimestamp;\n 75:                 if (costTime > 5 * 1000) {\n 76:                     log.info(\"[NOTIFYME] check hold request cost {} ms.\", costTime);\n 77:                 }\n 78:             } catch (Throwable e) {\n 79:                 log.warn(this.getServiceName() + \" service has exception. \", e);\n 80:             }\n 81:         }\n 82: \n 83:         log.info(\"{} service end\", this.getServiceName());\n 84:     }\n 85: \n 86:     @Override\n 87:     public String getServiceName() {\n 88:         return PullRequestHoldService.class.getSimpleName();\n 89:     }\n 90: \n 91:     /**\n 92:      * 遍历挂起请求，检查是否有需要通知的请求。\n 93:      */\n 94:     private void checkHoldRequest() {\n 95:         for (String key : this.pullRequestTable.keySet()) {\n 96:             String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);\n 97:             if (2 == kArray.length) {\n 98:                 String topic = kArray[0];\n 99:                 int queueId = Integer.parseInt(kArray[1]);\n100:                 final long offset = this.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);\n101:                 try {\n102:                     this.notifyMessageArriving(topic, queueId, offset);\n103:                 } catch (Throwable e) {\n104:                     log.error(\"check hold request failed. topic={}, queueId={}\", topic, queueId, e);\n105:                 }\n106:             }\n107:         }\n108:     }\n109: \n110:     /**\n111:      * 检查是否有需要通知的请求\n112:      *\n113:      * @param topic 主题\n114:      * @param queueId 队列编号\n115:      * @param maxOffset 消费队列最大offset\n116:      */\n117:     public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset) {\n118:         notifyMessageArriving(topic, queueId, maxOffset, null);\n119:     }\n120: \n121:     /**\n122:      * 检查是否有需要通知的请求\n123:      *\n124:      * @param topic 主题\n125:      * @param queueId 队列编号\n126:      * @param maxOffset 消费队列最大offset\n127:      * @param tagsCode 过滤tagsCode\n128:      */\n129:     public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset, final Long tagsCode) {\n130:         String key = this.buildKey(topic, queueId);\n131:         ManyPullRequest mpr = this.pullRequestTable.get(key);\n132:         if (mpr != null) {\n133:             //\n134:             List<PullRequest> requestList = mpr.cloneListAndClear();\n135:             if (requestList != null) {\n136:                 List<PullRequest> replayList = new ArrayList<>(); // 不符合唤醒的请求数组\n137: \n138:                 for (PullRequest request : requestList) {\n139:                     // 如果 maxOffset 过小，则重新读取一次。\n140:                     long newestOffset = maxOffset;\n141:                     if (newestOffset <= request.getPullFromThisOffset()) {\n142:                         newestOffset = this.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);\n143:                     }\n144:                     // 有新的匹配消息，唤醒请求，即再次拉取消息。\n145:                     if (newestOffset > request.getPullFromThisOffset()) {\n146:                         if (this.messageFilter.isMessageMatched(request.getSubscriptionData(), tagsCode)) {\n147:                             try {\n148:                                 this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),\n149:                                     request.getRequestCommand());\n150:                             } catch (Throwable e) {\n151:                                 log.error(\"execute request when wakeup failed.\", e);\n152:                             }\n153:                             continue;\n154:                         }\n155:                     }\n156:                     // 超过挂起时间，唤醒请求，即再次拉取消息。\n157:                     if (System.currentTimeMillis() >= (request.getSuspendTimestamp() + request.getTimeoutMillis())) {\n158:                         try {\n159:                             this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),\n160:                                 request.getRequestCommand());\n161:                         } catch (Throwable e) {\n162:                             log.error(\"execute request when wakeup failed.\", e);\n163:                         }\n164:                         continue;\n165:                     }\n166:                     // 不符合再次拉取的请求，再次添加回去\n167:                     replayList.add(request);\n168:                 }\n169:                 // 添加回去\n170:                 if (!replayList.isEmpty()) {\n171:                     mpr.addPullRequest(replayList);\n172:                 }\n173:             }\n174:         }\n175:     }\n176: }\n```\n\n* `PullRequestHoldService` 说明 ：拉取消息请求挂起维护线程服务。\n    * 当拉取消息请求获得不了消息时，则会将请求进行挂起，添加到该服务。\n    * 当有符合条件信息时 或 挂起超时时，重新执行获取消息逻辑。\n* `#suspendPullRequest(...)` 说明 ：添加拉取消息挂起请求到集合( `pullRequestTable` )。\n* `#run(...)` 说明 ：**定时**检查挂起请求是否有需要通知重新拉取消息并进行通知。\n    * 第 65 至 70 行 ：根据`长轮训`or`短轮训`设置不同的等待时间。\n    * 第 71 至 77 行 ：检查挂起请求是否有需要通知的。\n* `#checkHoldRequest(...)` 说明 ：遍历挂起请求，检查是否有需要通知的。\n* `#notifyMessageArriving(...)` 说明 ：检查**指定队列**是否有需要通知的请求。\n    * 第 139 至 143 行 ：如果 `maxOffset` 过小，重新获取一次最新的。\n    * 第 144 至 155 行 ：有新的匹配消息，唤醒请求，即再次拉取消息。\n    * 第 156 至 165 行 ：超过挂起时间，唤醒请求，即再次拉取消息。\n    * 第 148 || 159 行 ：唤醒请求，再次拉取消息。原先担心拉取消息时间过长，导致影响整个挂起请求的遍历，后面查看`#executeRequestWhenWakeup(...)`，实际是丢到线程池进行一步的消息拉取，不会有性能上的问题。详细解析见：[PullMessageProcessor#executeRequestWhenWakeup(...)](pullmessageprocessorexecuterequestwhenwakeup)。\n    * 第 166 至 172 行 ：不符合唤醒的请求重新添加到集合(`pullRequestTable`)。\n\n## PullMessageProcessor#executeRequestWhenWakeup(...)\n\n```Java\n  1: public void executeRequestWhenWakeup(final Channel channel, final RemotingCommand request) throws RemotingCommandException {\n  2:     Runnable run = new Runnable() {\n  3:         @Override\n  4:         public void run() {\n  5:             try {\n  6:                 // 调用拉取请求。本次调用，设置不挂起请求。\n  7:                 final RemotingCommand response = PullMessageProcessor.this.processRequest(channel, request, false);\n  8: \n  9:                 if (response != null) {\n 10:                     response.setOpaque(request.getOpaque());\n 11:                     response.markResponseType();\n 12:                     try {\n 13:                         channel.writeAndFlush(response).addListener(new ChannelFutureListener() {\n 14:                             @Override\n 15:                             public void operationComplete(ChannelFuture future) throws Exception {\n 16:                                 if (!future.isSuccess()) {\n 17:                                     LOG.error(\"ProcessRequestWrapper response to {} failed\", future.channel().remoteAddress(), future.cause());\n 18:                                     LOG.error(request.toString());\n 19:                                     LOG.error(response.toString());\n 20:                                 }\n 21:                             }\n 22:                         });\n 23:                     } catch (Throwable e) {\n 24:                         LOG.error(\"ProcessRequestWrapper process request over, but response failed\", e);\n 25:                         LOG.error(request.toString());\n 26:                         LOG.error(response.toString());\n 27:                     }\n 28:                 }\n 29:             } catch (RemotingCommandException e1) {\n 30:                 LOG.error(\"ExecuteRequestWhenWakeup run\", e1);\n 31:             }\n 32:         }\n 33:     };\n 34:     // 提交拉取请求到线程池\n 35:     this.brokerController.getPullMessageExecutor().submit(new RequestTask(run, channel, request));\n 36: }\n```\n\n* 说明 ：执行请求唤醒，即再次拉取消息。该方法调用线程池，因此，不会阻塞。\n* 第 7 行 ：调用拉取消息请求。本次调用，设置即使请求不到消息，也不挂起请求。如果不设置，请求可能被无限挂起，被 `Broker` 无限循环。\n* 第 35 行 ：**提交拉取消息请求到线程池**。\n\n# 5、Broker 提供[更新消费进度]接口\n\n```bash\nYunai-MacdeMacBook-Pro-2:config yunai$ pwd\n/Users/yunai/store/config\nYunai-MacdeMacBook-Pro-2:config yunai$ ls -ls\ntotal 40\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json.bak\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json\n8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json.bak\n8 -rw-r--r--  1 yunai  staff  1401  4 27 21:51 topics.json\nYunai-MacdeMacBook-Pro-2:config yunai$ cat consumerOffset.json\n{\n\t\"offsetTable\":{\n\t\t\"%RETRY%please_rename_unique_group_name_4@please_rename_unique_group_name_4\":{0:0\n\t\t},\n\t\t\"TopicRead3@please_rename_unique_group_name_4\":{1:5\n\t\t}\n\t}\n}\n```\n\n* `consumerOffset.json` ：消费进度存储文件。\n* `consumerOffset.json.bak` ：消费进度存储文件备份。\n* 每次写入 `consumerOffset.json`，将原内容备份到 `consumerOffset.json.bak`。实现见：[MixAll#string2File(...)](mixallstring2file)。\n\n## BrokerController#initialize(...)\n\n```Java\n  1:this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  2:    @Override\n  3:    public void run() {\n  4:        try {\n  5:            BrokerController.this.consumerOffsetManager.persist();\n  6:        } catch (Throwable e) {\n  7:            log.error(\"schedule persist consumerOffset error.\", e);\n  8:        }\n  9:    }\n 10:}, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);\n```\n\n* 说明 ：每 5s 执行一次持久化逻辑。\n\n## ConfigManager\n\n```Java\n  1: public abstract class ConfigManager {\n  2: private static final Logger PLOG = LoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);\n  3: \n  4: /**\n  5:  * 编码内容\n  6:  * @return 编码后的内容\n  7:  */\n  8: public abstract String encode();\n  9: \n 10: /**\n 11:  * 加载文件\n 12:  *\n 13:  * @return 加载是否成功\n 14:  */\n 15: public boolean load() {\n 16:     String fileName = null;\n 17:     try {\n 18:         fileName = this.configFilePath();\n 19:         String jsonString = MixAll.file2String(fileName);\n 20:         // 如果内容不存在，则加载备份文件\n 21:         if (null == jsonString || jsonString.length() == 0) {\n 22:             return this.loadBak();\n 23:         } else {\n 24:             this.decode(jsonString);\n 25:             PLOG.info(\"load {} OK\", fileName);\n 26:             return true;\n 27:         }\n 28:     } catch (Exception e) {\n 29:         PLOG.error(\"load \" + fileName + \" Failed, and try to load backup file\", e);\n 30:         return this.loadBak();\n 31:     }\n 32: }\n 33: \n 34: /**\n 35:  * 配置文件地址\n 36:  *\n 37:  * @return 配置文件地址\n 38:  */\n 39: public abstract String configFilePath();\n 40: \n 41: /**\n 42:  * 加载备份文件\n 43:  *\n 44:  * @return 是否成功\n 45:  */\n 46: private boolean loadBak() {\n 47:     String fileName = null;\n 48:     try {\n 49:         fileName = this.configFilePath();\n 50:         String jsonString = MixAll.file2String(fileName + \".bak\");\n 51:         if (jsonString != null && jsonString.length() > 0) {\n 52:             this.decode(jsonString);\n 53:             PLOG.info(\"load \" + fileName + \" OK\");\n 54:             return true;\n 55:         }\n 56:     } catch (Exception e) {\n 57:         PLOG.error(\"load \" + fileName + \" Failed\", e);\n 58:         return false;\n 59:     }\n 60: \n 61:     return true;\n 62: }\n 63: \n 64: /**\n 65:  * 解码内容\n 66:  *\n 67:  * @param jsonString 内容\n 68:  */\n 69: public abstract void decode(final String jsonString);\n 70: \n 71: /**\n 72:  * 持久化\n 73:  */\n 74: public synchronized void persist() {\n 75:     String jsonString = this.encode(true);\n 76:     if (jsonString != null) {\n 77:         String fileName = this.configFilePath();\n 78:         try {\n 79:             MixAll.string2File(jsonString, fileName);\n 80:         } catch (IOException e) {\n 81:             PLOG.error(\"persist file Exception, \" + fileName, e);\n 82:         }\n 83:     }\n 84: }\n 85: \n 86: /**\n 87:  * 编码存储内容\n 88:  *\n 89:  * @param prettyFormat 是否格式化\n 90:  * @return 内容\n 91:  */\n 92: public abstract String encode(final boolean prettyFormat);\n 93: }\n```\n\n### MixAll#string2File(...)\n\n```Java\n  1: /**\n  2:  * 将内容写到文件\n  3:  * 安全写\n  4:  * 1. 写到.tmp文件\n  5:  * 2. 备份准备写入文件到.bak文件\n  6:  * 3. 删除原文件，将.tmp修改成文件\n  7:  *\n  8:  * @param str 内容\n  9:  * @param fileName 文件名\n 10:  * @throws IOException 当IO发生异常时\n 11:  */\n 12: public static void string2File(final String str, final String fileName) throws IOException {\n 13:     // 写到 tmp文件\n 14:     String tmpFile = fileName + \".tmp\";\n 15:     string2FileNotSafe(str, tmpFile);\n 16:     //\n 17:     String bakFile = fileName + \".bak\";\n 18:     String prevContent = file2String(fileName);\n 19:     if (prevContent != null) {\n 20:         string2FileNotSafe(prevContent, bakFile);\n 21:     }\n 22: \n 23:     File file = new File(fileName);\n 24:     file.delete();\n 25: \n 26:     file = new File(tmpFile);\n 27:     file.renameTo(new File(fileName));\n 28: }\n 29: \n 30: /**\n 31:  * 将内容写到文件\n 32:  * 非安全写\n 33:  *\n 34:  * @param str 内容\n 35:  * @param fileName 文件内容\n 36:  * @throws IOException 当IO发生异常时\n 37:  */\n 38: public static void string2FileNotSafe(final String str, final String fileName) throws IOException {\n 39:     File file = new File(fileName);\n 40:     // 创建上级目录\n 41:     File fileParent = file.getParentFile();\n 42:     if (fileParent != null) {\n 43:         fileParent.mkdirs();\n 44:     }\n 45:     // 写内容\n 46:     FileWriter fileWriter = null;\n 47:     try {\n 48:         fileWriter = new FileWriter(file);\n 49:         fileWriter.write(str);\n 50:     } catch (IOException e) {\n 51:         throw e;\n 52:     } finally {\n 53:         if (fileWriter != null) {\n 54:             fileWriter.close();\n 55:         }\n 56:     }\n 57: }\n```\n\n## ConsumerOffsetManager\n\n```Java\n  1: public class ConsumerOffsetManager extends ConfigManager {\n  2:     private static final Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);\n  3:     private static final String TOPIC_GROUP_SEPARATOR = \"@\";\n  4: \n  5:     /**\n  6:      * 消费进度集合\n  7:      */\n  8:     private ConcurrentHashMap<String/* topic@group */, ConcurrentHashMap<Integer, Long>> offsetTable = new ConcurrentHashMap<>(512);\n  9: \n 10:     private transient BrokerController brokerController;\n 11: \n 12:     public ConsumerOffsetManager() {\n 13:     }\n 14: \n 15:     public ConsumerOffsetManager(BrokerController brokerController) {\n 16:         this.brokerController = brokerController;\n 17:     }\n 18: \n 19:     /**\n 20:      * 提交消费进度\n 21:      *\n 22:      * @param clientHost 提交client地址\n 23:      * @param group 消费分组\n 24:      * @param topic 主题\n 25:      * @param queueId 队列编号\n 26:      * @param offset 进度（队列位置）\n 27:      */\n 28:     public void commitOffset(final String clientHost, final String group, final String topic, final int queueId, final long offset) {\n 29:         // topic@group\n 30:         String key = topic + TOPIC_GROUP_SEPARATOR + group;\n 31:         this.commitOffset(clientHost, key, queueId, offset);\n 32:     }\n 33: \n 34:     /**\n 35:      * 提交消费进度\n 36:      *\n 37:      * @param clientHost 提交client地址\n 38:      * @param key 主题@消费分组\n 39:      * @param queueId 队列编号\n 40:      * @param offset 进度（队列位置）\n 41:      */\n 42:     private void commitOffset(final String clientHost, final String key, final int queueId, final long offset) {\n 43:         ConcurrentHashMap<Integer, Long> map = this.offsetTable.get(key);\n 44:         if (null == map) {\n 45:             map = new ConcurrentHashMap<>(32);\n 46:             map.put(queueId, offset);\n 47:             this.offsetTable.put(key, map);\n 48:         } else {\n 49:             Long storeOffset = map.put(queueId, offset);\n 50:             if (storeOffset != null && offset < storeOffset) {\n 51:                 log.warn(\"[NOTIFYME]update consumer offset less than store. clientHost={}, key={}, queueId={}, requestOffset={}, storeOffset={}\", clientHost, key, queueId, offset, storeOffset);\n 52:             }\n 53:         }\n 54:     }\n 55: \n 56:     public String encode() {\n 57:         return this.encode(false);\n 58:     }\n 59: \n 60:     @Override\n 61:     public String configFilePath() {\n 62:         return BrokerPathConfigHelper.getConsumerOffsetPath(this.brokerController.getMessageStoreConfig().getStorePathRootDir());\n 63:     }\n 64: \n 65:     /**\n 66:      * 解码内容\n 67:      * 格式:JSON\n 68:      *\n 69:      * @param jsonString 内容\n 70:      */\n 71:     @Override\n 72:     public void decode(String jsonString) {\n 73:         if (jsonString != null) {\n 74:             ConsumerOffsetManager obj = RemotingSerializable.fromJson(jsonString, ConsumerOffsetManager.class);\n 75:             if (obj != null) {\n 76:                 this.offsetTable = obj.offsetTable;\n 77:             }\n 78:         }\n 79:     }\n 80: \n 81:     /**\n 82:      * 编码内容\n 83:      * 格式为JSON\n 84:      *\n 85:      * @param prettyFormat 是否格式化\n 86:      * @return 编码后的内容\n 87:      */\n 88:     public String encode(final boolean prettyFormat) {\n 89:         return RemotingSerializable.toJson(this, prettyFormat);\n 90:     }\n 91: \n 92: }\n```\n\n* 说明 ：消费进度管理器。\n\n# 6、Broker 提供[发回消息]接口\n\n大部分逻辑和 [`Broker` 提供[接收消息]接口](http://www.yunai.me/RocketMQ/message-send-and-receive/#3、Broker-接收消息) 类似，可以先看下相关内容。\n\n## SendMessageProcessor#consumerSendMsgBack(...)\n\n```Java\n  1: private RemotingCommand consumerSendMsgBack(final ChannelHandlerContext ctx, final RemotingCommand request)\n  2:     throws RemotingCommandException {\n  3: \n  4:     // 初始化响应\n  5:     final RemotingCommand response = RemotingCommand.createResponseCommand(null);\n  6:     final ConsumerSendMsgBackRequestHeader requestHeader =\n  7:         (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);\n  8: \n  9:     // hook（独有）\n 10:     if (this.hasConsumeMessageHook() && !UtilAll.isBlank(requestHeader.getOriginMsgId())) {\n 11: \n 12:         ConsumeMessageContext context = new ConsumeMessageContext();\n 13:         context.setConsumerGroup(requestHeader.getGroup());\n 14:         context.setTopic(requestHeader.getOriginTopic());\n 15:         context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);\n 16:         context.setCommercialRcvTimes(1);\n 17:         context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));\n 18: \n 19:         this.executeConsumeMessageHookAfter(context);\n 20:     }\n 21: \n 22:     // 判断消费分组是否存在（独有）\n 23:     SubscriptionGroupConfig subscriptionGroupConfig =\n 24:         this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());\n 25:     if (null == subscriptionGroupConfig) {\n 26:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);\n 27:         response.setRemark(\"subscription group not exist, \" + requestHeader.getGroup() + \" \"\n 28:             + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));\n 29:         return response;\n 30:     }\n 31: \n 32:     // 检查 broker 是否有写入权限\n 33:     if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) {\n 34:         response.setCode(ResponseCode.NO_PERMISSION);\n 35:         response.setRemark(\"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \"] sending message is forbidden\");\n 36:         return response;\n 37:     }\n 38: \n 39:     // 检查 重试队列数 是否大于0（独有）\n 40:     if (subscriptionGroupConfig.getRetryQueueNums() <= 0) {\n 41:         response.setCode(ResponseCode.SUCCESS);\n 42:         response.setRemark(null);\n 43:         return response;\n 44:     }\n 45: \n 46:     // 计算retry Topic\n 47:     String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());\n 48: \n 49:     // 计算队列编号（独有）\n 50:     int queueIdInt = Math.abs(this.random.nextInt() % 99999999) % subscriptionGroupConfig.getRetryQueueNums();\n 51: \n 52:     // 计算sysFlag（独有）\n 53:     int topicSysFlag = 0;\n 54:     if (requestHeader.isUnitMode()) {\n 55:         topicSysFlag = TopicSysFlag.buildSysFlag(false, true);\n 56:     }\n 57: \n 58:     // 获取topicConfig。如果获取不到，则进行创建\n 59:     TopicConfig topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(//\n 60:         newTopic, //\n 61:         subscriptionGroupConfig.getRetryQueueNums(), //\n 62:         PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);\n 63:     if (null == topicConfig) { // 没有配置\n 64:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 65:         response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n 66:         return response;\n 67:     }\n 68:     if (!PermName.isWriteable(topicConfig.getPerm())) { // 不允许写入\n 69:         response.setCode(ResponseCode.NO_PERMISSION);\n 70:         response.setRemark(String.format(\"the topic[%s] sending message is forbidden\", newTopic));\n 71:         return response;\n 72:     }\n 73: \n 74:     // 查询消息。若不存在，返回异常错误。（独有）\n 75:     MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());\n 76:     if (null == msgExt) {\n 77:         response.setCode(ResponseCode.SYSTEM_ERROR);\n 78:         response.setRemark(\"look message by offset failed, \" + requestHeader.getOffset());\n 79:         return response;\n 80:     }\n 81: \n 82:     // 设置retryTopic到拓展属性（独有）\n 83:     final String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);\n 84:     if (null == retryTopic) {\n 85:         MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());\n 86:     }\n 87: \n 88:     // 设置消息不等待存储完成（独有） TODO 疑问：如果设置成不等待存储，broker设置成同步落盘，岂不是不能批量提交了？\n 89:     msgExt.setWaitStoreMsgOK(false);\n 90: \n 91:     // 处理 delayLevel（独有）。\n 92:     int delayLevel = requestHeader.getDelayLevel();\n 93:     int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();\n 94:     if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) {\n 95:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();\n 96:     }\n 97:     if (msgExt.getReconsumeTimes() >= maxReconsumeTimes//\n 98:         || delayLevel < 0) { // 如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)\n 99:         newTopic = MixAll.getDLQTopic(requestHeader.getGroup());\n100:         queueIdInt = Math.abs(this.random.nextInt() % 99999999) % DLQ_NUMS_PER_GROUP;\n101: \n102:         topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, //\n103:             DLQ_NUMS_PER_GROUP, //\n104:             PermName.PERM_WRITE, 0\n105:         );\n106:         if (null == topicConfig) {\n107:             response.setCode(ResponseCode.SYSTEM_ERROR);\n108:             response.setRemark(\"topic[\" + newTopic + \"] not exist\");\n109:             return response;\n110:         }\n111:     } else {\n112:         if (0 == delayLevel) {\n113:             delayLevel = 3 + msgExt.getReconsumeTimes();\n114:         }\n115:         msgExt.setDelayTimeLevel(delayLevel);\n116:     }\n117: \n118:     // 创建MessageExtBrokerInner\n119:     MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n120:     msgInner.setTopic(newTopic);\n121:     msgInner.setBody(msgExt.getBody());\n122:     msgInner.setFlag(msgExt.getFlag());\n123:     MessageAccessor.setProperties(msgInner, msgExt.getProperties());\n124:     msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));\n125:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags()));\n126:     msgInner.setQueueId(queueIdInt);\n127:     msgInner.setSysFlag(msgExt.getSysFlag());\n128:     msgInner.setBornTimestamp(msgExt.getBornTimestamp());\n129:     msgInner.setBornHost(msgExt.getBornHost());\n130:     msgInner.setStoreHost(this.getStoreHost());\n131:     msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1);\n132: \n133:     // 设置原始消息编号到拓展字段（独有）\n134:     String originMsgId = MessageAccessor.getOriginMessageId(msgExt);\n135:     MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);\n136: \n137:     // 添加消息\n138:     PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);\n139:     if (putMessageResult != null) {\n140:         switch (putMessageResult.getPutMessageStatus()) {\n141:             case PUT_OK:\n142:                 String backTopic = msgExt.getTopic();\n143:                 String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);\n144:                 if (correctTopic != null) {\n145:                     backTopic = correctTopic;\n146:                 }\n147: \n148:                 this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);\n149: \n150:                 response.setCode(ResponseCode.SUCCESS);\n151:                 response.setRemark(null);\n152: \n153:                 return response;\n154:             default:\n155:                 break;\n156:         }\n157: \n158:         response.setCode(ResponseCode.SYSTEM_ERROR);\n159:         response.setRemark(putMessageResult.getPutMessageStatus().name());\n160:         return response;\n161:     }\n162: \n163:     response.setCode(ResponseCode.SYSTEM_ERROR);\n164:     response.setRemark(\"putMessageResult is null\");\n165:     return response;\n166: }\n```\n\n* 说明 ：当 `Consumer` 消费某条消息失败时，会调用该接口发回消息。`Broker` 会存储发回的消息。这样，下次 `Consumer` 拉取该消息，能够从 `CommitLog` 和 `ConsumeQueue` 顺序读取。\n* [x] 因为大多数逻辑和 **`Broker` 接收普通消息** 很相似，时候 `TODO` 标记成独有的逻辑。\n* 第 4 至 7 行 ：初始化响应。\n* [x] 第 9 至 20 行 ：Hook逻辑。\n* [x] 第22 至 30 行 ：判断消费分组是否存在。\n* 第 32 至 37 行 ：检查 `Broker` 是否有写入权限。\n* [x] 第 39 至 44 行 ：检查重试队列数是否大于0。\n* 第 47 行 ：计算 retry topic。\n* [x] 第 50 行 ：随机分配队列编号，依赖 `retryQueueNums`。\n* [x] 第 52 至 56 行 ：计算 `sysFlag`。\n* 第 58 至 72 行 ：获取 `TopicConfig`。如果不存在，则创建。\n* [x] 第 74 至 80 行 ：查询消息。若不存在，返回异常错误。\n* [x] 第 82 至 86 行 ：设置 `retryTopic` 到消息拓展属性。\n* [x] 第 89 行 ：设置消息不等待存储完成。\n    * 当 `Broker` 刷盘方式为同步，会导致同步落盘不能批量提交，这样会不会存在问题？有知道的同学麻烦告知下。😈。\n* [x] 第 91 至 116 行 ：处理 `delayLevel` 。\n* 第 118 至 131 行 ：创建 `MessageExtBrokerInner` 。\n* [x] 第 133 至 135 行 ：设置原始消息编号到拓展属性。\n* 第 137 至 161 行 ：添加消息。\n\n# 7、结尾\n\n感谢同学们对本文的阅读、收藏、点赞。\n\n😈如果解析存在问题或者表达误解的，表示抱歉。如果方便的话，可以加下 **QQ：7685413**。让我们来一场 1 ：1 交流（搞基）。\n\n再次表示十分感谢。\n\n\n","slug":"RocketMQ/message-pull-and-consume-first","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzb1001uag5dvvfywp1k","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">http://www.yunai.me/RocketMQ/message-pull-and-consume-first/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、ConsumeQueue 结构</a></li>\n<li><a href=\"#\">3、ConsumeQueue 存储</a><ul>\n<li><a href=\"#\">ReputMessageService</a><ul>\n<li><a href=\"#\">DefaultMessageStore#doDispatch(…)</a></li>\n<li><a href=\"#\">ConsumeQueue#putMessagePositionInfoWrapper(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">FlushConsumeQueueService</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4、Broker 提供[拉取消息]接口</a><ul>\n<li><a href=\"#\">PullMessageRequestHeader</a></li>\n<li><a href=\"#\">PullMessageProcessor#processRequest(…)</a></li>\n<li><a href=\"#\">MessageStore#getMessage(…)</a></li>\n<li><a href=\"#\">DefaultMessageFilter#isMessageMatched(…)</a></li>\n<li><a href=\"#\">PullRequestHoldService</a></li>\n<li><a href=\"#\">PullMessageProcessor#executeRequestWhenWakeup(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5、Broker 提供[更新消费进度]接口</a><ul>\n<li><a href=\"#\">BrokerController#initialize(…)</a></li>\n<li><a href=\"#\">ConfigManager</a><ul>\n<li><a href=\"#\">MixAll#string2File(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumerOffsetManager</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、Broker 提供[发回消息]接口</a><ul>\n<li><a href=\"#\">SendMessageProcessor#consumerSendMsgBack(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">7、结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本章主要解析 <strong>消费</strong> 逻辑涉及到的源码。<br>因为篇幅较长，分成上下两篇：</p>\n<ol>\n<li>上篇：<code>Broker</code> 相关源码。</li>\n<li>下篇：<code>Consumer</code> 相关源码。</li>\n</ol>\n<p><em>本文即是上篇。</em></p>\n<hr>\n<p>ok，先看第一张关于消费逻辑的图：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/13.png\" alt=\"消费逻辑图\"></p>\n</blockquote>\n<p>再看消费逻辑精简的顺序图（实际情况会略有差别）：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/04.png\" alt=\"Consumer&amp;Broker消费精简图.png\"></p>\n</blockquote>\n<h1 id=\"2、ConsumeQueue-结构\"><a href=\"#2、ConsumeQueue-结构\" class=\"headerlink\" title=\"2、ConsumeQueue 结构\"></a>2、ConsumeQueue 结构</h1><p><code>ConsumeQueue</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的关系如下：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/03.png\" alt=\"ConsumeQueue、MappedFileQueue、MappedFile的关系\"><br><code>ConsumeQueue</code> : <code>MappedFileQueue</code> : <code>MappedFile</code> = 1 : 1 : N。</p>\n</blockquote>\n<p>反应到系统文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:consumequeue yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/consumequeue</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:consumequeue yunai$ <span class=\"built_in\">cd</span> TopicRead3/</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ ls -ls</div><div class=\"line\">total 0</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:52 0</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 1</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 2</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 3</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ <span class=\"built_in\">cd</span> 0/</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:0 yunai$ ls -ls</div><div class=\"line\">total 11720</div><div class=\"line\">11720 -rw-r--r--  1 yunai  staff  6000000  4 27 21:55 00000000000000000000</div></pre></td></tr></table></figure>\n<hr>\n<p><code>ConsumeQueue</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的定义如下：</p>\n<ul>\n<li><code>MappedFile</code> ：00000000000000000000等文件。</li>\n<li><code>MappedFileQueue</code> ：<code>MappedFile</code> 所在的文件夹，对 <code>MappedFile</code> 进行封装成文件队列，对上层提供可无限使用的文件容量。<ul>\n<li>每个 <code>MappedFile</code> 统一文件大小。</li>\n<li>文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 <code>ConsumeQueue</code> 里默认为 6000000B。</li>\n</ul>\n</li>\n<li><code>ConsumeQueue</code> ：针对 <code>MappedFileQueue</code> 的封装使用。<ul>\n<li><code>Store : ConsumeQueue = ConcurrentHashMap&lt;String/* topic */, ConcurrentHashMap&lt;Integer/* queueId */, ConsumeQueue&gt;&gt;</code>。</li>\n</ul>\n</li>\n</ul>\n<p><code>ConsumeQueue</code> 存储在 <code>MappedFile</code> 的内容<strong>必须</strong>大小是 20B( <code>ConsumeQueue.CQ_STORE_UNIT_SIZE</code> )，有两种内容类型：</p>\n<ol>\n<li><code>MESSAGE_POSITION_INFO</code> ：消息位置信息。</li>\n<li><code>BLANK</code> : 文件前置空白占位。当历史 <code>Message</code> 被删除时，需要用 <code>BLANK</code>占位被删除的消息。</li>\n</ol>\n<p><code>MESSAGE_POSITION_INFO</code> 在 <code>ConsumeQueue</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">offset</td>\n<td style=\"text-align:left\">消息 <code>CommitLog</code> 存储位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">消息长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">tagsCode</td>\n<td style=\"text-align:left\">消息tagsCode</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<p><code>BLANK</code> 在 <code>ConsumeQueue</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Integer.MAX_VALUE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3、ConsumeQueue-存储\"><a href=\"#3、ConsumeQueue-存储\" class=\"headerlink\" title=\"3、ConsumeQueue 存储\"></a>3、ConsumeQueue 存储</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/02.png\" alt=\"CommitLog重放ConsumeQueue图\"></p>\n<p>主要有两个组件：</p>\n<ul>\n<li><code>ReputMessageService</code> ：write ConsumeQueue。</li>\n<li><code>FlushConsumeQueueService</code> ：flush ConsumeQueue。</li>\n</ul>\n<h2 id=\"ReputMessageService\"><a href=\"#ReputMessageService\" class=\"headerlink\" title=\"ReputMessageService\"></a>ReputMessageService</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/12.png\" alt=\"ReputMessageService顺序图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReputMessageService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 开始重放消息的CommitLog物理位置</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> reputFromOffset = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getReputFromOffset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">9</span>:         <span class=\"keyword\">return</span> reputFromOffset;</div><div class=\"line\"> <span class=\"number\">10</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setReputFromOffset</span><span class=\"params\">(<span class=\"keyword\">long</span> reputFromOffset)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.reputFromOffset = reputFromOffset;</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span> &amp;&amp; <span class=\"keyword\">this</span>.isCommitLogAvailable(); i++) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:                 Thread.sleep(<span class=\"number\">100</span>);</div><div class=\"line\"> <span class=\"number\">21</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isCommitLogAvailable()) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:             log.warn(<span class=\"string\">\"shutdown ReputMessageService, but commitlog have not finish to be dispatched, CL: &#123;&#125; reputFromOffset: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">27</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset(), <span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">super</span>.shutdown();</div><div class=\"line\"> <span class=\"number\">31</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">32</span>: </div><div class=\"line\"> <span class=\"number\">33</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 34:      * 剩余需要重放消息字节数</div><div class=\"line\"> 35:      *</div><div class=\"line\"> 36:      * <span class=\"doctag\">@return</span> 字节数</div><div class=\"line\"> 37:      */</div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">behind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">39</span>:         <span class=\"keyword\">return</span> DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset() - <span class=\"keyword\">this</span>.reputFromOffset;</div><div class=\"line\"> <span class=\"number\">40</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 43:      * 是否commitLog需要重放消息</div><div class=\"line\"> 44:      *</div><div class=\"line\"> 45:      * <span class=\"doctag\">@return</span> 是否</div><div class=\"line\"> 46:      */</div><div class=\"line\"> <span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCommitLogAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset();</div><div class=\"line\"> <span class=\"number\">49</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">50</span>: </div><div class=\"line\"> <span class=\"number\">51</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReput</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">52</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> doNext = <span class=\"keyword\">true</span>; <span class=\"keyword\">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"comment\">// TODO 疑问：这个是啥</span></div><div class=\"line\"> <span class=\"number\">55</span>:             <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().isDuplicationEnable() <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">56</span>:                 &amp;&amp; <span class=\"keyword\">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class=\"keyword\">this</span>.getConfirmOffset()) &#123;</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 获取从reputFromOffset开始的commitLog对应的MappeFile对应的MappedByteBuffer</span></div><div class=\"line\"> <span class=\"number\">61</span>:             SelectMappedBufferResult result = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getData(reputFromOffset);</div><div class=\"line\"> <span class=\"number\">62</span>:             <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:                     <span class=\"keyword\">this</span>.reputFromOffset = result.getStartOffset();</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                     <span class=\"comment\">// 遍历MappedByteBuffer</span></div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> readSize = <span class=\"number\">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:                         <span class=\"comment\">// 生成重放消息重放调度请求</span></div><div class=\"line\"> <span class=\"number\">69</span>:                         DispatchRequest dispatchRequest = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">70</span>:                         <span class=\"keyword\">int</span> size = dispatchRequest.getMsgSize(); <span class=\"comment\">// 消息长度</span></div><div class=\"line\"> <span class=\"number\">71</span>:                         <span class=\"comment\">// 根据请求的结果处理</span></div><div class=\"line\"> <span class=\"number\">72</span>:                         <span class=\"keyword\">if</span> (dispatchRequest.isSuccess()) &#123; <span class=\"comment\">// 读取成功</span></div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取Message</span></div><div class=\"line\"> <span class=\"number\">74</span>:                                 DefaultMessageStore.<span class=\"keyword\">this</span>.doDispatch(dispatchRequest);</div><div class=\"line\"> <span class=\"number\">75</span>:                                 <span class=\"comment\">// 通知有新消息</span></div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole()</div><div class=\"line\"> <span class=\"number\">77</span>:                                     &amp;&amp; DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.isLongPollingEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</div><div class=\"line\"> <span class=\"number\">79</span>:                                         dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class=\"number\">1</span>,</div><div class=\"line\"> <span class=\"number\">80</span>:                                         dispatchRequest.getTagsCode());</div><div class=\"line\"> <span class=\"number\">81</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:                                 <span class=\"comment\">// FIXED BUG By shijia</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset += size;</div><div class=\"line\"> <span class=\"number\">84</span>:                                 readSize += size;</div><div class=\"line\"> <span class=\"number\">85</span>:                                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">86</span>:                                 <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.storeStatsService</div><div class=\"line\"> <span class=\"number\">88</span>:                                         .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</div><div class=\"line\"> <span class=\"number\">89</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.storeStatsService</div><div class=\"line\"> <span class=\"number\">90</span>:                                         .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</div><div class=\"line\"> <span class=\"number\">91</span>:                                         .addAndGet(dispatchRequest.getMsgSize());</div><div class=\"line\"> <span class=\"number\">92</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:                             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取到MappedFile文件尾</span></div><div class=\"line\"> <span class=\"number\">94</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.rollNextFile(<span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"> <span class=\"number\">95</span>:                                 readSize = result.getSize();</div><div class=\"line\"> <span class=\"number\">96</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:                         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!dispatchRequest.isSuccess()) &#123; <span class=\"comment\">// 读取失败</span></div><div class=\"line\"> <span class=\"number\">98</span>:                             <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取到Message却不是Message</span></div><div class=\"line\"> <span class=\"number\">99</span>:                                 log.error(<span class=\"string\">\"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;\"</span>, reputFromOffset);</div><div class=\"line\"><span class=\"number\">100</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset += size;</div><div class=\"line\"><span class=\"number\">101</span>:                             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 读取到Blank却不是Blank</span></div><div class=\"line\"><span class=\"number\">102</span>:                                 doNext = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">103</span>:                                 <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                                     log.error(<span class=\"string\">\"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">105</span>:                                         <span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:                                     <span class=\"keyword\">this</span>.reputFromOffset += result.getSize() - readSize;</div><div class=\"line\"><span class=\"number\">108</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">110</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">111</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">112</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">113</span>:                     result.release();</div><div class=\"line\"><span class=\"number\">114</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">115</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">116</span>:                 doNext = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">117</span>:             &#125;</div><div class=\"line\"><span class=\"number\">118</span>:         &#125;</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">122</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">123</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">124</span>: </div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">127</span>:                 Thread.sleep(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">128</span>:                 <span class=\"keyword\">this</span>.doReput();</div><div class=\"line\"><span class=\"number\">129</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:                 DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">131</span>:             &#125;</div><div class=\"line\"><span class=\"number\">132</span>:         &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">135</span>:     &#125;</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">138</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"keyword\">return</span> ReputMessageService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">140</span>:     &#125;</div><div class=\"line\"><span class=\"number\">141</span>: </div><div class=\"line\"><span class=\"number\">142</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：重放消息线程服务。<ul>\n<li>该服务不断生成 消息位置信息 到 消费队列(ConsumeQueue)</li>\n<li>该服务不断生成 消息索引 到 索引文件(IndexFile)    </li>\n</ul>\n</li>\n<li><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/11.png\" alt=\"ReputMessageService用例图\"><ul>\n<li>第 61 行 ：获取 <code>reputFromOffset</code> 开始的 <code>CommitLog</code> 对应的 <code>MappedFile</code> 对应的 <code>MappedByteBuffer</code>。</li>\n<li>第 67 行 ：遍历 <code>MappedByteBuffer</code>。</li>\n<li>第 69 行 ：生成重放消息重放调度请求 (<code>DispatchRequest</code>) 。请求里主要包含一条消息 (<code>Message</code>) 或者 文件尾 (<code>BLANK</code>) 的基本信息。</li>\n<li>第 72 至 96 行 ：请求是有效请求，进行逻辑处理。<ul>\n<li>第 75 至 81 行 ：当 <code>Broker</code> 是主节点 &amp;&amp; <code>Broker</code> 开启的是长轮询，通知消费队列有新的消息。<code>NotifyMessageArrivingListener</code> 会 调用 <code>PullRequestHoldService#notifyMessageArriving(...)</code> 方法，详细解析见：<a href=\"#pullrequestholdservice\">PullRequestHoldService</a></li>\n</ul>\n</li>\n<li>第 73 至 92 行 ：请求对应的是 <code>Message</code>，进行调度，生成 <code>ConsumeQueue</code> 和 <code>IndexFile</code> 对应的内容。详细解析见：</li>\n<li>第 93 至 96 行 ：请求对应的是 <code>Blank</code>，即文件尾，跳转指向下一个 <code>MappedFile</code>。</li>\n<li>第 97 至 110 行 ：请求是无效请求。出现该情况，基本是一个<strong>BUG</strong>。</li>\n</ul>\n</li>\n<li>第 127 至 128 行 ：每 1ms 循环执行重放逻辑。</li>\n<li>第 18 至 30 行 ：<code>shutdown</code>时，多次 <code>sleep(100)</code> 直到 <code>CommitLog</code> 回放到最新位置。恩，如果未回放完，会输出警告日志。</li>\n</ul>\n<h3 id=\"DefaultMessageStore-doDispatch-…\"><a href=\"#DefaultMessageStore-doDispatch-…\" class=\"headerlink\" title=\"DefaultMessageStore#doDispatch(…)\"></a>DefaultMessageStore#doDispatch(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 执行调度请求</div><div class=\"line\"> 3:  * 1. 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</div><div class=\"line\"> 4:  * 2. 建立 索引信息 到 IndexFile</div><div class=\"line\"> 5:  *</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> req 调度请求</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</span></div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"><span class=\"number\">14</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),</div><div class=\"line\"><span class=\"number\">15</span>:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"comment\">// 建立 索引信息 到 IndexFile</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().isMessageIndexEnable()) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:         DefaultMessageStore.<span class=\"keyword\">this</span>.indexService.buildIndex(req);</div><div class=\"line\"><span class=\"number\">24</span>:     &#125;</div><div class=\"line\"><span class=\"number\">25</span>: &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>: <span class=\"comment\">/**</span></div><div class=\"line\">28:  * 建立 消息位置信息 到 ConsumeQueue</div><div class=\"line\">29:  *</div><div class=\"line\">30:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">31:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">32:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\">33:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\">35:  * <span class=\"doctag\">@param</span> storeTimestamp 存储时间</div><div class=\"line\">36:  * <span class=\"doctag\">@param</span> logicOffset 队列位置</div><div class=\"line\">37:  */</div><div class=\"line\"><span class=\"number\">38</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putMessagePositionInfo</span><span class=\"params\">(String topic, <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> tagsCode, <span class=\"keyword\">long</span> storeTimestamp,</span></span></div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">long</span> logicOffset) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:     ConsumeQueue cq = <span class=\"keyword\">this</span>.findConsumeQueue(topic, queueId);</div><div class=\"line\"><span class=\"number\">41</span>:     cq.putMessagePositionInfoWrapper(offset, size, tagsCode, storeTimestamp, logicOffset);</div><div class=\"line\"><span class=\"number\">42</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ConsumeQueue-putMessagePositionInfoWrapper-…\"><a href=\"#ConsumeQueue-putMessagePositionInfoWrapper-…\" class=\"headerlink\" title=\"ConsumeQueue#putMessagePositionInfoWrapper(…)\"></a>ConsumeQueue#putMessagePositionInfoWrapper(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * 添加位置信息封装</div><div class=\"line\">  3:  *</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> storeTimestamp 消息存储时间</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> logicOffset 队列位置</div><div class=\"line\">  9:  */</div><div class=\"line\"> <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putMessagePositionInfoWrapper</span><span class=\"params\">(<span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> tagsCode, <span class=\"keyword\">long</span> storeTimestamp,</span></span></div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">long</span> logicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxRetries = <span class=\"number\">30</span>;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">boolean</span> canWrite = <span class=\"keyword\">this</span>.defaultMessageStore.getRunningFlags().isWriteable();</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 多次循环写，直到成功</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxRetries &amp;&amp; canWrite; i++) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"comment\">// 调用添加位置信息</span></div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.putMessagePositionInfo(offset, size, tagsCode, logicOffset);</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"comment\">// 添加成功，使用消息存储时间 作为 存储check point。</span></div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(storeTimestamp);</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">22</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">24</span>:             log.warn(<span class=\"string\">\"[BUG]put commit log position info to \"</span> + topic + <span class=\"string\">\":\"</span> + queueId + <span class=\"string\">\" \"</span> + offset</div><div class=\"line\"> <span class=\"number\">25</span>:                 + <span class=\"string\">\" failed, retry \"</span> + i + <span class=\"string\">\" times\"</span>);</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">28</span>:                 Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\"> <span class=\"number\">29</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                 log.warn(<span class=\"string\">\"\"</span>, e);</div><div class=\"line\"> <span class=\"number\">31</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">32</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">33</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me 设置异常不可写入</span></div><div class=\"line\"> <span class=\"number\">36</span>:     log.error(<span class=\"string\">\"[BUG]consume queue can not write, &#123;&#125; &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.topic, <span class=\"keyword\">this</span>.queueId);</div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">this</span>.defaultMessageStore.getRunningFlags().makeLogicsQueueError();</div><div class=\"line\"> <span class=\"number\">38</span>: &#125;</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 41:  * 添加位置信息，并返回添加是否成功</div><div class=\"line\"> 42:  *</div><div class=\"line\"> 43:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\"> 44:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\"> 45:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\"> 46:  * <span class=\"doctag\">@param</span> cqOffset 队列位置</div><div class=\"line\"> 47:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\"> 48:  */</div><div class=\"line\"> <span class=\"number\">49</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putMessagePositionInfo</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tagsCode,</span></span></div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> cqOffset) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:     <span class=\"comment\">// 如果已经重放过，直接返回成功</span></div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"keyword\">if</span> (offset &lt;= <span class=\"keyword\">this</span>.maxPhysicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"comment\">// 写入位置信息到byteBuffer</span></div><div class=\"line\"> <span class=\"number\">56</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.flip();</div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putLong(offset);</div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putInt(size);</div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putLong(tagsCode);</div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"comment\">// 计算consumeQueue存储位置，并获得对应的MappedFile</span></div><div class=\"line\"> <span class=\"number\">62</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</div><div class=\"line\"> <span class=\"number\">63</span>:     MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">64</span>:     <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:         <span class=\"comment\">// 当是ConsumeQueue第一个MappedFile &amp;&amp; 队列位置非第一个 &amp;&amp; MappedFile未写入内容，则填充前置空白占位</span></div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">if</span> (mappedFile.isFirstCreateInQueue() &amp;&amp; cqOffset != <span class=\"number\">0</span> &amp;&amp; mappedFile.getWrotePosition() == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// TODO 疑问：为啥这个操作。目前能够想象到的是，一些老的消息很久没发送，突然发送，这个时候刚好满足。</span></div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">this</span>.minLogicOffset = expectLogicOffset;</div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">this</span>.mappedFileQueue.setFlushedWhere(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">this</span>.mappedFileQueue.setCommittedWhere(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">70</span>:             <span class=\"keyword\">this</span>.fillPreBlank(mappedFile, expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">71</span>:             log.info(<span class=\"string\">\"fill pre blank space \"</span> + mappedFile.getFileName() + <span class=\"string\">\" \"</span> + expectLogicOffset + <span class=\"string\">\" \"</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 + mappedFile.getWrotePosition());</div><div class=\"line\"> <span class=\"number\">73</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">74</span>:         <span class=\"comment\">// 校验consumeQueue存储位置是否合法。TODO 如果不合法，继续写入会不会有问题？</span></div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">if</span> (cqOffset != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">long</span> currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();</div><div class=\"line\"> <span class=\"number\">77</span>:             <span class=\"keyword\">if</span> (expectLogicOffset != currentLogicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                 LOG_ERROR.warn(</div><div class=\"line\"> <span class=\"number\">79</span>:                     <span class=\"string\">\"[BUG]logic queue order maybe wrong, expectLogicOffset: &#123;&#125; currentLogicOffset: &#123;&#125; Topic: &#123;&#125; QID: &#123;&#125; Diff: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">80</span>:                     expectLogicOffset,</div><div class=\"line\"> <span class=\"number\">81</span>:                     currentLogicOffset,</div><div class=\"line\"> <span class=\"number\">82</span>:                     <span class=\"keyword\">this</span>.topic,</div><div class=\"line\"> <span class=\"number\">83</span>:                     <span class=\"keyword\">this</span>.queueId,</div><div class=\"line\"> <span class=\"number\">84</span>:                     expectLogicOffset - currentLogicOffset</div><div class=\"line\"> <span class=\"number\">85</span>:                 );</div><div class=\"line\"> <span class=\"number\">86</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">87</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"comment\">// 设置commitLog重放消息到ConsumeQueue位置。</span></div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">this</span>.maxPhysicOffset = offset;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"comment\">// 插入mappedFile</span></div><div class=\"line\"> <span class=\"number\">91</span>:         <span class=\"keyword\">return</span> mappedFile.appendMessage(<span class=\"keyword\">this</span>.byteBufferIndex.array());</div><div class=\"line\"> <span class=\"number\">92</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">94</span>: &#125;</div><div class=\"line\"> <span class=\"number\">95</span>: </div><div class=\"line\"> <span class=\"number\">96</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 97:  * 填充前置空白占位</div><div class=\"line\"> 98:  *</div><div class=\"line\"> 99:  * <span class=\"doctag\">@param</span> mappedFile MappedFile</div><div class=\"line\">100:  * <span class=\"doctag\">@param</span> untilWhere consumeQueue存储位置</div><div class=\"line\">101:  */</div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fillPreBlank</span><span class=\"params\">(<span class=\"keyword\">final</span> MappedFile mappedFile, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> untilWhere)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"comment\">// 写入前置空白占位到byteBuffer</span></div><div class=\"line\"><span class=\"number\">104</span>:     ByteBuffer byteBuffer = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">105</span>:     byteBuffer.putLong(<span class=\"number\">0L</span>);</div><div class=\"line\"><span class=\"number\">106</span>:     byteBuffer.putInt(Integer.MAX_VALUE);</div><div class=\"line\"><span class=\"number\">107</span>:     byteBuffer.putLong(<span class=\"number\">0L</span>);</div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"comment\">// 循环填空</span></div><div class=\"line\"><span class=\"number\">109</span>:     <span class=\"keyword\">int</span> until = (<span class=\"keyword\">int</span>) (untilWhere % <span class=\"keyword\">this</span>.mappedFileQueue.getMappedFileSize());</div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; until; i += CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"><span class=\"number\">111</span>:         mappedFile.appendMessage(byteBuffer.array());</div><div class=\"line\"><span class=\"number\">112</span>:     &#125;</div><div class=\"line\"><span class=\"number\">113</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#putMessagePositionInfoWrapper(...)</code> 说明 ：添加位置信息到 <code>ConsumeQueue</code> 的封装，实际需要调用 <code>#putMessagePositionInfo(...)</code> 方法。<ul>\n<li>第 13 行 ：判断 <code>ConsumeQueue</code> 是否允许写入。当发生Bug时，不允许写入。</li>\n<li>第 17 行 ：调用 <code>#putMessagePositionInfo(...)</code> 方法，添加位置信息。</li>\n<li>第 18 至 21 行 ：添加成功，使用消息存储时间 作为 存储检查点。<code>StoreCheckpoint</code> 的详细解析见：<a href=\"http://www.yunai.me/RocketMQ/store-init-and-shutdown/\">Store初始化与关闭</a>。</li>\n<li>第 22 至 32 行 ：添加失败，目前基本可以认为是BUG。</li>\n<li>第 35 至 37 行 ：写入失败时，标记 <code>ConsumeQueue</code> 写入异常，不允许继续写入。</li>\n</ul>\n</li>\n<li><code>#putMessagePositionInfo(...)</code> 说明 ：添加位置信息到 <code>ConsumeQueue</code>，并返回添加是否成功。<ul>\n<li>第 51 至 54 行 ：如果 <code>offset</code>(存储位置) 小于等于  <code>maxPhysicOffset</code>(<code>CommitLog</code> 消息重放到 <code>ConsumeQueue</code> 最大的 <code>CommitLog</code> 存储位置)，表示已经重放过，此时，不再重复写入，直接返回写入成功。</li>\n<li>第 55 至 60 行 ：写 位置信息到byteBuffer。</li>\n<li>第 62 至 63 行 ：计算 <code>ConsumeQueue</code>存储位置，并获得对应的MappedFile。</li>\n<li>第 65 至 73 行 ：当 <code>MappedFile</code> 是 <code>ConsumeQueue</code> 当前第一个文件 &amp;&amp; <code>MappedFile</code> 未写入内容 &amp;&amp; 重放消息队列位置大于0，则需要进行 <code>MappedFile</code> 填充前置  <code>BLANK</code>。<ul>\n<li><em>这块比较有疑问，什么场景下会需要。猜测产生的原因：一个 <code>Topic</code> 长期无消息产生，突然N天后进行发送，<code>Topic</code> 对应的历史消息以及和消费队列数据已经被清理，新生成的<code>MappedFile</code>需要前置占位。</em></li>\n</ul>\n</li>\n<li>第 74 至 87 行 ：校验 <code>ConsumeQueue</code> 存储位置是否合法，不合法则输出日志。<ul>\n<li><em>这块比较有疑问，如果计算出来的存储位置不合法，不返回添加失败，继续进行添加位置信息，会不会有问题？？？</em></li>\n</ul>\n</li>\n<li>第 89 行 ：设置 <code>CommitLog</code> 重放消息到 <code>ConsumeQueue</code> 的最大位置。</li>\n<li>第 91 行 ：插入消息位置到 <code>MappedFile</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FlushConsumeQueueService\"><a href=\"#FlushConsumeQueueService\" class=\"headerlink\" title=\"FlushConsumeQueueService\"></a>FlushConsumeQueueService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlushConsumeQueueService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RETRY_TIMES_OVER = <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 最后flush时间戳</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastFlushTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doFlush</span><span class=\"params\">(<span class=\"keyword\">int</span> retryTimes)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">int</span> flushConsumeQueueLeastPages = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushConsumeQueueLeastPages();</div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// retryTimes == RETRY_TIMES_OVER时，进行强制flush。主要用于shutdown时。</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">if</span> (retryTimes == RETRY_TIMES_OVER) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             flushConsumeQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         &#125;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"comment\">// 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">long</span> logicsMsgTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">int</span> flushConsumeQueueThoroughInterval = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval();</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (currentTimeMillis &gt;= (<span class=\"keyword\">this</span>.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.lastFlushTimestamp = currentTimeMillis;</div><div class=\"line\"><span class=\"number\">21</span>:             flushConsumeQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">22</span>:             logicsMsgTimestamp = DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().getLogicsMsgTimestamp();</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// flush消费队列</span></div><div class=\"line\"><span class=\"number\">25</span>:         ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class=\"keyword\">this</span>.consumeQueueTable;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">for</span> (ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">for</span> (ConsumeQueue cq : maps.values()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                 <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                     result = cq.flush(flushConsumeQueueLeastPages);</div><div class=\"line\"><span class=\"number\">31</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"comment\">// flush 存储 check point</span></div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == flushConsumeQueueLeastPages) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">if</span> (logicsMsgTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp);</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().flush();</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">int</span> interval = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushIntervalConsumeQueue();</div><div class=\"line\"><span class=\"number\">49</span>:                 <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.doFlush(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">51</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                 DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">53</span>:             &#125;</div><div class=\"line\"><span class=\"number\">54</span>:         &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:         <span class=\"keyword\">this</span>.doFlush(RETRY_TIMES_OVER);</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">59</span>:     &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">62</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"keyword\">return</span> FlushConsumeQueueService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">64</span>:     &#125;</div><div class=\"line\"><span class=\"number\">65</span>: </div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span>;</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：flush <code>ConsumeQueue</code>(消费队列) 线程服务。</li>\n<li>第 11 至 14 行 ：当 <code>retryTimes == RETRY_TIMES_OVER</code> 时，进行强制flush。用于 <code>shutdown</code> 时。</li>\n<li>第 15 至 23 行 ：每 flushConsumeQueueThoroughInterval 周期，执行一次 flush 。因为不是每次循环到都能满足 flushConsumeQueueLeastPages 大小，因此，需要一定周期进行一次强制 flush 。当然，不能每次循环都去执行强制 flush，这样性能较差。</li>\n<li>第 24 至 33 行 ：flush <code>ConsumeQueue</code>(消费队列)。<ul>\n<li>flush 逻辑：<a href=\"http://www.yunai.me/RocketMQ/message-store/#MappedFile-落盘\">MappedFile#落盘</a>。</li>\n</ul>\n</li>\n<li>第 34 至 40 行 ：flush <code>StoreCheckpoint</code>。<code>StoreCheckpoint</code> 的详细解析见：<a href=\"http://www.yunai.me/RocketMQ/store-init-and-shutdown/\">Store初始化与关闭</a>。</li>\n<li>第 43 至 59 行 ：每 1000ms 执行一次 <code>flush</code>。如果 wakeup() 时，则会立即进行一次 <code>flush</code>。目前，暂时不存在 wakeup() 的调用。</li>\n</ul>\n<h1 id=\"4、Broker-提供-拉取消息-接口\"><a href=\"#4、Broker-提供-拉取消息-接口\" class=\"headerlink\" title=\"4、Broker 提供[拉取消息]接口\"></a>4、Broker 提供[拉取消息]接口</h1><h2 id=\"PullMessageRequestHeader\"><a href=\"#PullMessageRequestHeader\" class=\"headerlink\" title=\"PullMessageRequestHeader\"></a>PullMessageRequestHeader</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullMessageRequestHeader</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandCustomHeader</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 消费者分组</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> String consumerGroup;</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 8:      * Topic</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">private</span> String topic;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">13:      * 队列编号</div><div class=\"line\">14:      */</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">private</span> Integer queueId;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">18:      * 队列开始位置</div><div class=\"line\">19:      */</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">private</span> Long queueOffset;</div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">23:      * 消息数量</div><div class=\"line\">24:      */</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">private</span> Integer maxMsgNums;</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">28:      * 系统标识</div><div class=\"line\">29:      */</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">private</span> Integer sysFlag;</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">33:      * 提交消费进度位置</div><div class=\"line\">34:      */</div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">private</span> Long commitOffset;</div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">38:      * 挂起超时时间</div><div class=\"line\">39:      */</div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">private</span> Long suspendTimeoutMillis;</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">43:      * 订阅表达式</div><div class=\"line\">44:      */</div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"meta\">@CFNullable</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">private</span> String subscription;</div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">48:      * 订阅版本号</div><div class=\"line\">49:      */</div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">51</span>:     <span class=\"keyword\">private</span> Long subVersion;</div><div class=\"line\"><span class=\"number\">52</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：拉取消息请求Header</li>\n<li>topic +  queueId + queueOffset + maxMsgNums</li>\n<li>sysFlag ：系统标识。<ul>\n<li>第 0 位 <code>FLAG_COMMIT_OFFSET</code> ：标记请求提交消费进度位置，和 <code>commitOffset</code> 配合。</li>\n<li>第 1 位 <code>FLAG_SUSPEND</code> ：标记请求是否挂起请求，和 <code>suspendTimeoutMillis</code> 配合。当拉取不到消息时， <code>Broker</code> 会挂起请求，直到有消息。最大挂起时间：<code>suspendTimeoutMillis</code> 毫秒。</li>\n<li>第 2 位 <code>FLAG_SUBSCRIPTION</code> ：是否过滤订阅表达式，和 <code>subscription</code> 配置。</li>\n</ul>\n</li>\n<li>subVersion ：订阅版本号。请求时，如果版本号不对，则无法拉取到消息，需要重新获取订阅信息，使用最新的订阅版本号。</li>\n</ul>\n<h2 id=\"PullMessageProcessor-processRequest-…\"><a href=\"#PullMessageProcessor-processRequest-…\" class=\"headerlink\" title=\"PullMessageProcessor#processRequest(…)\"></a>PullMessageProcessor#processRequest(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel channel, RemotingCommand request, <span class=\"keyword\">boolean</span> brokerAllowSuspend)</span></span></div><div class=\"line\">  2:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> PullMessageRequestHeader requestHeader =</div><div class=\"line\">  <span class=\"number\">6</span>:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     response.setOpaque(request.getOpaque());</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (LOG.isDebugEnabled()) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:         LOG.debug(<span class=\"string\">\"receive PullMessage request command, &#123;&#125;\"</span>, request);</div><div class=\"line\"> <span class=\"number\">12</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">13</span>: </div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 校验 broker 是否可读</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (!PermName.isReadable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">17</span>:         response.setRemark(String.format(<span class=\"string\">\"the broker[%s] pulling message is forbidden\"</span>, <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1()));</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">19</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">20</span>: </div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"comment\">// 校验 consumer分组配置 是否存在</span></div><div class=\"line\"> <span class=\"number\">22</span>:     SubscriptionGroupConfig subscriptionGroupConfig = <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">24</span>:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">25</span>:         response.setRemark(String.format(<span class=\"string\">\"subscription group [%s] does not exist, %s\"</span>, requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));</div><div class=\"line\"> <span class=\"number\">26</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">27</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"comment\">// 校验 consumer分组配置 是否可消费</span></div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">if</span> (!subscriptionGroupConfig.isConsumeEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">31</span>:         response.setRemark(<span class=\"string\">\"subscription group no permission, \"</span> + requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">33</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否挂起请求，当没有消息时</span></div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否提交消费进度</span></div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否过滤订阅表达式(subscription)</span></div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class=\"number\">0</span>; <span class=\"comment\">// 挂起请求超时时长</span></div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"comment\">// 校验 topic配置 存在</span></div><div class=\"line\"> <span class=\"number\">41</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:         LOG.error(<span class=\"string\">\"The topic &#123;&#125; not exist, consumer: &#123;&#125; \"</span>, requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));</div><div class=\"line\"> <span class=\"number\">44</span>:         response.setCode(ResponseCode.TOPIC_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">45</span>:         response.setRemark(String.format(<span class=\"string\">\"topic[%s] not exist, apply first please! %s\"</span>, requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));</div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">47</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>:     <span class=\"comment\">// 校验 topic配置 权限可读</span></div><div class=\"line\"> <span class=\"number\">49</span>:     <span class=\"keyword\">if</span> (!PermName.isReadable(topicConfig.getPerm())) &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">51</span>:         response.setRemark(<span class=\"string\">\"the topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] pulling message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">52</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">53</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     <span class=\"comment\">// 校验 读取队列 在 topic配置 队列范围内</span></div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (requestHeader.getQueueId() &lt; <span class=\"number\">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:         String errorInfo = String.format(<span class=\"string\">\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\"</span>,</div><div class=\"line\"> <span class=\"number\">57</span>:                 requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());</div><div class=\"line\"> <span class=\"number\">58</span>:         LOG.warn(errorInfo);</div><div class=\"line\"> <span class=\"number\">59</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">60</span>:         response.setRemark(errorInfo);</div><div class=\"line\"> <span class=\"number\">61</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">62</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:     <span class=\"comment\">// 校验 订阅关系</span></div><div class=\"line\"> <span class=\"number\">65</span>:     SubscriptionData subscriptionData;</div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"keyword\">if</span> (hasSubscriptionFlag) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:             subscriptionData = FilterAPI.buildSubscriptionData(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"> <span class=\"number\">69</span>:                 requestHeader.getSubscription());</div><div class=\"line\"> <span class=\"number\">70</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:             LOG.warn(<span class=\"string\">\"Parse the consumer's subscription[&#123;&#125;] failed, group: &#123;&#125;\"</span>, requestHeader.getSubscription(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">72</span>:                     requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">73</span>:             response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);</div><div class=\"line\"> <span class=\"number\">74</span>:             response.setRemark(<span class=\"string\">\"parse the consumer's subscription failed\"</span>);</div><div class=\"line\"> <span class=\"number\">75</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">76</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">77</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:         <span class=\"comment\">// 校验 消费分组信息 是否存在</span></div><div class=\"line\"> <span class=\"number\">79</span>:         ConsumerGroupInfo consumerGroupInfo = <span class=\"keyword\">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">80</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == consumerGroupInfo) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:             LOG.warn(<span class=\"string\">\"The consumer's group info not exist, group: &#123;&#125;\"</span>, requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">82</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">83</span>:             response.setRemark(<span class=\"string\">\"the consumer's group info not exist\"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"comment\">// 校验 消费分组信息 消息模型是否匹配</span></div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">if</span> (!subscriptionGroupConfig.isConsumeBroadcastEnable() <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">88</span>:             &amp;&amp; consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">90</span>:             response.setRemark(<span class=\"string\">\"the consumer group[\"</span> + requestHeader.getConsumerGroup() + <span class=\"string\">\"] can not consume by broadcast way\"</span>);</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">92</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">93</span>: </div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"comment\">// 校验 订阅信息 是否存在</span></div><div class=\"line\"> <span class=\"number\">95</span>:         subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">97</span>:             LOG.warn(<span class=\"string\">\"The consumer's subscription not exist, group: &#123;&#125;, topic:&#123;&#125;\"</span>, requestHeader.getConsumerGroup(), requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">98</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">99</span>:             response.setRemark(<span class=\"string\">\"the consumer's subscription not exist\"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</div><div class=\"line\"><span class=\"number\">100</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">101</span>:         &#125;</div><div class=\"line\"><span class=\"number\">102</span>:         <span class=\"comment\">// 校验 订阅信息版本 是否合法</span></div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"keyword\">if</span> (subscriptionData.getSubVersion() &lt; requestHeader.getSubVersion()) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:             LOG.warn(<span class=\"string\">\"The broker's subscription is not latest, group: &#123;&#125; &#123;&#125;\"</span>, requestHeader.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">105</span>:                     subscriptionData.getSubString());</div><div class=\"line\"><span class=\"number\">106</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);</div><div class=\"line\"><span class=\"number\">107</span>:             response.setRemark(<span class=\"string\">\"the consumer's subscription not latest\"</span>);</div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">109</span>:         &#125;</div><div class=\"line\"><span class=\"number\">110</span>:     &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:     <span class=\"comment\">// 获取消息</span></div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"keyword\">final</span> GetMessageResult getMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">114</span>:             requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), subscriptionData);</div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"keyword\">if</span> (getMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">116</span>:         response.setRemark(getMessageResult.getStatus().name());</div><div class=\"line\"><span class=\"number\">117</span>:         responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">118</span>:         responseHeader.setMinOffset(getMessageResult.getMinOffset());</div><div class=\"line\"><span class=\"number\">119</span>:         responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"comment\">// TODO 待读</span></div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"comment\">// 计算建议读取brokerId</span></div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</div><div class=\"line\"><span class=\"number\">125</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">127</span>:         &#125;</div><div class=\"line\"><span class=\"number\">128</span>: </div><div class=\"line\"><span class=\"number\">129</span>:         <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">case</span> ASYNC_MASTER:</div><div class=\"line\"><span class=\"number\">131</span>:             <span class=\"keyword\">case</span> SYNC_MASTER:</div><div class=\"line\"><span class=\"number\">132</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">133</span>:             <span class=\"keyword\">case</span> SLAVE:</div><div class=\"line\"><span class=\"number\">134</span>:                 <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123; <span class=\"comment\">// 从节点不允许读取，告诉consumer读取主节点。</span></div><div class=\"line\"><span class=\"number\">135</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">136</span>:                     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">137</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">139</span>:         &#125;</div><div class=\"line\"><span class=\"number\">140</span>: </div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"comment\">// consume too slow ,redirect to another machine</span></div><div class=\"line\"><span class=\"number\">143</span>:             <span class=\"keyword\">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</div><div class=\"line\"><span class=\"number\">144</span>:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</div><div class=\"line\"><span class=\"number\">145</span>:             &#125;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"comment\">// consume ok</span></div><div class=\"line\"><span class=\"number\">147</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</div><div class=\"line\"><span class=\"number\">149</span>:             &#125;</div><div class=\"line\"><span class=\"number\">150</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">151</span>:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">152</span>:         &#125;</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:         <span class=\"keyword\">switch</span> (getMessageResult.getStatus()) &#123;</div><div class=\"line\"><span class=\"number\">155</span>:             <span class=\"keyword\">case</span> FOUND:</div><div class=\"line\"><span class=\"number\">156</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">157</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">158</span>:             <span class=\"keyword\">case</span> MESSAGE_WAS_REMOVING:</div><div class=\"line\"><span class=\"number\">159</span>:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">160</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">161</span>:             <span class=\"keyword\">case</span> NO_MATCHED_LOGIC_QUEUE:</div><div class=\"line\"><span class=\"number\">162</span>:             <span class=\"keyword\">case</span> NO_MESSAGE_IN_QUEUE:</div><div class=\"line\"><span class=\"number\">163</span>:                 <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != requestHeader.getQueueOffset()) &#123;</div><div class=\"line\"><span class=\"number\">164</span>:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"><span class=\"number\">167</span>:                     LOG.info(<span class=\"string\">\"the broker store no queue data, fix the request offset &#123;&#125; to &#123;&#125;, Topic: &#123;&#125; QueueId: &#123;&#125; Consumer Group: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">168</span>:                         requestHeader.getQueueOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">169</span>:                         getMessageResult.getNextBeginOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">170</span>:                         requestHeader.getTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">171</span>:                         requestHeader.getQueueId(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">172</span>:                         requestHeader.getConsumerGroup()<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">173</span>:                     );</div><div class=\"line\"><span class=\"number\">174</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:                     response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">176</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">177</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">178</span>:             <span class=\"keyword\">case</span> NO_MATCHED_MESSAGE:</div><div class=\"line\"><span class=\"number\">179</span>:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">180</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">181</span>:             <span class=\"keyword\">case</span> OFFSET_FOUND_NULL:</div><div class=\"line\"><span class=\"number\">182</span>:                 response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">183</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">184</span>:             <span class=\"keyword\">case</span> OFFSET_OVERFLOW_BADLY:</div><div class=\"line\"><span class=\"number\">185</span>:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">186</span>:                 <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"><span class=\"number\">187</span>:                 LOG.info(<span class=\"string\">\"The request offset:&#123;&#125; over flow badly, broker max offset:&#123;&#125; , consumer: &#123;&#125;\"</span>, requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</div><div class=\"line\"><span class=\"number\">188</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">189</span>:             <span class=\"keyword\">case</span> OFFSET_OVERFLOW_ONE:</div><div class=\"line\"><span class=\"number\">190</span>:                 response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">191</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">192</span>:             <span class=\"keyword\">case</span> OFFSET_TOO_SMALL:</div><div class=\"line\"><span class=\"number\">193</span>:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">194</span>:                 LOG.info(<span class=\"string\">\"The request offset is too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">195</span>:                     requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</div><div class=\"line\"><span class=\"number\">196</span>:                     getMessageResult.getMinOffset(), channel.remoteAddress());</div><div class=\"line\"><span class=\"number\">197</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">198</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">199</span>:                 <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">200</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">201</span>:         &#125;</div><div class=\"line\"><span class=\"number\">202</span>: </div><div class=\"line\"><span class=\"number\">203</span>:         <span class=\"comment\">// hook：before</span></div><div class=\"line\"><span class=\"number\">204</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasConsumeMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">205</span>:             ConsumeMessageContext context = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"><span class=\"number\">206</span>:             context.setConsumerGroup(requestHeader.getConsumerGroup());</div><div class=\"line\"><span class=\"number\">207</span>:             context.setTopic(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">208</span>:             context.setQueueId(requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">209</span>: </div><div class=\"line\"><span class=\"number\">210</span>:             String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);</div><div class=\"line\"><span class=\"number\">211</span>: </div><div class=\"line\"><span class=\"number\">212</span>:             <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">213</span>:                 <span class=\"keyword\">case</span> ResponseCode.SUCCESS:</div><div class=\"line\"><span class=\"number\">214</span>:                     <span class=\"keyword\">int</span> commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();</div><div class=\"line\"><span class=\"number\">215</span>:                     <span class=\"keyword\">int</span> incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;</div><div class=\"line\"><span class=\"number\">216</span>: </div><div class=\"line\"><span class=\"number\">217</span>:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);</div><div class=\"line\"><span class=\"number\">218</span>:                     context.setCommercialRcvTimes(incValue);</div><div class=\"line\"><span class=\"number\">219</span>:                     context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());</div><div class=\"line\"><span class=\"number\">220</span>:                     context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">221</span>: </div><div class=\"line\"><span class=\"number\">222</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">223</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\"><span class=\"number\">224</span>:                     <span class=\"keyword\">if</span> (!brokerAllowSuspend) &#123;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>:                         context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</div><div class=\"line\"><span class=\"number\">227</span>:                         context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">228</span>:                         context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">229</span>: </div><div class=\"line\"><span class=\"number\">230</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">231</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">232</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</div><div class=\"line\"><span class=\"number\">233</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_OFFSET_MOVED:</div><div class=\"line\"><span class=\"number\">234</span>:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</div><div class=\"line\"><span class=\"number\">235</span>:                     context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">236</span>:                     context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">237</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">238</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">239</span>:                     <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">240</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">241</span>:             &#125;</div><div class=\"line\"><span class=\"number\">242</span>: </div><div class=\"line\"><span class=\"number\">243</span>:             <span class=\"keyword\">this</span>.executeConsumeMessageHookBefore(context);</div><div class=\"line\"><span class=\"number\">244</span>:         &#125;</div><div class=\"line\"><span class=\"number\">245</span>: </div><div class=\"line\"><span class=\"number\">246</span>:         <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">247</span>:             <span class=\"keyword\">case</span> ResponseCode.SUCCESS:</div><div class=\"line\"><span class=\"number\">248</span>: </div><div class=\"line\"><span class=\"number\">249</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">250</span>:                     getMessageResult.getMessageCount());</div><div class=\"line\"><span class=\"number\">251</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">252</span>:                     getMessageResult.getBufferTotalSize());</div><div class=\"line\"><span class=\"number\">253</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</div><div class=\"line\"><span class=\"number\">254</span>:                 <span class=\"comment\">// 读取消息</span></div><div class=\"line\"><span class=\"number\">255</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123; <span class=\"comment\">// 内存中</span></div><div class=\"line\"><span class=\"number\">256</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = <span class=\"keyword\">this</span>.brokerController.getMessageStore().now();</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] r = <span class=\"keyword\">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">259</span>: </div><div class=\"line\"><span class=\"number\">260</span>:                     <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">261</span>:                         requestHeader.getTopic(), requestHeader.getQueueId(),</div><div class=\"line\"><span class=\"number\">262</span>:                         (<span class=\"keyword\">int</span>) (<span class=\"keyword\">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</div><div class=\"line\"><span class=\"number\">263</span>:                     response.setBody(r);</div><div class=\"line\"><span class=\"number\">264</span>:                 &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// zero-copy</span></div><div class=\"line\"><span class=\"number\">265</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">266</span>:                         FileRegion fileRegion = <span class=\"keyword\">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</div><div class=\"line\"><span class=\"number\">267</span>:                         channel.writeAndFlush(fileRegion).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\"><span class=\"number\">268</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">269</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">270</span>:                                 getMessageResult.release();</div><div class=\"line\"><span class=\"number\">271</span>:                                 <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</div><div class=\"line\"><span class=\"number\">272</span>:                                     LOG.error(<span class=\"string\">\"Fail to transfer messages from page cache to &#123;&#125;\"</span>, channel.remoteAddress(), future.cause());</div><div class=\"line\"><span class=\"number\">273</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">274</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">275</span>:                         &#125;);</div><div class=\"line\"><span class=\"number\">276</span>:                     &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">277</span>:                         LOG.error(<span class=\"string\">\"Error occurred when transferring messages from page cache\"</span>, e);</div><div class=\"line\"><span class=\"number\">278</span>:                         getMessageResult.release();</div><div class=\"line\"><span class=\"number\">279</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">280</span>: </div><div class=\"line\"><span class=\"number\">281</span>:                     response = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">282</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">283</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">284</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\"><span class=\"number\">285</span>:                 <span class=\"comment\">// 消息未查询到 &amp;&amp; broker允许挂起请求 &amp;&amp; 请求允许挂起</span></div><div class=\"line\"><span class=\"number\">286</span>:                 <span class=\"keyword\">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</div><div class=\"line\"><span class=\"number\">287</span>:                     <span class=\"keyword\">long</span> pollingTimeMills = suspendTimeoutMillisLong;</div><div class=\"line\"><span class=\"number\">288</span>:                     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\"><span class=\"number\">289</span>:                         pollingTimeMills = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</div><div class=\"line\"><span class=\"number\">290</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">291</span>: </div><div class=\"line\"><span class=\"number\">292</span>:                     String topic = requestHeader.getTopic();</div><div class=\"line\"><span class=\"number\">293</span>:                     <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();</div><div class=\"line\"><span class=\"number\">294</span>:                     <span class=\"keyword\">int</span> queueId = requestHeader.getQueueId();</div><div class=\"line\"><span class=\"number\">295</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest(request, channel, pollingTimeMills,</div><div class=\"line\"><span class=\"number\">296</span>:                         <span class=\"keyword\">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData);</div><div class=\"line\"><span class=\"number\">297</span>:                     <span class=\"keyword\">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</div><div class=\"line\"><span class=\"number\">298</span>:                     response = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">299</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">300</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">301</span>: </div><div class=\"line\"><span class=\"number\">302</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</div><div class=\"line\"><span class=\"number\">303</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">304</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_OFFSET_MOVED:</div><div class=\"line\"><span class=\"number\">305</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</div><div class=\"line\"><span class=\"number\">306</span>:                     || <span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123; <span class=\"comment\">// TODO 待博客补充</span></div><div class=\"line\"><span class=\"number\">307</span>:                     MessageQueue mq = <span class=\"keyword\">new</span> MessageQueue();</div><div class=\"line\"><span class=\"number\">308</span>:                     mq.setTopic(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">309</span>:                     mq.setQueueId(requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">310</span>:                     mq.setBrokerName(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerName());</div><div class=\"line\"><span class=\"number\">311</span>: </div><div class=\"line\"><span class=\"number\">312</span>:                     OffsetMovedEvent event = <span class=\"keyword\">new</span> OffsetMovedEvent();</div><div class=\"line\"><span class=\"number\">313</span>:                     event.setConsumerGroup(requestHeader.getConsumerGroup());</div><div class=\"line\"><span class=\"number\">314</span>:                     event.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">315</span>:                     event.setOffsetRequest(requestHeader.getQueueOffset());</div><div class=\"line\"><span class=\"number\">316</span>:                     event.setOffsetNew(getMessageResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">317</span>:                     <span class=\"keyword\">this</span>.generateOffsetMovedEvent(event);</div><div class=\"line\"><span class=\"number\">318</span>:                     LOG.warn(</div><div class=\"line\"><span class=\"number\">319</span>:                         <span class=\"string\">\"PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">320</span>:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</div><div class=\"line\"><span class=\"number\">321</span>:                         responseHeader.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">322</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">323</span>:                     responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</div><div class=\"line\"><span class=\"number\">324</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">325</span>:                     LOG.warn(<span class=\"string\">\"PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">326</span>:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</div><div class=\"line\"><span class=\"number\">327</span>:                         responseHeader.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">328</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">329</span>: </div><div class=\"line\"><span class=\"number\">330</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">331</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">332</span>:                 <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">333</span>:         &#125;</div><div class=\"line\"><span class=\"number\">334</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">335</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">336</span>:         response.setRemark(<span class=\"string\">\"store getMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">337</span>:     &#125;</div><div class=\"line\"><span class=\"number\">338</span>: </div><div class=\"line\"><span class=\"number\">339</span>:     <span class=\"comment\">// 请求要求持久化进度 &amp;&amp; broker非主，进行持久化进度。</span></div><div class=\"line\"><span class=\"number\">340</span>:     <span class=\"keyword\">boolean</span> storeOffsetEnable = brokerAllowSuspend;</div><div class=\"line\"><span class=\"number\">341</span>:     storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</div><div class=\"line\"><span class=\"number\">342</span>:     storeOffsetEnable = storeOffsetEnable &amp;&amp; <span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</div><div class=\"line\"><span class=\"number\">343</span>:     <span class=\"keyword\">if</span> (storeOffsetEnable) &#123;</div><div class=\"line\"><span class=\"number\">344</span>:         <span class=\"keyword\">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</div><div class=\"line\"><span class=\"number\">345</span>:             requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</div><div class=\"line\"><span class=\"number\">346</span>:     &#125;</div><div class=\"line\"><span class=\"number\">347</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">348</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：处理拉取消息请求，返回响应。</li>\n<li>第 14 至 19 行 ：校验 <code>Broker</code> 是否可读。</li>\n<li>第 21 至 33 行 ：校验 <code>SubscriptionGroupConfig</code>(订阅分组配置) 是否存在 &amp;&amp; 可以消费。</li>\n<li>第 35 至 38 行 ：处理 <code>PullMessageRequestHeader.sysFlag</code> 对应的标志位。</li>\n<li>第 40 至 62 行 ：校验 <code>TopicConfig</code>(主题配置) 是否存在 &amp;&amp; 可读 &amp;&amp; 队列编号正确。</li>\n<li>第 64 至 110 行 ：校验 <code>SubscriptionData</code>(订阅信息) 是否正确。</li>\n<li>第 113 行 ：调用 <code>MessageStore#getMessage(...)</code> 获取 <code>GetMessageResult</code>(消息)。详细解析见：<a href=\"#messagestoregetmessage\">MessageStore#getMessage(…)</a>。</li>\n<li>第 122 至 152 行 ：计算建议拉取消息 <code>brokerId</code> 。</li>\n<li>第 154 至 201 行 ：<img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/08.png\" alt=\"PullMessageProcessor拉取消息状态图\"></li>\n<li>第 204 至 244 行 ：<code>Hook</code> 逻辑，<code>#executeConsumeMessageHookBefore(...)</code> 。</li>\n<li>第 247 至 283 行 ：拉取消息成功，即拉取到消息。<ul>\n<li>第 255 至 263 行 ：方式一 ：调用 <code>readGetMessageResult(...)</code> 获取消息内容到堆内内存，设置到 响应<code>body</code>。</li>\n<li>第 265 至 281 行 ：方式二 ：基于 <code>zero-copy</code> 实现，直接响应，无需堆内内存，性能更优。<em>TODO ：此处等对zero-copy有研究，再补充一些</em>。</li>\n</ul>\n</li>\n<li>第 284 至 300 行 ：拉取不到消息，当满足条件 (<code>Broker</code> 允许挂起 &amp;&amp; 请求要求挂起)，执行挂起请求。详细解析见：<a href=\"#pullrequestholdservice\">PullRequestHoldService</a>。</li>\n<li>第 304 至 328 行 ：<em>TODO ：此处等对<code>tools</code>模块研究后再补充</em>。</li>\n<li>第 339 至 346 ：持久化消费进度，当满足 (<code>Broker</code> 非主 &amp;&amp; 请求要求持久化进度)。详细解析见：<a href=\"#3broker-提供更新消费进度接口\">更新消费进度</a>。</li>\n</ul>\n<h2 id=\"MessageStore-getMessage-…\"><a href=\"#MessageStore-getMessage-…\" class=\"headerlink\" title=\"MessageStore#getMessage(…)\"></a>MessageStore#getMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * 获取消息结果</div><div class=\"line\">  3:  *</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> group 消费分组</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> offset 队列位置</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> maxMsgNums 消息数量</div><div class=\"line\">  9:  * <span class=\"doctag\">@param</span> subscriptionData 订阅信息</div><div class=\"line\"> 10:  * <span class=\"doctag\">@return</span> 消息结果</div><div class=\"line\"> 11:  */</div><div class=\"line\"> <span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> GetMessageResult <span class=\"title\">getMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> String group, <span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMsgNums,</span></span></div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 是否关闭</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.shutdown) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         log.warn(<span class=\"string\">\"message store has shutdown, so getMessage is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">// 是否可读</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.runningFlags.isReadable()) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         log.warn(<span class=\"string\">\"message store is not readable, so getMessage is forbidden \"</span> + <span class=\"keyword\">this</span>.runningFlags.getFlagBits());</div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">23</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">long</span> beginTime = <span class=\"keyword\">this</span>.getSystemClock().now();</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">long</span> nextBeginOffset = offset;</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">long</span> minOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"keyword\">long</span> maxOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">31</span>: </div><div class=\"line\"> <span class=\"number\">32</span>:     GetMessageResult getResult = <span class=\"keyword\">new</span> GetMessageResult();</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffsetPy = <span class=\"keyword\">this</span>.commitLog.getMaxOffset();</div><div class=\"line\"> <span class=\"number\">35</span>: </div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"comment\">// 获取消费队列</span></div><div class=\"line\"> <span class=\"number\">37</span>:     ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">if</span> (consumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">39</span>:         minOffset = consumeQueue.getMinOffsetInQueue(); <span class=\"comment\">// 消费队列 最小队列编号</span></div><div class=\"line\"> <span class=\"number\">40</span>:         maxOffset = consumeQueue.getMaxOffsetInQueue(); <span class=\"comment\">// 消费队列 最大队列编号</span></div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"comment\">// 判断 队列位置(offset)</span></div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">if</span> (maxOffset == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 消费队列无消息</span></div><div class=\"line\"> <span class=\"number\">44</span>:             status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class=\"line\"> <span class=\"number\">45</span>:             nextBeginOffset = nextOffsetCorrection(offset, <span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">46</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset &lt; minOffset) &#123; <span class=\"comment\">// 查询offset 太小</span></div><div class=\"line\"> <span class=\"number\">47</span>:             status = GetMessageStatus.OFFSET_TOO_SMALL;</div><div class=\"line\"> <span class=\"number\">48</span>:             nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class=\"line\"> <span class=\"number\">49</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset == maxOffset) &#123; <span class=\"comment\">// 查询offset 超过 消费队列 一个位置</span></div><div class=\"line\"> <span class=\"number\">50</span>:             status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</div><div class=\"line\"> <span class=\"number\">51</span>:             nextBeginOffset = nextOffsetCorrection(offset, offset);</div><div class=\"line\"> <span class=\"number\">52</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset &gt; maxOffset) &#123; <span class=\"comment\">// 查询offset 超过 消费队列 太多(大于一个位置)</span></div><div class=\"line\"> <span class=\"number\">53</span>:             status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == minOffset) &#123; <span class=\"comment\">// TODO blog 这里是？？为啥0 == minOffset做了特殊判断</span></div><div class=\"line\"> <span class=\"number\">55</span>:                 nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class=\"line\"> <span class=\"number\">56</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">57</span>:                 nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 获得 映射Buffer结果(MappedFile)</span></div><div class=\"line\"> <span class=\"number\">61</span>:             SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</div><div class=\"line\"> <span class=\"number\">62</span>:             <span class=\"keyword\">if</span> (bufferConsumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:                     status = GetMessageStatus.NO_MATCHED_MESSAGE;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                     <span class=\"keyword\">long</span> nextPhyFileStartOffset = Long.MIN_VALUE; <span class=\"comment\">// commitLog下一个文件(MappedFile)对应的开始offset。</span></div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">long</span> maxPhyOffsetPulling = <span class=\"number\">0</span>; <span class=\"comment\">// 消息物理位置拉取到的最大offset</span></div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxFilterMessageCount = <span class=\"number\">16000</span>;</div><div class=\"line\"> <span class=\"number\">71</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> diskFallRecorded = <span class=\"keyword\">this</span>.messageStoreConfig.isDiskFallRecorded();</div><div class=\"line\"> <span class=\"number\">72</span>:                     <span class=\"comment\">// 循环获取 消息位置信息</span></div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                         <span class=\"keyword\">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); <span class=\"comment\">// 消息物理位置offset</span></div><div class=\"line\"> <span class=\"number\">75</span>:                         <span class=\"keyword\">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt(); <span class=\"comment\">// 消息长度</span></div><div class=\"line\"> <span class=\"number\">76</span>:                         <span class=\"keyword\">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); <span class=\"comment\">// 消息tagsCode</span></div><div class=\"line\"> <span class=\"number\">77</span>:                         <span class=\"comment\">// 设置消息物理位置拉取到的最大offset</span></div><div class=\"line\"> <span class=\"number\">78</span>:                         maxPhyOffsetPulling = offsetPy;</div><div class=\"line\"> <span class=\"number\">79</span>:                         <span class=\"comment\">// 当 offsetPy 小于 nextPhyFileStartOffset 时，意味着对应的 Message 已经移除，所以直接continue，直到可读取的Message。</span></div><div class=\"line\"> <span class=\"number\">80</span>:                         <span class=\"keyword\">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:                             <span class=\"keyword\">if</span> (offsetPy &lt; nextPhyFileStartOffset)</div><div class=\"line\"> <span class=\"number\">82</span>:                                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>:                         <span class=\"comment\">// 校验 commitLog 是否需要硬盘，无法全部放在内存</span></div><div class=\"line\"> <span class=\"number\">85</span>:                         <span class=\"keyword\">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</div><div class=\"line\"> <span class=\"number\">86</span>:                         <span class=\"comment\">// 是否已经获得足够消息</span></div><div class=\"line\"> <span class=\"number\">87</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</div><div class=\"line\"> <span class=\"number\">88</span>:                             isInDisk)) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:                             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 判断消息是否符合条件</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageFilter.isMessageMatched(subscriptionData, tagsCode)) &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:                             <span class=\"comment\">// 从commitLog获取对应消息ByteBuffer</span></div><div class=\"line\"> <span class=\"number\">94</span>:                             SelectMappedBufferResult selectResult = <span class=\"keyword\">this</span>.commitLog.getMessage(offsetPy, sizePy);</div><div class=\"line\"> <span class=\"number\">95</span>:                             <span class=\"keyword\">if</span> (selectResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:                                 <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</div><div class=\"line\"> <span class=\"number\">97</span>:                                 getResult.addMessage(selectResult);</div><div class=\"line\"> <span class=\"number\">98</span>:                                 status = GetMessageStatus.FOUND;</div><div class=\"line\"> <span class=\"number\">99</span>:                                 nextPhyFileStartOffset = Long.MIN_VALUE;</div><div class=\"line\"><span class=\"number\">100</span>:                             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                                 <span class=\"comment\">// 从commitLog无法读取到消息，说明该消息对应的文件（MappedFile）已经删除，计算下一个MappedFile的起始位置</span></div><div class=\"line\"><span class=\"number\">102</span>:                                 <span class=\"keyword\">if</span> (getResult.getBufferTotalSize() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">103</span>:                                     status = GetMessageStatus.MESSAGE_WAS_REMOVING;</div><div class=\"line\"><span class=\"number\">104</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">105</span>:                                 nextPhyFileStartOffset = <span class=\"keyword\">this</span>.commitLog.rollNextFile(offsetPy);</div><div class=\"line\"><span class=\"number\">106</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">107</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">108</span>:                             <span class=\"keyword\">if</span> (getResult.getBufferTotalSize() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:                                 status = GetMessageStatus.NO_MATCHED_MESSAGE;</div><div class=\"line\"><span class=\"number\">110</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:                             <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:                                 log.debug(<span class=\"string\">\"message type not matched, client: \"</span> + subscriptionData + <span class=\"string\">\" server: \"</span> + tagsCode);</div><div class=\"line\"><span class=\"number\">114</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">115</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">116</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">117</span>:                     <span class=\"comment\">// 统计剩余可拉取消息字节数</span></div><div class=\"line\"><span class=\"number\">118</span>:                     <span class=\"keyword\">if</span> (diskFallRecorded) &#123;</div><div class=\"line\"><span class=\"number\">119</span>:                         <span class=\"keyword\">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</div><div class=\"line\"><span class=\"number\">120</span>:                         brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</div><div class=\"line\"><span class=\"number\">121</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">122</span>:                     <span class=\"comment\">// 计算下次拉取消息的消息队列编号</span></div><div class=\"line\"><span class=\"number\">123</span>:                     nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">124</span>:                     <span class=\"comment\">// 根据剩余可拉取消息字节数与内存判断是否建议读取从节点</span></div><div class=\"line\"><span class=\"number\">125</span>:                     <span class=\"keyword\">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</div><div class=\"line\"><span class=\"number\">126</span>:                     <span class=\"keyword\">long</span> memory = (<span class=\"keyword\">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</div><div class=\"line\"><span class=\"number\">127</span>:                             * (<span class=\"keyword\">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class=\"number\">100.0</span>));</div><div class=\"line\"><span class=\"number\">128</span>:                     getResult.setSuggestPullingFromSlave(diff &gt; memory);</div><div class=\"line\"><span class=\"number\">129</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:                     bufferConsumeQueue.release();</div><div class=\"line\"><span class=\"number\">131</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">132</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">133</span>:                 status = GetMessageStatus.OFFSET_FOUND_NULL;</div><div class=\"line\"><span class=\"number\">134</span>:                 nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</div><div class=\"line\"><span class=\"number\">135</span>:                 log.warn(<span class=\"string\">\"consumer request topic: \"</span> + topic + <span class=\"string\">\"offset: \"</span> + offset + <span class=\"string\">\" minOffset: \"</span> + minOffset + <span class=\"string\">\" maxOffset: \"</span></div><div class=\"line\"><span class=\"number\">136</span>:                     + maxOffset + <span class=\"string\">\", but access logic queue failed.\"</span>);</div><div class=\"line\"><span class=\"number\">137</span>:             &#125;</div><div class=\"line\"><span class=\"number\">138</span>:         &#125;</div><div class=\"line\"><span class=\"number\">139</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">140</span>:         status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</div><div class=\"line\"><span class=\"number\">141</span>:         nextBeginOffset = nextOffsetCorrection(offset, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">142</span>:     &#125;</div><div class=\"line\"><span class=\"number\">143</span>:     <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">144</span>:     <span class=\"keyword\">if</span> (GetMessageStatus.FOUND == status) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</div><div class=\"line\"><span class=\"number\">146</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</div><div class=\"line\"><span class=\"number\">148</span>:     &#125;</div><div class=\"line\"><span class=\"number\">149</span>:     <span class=\"keyword\">long</span> eclipseTime = <span class=\"keyword\">this</span>.getSystemClock().now() - beginTime;</div><div class=\"line\"><span class=\"number\">150</span>:     <span class=\"keyword\">this</span>.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);</div><div class=\"line\"><span class=\"number\">151</span>:     <span class=\"comment\">// 设置返回结果</span></div><div class=\"line\"><span class=\"number\">152</span>:     getResult.setStatus(status);</div><div class=\"line\"><span class=\"number\">153</span>:     getResult.setNextBeginOffset(nextBeginOffset);</div><div class=\"line\"><span class=\"number\">154</span>:     getResult.setMaxOffset(maxOffset);</div><div class=\"line\"><span class=\"number\">155</span>:     getResult.setMinOffset(minOffset);</div><div class=\"line\"><span class=\"number\">156</span>:     <span class=\"keyword\">return</span> getResult;</div><div class=\"line\"><span class=\"number\">157</span>: &#125;</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>: <span class=\"comment\">/**</span></div><div class=\"line\">160:  * 根据 主题 + 队列编号 获取 消费队列</div><div class=\"line\">161:  *</div><div class=\"line\">162:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">163:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">164:  * <span class=\"doctag\">@return</span> 消费队列</div><div class=\"line\">165:  */</div><div class=\"line\"><span class=\"number\">166</span>: <span class=\"function\"><span class=\"keyword\">public</span> ConsumeQueue <span class=\"title\">findConsumeQueue</span><span class=\"params\">(String topic, <span class=\"keyword\">int</span> queueId)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">167</span>:     <span class=\"comment\">// 获取 topic 对应的 所有消费队列</span></div><div class=\"line\"><span class=\"number\">168</span>:     ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; map = consumeQueueTable.get(topic);</div><div class=\"line\"><span class=\"number\">169</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == map) &#123;</div><div class=\"line\"><span class=\"number\">170</span>:         ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; newMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"number\">171</span>:         ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; oldMap = consumeQueueTable.putIfAbsent(topic, newMap);</div><div class=\"line\"><span class=\"number\">172</span>:         <span class=\"keyword\">if</span> (oldMap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">173</span>:             map = oldMap;</div><div class=\"line\"><span class=\"number\">174</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:             map = newMap;</div><div class=\"line\"><span class=\"number\">176</span>:         &#125;</div><div class=\"line\"><span class=\"number\">177</span>:     &#125;</div><div class=\"line\"><span class=\"number\">178</span>:     <span class=\"comment\">// 获取 queueId 对应的 消费队列</span></div><div class=\"line\"><span class=\"number\">179</span>:     ConsumeQueue logic = map.get(queueId);</div><div class=\"line\"><span class=\"number\">180</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == logic) &#123;</div><div class=\"line\"><span class=\"number\">181</span>:         ConsumeQueue newLogic = <span class=\"keyword\">new</span> ConsumeQueue(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">182</span>:             topic, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">183</span>:             queueId, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">184</span>:             StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"keyword\">this</span>.messageStoreConfig.getStorePathRootDir()), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">185</span>:             <span class=\"keyword\">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">186</span>:             <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">187</span>:         ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);</div><div class=\"line\"><span class=\"number\">188</span>:         <span class=\"keyword\">if</span> (oldLogic != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">189</span>:             logic = oldLogic;</div><div class=\"line\"><span class=\"number\">190</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">191</span>:             logic = newLogic;</div><div class=\"line\"><span class=\"number\">192</span>:         &#125;</div><div class=\"line\"><span class=\"number\">193</span>:     &#125;</div><div class=\"line\"><span class=\"number\">194</span>: </div><div class=\"line\"><span class=\"number\">195</span>:     <span class=\"keyword\">return</span> logic;</div><div class=\"line\"><span class=\"number\">196</span>: &#125;</div><div class=\"line\"><span class=\"number\">197</span>: </div><div class=\"line\"><span class=\"number\">198</span>: <span class=\"comment\">/**</span></div><div class=\"line\">199:  * 下一个获取队列offset修正</div><div class=\"line\">200:  * 修正条件：主节点 或者 从节点开启校验offset开关</div><div class=\"line\">201:  *</div><div class=\"line\">202:  * <span class=\"doctag\">@param</span> oldOffset 老队列offset</div><div class=\"line\">203:  * <span class=\"doctag\">@param</span> newOffset 新队列offset</div><div class=\"line\">204:  * <span class=\"doctag\">@return</span> 修正后的队列offset</div><div class=\"line\">205:  */</div><div class=\"line\"><span class=\"number\">206</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">nextOffsetCorrection</span><span class=\"params\">(<span class=\"keyword\">long</span> oldOffset, <span class=\"keyword\">long</span> newOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">207</span>:     <span class=\"keyword\">long</span> nextOffset = oldOffset;</div><div class=\"line\"><span class=\"number\">208</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || <span class=\"keyword\">this</span>.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</div><div class=\"line\"><span class=\"number\">209</span>:         nextOffset = newOffset;</div><div class=\"line\"><span class=\"number\">210</span>:     &#125;</div><div class=\"line\"><span class=\"number\">211</span>:     <span class=\"keyword\">return</span> nextOffset;</div><div class=\"line\"><span class=\"number\">212</span>: &#125;</div><div class=\"line\"><span class=\"number\">213</span>: </div><div class=\"line\"><span class=\"number\">214</span>: <span class=\"comment\">/**</span></div><div class=\"line\">215:  * 校验 commitLog 是否需要硬盘，无法全部放在内存</div><div class=\"line\">216:  *</div><div class=\"line\">217:  * <span class=\"doctag\">@param</span> offsetPy commitLog 指定offset</div><div class=\"line\">218:  * <span class=\"doctag\">@param</span> maxOffsetPy commitLog 最大offset</div><div class=\"line\">219:  * <span class=\"doctag\">@return</span> 是否需要硬盘</div><div class=\"line\">220:  */</div><div class=\"line\"><span class=\"number\">221</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkInDiskByCommitOffset</span><span class=\"params\">(<span class=\"keyword\">long</span> offsetPy, <span class=\"keyword\">long</span> maxOffsetPy)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">222</span>:     <span class=\"keyword\">long</span> memory = (<span class=\"keyword\">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (<span class=\"keyword\">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class=\"number\">100.0</span>));</div><div class=\"line\"><span class=\"number\">223</span>:     <span class=\"keyword\">return</span> (maxOffsetPy - offsetPy) &gt; memory;</div><div class=\"line\"><span class=\"number\">224</span>: &#125;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>: <span class=\"comment\">/**</span></div><div class=\"line\">227:  * 判断获取消息是否已经满</div><div class=\"line\">228:  *</div><div class=\"line\">229:  * <span class=\"doctag\">@param</span> sizePy 字节数</div><div class=\"line\">230:  * <span class=\"doctag\">@param</span> maxMsgNums 最大消息数</div><div class=\"line\">231:  * <span class=\"doctag\">@param</span> bufferTotal 目前已经计算字节数</div><div class=\"line\">232:  * <span class=\"doctag\">@param</span> messageTotal 目前已经计算消息数</div><div class=\"line\">233:  * <span class=\"doctag\">@param</span> isInDisk 是否在硬盘中</div><div class=\"line\">234:  * <span class=\"doctag\">@return</span> 是否已满</div><div class=\"line\">235:  */</div><div class=\"line\"><span class=\"number\">236</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTheBatchFull</span><span class=\"params\">(<span class=\"keyword\">int</span> sizePy, <span class=\"keyword\">int</span> maxMsgNums, <span class=\"keyword\">int</span> bufferTotal, <span class=\"keyword\">int</span> messageTotal, <span class=\"keyword\">boolean</span> isInDisk)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">237</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == bufferTotal || <span class=\"number\">0</span> == messageTotal) &#123;</div><div class=\"line\"><span class=\"number\">238</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">239</span>:     &#125;</div><div class=\"line\"><span class=\"number\">240</span>:     <span class=\"comment\">// 消息数量已经满足请求数量(maxMsgNums)</span></div><div class=\"line\"><span class=\"number\">241</span>:     <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt;= maxMsgNums) &#123;</div><div class=\"line\"><span class=\"number\">242</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">243</span>:     &#125;</div><div class=\"line\"><span class=\"number\">244</span>:     <span class=\"comment\">// 根据消息存储配置的最大传输字节数、最大传输消息数是否已满</span></div><div class=\"line\"><span class=\"number\">245</span>:     <span class=\"keyword\">if</span> (isInDisk) &#123;</div><div class=\"line\"><span class=\"number\">246</span>:         <span class=\"keyword\">if</span> ((bufferTotal + sizePy) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferBytesOnMessageInDisk()) &#123;</div><div class=\"line\"><span class=\"number\">247</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">248</span>:         &#125;</div><div class=\"line\"><span class=\"number\">249</span>: </div><div class=\"line\"><span class=\"number\">250</span>:         <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferCountOnMessageInDisk()) &#123;</div><div class=\"line\"><span class=\"number\">251</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">252</span>:         &#125;</div><div class=\"line\"><span class=\"number\">253</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">254</span>:         <span class=\"keyword\">if</span> ((bufferTotal + sizePy) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferBytesOnMessageInMemory()) &#123;</div><div class=\"line\"><span class=\"number\">255</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">256</span>:         &#125;</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>:         <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferCountOnMessageInMemory()) &#123;</div><div class=\"line\"><span class=\"number\">259</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">260</span>:         &#125;</div><div class=\"line\"><span class=\"number\">261</span>:     &#125;</div><div class=\"line\"><span class=\"number\">262</span>: </div><div class=\"line\"><span class=\"number\">263</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">264</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：根据 消息分组(<code>group</code>) + 主题(<code>Topic</code>) + 队列编号(<code>queueId</code>) + 队列位置(<code>offset</code>) + 订阅信息(<code>subscriptionData</code>) 获取 指定条数(<code>maxMsgNums</code>) 消息(<code>Message</code>)。</li>\n<li>第 14 至 18 行 ：判断 <code>Store</code> 是否处于关闭状态，若关闭，则无法获取消息。</li>\n<li>第 19 至 23 行 ：判断当前运行状态是否可读，若不可读，则无法获取消息。</li>\n<li>第 37 行 ：根据 主题(<code>Topic</code>) + 队列编号(<code>queueId</code>) 获取 消息队列(<code>ConsumeQueue</code>)。<ul>\n<li><code>#findConsumeQueue(...)</code> ：第 159 至 196 行。</li>\n</ul>\n</li>\n<li>第 43 至 58 行 ：各种队列位置(<code>offset</code>) 无法读取消息，并针对对应的情况，计算下一次 <code>Client</code> 队列拉取位置。<ul>\n<li>第 43 至 45 行 ：消息队列无消息。</li>\n<li>第 46 至 48 行 ：查询的消息队列位置（<code>offset</code>） 太小。</li>\n<li>第 49 至 51 行 ：查询的消息队列位置（<code>offset</code>） 恰好等于 消息队列最大的队列位置。该情况是正常现象，相当于查询最新的消息。</li>\n<li>第 52 至 58 行 ：查询的消息队列位置（<code>offset</code>） 超过过多。</li>\n<li><code>#nextOffsetCorrection(...)</code> ：第 198 至 212 行。</li>\n</ul>\n</li>\n<li>第 61 行 ：根据 消费队列位置(<code>offset</code>) 获取 对应的<code>MappedFile</code>。</li>\n<li>第 72 至 128 行 ：<strong>循环</strong>获取 <code>消息位置信息</code>。<ul>\n<li>第 74 至 76 行 ：读取每一个 <code>消息位置信息</code>。</li>\n<li>第 79 至 83 行 ：当 <code>offsetPy</code> 小于 <code>nextPhyFileStartOffset</code> 时，意味着对<br>应的 <code>Message</code> 已经移除，所以直接continue，直到可读取的 <code>Message</code>。</li>\n<li>第 84 至 90 行 ：判断是否已经获得足够的消息。<ul>\n<li><code>#checkInDiskByCommitOffset(...)</code> ：第 214 至 224 行。</li>\n<li><code>#isTheBatchFull(...)</code> ：第 226 至 264 行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第 92 行 ：判断消息是否符合条件。详细解析见：<a href=\"defaultmessagefilterismessagematched\">DefaultMessageFilter#isMessageMatched(…)</a>。</li>\n<li>第 94 行 ：从 <code>CommitLog</code> 获取对应 消息的<code>MappedByteBuffer</code>。</li>\n<li>第 95 至 99 行 ：获取 <code>消息MappedByteBuffer</code> 成功。</li>\n<li>第 100 至 106 行 ：获取 <code>消息MappedByteBuffer</code> 失败。从 <code>CommitLog</code> 无法读取到消息，说明 该消息对应的文件(<code>MappedFile</code>) 已经删除，此时计算下一个<code>MappedFile</code>的起始位置。<strong>该逻辑需要配合（第 79 至 83 行）一起理解。</strong></li>\n<li>第 117 至 120 行 ：统计剩余可拉取消息字节数。</li>\n<li>第 123 行 ：计算下次拉取消息的消息队列编号。</li>\n<li>第 124 至 128 行 ：根据剩余可拉取消息字节数与内存判断是否建议读取从节点。</li>\n<li>第 130 行 ：释放 <code>bufferConsumeQueue</code> 对 <code>MappedFile</code> 的指向。此处 <code>MappedFile</code> 是 <code>ConsumeQueue</code> 里的文件，不是 <code>CommitLog</code> 下的文件。</li>\n<li>第 133 至 136 行 ：获得消费队列位置(<code>offset</code>) 获取 对应的<code>MappedFile</code> 为<strong>空</strong>，计算<code>ConsumeQueue</code> 从 <code>offset</code> 开始的下一个 <code>MappedFile</code> 对应的位置。</li>\n<li>第 143 至 150 行 ：记录统计信息：消耗时间、拉取到消息/未拉取到消息次数。</li>\n<li>第 151 至 156 行 ：设置返回结果并返回。 </li>\n</ul>\n<h2 id=\"DefaultMessageFilter-isMessageMatched-…\"><a href=\"#DefaultMessageFilter-isMessageMatched-…\" class=\"headerlink\" title=\"DefaultMessageFilter#isMessageMatched(…)\"></a>DefaultMessageFilter#isMessageMatched(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultMessageFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageFilter</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMessageMatched</span><span class=\"params\">(SubscriptionData subscriptionData, Long tagsCode)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"comment\">// 消息tagsCode 空</span></div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">if</span> (tagsCode == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">8</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"comment\">// 订阅数据 空</span></div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         &#125;</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"comment\">// classFilter</span></div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (subscriptionData.isClassFilterMode())</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 订阅表达式 全匹配</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">if</span> (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 订阅数据code数组 是否包含 消息tagsCode</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">return</span> subscriptionData.getCodeSet().contains(tagsCode.intValue());</div><div class=\"line\"><span class=\"number\">22</span>:     &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消息过滤器默认实现。</li>\n</ul>\n<h2 id=\"PullRequestHoldService\"><a href=\"#PullRequestHoldService\" class=\"headerlink\" title=\"PullRequestHoldService\"></a>PullRequestHoldService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullRequestHoldService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);</div><div class=\"line\">  <span class=\"number\">4</span>: </div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOPIC_QUEUEID_SEPARATOR = <span class=\"string\">\"@\"</span>;</div><div class=\"line\">  <span class=\"number\">6</span>: </div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BrokerController brokerController;</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SystemClock systemClock = <span class=\"keyword\">new</span> SystemClock();</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 11:      * 消息过滤器</div><div class=\"line\"> 12:      */</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageFilter messageFilter = <span class=\"keyword\">new</span> DefaultMessageFilter();</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 15:      * 拉取消息请求集合</div><div class=\"line\"> 16:      */</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* topic@queueId */</span>, ManyPullRequest&gt; pullRequestTable =</div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">1024</span>);</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PullRequestHoldService</span><span class=\"params\">(<span class=\"keyword\">final</span> BrokerController brokerController)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">this</span>.brokerController = brokerController;</div><div class=\"line\"> <span class=\"number\">22</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">23</span>: </div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 25:      * 添加拉取消息挂起请求</div><div class=\"line\"> 26:      *</div><div class=\"line\"> 27:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\"> 28:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\"> 29:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 30:      */</div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">suspendPullRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         String key = <span class=\"keyword\">this</span>.buildKey(topic, queueId);</div><div class=\"line\"> <span class=\"number\">33</span>:         ManyPullRequest mpr = <span class=\"keyword\">this</span>.pullRequestTable.get(key);</div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mpr) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:             mpr = <span class=\"keyword\">new</span> ManyPullRequest();</div><div class=\"line\"> <span class=\"number\">36</span>:             ManyPullRequest prev = <span class=\"keyword\">this</span>.pullRequestTable.putIfAbsent(key, mpr);</div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 mpr = prev;</div><div class=\"line\"> <span class=\"number\">39</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">40</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         mpr.addPullRequest(pullRequest);</div><div class=\"line\"> <span class=\"number\">43</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 46:      * 根据 主题 + 队列编号 创建唯一标识</div><div class=\"line\"> 47:      *</div><div class=\"line\"> 48:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\"> 49:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\"> 50:      * <span class=\"doctag\">@return</span> key</div><div class=\"line\"> 51:      */</div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">buildKey</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">53</span>:         StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"> <span class=\"number\">54</span>:         sb.append(topic);</div><div class=\"line\"> <span class=\"number\">55</span>:         sb.append(TOPIC_QUEUEID_SEPARATOR);</div><div class=\"line\"> <span class=\"number\">56</span>:         sb.append(queueId);</div><div class=\"line\"> <span class=\"number\">57</span>:         <span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\"> <span class=\"number\">58</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">62</span>:         log.info(<span class=\"string\">\"&#123;&#125; service started\"</span>, <span class=\"keyword\">this</span>.getServiceName());</div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"comment\">// 根据 长轮训 还是 短轮训 设置不同的等待时间</span></div><div class=\"line\"> <span class=\"number\">66</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</div><div class=\"line\"> <span class=\"number\">68</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">this</span>.waitForRunning(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</div><div class=\"line\"> <span class=\"number\">70</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"comment\">// 检查挂起请求是否有需要通知的</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">long</span> beginLockTimestamp = <span class=\"keyword\">this</span>.systemClock.now();</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.checkHoldRequest();</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">long</span> costTime = <span class=\"keyword\">this</span>.systemClock.now() - beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">if</span> (costTime &gt; <span class=\"number\">5</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                     log.info(<span class=\"string\">\"[NOTIFYME] check hold request cost &#123;&#125; ms.\"</span>, costTime);</div><div class=\"line\"> <span class=\"number\">77</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:                 log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>:         log.info(<span class=\"string\">\"&#123;&#125; service end\"</span>, <span class=\"keyword\">this</span>.getServiceName());</div><div class=\"line\"> <span class=\"number\">84</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">85</span>: </div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">87</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">return</span> PullRequestHoldService.class.getSimpleName();</div><div class=\"line\"> <span class=\"number\">89</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 92:      * 遍历挂起请求，检查是否有需要通知的请求。</div><div class=\"line\"> 93:      */</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkHoldRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">95</span>:         <span class=\"keyword\">for</span> (String key : <span class=\"keyword\">this</span>.pullRequestTable.keySet()) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:             String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</div><div class=\"line\"> <span class=\"number\">97</span>:             <span class=\"keyword\">if</span> (<span class=\"number\">2</span> == kArray.length) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 String topic = kArray[<span class=\"number\">0</span>];</div><div class=\"line\"> <span class=\"number\">99</span>:                 <span class=\"keyword\">int</span> queueId = Integer.parseInt(kArray[<span class=\"number\">1</span>]);</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);</div><div class=\"line\"><span class=\"number\">101</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">102</span>:                     <span class=\"keyword\">this</span>.notifyMessageArriving(topic, queueId, offset);</div><div class=\"line\"><span class=\"number\">103</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                     log.error(<span class=\"string\">\"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;\"</span>, topic, queueId, e);</div><div class=\"line\"><span class=\"number\">105</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">106</span>:             &#125;</div><div class=\"line\"><span class=\"number\">107</span>:         &#125;</div><div class=\"line\"><span class=\"number\">108</span>:     &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">111:      * 检查是否有需要通知的请求</div><div class=\"line\">112:      *</div><div class=\"line\">113:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">114:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">115:      * <span class=\"doctag\">@param</span> maxOffset 消费队列最大offset</div><div class=\"line\">116:      */</div><div class=\"line\"><span class=\"number\">117</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyMessageArriving</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">118</span>:         notifyMessageArriving(topic, queueId, maxOffset, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">122:      * 检查是否有需要通知的请求</div><div class=\"line\">123:      *</div><div class=\"line\">124:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">125:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">126:      * <span class=\"doctag\">@param</span> maxOffset 消费队列最大offset</div><div class=\"line\">127:      * <span class=\"doctag\">@param</span> tagsCode 过滤tagsCode</div><div class=\"line\">128:      */</div><div class=\"line\"><span class=\"number\">129</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyMessageArriving</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset, <span class=\"keyword\">final</span> Long tagsCode)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">130</span>:         String key = <span class=\"keyword\">this</span>.buildKey(topic, queueId);</div><div class=\"line\"><span class=\"number\">131</span>:         ManyPullRequest mpr = <span class=\"keyword\">this</span>.pullRequestTable.get(key);</div><div class=\"line\"><span class=\"number\">132</span>:         <span class=\"keyword\">if</span> (mpr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">133</span>:             <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">134</span>:             List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</div><div class=\"line\"><span class=\"number\">135</span>:             <span class=\"keyword\">if</span> (requestList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:                 List&lt;PullRequest&gt; replayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 不符合唤醒的请求数组</span></div><div class=\"line\"><span class=\"number\">137</span>: </div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">for</span> (PullRequest request : requestList) &#123;</div><div class=\"line\"><span class=\"number\">139</span>:                     <span class=\"comment\">// 如果 maxOffset 过小，则重新读取一次。</span></div><div class=\"line\"><span class=\"number\">140</span>:                     <span class=\"keyword\">long</span> newestOffset = maxOffset;</div><div class=\"line\"><span class=\"number\">141</span>:                     <span class=\"keyword\">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:                         newestOffset = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);</div><div class=\"line\"><span class=\"number\">143</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">144</span>:                     <span class=\"comment\">// 有新的匹配消息，唤醒请求，即再次拉取消息。</span></div><div class=\"line\"><span class=\"number\">145</span>:                     <span class=\"keyword\">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</div><div class=\"line\"><span class=\"number\">146</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageFilter.isMessageMatched(request.getSubscriptionData(), tagsCode)) &#123;</div><div class=\"line\"><span class=\"number\">147</span>:                             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                                 <span class=\"keyword\">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class=\"line\"><span class=\"number\">149</span>:                                     request.getRequestCommand());</div><div class=\"line\"><span class=\"number\">150</span>:                             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">151</span>:                                 log.error(<span class=\"string\">\"execute request when wakeup failed.\"</span>, e);</div><div class=\"line\"><span class=\"number\">152</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">153</span>:                             <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">154</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">155</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">156</span>:                     <span class=\"comment\">// 超过挂起时间，唤醒请求，即再次拉取消息。</span></div><div class=\"line\"><span class=\"number\">157</span>:                     <span class=\"keyword\">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</div><div class=\"line\"><span class=\"number\">158</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">159</span>:                             <span class=\"keyword\">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class=\"line\"><span class=\"number\">160</span>:                                 request.getRequestCommand());</div><div class=\"line\"><span class=\"number\">161</span>:                         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">162</span>:                             log.error(<span class=\"string\">\"execute request when wakeup failed.\"</span>, e);</div><div class=\"line\"><span class=\"number\">163</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">164</span>:                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">165</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">166</span>:                     <span class=\"comment\">// 不符合再次拉取的请求，再次添加回去</span></div><div class=\"line\"><span class=\"number\">167</span>:                     replayList.add(request);</div><div class=\"line\"><span class=\"number\">168</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">169</span>:                 <span class=\"comment\">// 添加回去</span></div><div class=\"line\"><span class=\"number\">170</span>:                 <span class=\"keyword\">if</span> (!replayList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">171</span>:                     mpr.addPullRequest(replayList);</div><div class=\"line\"><span class=\"number\">172</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">173</span>:             &#125;</div><div class=\"line\"><span class=\"number\">174</span>:         &#125;</div><div class=\"line\"><span class=\"number\">175</span>:     &#125;</div><div class=\"line\"><span class=\"number\">176</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>PullRequestHoldService</code> 说明 ：拉取消息请求挂起维护线程服务。<ul>\n<li>当拉取消息请求获得不了消息时，则会将请求进行挂起，添加到该服务。</li>\n<li>当有符合条件信息时 或 挂起超时时，重新执行获取消息逻辑。</li>\n</ul>\n</li>\n<li><code>#suspendPullRequest(...)</code> 说明 ：添加拉取消息挂起请求到集合( <code>pullRequestTable</code> )。</li>\n<li><code>#run(...)</code> 说明 ：<strong>定时</strong>检查挂起请求是否有需要通知重新拉取消息并进行通知。<ul>\n<li>第 65 至 70 行 ：根据<code>长轮训</code>or<code>短轮训</code>设置不同的等待时间。</li>\n<li>第 71 至 77 行 ：检查挂起请求是否有需要通知的。</li>\n</ul>\n</li>\n<li><code>#checkHoldRequest(...)</code> 说明 ：遍历挂起请求，检查是否有需要通知的。</li>\n<li><code>#notifyMessageArriving(...)</code> 说明 ：检查<strong>指定队列</strong>是否有需要通知的请求。<ul>\n<li>第 139 至 143 行 ：如果 <code>maxOffset</code> 过小，重新获取一次最新的。</li>\n<li>第 144 至 155 行 ：有新的匹配消息，唤醒请求，即再次拉取消息。</li>\n<li>第 156 至 165 行 ：超过挂起时间，唤醒请求，即再次拉取消息。</li>\n<li>第 148 || 159 行 ：唤醒请求，再次拉取消息。原先担心拉取消息时间过长，导致影响整个挂起请求的遍历，后面查看<code>#executeRequestWhenWakeup(...)</code>，实际是丢到线程池进行一步的消息拉取，不会有性能上的问题。详细解析见：<a href=\"pullmessageprocessorexecuterequestwhenwakeup\">PullMessageProcessor#executeRequestWhenWakeup(…)</a>。</li>\n<li>第 166 至 172 行 ：不符合唤醒的请求重新添加到集合(<code>pullRequestTable</code>)。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PullMessageProcessor-executeRequestWhenWakeup-…\"><a href=\"#PullMessageProcessor-executeRequestWhenWakeup-…\" class=\"headerlink\" title=\"PullMessageProcessor#executeRequestWhenWakeup(…)\"></a>PullMessageProcessor#executeRequestWhenWakeup(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeRequestWhenWakeup</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel channel, <span class=\"keyword\">final</span> RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     Runnable run = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 <span class=\"comment\">// 调用拉取请求。本次调用，设置不挂起请求。</span></div><div class=\"line\"> <span class=\"number\">7</span>:                 <span class=\"keyword\">final</span> RemotingCommand response = PullMessageProcessor.<span class=\"keyword\">this</span>.processRequest(channel, request, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:                 <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                     response.setOpaque(request.getOpaque());</div><div class=\"line\"><span class=\"number\">11</span>:                     response.markResponseType();</div><div class=\"line\"><span class=\"number\">12</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                         channel.writeAndFlush(response).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">15</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:                                 <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                                     LOG.error(<span class=\"string\">\"ProcessRequestWrapper response to &#123;&#125; failed\"</span>, future.channel().remoteAddress(), future.cause());</div><div class=\"line\"><span class=\"number\">18</span>:                                     LOG.error(request.toString());</div><div class=\"line\"><span class=\"number\">19</span>:                                     LOG.error(response.toString());</div><div class=\"line\"><span class=\"number\">20</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">22</span>:                         &#125;);</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                         LOG.error(<span class=\"string\">\"ProcessRequestWrapper process request over, but response failed\"</span>, e);</div><div class=\"line\"><span class=\"number\">25</span>:                         LOG.error(request.toString());</div><div class=\"line\"><span class=\"number\">26</span>:                         LOG.error(response.toString());</div><div class=\"line\"><span class=\"number\">27</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">28</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">29</span>:             &#125; <span class=\"keyword\">catch</span> (RemotingCommandException e1) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 LOG.error(<span class=\"string\">\"ExecuteRequestWhenWakeup run\"</span>, e1);</div><div class=\"line\"><span class=\"number\">31</span>:             &#125;</div><div class=\"line\"><span class=\"number\">32</span>:         &#125;</div><div class=\"line\"><span class=\"number\">33</span>:     &#125;;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 提交拉取请求到线程池</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">this</span>.brokerController.getPullMessageExecutor().submit(<span class=\"keyword\">new</span> RequestTask(run, channel, request));</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：执行请求唤醒，即再次拉取消息。该方法调用线程池，因此，不会阻塞。</li>\n<li>第 7 行 ：调用拉取消息请求。本次调用，设置即使请求不到消息，也不挂起请求。如果不设置，请求可能被无限挂起，被 <code>Broker</code> 无限循环。</li>\n<li>第 35 行 ：<strong>提交拉取消息请求到线程池</strong>。</li>\n</ul>\n<h1 id=\"5、Broker-提供-更新消费进度-接口\"><a href=\"#5、Broker-提供-更新消费进度-接口\" class=\"headerlink\" title=\"5、Broker 提供[更新消费进度]接口\"></a>5、Broker 提供[更新消费进度]接口</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/config</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ ls -ls</div><div class=\"line\">total 40</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json.bak</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json.bak</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff  1401  4 27 21:51 topics.json</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ cat consumerOffset.json</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"offsetTable\"</span>:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"%RETRY%please_rename_unique_group_name_4@please_rename_unique_group_name_4\"</span>:&#123;0:0</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"string\">\"TopicRead3@please_rename_unique_group_name_4\"</span>:&#123;1:5</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>consumerOffset.json</code> ：消费进度存储文件。</li>\n<li><code>consumerOffset.json.bak</code> ：消费进度存储文件备份。</li>\n<li>每次写入 <code>consumerOffset.json</code>，将原内容备份到 <code>consumerOffset.json.bak</code>。实现见：<a href=\"mixallstring2file\">MixAll#string2File(…)</a>。</li>\n</ul>\n<h2 id=\"BrokerController-initialize-…\"><a href=\"#BrokerController-initialize-…\" class=\"headerlink\" title=\"BrokerController#initialize(…)\"></a>BrokerController#initialize(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>:<span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">2</span>:    <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>:    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>:        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:            BrokerController.<span class=\"keyword\">this</span>.consumerOffsetManager.persist();</div><div class=\"line\"> <span class=\"number\">6</span>:        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:            log.error(<span class=\"string\">\"schedule persist consumerOffset error.\"</span>, e);</div><div class=\"line\"> <span class=\"number\">8</span>:        &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:    &#125;</div><div class=\"line\"><span class=\"number\">10</span>:&#125;, <span class=\"number\">1000</span> * <span class=\"number\">10</span>, <span class=\"keyword\">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：每 5s 执行一次持久化逻辑。</li>\n</ul>\n<h2 id=\"ConfigManager\"><a href=\"#ConfigManager\" class=\"headerlink\" title=\"ConfigManager\"></a>ConfigManager</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfigManager</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger PLOG = LoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 5:  * 编码内容</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 编码后的内容</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">encode</span><span class=\"params\">()</span></span>;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"comment\">/**</span></div><div class=\"line\">11:  * 加载文件</div><div class=\"line\">12:  *</div><div class=\"line\">13:  * <span class=\"doctag\">@return</span> 加载是否成功</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:     String fileName = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:         fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">19</span>:         String jsonString = MixAll.file2String(fileName);</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 如果内容不存在，则加载备份文件</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == jsonString || jsonString.length() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loadBak();</div><div class=\"line\"><span class=\"number\">23</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.decode(jsonString);</div><div class=\"line\"><span class=\"number\">25</span>:             PLOG.info(<span class=\"string\">\"load &#123;&#125; OK\"</span>, fileName);</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">27</span>:         &#125;</div><div class=\"line\"><span class=\"number\">28</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:         PLOG.error(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" Failed, and try to load backup file\"</span>, e);</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loadBak();</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>: <span class=\"comment\">/**</span></div><div class=\"line\">35:  * 配置文件地址</div><div class=\"line\">36:  *</div><div class=\"line\">37:  * <span class=\"doctag\">@return</span> 配置文件地址</div><div class=\"line\">38:  */</div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">configFilePath</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>: <span class=\"comment\">/**</span></div><div class=\"line\">42:  * 加载备份文件</div><div class=\"line\">43:  *</div><div class=\"line\">44:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">45:  */</div><div class=\"line\"><span class=\"number\">46</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">loadBak</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">47</span>:     String fileName = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">48</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">49</span>:         fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">50</span>:         String jsonString = MixAll.file2String(fileName + <span class=\"string\">\".bak\"</span>);</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span> &amp;&amp; jsonString.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.decode(jsonString);</div><div class=\"line\"><span class=\"number\">53</span>:             PLOG.info(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" OK\"</span>);</div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">55</span>:         &#125;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">57</span>:         PLOG.error(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" Failed\"</span>, e);</div><div class=\"line\"><span class=\"number\">58</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">59</span>:     &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">62</span>: &#125;</div><div class=\"line\"><span class=\"number\">63</span>: </div><div class=\"line\"><span class=\"number\">64</span>: <span class=\"comment\">/**</span></div><div class=\"line\">65:  * 解码内容</div><div class=\"line\">66:  *</div><div class=\"line\">67:  * <span class=\"doctag\">@param</span> jsonString 内容</div><div class=\"line\">68:  */</div><div class=\"line\"><span class=\"number\">69</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"keyword\">final</span> String jsonString)</span></span>;</div><div class=\"line\"><span class=\"number\">70</span>: </div><div class=\"line\"><span class=\"number\">71</span>: <span class=\"comment\">/**</span></div><div class=\"line\">72:  * 持久化</div><div class=\"line\">73:  */</div><div class=\"line\"><span class=\"number\">74</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">persist</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">75</span>:     String jsonString = <span class=\"keyword\">this</span>.encode(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">76</span>:     <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">77</span>:         String fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">78</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">79</span>:             MixAll.string2File(jsonString, fileName);</div><div class=\"line\"><span class=\"number\">80</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">81</span>:             PLOG.error(<span class=\"string\">\"persist file Exception, \"</span> + fileName, e);</div><div class=\"line\"><span class=\"number\">82</span>:         &#125;</div><div class=\"line\"><span class=\"number\">83</span>:     &#125;</div><div class=\"line\"><span class=\"number\">84</span>: &#125;</div><div class=\"line\"><span class=\"number\">85</span>: </div><div class=\"line\"><span class=\"number\">86</span>: <span class=\"comment\">/**</span></div><div class=\"line\">87:  * 编码存储内容</div><div class=\"line\">88:  *</div><div class=\"line\">89:  * <span class=\"doctag\">@param</span> prettyFormat 是否格式化</div><div class=\"line\">90:  * <span class=\"doctag\">@return</span> 内容</div><div class=\"line\">91:  */</div><div class=\"line\"><span class=\"number\">92</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">encode</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> prettyFormat)</span></span>;</div><div class=\"line\"><span class=\"number\">93</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"MixAll-string2File-…\"><a href=\"#MixAll-string2File-…\" class=\"headerlink\" title=\"MixAll#string2File(…)\"></a>MixAll#string2File(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 将内容写到文件</div><div class=\"line\"> 3:  * 安全写</div><div class=\"line\"> 4:  * 1. 写到.tmp文件</div><div class=\"line\"> 5:  * 2. 备份准备写入文件到.bak文件</div><div class=\"line\"> 6:  * 3. 删除原文件，将.tmp修改成文件</div><div class=\"line\"> 7:  *</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> str 内容</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> fileName 文件名</div><div class=\"line\">10:  * <span class=\"doctag\">@throws</span> IOException 当IO发生异常时</div><div class=\"line\">11:  */</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">string2File</span><span class=\"params\">(<span class=\"keyword\">final</span> String str, <span class=\"keyword\">final</span> String fileName)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 写到 tmp文件</span></div><div class=\"line\"><span class=\"number\">14</span>:     String tmpFile = fileName + <span class=\"string\">\".tmp\"</span>;</div><div class=\"line\"><span class=\"number\">15</span>:     string2FileNotSafe(str, tmpFile);</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">17</span>:     String bakFile = fileName + <span class=\"string\">\".bak\"</span>;</div><div class=\"line\"><span class=\"number\">18</span>:     String prevContent = file2String(fileName);</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (prevContent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:         string2FileNotSafe(prevContent, bakFile);</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:     File file = <span class=\"keyword\">new</span> File(fileName);</div><div class=\"line\"><span class=\"number\">24</span>:     file.delete();</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     file = <span class=\"keyword\">new</span> File(tmpFile);</div><div class=\"line\"><span class=\"number\">27</span>:     file.renameTo(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">/**</span></div><div class=\"line\">31:  * 将内容写到文件</div><div class=\"line\">32:  * 非安全写</div><div class=\"line\">33:  *</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> str 内容</div><div class=\"line\">35:  * <span class=\"doctag\">@param</span> fileName 文件内容</div><div class=\"line\">36:  * <span class=\"doctag\">@throws</span> IOException 当IO发生异常时</div><div class=\"line\">37:  */</div><div class=\"line\"><span class=\"number\">38</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">string2FileNotSafe</span><span class=\"params\">(<span class=\"keyword\">final</span> String str, <span class=\"keyword\">final</span> String fileName)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\"><span class=\"number\">39</span>:     File file = <span class=\"keyword\">new</span> File(fileName);</div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"comment\">// 创建上级目录</span></div><div class=\"line\"><span class=\"number\">41</span>:     File fileParent = file.getParentFile();</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">if</span> (fileParent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">43</span>:         fileParent.mkdirs();</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 写内容</span></div><div class=\"line\"><span class=\"number\">46</span>:     FileWriter fileWriter = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:         fileWriter = <span class=\"keyword\">new</span> FileWriter(file);</div><div class=\"line\"><span class=\"number\">49</span>:         fileWriter.write(str);</div><div class=\"line\"><span class=\"number\">50</span>:     &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>:         <span class=\"keyword\">if</span> (fileWriter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">54</span>:             fileWriter.close();</div><div class=\"line\"><span class=\"number\">55</span>:         &#125;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125;</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ConsumerOffsetManager\"><a href=\"#ConsumerOffsetManager\" class=\"headerlink\" title=\"ConsumerOffsetManager\"></a>ConsumerOffsetManager</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerOffsetManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ConfigManager</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOPIC_GROUP_SEPARATOR = <span class=\"string\">\"@\"</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 6:      * 消费进度集合</div><div class=\"line\"> 7:      */</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* topic@group */</span>, ConcurrentHashMap&lt;Integer, Long&gt;&gt; offsetTable = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">512</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> BrokerController brokerController;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumerOffsetManager</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumerOffsetManager</span><span class=\"params\">(BrokerController brokerController)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.brokerController = brokerController;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">20:      * 提交消费进度</div><div class=\"line\">21:      *</div><div class=\"line\">22:      * <span class=\"doctag\">@param</span> clientHost 提交client地址</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> group 消费分组</div><div class=\"line\">24:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">25:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">26:      * <span class=\"doctag\">@param</span> offset 进度（队列位置）</div><div class=\"line\">27:      */</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> String clientHost, <span class=\"keyword\">final</span> String group, <span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"comment\">// topic@group</span></div><div class=\"line\"><span class=\"number\">30</span>:         String key = topic + TOPIC_GROUP_SEPARATOR + group;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">this</span>.commitOffset(clientHost, key, queueId, offset);</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">35:      * 提交消费进度</div><div class=\"line\">36:      *</div><div class=\"line\">37:      * <span class=\"doctag\">@param</span> clientHost 提交client地址</div><div class=\"line\">38:      * <span class=\"doctag\">@param</span> key 主题@消费分组</div><div class=\"line\">39:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">40:      * <span class=\"doctag\">@param</span> offset 进度（队列位置）</div><div class=\"line\">41:      */</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> String clientHost, <span class=\"keyword\">final</span> String key, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">43</span>:         ConcurrentHashMap&lt;Integer, Long&gt; map = <span class=\"keyword\">this</span>.offsetTable.get(key);</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == map) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:             map = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">32</span>);</div><div class=\"line\"><span class=\"number\">46</span>:             map.put(queueId, offset);</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">this</span>.offsetTable.put(key, map);</div><div class=\"line\"><span class=\"number\">48</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">49</span>:             Long storeOffset = map.put(queueId, offset);</div><div class=\"line\"><span class=\"number\">50</span>:             <span class=\"keyword\">if</span> (storeOffset != <span class=\"keyword\">null</span> &amp;&amp; offset &lt; storeOffset) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:                 log.warn(<span class=\"string\">\"[NOTIFYME]update consumer offset less than store. clientHost=&#123;&#125;, key=&#123;&#125;, queueId=&#123;&#125;, requestOffset=&#123;&#125;, storeOffset=&#123;&#125;\"</span>, clientHost, key, queueId, offset, storeOffset);</div><div class=\"line\"><span class=\"number\">52</span>:             &#125;</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>:     &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.encode(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">configFilePath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">return</span> BrokerPathConfigHelper.getConsumerOffsetPath(<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getStorePathRootDir());</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">66:      * 解码内容</div><div class=\"line\">67:      * 格式:JSON</div><div class=\"line\">68:      *</div><div class=\"line\">69:      * <span class=\"doctag\">@param</span> jsonString 内容</div><div class=\"line\">70:      */</div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(String jsonString)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:             ConsumerOffsetManager obj = RemotingSerializable.fromJson(jsonString, ConsumerOffsetManager.class);</div><div class=\"line\"><span class=\"number\">75</span>:             <span class=\"keyword\">if</span> (obj != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">76</span>:                 <span class=\"keyword\">this</span>.offsetTable = obj.offsetTable;</div><div class=\"line\"><span class=\"number\">77</span>:             &#125;</div><div class=\"line\"><span class=\"number\">78</span>:         &#125;</div><div class=\"line\"><span class=\"number\">79</span>:     &#125;</div><div class=\"line\"><span class=\"number\">80</span>: </div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">82:      * 编码内容</div><div class=\"line\">83:      * 格式为JSON</div><div class=\"line\">84:      *</div><div class=\"line\">85:      * <span class=\"doctag\">@param</span> prettyFormat 是否格式化</div><div class=\"line\">86:      * <span class=\"doctag\">@return</span> 编码后的内容</div><div class=\"line\">87:      */</div><div class=\"line\"><span class=\"number\">88</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> prettyFormat)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">89</span>:         <span class=\"keyword\">return</span> RemotingSerializable.toJson(<span class=\"keyword\">this</span>, prettyFormat);</div><div class=\"line\"><span class=\"number\">90</span>:     &#125;</div><div class=\"line\"><span class=\"number\">91</span>: </div><div class=\"line\"><span class=\"number\">92</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消费进度管理器。</li>\n</ul>\n<h1 id=\"6、Broker-提供-发回消息-接口\"><a href=\"#6、Broker-提供-发回消息-接口\" class=\"headerlink\" title=\"6、Broker 提供[发回消息]接口\"></a>6、Broker 提供[发回消息]接口</h1><p>大部分逻辑和 <a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/#3、Broker-接收消息\"><code>Broker</code> 提供[接收消息]接口</a> 类似，可以先看下相关内容。</p>\n<h2 id=\"SendMessageProcessor-consumerSendMsgBack-…\"><a href=\"#SendMessageProcessor-consumerSendMsgBack-…\" class=\"headerlink\" title=\"SendMessageProcessor#consumerSendMsgBack(…)\"></a>SendMessageProcessor#consumerSendMsgBack(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">consumerSendMsgBack</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span></span></div><div class=\"line\">  2:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\">  <span class=\"number\">3</span>: </div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">// 初始化响应</span></div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class=\"keyword\">null</span>);</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</div><div class=\"line\">  <span class=\"number\">7</span>:         (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"comment\">// hook（独有）</span></div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:         ConsumeMessageContext context = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"> <span class=\"number\">13</span>:         context.setConsumerGroup(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">14</span>:         context.setTopic(requestHeader.getOriginTopic());</div><div class=\"line\"> <span class=\"number\">15</span>:         context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</div><div class=\"line\"> <span class=\"number\">16</span>:         context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"> <span class=\"number\">17</span>:         context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</div><div class=\"line\"> <span class=\"number\">18</span>: </div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">this</span>.executeConsumeMessageHookAfter(context);</div><div class=\"line\"> <span class=\"number\">20</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"comment\">// 判断消费分组是否存在（独有）</span></div><div class=\"line\"> <span class=\"number\">23</span>:     SubscriptionGroupConfig subscriptionGroupConfig =</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">27</span>:         response.setRemark(<span class=\"string\">\"subscription group not exist, \"</span> + requestHeader.getGroup() + <span class=\"string\">\" \"</span></div><div class=\"line\"> <span class=\"number\">28</span>:             + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</div><div class=\"line\"> <span class=\"number\">29</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">30</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">31</span>: </div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"comment\">// 检查 broker 是否有写入权限</span></div><div class=\"line\"> <span class=\"number\">33</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">35</span>:         response.setRemark(<span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class=\"string\">\"] sending message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">37</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"comment\">// 检查 重试队列数 是否大于0（独有）</span></div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"keyword\">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:         response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"> <span class=\"number\">42</span>:         response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">44</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:     <span class=\"comment\">// 计算retry Topic</span></div><div class=\"line\"> <span class=\"number\">47</span>:     String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">48</span>: </div><div class=\"line\"> <span class=\"number\">49</span>:     <span class=\"comment\">// 计算队列编号（独有）</span></div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"keyword\">int</span> queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</div><div class=\"line\"> <span class=\"number\">51</span>: </div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"comment\">// 计算sysFlag（独有）</span></div><div class=\"line\"> <span class=\"number\">53</span>:     <span class=\"keyword\">int</span> topicSysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:     <span class=\"keyword\">if</span> (requestHeader.isUnitMode()) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:         topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">56</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"comment\">// 获取topicConfig。如果获取不到，则进行创建</span></div><div class=\"line\"> <span class=\"number\">59</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">60</span>:         newTopic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">61</span>:         subscriptionGroupConfig.getRetryQueueNums(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">62</span>:         PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</div><div class=\"line\"> <span class=\"number\">63</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123; <span class=\"comment\">// 没有配置</span></div><div class=\"line\"> <span class=\"number\">64</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">65</span>:         response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">67</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123; <span class=\"comment\">// 不允许写入</span></div><div class=\"line\"> <span class=\"number\">69</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">70</span>:         response.setRemark(String.format(<span class=\"string\">\"the topic[%s] sending message is forbidden\"</span>, newTopic));</div><div class=\"line\"> <span class=\"number\">71</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">72</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">73</span>: </div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"comment\">// 查询消息。若不存在，返回异常错误。（独有）</span></div><div class=\"line\"> <span class=\"number\">75</span>:     MessageExt msgExt = <span class=\"keyword\">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</div><div class=\"line\"> <span class=\"number\">76</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == msgExt) &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">78</span>:         response.setRemark(<span class=\"string\">\"look message by offset failed, \"</span> + requestHeader.getOffset());</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">80</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:     <span class=\"comment\">// 设置retryTopic到拓展属性（独有）</span></div><div class=\"line\"> <span class=\"number\">83</span>:     <span class=\"keyword\">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == retryTopic) &#123;</div><div class=\"line\"> <span class=\"number\">85</span>:         MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</div><div class=\"line\"> <span class=\"number\">86</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"comment\">// 设置消息不等待存储完成（独有） TODO 疑问：如果设置成不等待存储，broker设置成同步落盘，岂不是不能批量提交了？</span></div><div class=\"line\"> <span class=\"number\">89</span>:     msgExt.setWaitStoreMsgOK(<span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"comment\">// 处理 delayLevel（独有）。</span></div><div class=\"line\"> <span class=\"number\">92</span>:     <span class=\"keyword\">int</span> delayLevel = requestHeader.getDelayLevel();</div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"> <span class=\"number\">95</span>:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">96</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"keyword\">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">98</span>:         || delayLevel &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)</span></div><div class=\"line\"> <span class=\"number\">99</span>:         newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</div><div class=\"line\"><span class=\"number\">100</span>:         queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % DLQ_NUMS_PER_GROUP;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>:         topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">103</span>:             DLQ_NUMS_PER_GROUP, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">104</span>:             PermName.PERM_WRITE, <span class=\"number\">0</span></div><div class=\"line\"><span class=\"number\">105</span>:         );</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">107</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">108</span>:             response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"><span class=\"number\">109</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">110</span>:         &#125;</div><div class=\"line\"><span class=\"number\">111</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == delayLevel) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:             delayLevel = <span class=\"number\">3</span> + msgExt.getReconsumeTimes();</div><div class=\"line\"><span class=\"number\">114</span>:         &#125;</div><div class=\"line\"><span class=\"number\">115</span>:         msgExt.setDelayTimeLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">116</span>:     &#125;</div><div class=\"line\"><span class=\"number\">117</span>: </div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"comment\">// 创建MessageExtBrokerInner</span></div><div class=\"line\"><span class=\"number\">119</span>:     MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">120</span>:     msgInner.setTopic(newTopic);</div><div class=\"line\"><span class=\"number\">121</span>:     msgInner.setBody(msgExt.getBody());</div><div class=\"line\"><span class=\"number\">122</span>:     msgInner.setFlag(msgExt.getFlag());</div><div class=\"line\"><span class=\"number\">123</span>:     MessageAccessor.setProperties(msgInner, msgExt.getProperties());</div><div class=\"line\"><span class=\"number\">124</span>:     msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</div><div class=\"line\"><span class=\"number\">125</span>:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class=\"keyword\">null</span>, msgExt.getTags()));</div><div class=\"line\"><span class=\"number\">126</span>:     msgInner.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">127</span>:     msgInner.setSysFlag(msgExt.getSysFlag());</div><div class=\"line\"><span class=\"number\">128</span>:     msgInner.setBornTimestamp(msgExt.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">129</span>:     msgInner.setBornHost(msgExt.getBornHost());</div><div class=\"line\"><span class=\"number\">130</span>:     msgInner.setStoreHost(<span class=\"keyword\">this</span>.getStoreHost());</div><div class=\"line\"><span class=\"number\">131</span>:     msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">132</span>: </div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"comment\">// 设置原始消息编号到拓展字段（独有）</span></div><div class=\"line\"><span class=\"number\">134</span>:     String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</div><div class=\"line\"><span class=\"number\">135</span>:     MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:     <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">138</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">139</span>:     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">140</span>:         <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">141</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">142</span>:                 String backTopic = msgExt.getTopic();</div><div class=\"line\"><span class=\"number\">143</span>:                 String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</div><div class=\"line\"><span class=\"number\">144</span>:                 <span class=\"keyword\">if</span> (correctTopic != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                     backTopic = correctTopic;</div><div class=\"line\"><span class=\"number\">146</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">147</span>: </div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</div><div class=\"line\"><span class=\"number\">149</span>: </div><div class=\"line\"><span class=\"number\">150</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">151</span>:                 response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">152</span>: </div><div class=\"line\"><span class=\"number\">153</span>:                 <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">154</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">155</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">156</span>:         &#125;</div><div class=\"line\"><span class=\"number\">157</span>: </div><div class=\"line\"><span class=\"number\">158</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">159</span>:         response.setRemark(putMessageResult.getPutMessageStatus().name());</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">161</span>:     &#125;</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">164</span>:     response.setRemark(<span class=\"string\">\"putMessageResult is null\"</span>);</div><div class=\"line\"><span class=\"number\">165</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">166</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：当 <code>Consumer</code> 消费某条消息失败时，会调用该接口发回消息。<code>Broker</code> 会存储发回的消息。这样，下次 <code>Consumer</code> 拉取该消息，能够从 <code>CommitLog</code> 和 <code>ConsumeQueue</code> 顺序读取。</li>\n<li>[x] 因为大多数逻辑和 <strong><code>Broker</code> 接收普通消息</strong> 很相似，时候 <code>TODO</code> 标记成独有的逻辑。</li>\n<li>第 4 至 7 行 ：初始化响应。</li>\n<li>[x] 第 9 至 20 行 ：Hook逻辑。</li>\n<li>[x] 第22 至 30 行 ：判断消费分组是否存在。</li>\n<li>第 32 至 37 行 ：检查 <code>Broker</code> 是否有写入权限。</li>\n<li>[x] 第 39 至 44 行 ：检查重试队列数是否大于0。</li>\n<li>第 47 行 ：计算 retry topic。</li>\n<li>[x] 第 50 行 ：随机分配队列编号，依赖 <code>retryQueueNums</code>。</li>\n<li>[x] 第 52 至 56 行 ：计算 <code>sysFlag</code>。</li>\n<li>第 58 至 72 行 ：获取 <code>TopicConfig</code>。如果不存在，则创建。</li>\n<li>[x] 第 74 至 80 行 ：查询消息。若不存在，返回异常错误。</li>\n<li>[x] 第 82 至 86 行 ：设置 <code>retryTopic</code> 到消息拓展属性。</li>\n<li>[x] 第 89 行 ：设置消息不等待存储完成。<ul>\n<li>当 <code>Broker</code> 刷盘方式为同步，会导致同步落盘不能批量提交，这样会不会存在问题？有知道的同学麻烦告知下。😈。</li>\n</ul>\n</li>\n<li>[x] 第 91 至 116 行 ：处理 <code>delayLevel</code> 。</li>\n<li>第 118 至 131 行 ：创建 <code>MessageExtBrokerInner</code> 。</li>\n<li>[x] 第 133 至 135 行 ：设置原始消息编号到拓展属性。</li>\n<li>第 137 至 161 行 ：添加消息。</li>\n</ul>\n<h1 id=\"7、结尾\"><a href=\"#7、结尾\" class=\"headerlink\" title=\"7、结尾\"></a>7、结尾</h1><p>感谢同学们对本文的阅读、收藏、点赞。</p>\n<p>😈如果解析存在问题或者表达误解的，表示抱歉。如果方便的话，可以加下 <strong>QQ：7685413</strong>。让我们来一场 1 ：1 交流（搞基）。</p>\n<p>再次表示十分感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">http://www.yunai.me/RocketMQ/message-pull-and-consume-first/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、ConsumeQueue 结构</a></li>\n<li><a href=\"#\">3、ConsumeQueue 存储</a><ul>\n<li><a href=\"#\">ReputMessageService</a><ul>\n<li><a href=\"#\">DefaultMessageStore#doDispatch(…)</a></li>\n<li><a href=\"#\">ConsumeQueue#putMessagePositionInfoWrapper(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">FlushConsumeQueueService</a></li>\n</ul>\n</li>\n<li><a href=\"#\">4、Broker 提供[拉取消息]接口</a><ul>\n<li><a href=\"#\">PullMessageRequestHeader</a></li>\n<li><a href=\"#\">PullMessageProcessor#processRequest(…)</a></li>\n<li><a href=\"#\">MessageStore#getMessage(…)</a></li>\n<li><a href=\"#\">DefaultMessageFilter#isMessageMatched(…)</a></li>\n<li><a href=\"#\">PullRequestHoldService</a></li>\n<li><a href=\"#\">PullMessageProcessor#executeRequestWhenWakeup(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5、Broker 提供[更新消费进度]接口</a><ul>\n<li><a href=\"#\">BrokerController#initialize(…)</a></li>\n<li><a href=\"#\">ConfigManager</a><ul>\n<li><a href=\"#\">MixAll#string2File(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumerOffsetManager</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、Broker 提供[发回消息]接口</a><ul>\n<li><a href=\"#\">SendMessageProcessor#consumerSendMsgBack(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">7、结尾</a></li>\n</ul>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本章主要解析 <strong>消费</strong> 逻辑涉及到的源码。<br>因为篇幅较长，分成上下两篇：</p>\n<ol>\n<li>上篇：<code>Broker</code> 相关源码。</li>\n<li>下篇：<code>Consumer</code> 相关源码。</li>\n</ol>\n<p><em>本文即是上篇。</em></p>\n<hr>\n<p>ok，先看第一张关于消费逻辑的图：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/13.png\" alt=\"消费逻辑图\"></p>\n</blockquote>\n<p>再看消费逻辑精简的顺序图（实际情况会略有差别）：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/04.png\" alt=\"Consumer&amp;Broker消费精简图.png\"></p>\n</blockquote>\n<h1 id=\"2、ConsumeQueue-结构\"><a href=\"#2、ConsumeQueue-结构\" class=\"headerlink\" title=\"2、ConsumeQueue 结构\"></a>2、ConsumeQueue 结构</h1><p><code>ConsumeQueue</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的关系如下：</p>\n<blockquote>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/03.png\" alt=\"ConsumeQueue、MappedFileQueue、MappedFile的关系\"><br><code>ConsumeQueue</code> : <code>MappedFileQueue</code> : <code>MappedFile</code> = 1 : 1 : N。</p>\n</blockquote>\n<p>反应到系统文件如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:consumequeue yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/consumequeue</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:consumequeue yunai$ <span class=\"built_in\">cd</span> TopicRead3/</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ ls -ls</div><div class=\"line\">total 0</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:52 0</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 1</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 2</div><div class=\"line\">0 drwxr-xr-x  3 yunai  staff  102  4 27 21:55 3</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:TopicRead3 yunai$ <span class=\"built_in\">cd</span> 0/</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:0 yunai$ ls -ls</div><div class=\"line\">total 11720</div><div class=\"line\">11720 -rw-r--r--  1 yunai  staff  6000000  4 27 21:55 00000000000000000000</div></pre></td></tr></table></figure>\n<hr>\n<p><code>ConsumeQueue</code>、<code>MappedFileQueue</code>、<code>MappedFile</code> 的定义如下：</p>\n<ul>\n<li><code>MappedFile</code> ：00000000000000000000等文件。</li>\n<li><code>MappedFileQueue</code> ：<code>MappedFile</code> 所在的文件夹，对 <code>MappedFile</code> 进行封装成文件队列，对上层提供可无限使用的文件容量。<ul>\n<li>每个 <code>MappedFile</code> 统一文件大小。</li>\n<li>文件命名方式：fileName[n] = fileName[n - 1] + mappedFileSize。在 <code>ConsumeQueue</code> 里默认为 6000000B。</li>\n</ul>\n</li>\n<li><code>ConsumeQueue</code> ：针对 <code>MappedFileQueue</code> 的封装使用。<ul>\n<li><code>Store : ConsumeQueue = ConcurrentHashMap&lt;String/* topic */, ConcurrentHashMap&lt;Integer/* queueId */, ConsumeQueue&gt;&gt;</code>。</li>\n</ul>\n</li>\n</ul>\n<p><code>ConsumeQueue</code> 存储在 <code>MappedFile</code> 的内容<strong>必须</strong>大小是 20B( <code>ConsumeQueue.CQ_STORE_UNIT_SIZE</code> )，有两种内容类型：</p>\n<ol>\n<li><code>MESSAGE_POSITION_INFO</code> ：消息位置信息。</li>\n<li><code>BLANK</code> : 文件前置空白占位。当历史 <code>Message</code> 被删除时，需要用 <code>BLANK</code>占位被删除的消息。</li>\n</ol>\n<p><code>MESSAGE_POSITION_INFO</code> 在 <code>ConsumeQueue</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">offset</td>\n<td style=\"text-align:left\">消息 <code>CommitLog</code> 存储位置</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">消息长度</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">tagsCode</td>\n<td style=\"text-align:left\">消息tagsCode</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<p><code>BLANK</code> 在 <code>ConsumeQueue</code> 存储结构：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">第几位</th>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">Integer.MAX_VALUE</td>\n<td style=\"text-align:left\">Int</td>\n<td style=\"text-align:left\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">Long</td>\n<td style=\"text-align:left\">8</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"3、ConsumeQueue-存储\"><a href=\"#3、ConsumeQueue-存储\" class=\"headerlink\" title=\"3、ConsumeQueue 存储\"></a>3、ConsumeQueue 存储</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/02.png\" alt=\"CommitLog重放ConsumeQueue图\"></p>\n<p>主要有两个组件：</p>\n<ul>\n<li><code>ReputMessageService</code> ：write ConsumeQueue。</li>\n<li><code>FlushConsumeQueueService</code> ：flush ConsumeQueue。</li>\n</ul>\n<h2 id=\"ReputMessageService\"><a href=\"#ReputMessageService\" class=\"headerlink\" title=\"ReputMessageService\"></a>ReputMessageService</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/12.png\" alt=\"ReputMessageService顺序图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReputMessageService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 开始重放消息的CommitLog物理位置</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> reputFromOffset = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getReputFromOffset</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">9</span>:         <span class=\"keyword\">return</span> reputFromOffset;</div><div class=\"line\"> <span class=\"number\">10</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setReputFromOffset</span><span class=\"params\">(<span class=\"keyword\">long</span> reputFromOffset)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.reputFromOffset = reputFromOffset;</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span> &amp;&amp; <span class=\"keyword\">this</span>.isCommitLogAvailable(); i++) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">20</span>:                 Thread.sleep(<span class=\"number\">100</span>);</div><div class=\"line\"> <span class=\"number\">21</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">23</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isCommitLogAvailable()) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:             log.warn(<span class=\"string\">\"shutdown ReputMessageService, but commitlog have not finish to be dispatched, CL: &#123;&#125; reputFromOffset: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">27</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset(), <span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">super</span>.shutdown();</div><div class=\"line\"> <span class=\"number\">31</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">32</span>: </div><div class=\"line\"> <span class=\"number\">33</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 34:      * 剩余需要重放消息字节数</div><div class=\"line\"> 35:      *</div><div class=\"line\"> 36:      * <span class=\"doctag\">@return</span> 字节数</div><div class=\"line\"> 37:      */</div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">behind</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">39</span>:         <span class=\"keyword\">return</span> DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset() - <span class=\"keyword\">this</span>.reputFromOffset;</div><div class=\"line\"> <span class=\"number\">40</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 43:      * 是否commitLog需要重放消息</div><div class=\"line\"> 44:      *</div><div class=\"line\"> 45:      * <span class=\"doctag\">@return</span> 是否</div><div class=\"line\"> 46:      */</div><div class=\"line\"> <span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCommitLogAvailable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getMaxOffset();</div><div class=\"line\"> <span class=\"number\">49</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">50</span>: </div><div class=\"line\"> <span class=\"number\">51</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReput</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">52</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">boolean</span> doNext = <span class=\"keyword\">true</span>; <span class=\"keyword\">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>: </div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"comment\">// TODO 疑问：这个是啥</span></div><div class=\"line\"> <span class=\"number\">55</span>:             <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().isDuplicationEnable() <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">56</span>:                 &amp;&amp; <span class=\"keyword\">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class=\"keyword\">this</span>.getConfirmOffset()) &#123;</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 获取从reputFromOffset开始的commitLog对应的MappeFile对应的MappedByteBuffer</span></div><div class=\"line\"> <span class=\"number\">61</span>:             SelectMappedBufferResult result = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.getData(reputFromOffset);</div><div class=\"line\"> <span class=\"number\">62</span>:             <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:                     <span class=\"keyword\">this</span>.reputFromOffset = result.getStartOffset();</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                     <span class=\"comment\">// 遍历MappedByteBuffer</span></div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> readSize = <span class=\"number\">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:                         <span class=\"comment\">// 生成重放消息重放调度请求</span></div><div class=\"line\"> <span class=\"number\">69</span>:                         DispatchRequest dispatchRequest = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">70</span>:                         <span class=\"keyword\">int</span> size = dispatchRequest.getMsgSize(); <span class=\"comment\">// 消息长度</span></div><div class=\"line\"> <span class=\"number\">71</span>:                         <span class=\"comment\">// 根据请求的结果处理</span></div><div class=\"line\"> <span class=\"number\">72</span>:                         <span class=\"keyword\">if</span> (dispatchRequest.isSuccess()) &#123; <span class=\"comment\">// 读取成功</span></div><div class=\"line\"> <span class=\"number\">73</span>:                             <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取Message</span></div><div class=\"line\"> <span class=\"number\">74</span>:                                 DefaultMessageStore.<span class=\"keyword\">this</span>.doDispatch(dispatchRequest);</div><div class=\"line\"> <span class=\"number\">75</span>:                                 <span class=\"comment\">// 通知有新消息</span></div><div class=\"line\"> <span class=\"number\">76</span>:                                 <span class=\"keyword\">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole()</div><div class=\"line\"> <span class=\"number\">77</span>:                                     &amp;&amp; DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.isLongPollingEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</div><div class=\"line\"> <span class=\"number\">79</span>:                                         dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class=\"number\">1</span>,</div><div class=\"line\"> <span class=\"number\">80</span>:                                         dispatchRequest.getTagsCode());</div><div class=\"line\"> <span class=\"number\">81</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:                                 <span class=\"comment\">// FIXED BUG By shijia</span></div><div class=\"line\"> <span class=\"number\">83</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset += size;</div><div class=\"line\"> <span class=\"number\">84</span>:                                 readSize += size;</div><div class=\"line\"> <span class=\"number\">85</span>:                                 <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">86</span>:                                 <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</div><div class=\"line\"> <span class=\"number\">87</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.storeStatsService</div><div class=\"line\"> <span class=\"number\">88</span>:                                         .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</div><div class=\"line\"> <span class=\"number\">89</span>:                                     DefaultMessageStore.<span class=\"keyword\">this</span>.storeStatsService</div><div class=\"line\"> <span class=\"number\">90</span>:                                         .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</div><div class=\"line\"> <span class=\"number\">91</span>:                                         .addAndGet(dispatchRequest.getMsgSize());</div><div class=\"line\"> <span class=\"number\">92</span>:                                 &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:                             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取到MappedFile文件尾</span></div><div class=\"line\"> <span class=\"number\">94</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset = DefaultMessageStore.<span class=\"keyword\">this</span>.commitLog.rollNextFile(<span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"> <span class=\"number\">95</span>:                                 readSize = result.getSize();</div><div class=\"line\"> <span class=\"number\">96</span>:                             &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:                         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!dispatchRequest.isSuccess()) &#123; <span class=\"comment\">// 读取失败</span></div><div class=\"line\"> <span class=\"number\">98</span>:                             <span class=\"keyword\">if</span> (size &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 读取到Message却不是Message</span></div><div class=\"line\"> <span class=\"number\">99</span>:                                 log.error(<span class=\"string\">\"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;\"</span>, reputFromOffset);</div><div class=\"line\"><span class=\"number\">100</span>:                                 <span class=\"keyword\">this</span>.reputFromOffset += size;</div><div class=\"line\"><span class=\"number\">101</span>:                             &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 读取到Blank却不是Blank</span></div><div class=\"line\"><span class=\"number\">102</span>:                                 doNext = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">103</span>:                                 <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                                     log.error(<span class=\"string\">\"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">105</span>:                                         <span class=\"keyword\">this</span>.reputFromOffset);</div><div class=\"line\"><span class=\"number\">106</span>: </div><div class=\"line\"><span class=\"number\">107</span>:                                     <span class=\"keyword\">this</span>.reputFromOffset += result.getSize() - readSize;</div><div class=\"line\"><span class=\"number\">108</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">109</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">110</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">111</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">112</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">113</span>:                     result.release();</div><div class=\"line\"><span class=\"number\">114</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">115</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">116</span>:                 doNext = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">117</span>:             &#125;</div><div class=\"line\"><span class=\"number\">118</span>:         &#125;</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">122</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">123</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">124</span>: </div><div class=\"line\"><span class=\"number\">125</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">127</span>:                 Thread.sleep(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">128</span>:                 <span class=\"keyword\">this</span>.doReput();</div><div class=\"line\"><span class=\"number\">129</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:                 DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">131</span>:             &#125;</div><div class=\"line\"><span class=\"number\">132</span>:         &#125;</div><div class=\"line\"><span class=\"number\">133</span>: </div><div class=\"line\"><span class=\"number\">134</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">135</span>:     &#125;</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">138</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">139</span>:         <span class=\"keyword\">return</span> ReputMessageService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">140</span>:     &#125;</div><div class=\"line\"><span class=\"number\">141</span>: </div><div class=\"line\"><span class=\"number\">142</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：重放消息线程服务。<ul>\n<li>该服务不断生成 消息位置信息 到 消费队列(ConsumeQueue)</li>\n<li>该服务不断生成 消息索引 到 索引文件(IndexFile)    </li>\n</ul>\n</li>\n<li><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/11.png\" alt=\"ReputMessageService用例图\"><ul>\n<li>第 61 行 ：获取 <code>reputFromOffset</code> 开始的 <code>CommitLog</code> 对应的 <code>MappedFile</code> 对应的 <code>MappedByteBuffer</code>。</li>\n<li>第 67 行 ：遍历 <code>MappedByteBuffer</code>。</li>\n<li>第 69 行 ：生成重放消息重放调度请求 (<code>DispatchRequest</code>) 。请求里主要包含一条消息 (<code>Message</code>) 或者 文件尾 (<code>BLANK</code>) 的基本信息。</li>\n<li>第 72 至 96 行 ：请求是有效请求，进行逻辑处理。<ul>\n<li>第 75 至 81 行 ：当 <code>Broker</code> 是主节点 &amp;&amp; <code>Broker</code> 开启的是长轮询，通知消费队列有新的消息。<code>NotifyMessageArrivingListener</code> 会 调用 <code>PullRequestHoldService#notifyMessageArriving(...)</code> 方法，详细解析见：<a href=\"#pullrequestholdservice\">PullRequestHoldService</a></li>\n</ul>\n</li>\n<li>第 73 至 92 行 ：请求对应的是 <code>Message</code>，进行调度，生成 <code>ConsumeQueue</code> 和 <code>IndexFile</code> 对应的内容。详细解析见：</li>\n<li>第 93 至 96 行 ：请求对应的是 <code>Blank</code>，即文件尾，跳转指向下一个 <code>MappedFile</code>。</li>\n<li>第 97 至 110 行 ：请求是无效请求。出现该情况，基本是一个<strong>BUG</strong>。</li>\n</ul>\n</li>\n<li>第 127 至 128 行 ：每 1ms 循环执行重放逻辑。</li>\n<li>第 18 至 30 行 ：<code>shutdown</code>时，多次 <code>sleep(100)</code> 直到 <code>CommitLog</code> 回放到最新位置。恩，如果未回放完，会输出警告日志。</li>\n</ul>\n<h3 id=\"DefaultMessageStore-doDispatch-…\"><a href=\"#DefaultMessageStore-doDispatch-…\" class=\"headerlink\" title=\"DefaultMessageStore#doDispatch(…)\"></a>DefaultMessageStore#doDispatch(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 执行调度请求</div><div class=\"line\"> 3:  * 1. 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</div><div class=\"line\"> 4:  * 2. 建立 索引信息 到 IndexFile</div><div class=\"line\"> 5:  *</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> req 调度请求</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(DispatchRequest req)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"comment\">// 非事务消息 或 事务提交消息 建立 消息位置信息 到 ConsumeQueue</span></div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> tranType = MessageSysFlag.getTransactionValue(req.getSysFlag());</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">switch</span> (tranType) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</div><div class=\"line\"><span class=\"number\">14</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.putMessagePositionInfo(req.getTopic(), req.getQueueId(), req.getCommitLogOffset(), req.getMsgSize(),</div><div class=\"line\"><span class=\"number\">15</span>:                 req.getTagsCode(), req.getStoreTimestamp(), req.getConsumeQueueOffset());</div><div class=\"line\"><span class=\"number\">16</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"comment\">// 建立 索引信息 到 IndexFile</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">if</span> (DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().isMessageIndexEnable()) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:         DefaultMessageStore.<span class=\"keyword\">this</span>.indexService.buildIndex(req);</div><div class=\"line\"><span class=\"number\">24</span>:     &#125;</div><div class=\"line\"><span class=\"number\">25</span>: &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>: <span class=\"comment\">/**</span></div><div class=\"line\">28:  * 建立 消息位置信息 到 ConsumeQueue</div><div class=\"line\">29:  *</div><div class=\"line\">30:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">31:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">32:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\">33:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\">35:  * <span class=\"doctag\">@param</span> storeTimestamp 存储时间</div><div class=\"line\">36:  * <span class=\"doctag\">@param</span> logicOffset 队列位置</div><div class=\"line\">37:  */</div><div class=\"line\"><span class=\"number\">38</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putMessagePositionInfo</span><span class=\"params\">(String topic, <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> tagsCode, <span class=\"keyword\">long</span> storeTimestamp,</span></span></div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">long</span> logicOffset) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:     ConsumeQueue cq = <span class=\"keyword\">this</span>.findConsumeQueue(topic, queueId);</div><div class=\"line\"><span class=\"number\">41</span>:     cq.putMessagePositionInfoWrapper(offset, size, tagsCode, storeTimestamp, logicOffset);</div><div class=\"line\"><span class=\"number\">42</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ConsumeQueue-putMessagePositionInfoWrapper-…\"><a href=\"#ConsumeQueue-putMessagePositionInfoWrapper-…\" class=\"headerlink\" title=\"ConsumeQueue#putMessagePositionInfoWrapper(…)\"></a>ConsumeQueue#putMessagePositionInfoWrapper(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * 添加位置信息封装</div><div class=\"line\">  3:  *</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> storeTimestamp 消息存储时间</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> logicOffset 队列位置</div><div class=\"line\">  9:  */</div><div class=\"line\"> <span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putMessagePositionInfoWrapper</span><span class=\"params\">(<span class=\"keyword\">long</span> offset, <span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> tagsCode, <span class=\"keyword\">long</span> storeTimestamp,</span></span></div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"keyword\">long</span> logicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxRetries = <span class=\"number\">30</span>;</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">boolean</span> canWrite = <span class=\"keyword\">this</span>.defaultMessageStore.getRunningFlags().isWriteable();</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 多次循环写，直到成功</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxRetries &amp;&amp; canWrite; i++) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"comment\">// 调用添加位置信息</span></div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.putMessagePositionInfo(offset, size, tagsCode, logicOffset);</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">if</span> (result) &#123;</div><div class=\"line\"> <span class=\"number\">19</span>:             <span class=\"comment\">// 添加成功，使用消息存储时间 作为 存储check point。</span></div><div class=\"line\"> <span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(storeTimestamp);</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">22</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">23</span>:             <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"> <span class=\"number\">24</span>:             log.warn(<span class=\"string\">\"[BUG]put commit log position info to \"</span> + topic + <span class=\"string\">\":\"</span> + queueId + <span class=\"string\">\" \"</span> + offset</div><div class=\"line\"> <span class=\"number\">25</span>:                 + <span class=\"string\">\" failed, retry \"</span> + i + <span class=\"string\">\" times\"</span>);</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">28</span>:                 Thread.sleep(<span class=\"number\">1000</span>);</div><div class=\"line\"> <span class=\"number\">29</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:                 log.warn(<span class=\"string\">\"\"</span>, e);</div><div class=\"line\"> <span class=\"number\">31</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">32</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">33</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me 设置异常不可写入</span></div><div class=\"line\"> <span class=\"number\">36</span>:     log.error(<span class=\"string\">\"[BUG]consume queue can not write, &#123;&#125; &#123;&#125;\"</span>, <span class=\"keyword\">this</span>.topic, <span class=\"keyword\">this</span>.queueId);</div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">this</span>.defaultMessageStore.getRunningFlags().makeLogicsQueueError();</div><div class=\"line\"> <span class=\"number\">38</span>: &#125;</div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 41:  * 添加位置信息，并返回添加是否成功</div><div class=\"line\"> 42:  *</div><div class=\"line\"> 43:  * <span class=\"doctag\">@param</span> offset commitLog存储位置</div><div class=\"line\"> 44:  * <span class=\"doctag\">@param</span> size 消息长度</div><div class=\"line\"> 45:  * <span class=\"doctag\">@param</span> tagsCode 消息tagsCode</div><div class=\"line\"> 46:  * <span class=\"doctag\">@param</span> cqOffset 队列位置</div><div class=\"line\"> 47:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\"> 48:  */</div><div class=\"line\"> <span class=\"number\">49</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putMessagePositionInfo</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> tagsCode,</span></span></div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> cqOffset) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:     <span class=\"comment\">// 如果已经重放过，直接返回成功</span></div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"keyword\">if</span> (offset &lt;= <span class=\"keyword\">this</span>.maxPhysicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"comment\">// 写入位置信息到byteBuffer</span></div><div class=\"line\"> <span class=\"number\">56</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.flip();</div><div class=\"line\"> <span class=\"number\">57</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putLong(offset);</div><div class=\"line\"> <span class=\"number\">59</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putInt(size);</div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"keyword\">this</span>.byteBufferIndex.putLong(tagsCode);</div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"comment\">// 计算consumeQueue存储位置，并获得对应的MappedFile</span></div><div class=\"line\"> <span class=\"number\">62</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</div><div class=\"line\"> <span class=\"number\">63</span>:     MappedFile mappedFile = <span class=\"keyword\">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">64</span>:     <span class=\"keyword\">if</span> (mappedFile != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:         <span class=\"comment\">// 当是ConsumeQueue第一个MappedFile &amp;&amp; 队列位置非第一个 &amp;&amp; MappedFile未写入内容，则填充前置空白占位</span></div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">if</span> (mappedFile.isFirstCreateInQueue() &amp;&amp; cqOffset != <span class=\"number\">0</span> &amp;&amp; mappedFile.getWrotePosition() == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// TODO 疑问：为啥这个操作。目前能够想象到的是，一些老的消息很久没发送，突然发送，这个时候刚好满足。</span></div><div class=\"line\"> <span class=\"number\">67</span>:             <span class=\"keyword\">this</span>.minLogicOffset = expectLogicOffset;</div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">this</span>.mappedFileQueue.setFlushedWhere(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">69</span>:             <span class=\"keyword\">this</span>.mappedFileQueue.setCommittedWhere(expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">70</span>:             <span class=\"keyword\">this</span>.fillPreBlank(mappedFile, expectLogicOffset);</div><div class=\"line\"> <span class=\"number\">71</span>:             log.info(<span class=\"string\">\"fill pre blank space \"</span> + mappedFile.getFileName() + <span class=\"string\">\" \"</span> + expectLogicOffset + <span class=\"string\">\" \"</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 + mappedFile.getWrotePosition());</div><div class=\"line\"> <span class=\"number\">73</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">74</span>:         <span class=\"comment\">// 校验consumeQueue存储位置是否合法。TODO 如果不合法，继续写入会不会有问题？</span></div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">if</span> (cqOffset != <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">long</span> currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset();</div><div class=\"line\"> <span class=\"number\">77</span>:             <span class=\"keyword\">if</span> (expectLogicOffset != currentLogicOffset) &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:                 LOG_ERROR.warn(</div><div class=\"line\"> <span class=\"number\">79</span>:                     <span class=\"string\">\"[BUG]logic queue order maybe wrong, expectLogicOffset: &#123;&#125; currentLogicOffset: &#123;&#125; Topic: &#123;&#125; QID: &#123;&#125; Diff: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">80</span>:                     expectLogicOffset,</div><div class=\"line\"> <span class=\"number\">81</span>:                     currentLogicOffset,</div><div class=\"line\"> <span class=\"number\">82</span>:                     <span class=\"keyword\">this</span>.topic,</div><div class=\"line\"> <span class=\"number\">83</span>:                     <span class=\"keyword\">this</span>.queueId,</div><div class=\"line\"> <span class=\"number\">84</span>:                     expectLogicOffset - currentLogicOffset</div><div class=\"line\"> <span class=\"number\">85</span>:                 );</div><div class=\"line\"> <span class=\"number\">86</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">87</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"comment\">// 设置commitLog重放消息到ConsumeQueue位置。</span></div><div class=\"line\"> <span class=\"number\">89</span>:         <span class=\"keyword\">this</span>.maxPhysicOffset = offset;</div><div class=\"line\"> <span class=\"number\">90</span>:         <span class=\"comment\">// 插入mappedFile</span></div><div class=\"line\"> <span class=\"number\">91</span>:         <span class=\"keyword\">return</span> mappedFile.appendMessage(<span class=\"keyword\">this</span>.byteBufferIndex.array());</div><div class=\"line\"> <span class=\"number\">92</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">94</span>: &#125;</div><div class=\"line\"> <span class=\"number\">95</span>: </div><div class=\"line\"> <span class=\"number\">96</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 97:  * 填充前置空白占位</div><div class=\"line\"> 98:  *</div><div class=\"line\"> 99:  * <span class=\"doctag\">@param</span> mappedFile MappedFile</div><div class=\"line\">100:  * <span class=\"doctag\">@param</span> untilWhere consumeQueue存储位置</div><div class=\"line\">101:  */</div><div class=\"line\"><span class=\"number\">102</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fillPreBlank</span><span class=\"params\">(<span class=\"keyword\">final</span> MappedFile mappedFile, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> untilWhere)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"comment\">// 写入前置空白占位到byteBuffer</span></div><div class=\"line\"><span class=\"number\">104</span>:     ByteBuffer byteBuffer = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">105</span>:     byteBuffer.putLong(<span class=\"number\">0L</span>);</div><div class=\"line\"><span class=\"number\">106</span>:     byteBuffer.putInt(Integer.MAX_VALUE);</div><div class=\"line\"><span class=\"number\">107</span>:     byteBuffer.putLong(<span class=\"number\">0L</span>);</div><div class=\"line\"><span class=\"number\">108</span>:     <span class=\"comment\">// 循环填空</span></div><div class=\"line\"><span class=\"number\">109</span>:     <span class=\"keyword\">int</span> until = (<span class=\"keyword\">int</span>) (untilWhere % <span class=\"keyword\">this</span>.mappedFileQueue.getMappedFileSize());</div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; until; i += CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"><span class=\"number\">111</span>:         mappedFile.appendMessage(byteBuffer.array());</div><div class=\"line\"><span class=\"number\">112</span>:     &#125;</div><div class=\"line\"><span class=\"number\">113</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#putMessagePositionInfoWrapper(...)</code> 说明 ：添加位置信息到 <code>ConsumeQueue</code> 的封装，实际需要调用 <code>#putMessagePositionInfo(...)</code> 方法。<ul>\n<li>第 13 行 ：判断 <code>ConsumeQueue</code> 是否允许写入。当发生Bug时，不允许写入。</li>\n<li>第 17 行 ：调用 <code>#putMessagePositionInfo(...)</code> 方法，添加位置信息。</li>\n<li>第 18 至 21 行 ：添加成功，使用消息存储时间 作为 存储检查点。<code>StoreCheckpoint</code> 的详细解析见：<a href=\"http://www.yunai.me/RocketMQ/store-init-and-shutdown/\">Store初始化与关闭</a>。</li>\n<li>第 22 至 32 行 ：添加失败，目前基本可以认为是BUG。</li>\n<li>第 35 至 37 行 ：写入失败时，标记 <code>ConsumeQueue</code> 写入异常，不允许继续写入。</li>\n</ul>\n</li>\n<li><code>#putMessagePositionInfo(...)</code> 说明 ：添加位置信息到 <code>ConsumeQueue</code>，并返回添加是否成功。<ul>\n<li>第 51 至 54 行 ：如果 <code>offset</code>(存储位置) 小于等于  <code>maxPhysicOffset</code>(<code>CommitLog</code> 消息重放到 <code>ConsumeQueue</code> 最大的 <code>CommitLog</code> 存储位置)，表示已经重放过，此时，不再重复写入，直接返回写入成功。</li>\n<li>第 55 至 60 行 ：写 位置信息到byteBuffer。</li>\n<li>第 62 至 63 行 ：计算 <code>ConsumeQueue</code>存储位置，并获得对应的MappedFile。</li>\n<li>第 65 至 73 行 ：当 <code>MappedFile</code> 是 <code>ConsumeQueue</code> 当前第一个文件 &amp;&amp; <code>MappedFile</code> 未写入内容 &amp;&amp; 重放消息队列位置大于0，则需要进行 <code>MappedFile</code> 填充前置  <code>BLANK</code>。<ul>\n<li><em>这块比较有疑问，什么场景下会需要。猜测产生的原因：一个 <code>Topic</code> 长期无消息产生，突然N天后进行发送，<code>Topic</code> 对应的历史消息以及和消费队列数据已经被清理，新生成的<code>MappedFile</code>需要前置占位。</em></li>\n</ul>\n</li>\n<li>第 74 至 87 行 ：校验 <code>ConsumeQueue</code> 存储位置是否合法，不合法则输出日志。<ul>\n<li><em>这块比较有疑问，如果计算出来的存储位置不合法，不返回添加失败，继续进行添加位置信息，会不会有问题？？？</em></li>\n</ul>\n</li>\n<li>第 89 行 ：设置 <code>CommitLog</code> 重放消息到 <code>ConsumeQueue</code> 的最大位置。</li>\n<li>第 91 行 ：插入消息位置到 <code>MappedFile</code>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FlushConsumeQueueService\"><a href=\"#FlushConsumeQueueService\" class=\"headerlink\" title=\"FlushConsumeQueueService\"></a>FlushConsumeQueueService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlushConsumeQueueService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RETRY_TIMES_OVER = <span class=\"number\">3</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 最后flush时间戳</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastFlushTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doFlush</span><span class=\"params\">(<span class=\"keyword\">int</span> retryTimes)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">int</span> flushConsumeQueueLeastPages = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushConsumeQueueLeastPages();</div><div class=\"line\"><span class=\"number\">10</span>: </div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"comment\">// retryTimes == RETRY_TIMES_OVER时，进行强制flush。主要用于shutdown时。</span></div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">if</span> (retryTimes == RETRY_TIMES_OVER) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             flushConsumeQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">14</span>:         &#125;</div><div class=\"line\"><span class=\"number\">15</span>:         <span class=\"comment\">// 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush</span></div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">long</span> logicsMsgTimestamp = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">int</span> flushConsumeQueueThoroughInterval = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval();</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">long</span> currentTimeMillis = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (currentTimeMillis &gt;= (<span class=\"keyword\">this</span>.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">this</span>.lastFlushTimestamp = currentTimeMillis;</div><div class=\"line\"><span class=\"number\">21</span>:             flushConsumeQueueLeastPages = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">22</span>:             logicsMsgTimestamp = DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().getLogicsMsgTimestamp();</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// flush消费队列</span></div><div class=\"line\"><span class=\"number\">25</span>:         ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class=\"keyword\">this</span>.consumeQueueTable;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">for</span> (ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">for</span> (ConsumeQueue cq : maps.values()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                 <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                     result = cq.flush(flushConsumeQueueLeastPages);</div><div class=\"line\"><span class=\"number\">31</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"comment\">// flush 存储 check point</span></div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == flushConsumeQueueLeastPages) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">if</span> (logicsMsgTimestamp &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                 DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp);</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>:             DefaultMessageStore.<span class=\"keyword\">this</span>.getStoreCheckpoint().flush();</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">45</span>: </div><div class=\"line\"><span class=\"number\">46</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">int</span> interval = DefaultMessageStore.<span class=\"keyword\">this</span>.getMessageStoreConfig().getFlushIntervalConsumeQueue();</div><div class=\"line\"><span class=\"number\">49</span>:                 <span class=\"keyword\">this</span>.waitForRunning(interval);</div><div class=\"line\"><span class=\"number\">50</span>:                 <span class=\"keyword\">this</span>.doFlush(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">51</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:                 DefaultMessageStore.log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"><span class=\"number\">53</span>:             &#125;</div><div class=\"line\"><span class=\"number\">54</span>:         &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:         <span class=\"keyword\">this</span>.doFlush(RETRY_TIMES_OVER);</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:         DefaultMessageStore.log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">59</span>:     &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">62</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">63</span>:         <span class=\"keyword\">return</span> FlushConsumeQueueService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">64</span>:     &#125;</div><div class=\"line\"><span class=\"number\">65</span>: </div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getJointime</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">68</span>:         <span class=\"keyword\">return</span> <span class=\"number\">1000</span> * <span class=\"number\">60</span>;</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：flush <code>ConsumeQueue</code>(消费队列) 线程服务。</li>\n<li>第 11 至 14 行 ：当 <code>retryTimes == RETRY_TIMES_OVER</code> 时，进行强制flush。用于 <code>shutdown</code> 时。</li>\n<li>第 15 至 23 行 ：每 flushConsumeQueueThoroughInterval 周期，执行一次 flush 。因为不是每次循环到都能满足 flushConsumeQueueLeastPages 大小，因此，需要一定周期进行一次强制 flush 。当然，不能每次循环都去执行强制 flush，这样性能较差。</li>\n<li>第 24 至 33 行 ：flush <code>ConsumeQueue</code>(消费队列)。<ul>\n<li>flush 逻辑：<a href=\"http://www.yunai.me/RocketMQ/message-store/#MappedFile-落盘\">MappedFile#落盘</a>。</li>\n</ul>\n</li>\n<li>第 34 至 40 行 ：flush <code>StoreCheckpoint</code>。<code>StoreCheckpoint</code> 的详细解析见：<a href=\"http://www.yunai.me/RocketMQ/store-init-and-shutdown/\">Store初始化与关闭</a>。</li>\n<li>第 43 至 59 行 ：每 1000ms 执行一次 <code>flush</code>。如果 wakeup() 时，则会立即进行一次 <code>flush</code>。目前，暂时不存在 wakeup() 的调用。</li>\n</ul>\n<h1 id=\"4、Broker-提供-拉取消息-接口\"><a href=\"#4、Broker-提供-拉取消息-接口\" class=\"headerlink\" title=\"4、Broker 提供[拉取消息]接口\"></a>4、Broker 提供[拉取消息]接口</h1><h2 id=\"PullMessageRequestHeader\"><a href=\"#PullMessageRequestHeader\" class=\"headerlink\" title=\"PullMessageRequestHeader\"></a>PullMessageRequestHeader</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullMessageRequestHeader</span> <span class=\"keyword\">implements</span> <span class=\"title\">CommandCustomHeader</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 消费者分组</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> String consumerGroup;</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 8:      * Topic</div><div class=\"line\"> 9:      */</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">private</span> String topic;</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">13:      * 队列编号</div><div class=\"line\">14:      */</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">private</span> Integer queueId;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">18:      * 队列开始位置</div><div class=\"line\">19:      */</div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">private</span> Long queueOffset;</div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">23:      * 消息数量</div><div class=\"line\">24:      */</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">private</span> Integer maxMsgNums;</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">28:      * 系统标识</div><div class=\"line\">29:      */</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">private</span> Integer sysFlag;</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">33:      * 提交消费进度位置</div><div class=\"line\">34:      */</div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">private</span> Long commitOffset;</div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">38:      * 挂起超时时间</div><div class=\"line\">39:      */</div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">private</span> Long suspendTimeoutMillis;</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">43:      * 订阅表达式</div><div class=\"line\">44:      */</div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"meta\">@CFNullable</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">private</span> String subscription;</div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">48:      * 订阅版本号</div><div class=\"line\">49:      */</div><div class=\"line\"><span class=\"number\">50</span>:     <span class=\"meta\">@CFNotNull</span></div><div class=\"line\"><span class=\"number\">51</span>:     <span class=\"keyword\">private</span> Long subVersion;</div><div class=\"line\"><span class=\"number\">52</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：拉取消息请求Header</li>\n<li>topic +  queueId + queueOffset + maxMsgNums</li>\n<li>sysFlag ：系统标识。<ul>\n<li>第 0 位 <code>FLAG_COMMIT_OFFSET</code> ：标记请求提交消费进度位置，和 <code>commitOffset</code> 配合。</li>\n<li>第 1 位 <code>FLAG_SUSPEND</code> ：标记请求是否挂起请求，和 <code>suspendTimeoutMillis</code> 配合。当拉取不到消息时， <code>Broker</code> 会挂起请求，直到有消息。最大挂起时间：<code>suspendTimeoutMillis</code> 毫秒。</li>\n<li>第 2 位 <code>FLAG_SUBSCRIPTION</code> ：是否过滤订阅表达式，和 <code>subscription</code> 配置。</li>\n</ul>\n</li>\n<li>subVersion ：订阅版本号。请求时，如果版本号不对，则无法拉取到消息，需要重新获取订阅信息，使用最新的订阅版本号。</li>\n</ul>\n<h2 id=\"PullMessageProcessor-processRequest-…\"><a href=\"#PullMessageProcessor-processRequest-…\" class=\"headerlink\" title=\"PullMessageProcessor#processRequest(…)\"></a>PullMessageProcessor#processRequest(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">processRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel channel, RemotingCommand request, <span class=\"keyword\">boolean</span> brokerAllowSuspend)</span></span></div><div class=\"line\">  2:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\">  <span class=\"number\">3</span>:     RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> PullMessageRequestHeader requestHeader =</div><div class=\"line\">  <span class=\"number\">6</span>:         (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     response.setOpaque(request.getOpaque());</div><div class=\"line\">  <span class=\"number\">9</span>: </div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (LOG.isDebugEnabled()) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>:         LOG.debug(<span class=\"string\">\"receive PullMessage request command, &#123;&#125;\"</span>, request);</div><div class=\"line\"> <span class=\"number\">12</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">13</span>: </div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 校验 broker 是否可读</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (!PermName.isReadable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">17</span>:         response.setRemark(String.format(<span class=\"string\">\"the broker[%s] pulling message is forbidden\"</span>, <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1()));</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">19</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">20</span>: </div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"comment\">// 校验 consumer分组配置 是否存在</span></div><div class=\"line\"> <span class=\"number\">22</span>:     SubscriptionGroupConfig subscriptionGroupConfig = <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">24</span>:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">25</span>:         response.setRemark(String.format(<span class=\"string\">\"subscription group [%s] does not exist, %s\"</span>, requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)));</div><div class=\"line\"> <span class=\"number\">26</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">27</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"comment\">// 校验 consumer分组配置 是否可消费</span></div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">if</span> (!subscriptionGroupConfig.isConsumeEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">31</span>:         response.setRemark(<span class=\"string\">\"subscription group no permission, \"</span> + requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">32</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">33</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否挂起请求，当没有消息时</span></div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否提交消费进度</span></div><div class=\"line\"> <span class=\"number\">37</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); <span class=\"comment\">// 是否过滤订阅表达式(subscription)</span></div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class=\"number\">0</span>; <span class=\"comment\">// 挂起请求超时时长</span></div><div class=\"line\"> <span class=\"number\">39</span>: </div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"comment\">// 校验 topic配置 存在</span></div><div class=\"line\"> <span class=\"number\">41</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:         LOG.error(<span class=\"string\">\"The topic &#123;&#125; not exist, consumer: &#123;&#125; \"</span>, requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel));</div><div class=\"line\"> <span class=\"number\">44</span>:         response.setCode(ResponseCode.TOPIC_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">45</span>:         response.setRemark(String.format(<span class=\"string\">\"topic[%s] not exist, apply first please! %s\"</span>, requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)));</div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">47</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">48</span>:     <span class=\"comment\">// 校验 topic配置 权限可读</span></div><div class=\"line\"> <span class=\"number\">49</span>:     <span class=\"keyword\">if</span> (!PermName.isReadable(topicConfig.getPerm())) &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">51</span>:         response.setRemark(<span class=\"string\">\"the topic[\"</span> + requestHeader.getTopic() + <span class=\"string\">\"] pulling message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">52</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">53</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">54</span>:     <span class=\"comment\">// 校验 读取队列 在 topic配置 队列范围内</span></div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"keyword\">if</span> (requestHeader.getQueueId() &lt; <span class=\"number\">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:         String errorInfo = String.format(<span class=\"string\">\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\"</span>,</div><div class=\"line\"> <span class=\"number\">57</span>:                 requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress());</div><div class=\"line\"> <span class=\"number\">58</span>:         LOG.warn(errorInfo);</div><div class=\"line\"> <span class=\"number\">59</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">60</span>:         response.setRemark(errorInfo);</div><div class=\"line\"> <span class=\"number\">61</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">62</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">63</span>: </div><div class=\"line\"> <span class=\"number\">64</span>:     <span class=\"comment\">// 校验 订阅关系</span></div><div class=\"line\"> <span class=\"number\">65</span>:     SubscriptionData subscriptionData;</div><div class=\"line\"> <span class=\"number\">66</span>:     <span class=\"keyword\">if</span> (hasSubscriptionFlag) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">68</span>:             subscriptionData = FilterAPI.buildSubscriptionData(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"> <span class=\"number\">69</span>:                 requestHeader.getSubscription());</div><div class=\"line\"> <span class=\"number\">70</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">71</span>:             LOG.warn(<span class=\"string\">\"Parse the consumer's subscription[&#123;&#125;] failed, group: &#123;&#125;\"</span>, requestHeader.getSubscription(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">72</span>:                     requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">73</span>:             response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED);</div><div class=\"line\"> <span class=\"number\">74</span>:             response.setRemark(<span class=\"string\">\"parse the consumer's subscription failed\"</span>);</div><div class=\"line\"> <span class=\"number\">75</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">76</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">77</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">78</span>:         <span class=\"comment\">// 校验 消费分组信息 是否存在</span></div><div class=\"line\"> <span class=\"number\">79</span>:         ConsumerGroupInfo consumerGroupInfo = <span class=\"keyword\">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">80</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == consumerGroupInfo) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:             LOG.warn(<span class=\"string\">\"The consumer's group info not exist, group: &#123;&#125;\"</span>, requestHeader.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">82</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">83</span>:             response.setRemark(<span class=\"string\">\"the consumer's group info not exist\"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</div><div class=\"line\"> <span class=\"number\">84</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>:         <span class=\"comment\">// 校验 消费分组信息 消息模型是否匹配</span></div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"keyword\">if</span> (!subscriptionGroupConfig.isConsumeBroadcastEnable() <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">88</span>:             &amp;&amp; consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">90</span>:             response.setRemark(<span class=\"string\">\"the consumer group[\"</span> + requestHeader.getConsumerGroup() + <span class=\"string\">\"] can not consume by broadcast way\"</span>);</div><div class=\"line\"> <span class=\"number\">91</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">92</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">93</span>: </div><div class=\"line\"> <span class=\"number\">94</span>:         <span class=\"comment\">// 校验 订阅信息 是否存在</span></div><div class=\"line\"> <span class=\"number\">95</span>:         subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">96</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">97</span>:             LOG.warn(<span class=\"string\">\"The consumer's subscription not exist, group: &#123;&#125;, topic:&#123;&#125;\"</span>, requestHeader.getConsumerGroup(), requestHeader.getTopic());</div><div class=\"line\"> <span class=\"number\">98</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">99</span>:             response.setRemark(<span class=\"string\">\"the consumer's subscription not exist\"</span> + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC));</div><div class=\"line\"><span class=\"number\">100</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">101</span>:         &#125;</div><div class=\"line\"><span class=\"number\">102</span>:         <span class=\"comment\">// 校验 订阅信息版本 是否合法</span></div><div class=\"line\"><span class=\"number\">103</span>:         <span class=\"keyword\">if</span> (subscriptionData.getSubVersion() &lt; requestHeader.getSubVersion()) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:             LOG.warn(<span class=\"string\">\"The broker's subscription is not latest, group: &#123;&#125; &#123;&#125;\"</span>, requestHeader.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">105</span>:                     subscriptionData.getSubString());</div><div class=\"line\"><span class=\"number\">106</span>:             response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST);</div><div class=\"line\"><span class=\"number\">107</span>:             response.setRemark(<span class=\"string\">\"the consumer's subscription not latest\"</span>);</div><div class=\"line\"><span class=\"number\">108</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">109</span>:         &#125;</div><div class=\"line\"><span class=\"number\">110</span>:     &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:     <span class=\"comment\">// 获取消息</span></div><div class=\"line\"><span class=\"number\">113</span>:     <span class=\"keyword\">final</span> GetMessageResult getMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">114</span>:             requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), subscriptionData);</div><div class=\"line\"><span class=\"number\">115</span>:     <span class=\"keyword\">if</span> (getMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">116</span>:         response.setRemark(getMessageResult.getStatus().name());</div><div class=\"line\"><span class=\"number\">117</span>:         responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">118</span>:         responseHeader.setMinOffset(getMessageResult.getMinOffset());</div><div class=\"line\"><span class=\"number\">119</span>:         responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:         <span class=\"comment\">// TODO 待读</span></div><div class=\"line\"><span class=\"number\">122</span>:         <span class=\"comment\">// 计算建议读取brokerId</span></div><div class=\"line\"><span class=\"number\">123</span>:         <span class=\"keyword\">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</div><div class=\"line\"><span class=\"number\">124</span>:             responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</div><div class=\"line\"><span class=\"number\">125</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">126</span>:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">127</span>:         &#125;</div><div class=\"line\"><span class=\"number\">128</span>: </div><div class=\"line\"><span class=\"number\">129</span>:         <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</div><div class=\"line\"><span class=\"number\">130</span>:             <span class=\"keyword\">case</span> ASYNC_MASTER:</div><div class=\"line\"><span class=\"number\">131</span>:             <span class=\"keyword\">case</span> SYNC_MASTER:</div><div class=\"line\"><span class=\"number\">132</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">133</span>:             <span class=\"keyword\">case</span> SLAVE:</div><div class=\"line\"><span class=\"number\">134</span>:                 <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123; <span class=\"comment\">// 从节点不允许读取，告诉consumer读取主节点。</span></div><div class=\"line\"><span class=\"number\">135</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">136</span>:                     responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">137</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">139</span>:         &#125;</div><div class=\"line\"><span class=\"number\">140</span>: </div><div class=\"line\"><span class=\"number\">141</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:             <span class=\"comment\">// consume too slow ,redirect to another machine</span></div><div class=\"line\"><span class=\"number\">143</span>:             <span class=\"keyword\">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</div><div class=\"line\"><span class=\"number\">144</span>:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</div><div class=\"line\"><span class=\"number\">145</span>:             &#125;</div><div class=\"line\"><span class=\"number\">146</span>:             <span class=\"comment\">// consume ok</span></div><div class=\"line\"><span class=\"number\">147</span>:             <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</div><div class=\"line\"><span class=\"number\">149</span>:             &#125;</div><div class=\"line\"><span class=\"number\">150</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">151</span>:             responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</div><div class=\"line\"><span class=\"number\">152</span>:         &#125;</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:         <span class=\"keyword\">switch</span> (getMessageResult.getStatus()) &#123;</div><div class=\"line\"><span class=\"number\">155</span>:             <span class=\"keyword\">case</span> FOUND:</div><div class=\"line\"><span class=\"number\">156</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">157</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">158</span>:             <span class=\"keyword\">case</span> MESSAGE_WAS_REMOVING:</div><div class=\"line\"><span class=\"number\">159</span>:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">160</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">161</span>:             <span class=\"keyword\">case</span> NO_MATCHED_LOGIC_QUEUE:</div><div class=\"line\"><span class=\"number\">162</span>:             <span class=\"keyword\">case</span> NO_MESSAGE_IN_QUEUE:</div><div class=\"line\"><span class=\"number\">163</span>:                 <span class=\"keyword\">if</span> (<span class=\"number\">0</span> != requestHeader.getQueueOffset()) &#123;</div><div class=\"line\"><span class=\"number\">164</span>:                     response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:                     <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"><span class=\"number\">167</span>:                     LOG.info(<span class=\"string\">\"the broker store no queue data, fix the request offset &#123;&#125; to &#123;&#125;, Topic: &#123;&#125; QueueId: &#123;&#125; Consumer Group: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">168</span>:                         requestHeader.getQueueOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">169</span>:                         getMessageResult.getNextBeginOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">170</span>:                         requestHeader.getTopic(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">171</span>:                         requestHeader.getQueueId(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">172</span>:                         requestHeader.getConsumerGroup()<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">173</span>:                     );</div><div class=\"line\"><span class=\"number\">174</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:                     response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">176</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">177</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">178</span>:             <span class=\"keyword\">case</span> NO_MATCHED_MESSAGE:</div><div class=\"line\"><span class=\"number\">179</span>:                 response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">180</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">181</span>:             <span class=\"keyword\">case</span> OFFSET_FOUND_NULL:</div><div class=\"line\"><span class=\"number\">182</span>:                 response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">183</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">184</span>:             <span class=\"keyword\">case</span> OFFSET_OVERFLOW_BADLY:</div><div class=\"line\"><span class=\"number\">185</span>:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">186</span>:                 <span class=\"comment\">// <span class=\"doctag\">XXX:</span> warn and notify me</span></div><div class=\"line\"><span class=\"number\">187</span>:                 LOG.info(<span class=\"string\">\"The request offset:&#123;&#125; over flow badly, broker max offset:&#123;&#125; , consumer: &#123;&#125;\"</span>, requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</div><div class=\"line\"><span class=\"number\">188</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">189</span>:             <span class=\"keyword\">case</span> OFFSET_OVERFLOW_ONE:</div><div class=\"line\"><span class=\"number\">190</span>:                 response.setCode(ResponseCode.PULL_NOT_FOUND);</div><div class=\"line\"><span class=\"number\">191</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">192</span>:             <span class=\"keyword\">case</span> OFFSET_TOO_SMALL:</div><div class=\"line\"><span class=\"number\">193</span>:                 response.setCode(ResponseCode.PULL_OFFSET_MOVED);</div><div class=\"line\"><span class=\"number\">194</span>:                 LOG.info(<span class=\"string\">\"The request offset is too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">195</span>:                     requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</div><div class=\"line\"><span class=\"number\">196</span>:                     getMessageResult.getMinOffset(), channel.remoteAddress());</div><div class=\"line\"><span class=\"number\">197</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">198</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">199</span>:                 <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">200</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">201</span>:         &#125;</div><div class=\"line\"><span class=\"number\">202</span>: </div><div class=\"line\"><span class=\"number\">203</span>:         <span class=\"comment\">// hook：before</span></div><div class=\"line\"><span class=\"number\">204</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasConsumeMessageHook()) &#123;</div><div class=\"line\"><span class=\"number\">205</span>:             ConsumeMessageContext context = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"><span class=\"number\">206</span>:             context.setConsumerGroup(requestHeader.getConsumerGroup());</div><div class=\"line\"><span class=\"number\">207</span>:             context.setTopic(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">208</span>:             context.setQueueId(requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">209</span>: </div><div class=\"line\"><span class=\"number\">210</span>:             String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER);</div><div class=\"line\"><span class=\"number\">211</span>: </div><div class=\"line\"><span class=\"number\">212</span>:             <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">213</span>:                 <span class=\"keyword\">case</span> ResponseCode.SUCCESS:</div><div class=\"line\"><span class=\"number\">214</span>:                     <span class=\"keyword\">int</span> commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount();</div><div class=\"line\"><span class=\"number\">215</span>:                     <span class=\"keyword\">int</span> incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount;</div><div class=\"line\"><span class=\"number\">216</span>: </div><div class=\"line\"><span class=\"number\">217</span>:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS);</div><div class=\"line\"><span class=\"number\">218</span>:                     context.setCommercialRcvTimes(incValue);</div><div class=\"line\"><span class=\"number\">219</span>:                     context.setCommercialRcvSize(getMessageResult.getBufferTotalSize());</div><div class=\"line\"><span class=\"number\">220</span>:                     context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">221</span>: </div><div class=\"line\"><span class=\"number\">222</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">223</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\"><span class=\"number\">224</span>:                     <span class=\"keyword\">if</span> (!brokerAllowSuspend) &#123;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>:                         context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</div><div class=\"line\"><span class=\"number\">227</span>:                         context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">228</span>:                         context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">229</span>: </div><div class=\"line\"><span class=\"number\">230</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">231</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">232</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</div><div class=\"line\"><span class=\"number\">233</span>:                 <span class=\"keyword\">case</span> ResponseCode.PULL_OFFSET_MOVED:</div><div class=\"line\"><span class=\"number\">234</span>:                     context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS);</div><div class=\"line\"><span class=\"number\">235</span>:                     context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">236</span>:                     context.setCommercialOwner(owner);</div><div class=\"line\"><span class=\"number\">237</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">238</span>:                 <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">239</span>:                     <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">240</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">241</span>:             &#125;</div><div class=\"line\"><span class=\"number\">242</span>: </div><div class=\"line\"><span class=\"number\">243</span>:             <span class=\"keyword\">this</span>.executeConsumeMessageHookBefore(context);</div><div class=\"line\"><span class=\"number\">244</span>:         &#125;</div><div class=\"line\"><span class=\"number\">245</span>: </div><div class=\"line\"><span class=\"number\">246</span>:         <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">247</span>:             <span class=\"keyword\">case</span> ResponseCode.SUCCESS:</div><div class=\"line\"><span class=\"number\">248</span>: </div><div class=\"line\"><span class=\"number\">249</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">250</span>:                     getMessageResult.getMessageCount());</div><div class=\"line\"><span class=\"number\">251</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</div><div class=\"line\"><span class=\"number\">252</span>:                     getMessageResult.getBufferTotalSize());</div><div class=\"line\"><span class=\"number\">253</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</div><div class=\"line\"><span class=\"number\">254</span>:                 <span class=\"comment\">// 读取消息</span></div><div class=\"line\"><span class=\"number\">255</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123; <span class=\"comment\">// 内存中</span></div><div class=\"line\"><span class=\"number\">256</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimeMills = <span class=\"keyword\">this</span>.brokerController.getMessageStore().now();</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] r = <span class=\"keyword\">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">259</span>: </div><div class=\"line\"><span class=\"number\">260</span>:                     <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">261</span>:                         requestHeader.getTopic(), requestHeader.getQueueId(),</div><div class=\"line\"><span class=\"number\">262</span>:                         (<span class=\"keyword\">int</span>) (<span class=\"keyword\">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</div><div class=\"line\"><span class=\"number\">263</span>:                     response.setBody(r);</div><div class=\"line\"><span class=\"number\">264</span>:                 &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// zero-copy</span></div><div class=\"line\"><span class=\"number\">265</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">266</span>:                         FileRegion fileRegion = <span class=\"keyword\">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</div><div class=\"line\"><span class=\"number\">267</span>:                         channel.writeAndFlush(fileRegion).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\"><span class=\"number\">268</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">269</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">270</span>:                                 getMessageResult.release();</div><div class=\"line\"><span class=\"number\">271</span>:                                 <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</div><div class=\"line\"><span class=\"number\">272</span>:                                     LOG.error(<span class=\"string\">\"Fail to transfer messages from page cache to &#123;&#125;\"</span>, channel.remoteAddress(), future.cause());</div><div class=\"line\"><span class=\"number\">273</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">274</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">275</span>:                         &#125;);</div><div class=\"line\"><span class=\"number\">276</span>:                     &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">277</span>:                         LOG.error(<span class=\"string\">\"Error occurred when transferring messages from page cache\"</span>, e);</div><div class=\"line\"><span class=\"number\">278</span>:                         getMessageResult.release();</div><div class=\"line\"><span class=\"number\">279</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">280</span>: </div><div class=\"line\"><span class=\"number\">281</span>:                     response = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">282</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">283</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">284</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_NOT_FOUND:</div><div class=\"line\"><span class=\"number\">285</span>:                 <span class=\"comment\">// 消息未查询到 &amp;&amp; broker允许挂起请求 &amp;&amp; 请求允许挂起</span></div><div class=\"line\"><span class=\"number\">286</span>:                 <span class=\"keyword\">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</div><div class=\"line\"><span class=\"number\">287</span>:                     <span class=\"keyword\">long</span> pollingTimeMills = suspendTimeoutMillisLong;</div><div class=\"line\"><span class=\"number\">288</span>:                     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\"><span class=\"number\">289</span>:                         pollingTimeMills = <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</div><div class=\"line\"><span class=\"number\">290</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">291</span>: </div><div class=\"line\"><span class=\"number\">292</span>:                     String topic = requestHeader.getTopic();</div><div class=\"line\"><span class=\"number\">293</span>:                     <span class=\"keyword\">long</span> offset = requestHeader.getQueueOffset();</div><div class=\"line\"><span class=\"number\">294</span>:                     <span class=\"keyword\">int</span> queueId = requestHeader.getQueueId();</div><div class=\"line\"><span class=\"number\">295</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest(request, channel, pollingTimeMills,</div><div class=\"line\"><span class=\"number\">296</span>:                         <span class=\"keyword\">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData);</div><div class=\"line\"><span class=\"number\">297</span>:                     <span class=\"keyword\">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</div><div class=\"line\"><span class=\"number\">298</span>:                     response = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">299</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">300</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">301</span>: </div><div class=\"line\"><span class=\"number\">302</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</div><div class=\"line\"><span class=\"number\">303</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">304</span>:             <span class=\"keyword\">case</span> ResponseCode.PULL_OFFSET_MOVED:</div><div class=\"line\"><span class=\"number\">305</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</div><div class=\"line\"><span class=\"number\">306</span>:                     || <span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123; <span class=\"comment\">// TODO 待博客补充</span></div><div class=\"line\"><span class=\"number\">307</span>:                     MessageQueue mq = <span class=\"keyword\">new</span> MessageQueue();</div><div class=\"line\"><span class=\"number\">308</span>:                     mq.setTopic(requestHeader.getTopic());</div><div class=\"line\"><span class=\"number\">309</span>:                     mq.setQueueId(requestHeader.getQueueId());</div><div class=\"line\"><span class=\"number\">310</span>:                     mq.setBrokerName(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerName());</div><div class=\"line\"><span class=\"number\">311</span>: </div><div class=\"line\"><span class=\"number\">312</span>:                     OffsetMovedEvent event = <span class=\"keyword\">new</span> OffsetMovedEvent();</div><div class=\"line\"><span class=\"number\">313</span>:                     event.setConsumerGroup(requestHeader.getConsumerGroup());</div><div class=\"line\"><span class=\"number\">314</span>:                     event.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">315</span>:                     event.setOffsetRequest(requestHeader.getQueueOffset());</div><div class=\"line\"><span class=\"number\">316</span>:                     event.setOffsetNew(getMessageResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">317</span>:                     <span class=\"keyword\">this</span>.generateOffsetMovedEvent(event);</div><div class=\"line\"><span class=\"number\">318</span>:                     LOG.warn(</div><div class=\"line\"><span class=\"number\">319</span>:                         <span class=\"string\">\"PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">320</span>:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</div><div class=\"line\"><span class=\"number\">321</span>:                         responseHeader.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">322</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">323</span>:                     responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</div><div class=\"line\"><span class=\"number\">324</span>:                     response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</div><div class=\"line\"><span class=\"number\">325</span>:                     LOG.warn(<span class=\"string\">\"PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">326</span>:                         requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</div><div class=\"line\"><span class=\"number\">327</span>:                         responseHeader.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">328</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">329</span>: </div><div class=\"line\"><span class=\"number\">330</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">331</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">332</span>:                 <span class=\"keyword\">assert</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">333</span>:         &#125;</div><div class=\"line\"><span class=\"number\">334</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">335</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">336</span>:         response.setRemark(<span class=\"string\">\"store getMessage return null\"</span>);</div><div class=\"line\"><span class=\"number\">337</span>:     &#125;</div><div class=\"line\"><span class=\"number\">338</span>: </div><div class=\"line\"><span class=\"number\">339</span>:     <span class=\"comment\">// 请求要求持久化进度 &amp;&amp; broker非主，进行持久化进度。</span></div><div class=\"line\"><span class=\"number\">340</span>:     <span class=\"keyword\">boolean</span> storeOffsetEnable = brokerAllowSuspend;</div><div class=\"line\"><span class=\"number\">341</span>:     storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</div><div class=\"line\"><span class=\"number\">342</span>:     storeOffsetEnable = storeOffsetEnable &amp;&amp; <span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</div><div class=\"line\"><span class=\"number\">343</span>:     <span class=\"keyword\">if</span> (storeOffsetEnable) &#123;</div><div class=\"line\"><span class=\"number\">344</span>:         <span class=\"keyword\">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</div><div class=\"line\"><span class=\"number\">345</span>:             requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</div><div class=\"line\"><span class=\"number\">346</span>:     &#125;</div><div class=\"line\"><span class=\"number\">347</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">348</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：处理拉取消息请求，返回响应。</li>\n<li>第 14 至 19 行 ：校验 <code>Broker</code> 是否可读。</li>\n<li>第 21 至 33 行 ：校验 <code>SubscriptionGroupConfig</code>(订阅分组配置) 是否存在 &amp;&amp; 可以消费。</li>\n<li>第 35 至 38 行 ：处理 <code>PullMessageRequestHeader.sysFlag</code> 对应的标志位。</li>\n<li>第 40 至 62 行 ：校验 <code>TopicConfig</code>(主题配置) 是否存在 &amp;&amp; 可读 &amp;&amp; 队列编号正确。</li>\n<li>第 64 至 110 行 ：校验 <code>SubscriptionData</code>(订阅信息) 是否正确。</li>\n<li>第 113 行 ：调用 <code>MessageStore#getMessage(...)</code> 获取 <code>GetMessageResult</code>(消息)。详细解析见：<a href=\"#messagestoregetmessage\">MessageStore#getMessage(…)</a>。</li>\n<li>第 122 至 152 行 ：计算建议拉取消息 <code>brokerId</code> 。</li>\n<li>第 154 至 201 行 ：<img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/08.png\" alt=\"PullMessageProcessor拉取消息状态图\"></li>\n<li>第 204 至 244 行 ：<code>Hook</code> 逻辑，<code>#executeConsumeMessageHookBefore(...)</code> 。</li>\n<li>第 247 至 283 行 ：拉取消息成功，即拉取到消息。<ul>\n<li>第 255 至 263 行 ：方式一 ：调用 <code>readGetMessageResult(...)</code> 获取消息内容到堆内内存，设置到 响应<code>body</code>。</li>\n<li>第 265 至 281 行 ：方式二 ：基于 <code>zero-copy</code> 实现，直接响应，无需堆内内存，性能更优。<em>TODO ：此处等对zero-copy有研究，再补充一些</em>。</li>\n</ul>\n</li>\n<li>第 284 至 300 行 ：拉取不到消息，当满足条件 (<code>Broker</code> 允许挂起 &amp;&amp; 请求要求挂起)，执行挂起请求。详细解析见：<a href=\"#pullrequestholdservice\">PullRequestHoldService</a>。</li>\n<li>第 304 至 328 行 ：<em>TODO ：此处等对<code>tools</code>模块研究后再补充</em>。</li>\n<li>第 339 至 346 ：持久化消费进度，当满足 (<code>Broker</code> 非主 &amp;&amp; 请求要求持久化进度)。详细解析见：<a href=\"#3broker-提供更新消费进度接口\">更新消费进度</a>。</li>\n</ul>\n<h2 id=\"MessageStore-getMessage-…\"><a href=\"#MessageStore-getMessage-…\" class=\"headerlink\" title=\"MessageStore#getMessage(…)\"></a>MessageStore#getMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\">  2:  * 获取消息结果</div><div class=\"line\">  3:  *</div><div class=\"line\">  4:  * <span class=\"doctag\">@param</span> group 消费分组</div><div class=\"line\">  5:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">  6:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">  7:  * <span class=\"doctag\">@param</span> offset 队列位置</div><div class=\"line\">  8:  * <span class=\"doctag\">@param</span> maxMsgNums 消息数量</div><div class=\"line\">  9:  * <span class=\"doctag\">@param</span> subscriptionData 订阅信息</div><div class=\"line\"> 10:  * <span class=\"doctag\">@return</span> 消息结果</div><div class=\"line\"> 11:  */</div><div class=\"line\"> <span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> GetMessageResult <span class=\"title\">getMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> String group, <span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxMsgNums,</span></span></div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">// 是否关闭</span></div><div class=\"line\"> <span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.shutdown) &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:         log.warn(<span class=\"string\">\"message store has shutdown, so getMessage is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">19</span>:     <span class=\"comment\">// 是否可读</span></div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.runningFlags.isReadable()) &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         log.warn(<span class=\"string\">\"message store is not readable, so getMessage is forbidden \"</span> + <span class=\"keyword\">this</span>.runningFlags.getFlagBits());</div><div class=\"line\"> <span class=\"number\">22</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">23</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">24</span>: </div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">long</span> beginTime = <span class=\"keyword\">this</span>.getSystemClock().now();</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">long</span> nextBeginOffset = offset;</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">long</span> minOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">30</span>:     <span class=\"keyword\">long</span> maxOffset = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">31</span>: </div><div class=\"line\"> <span class=\"number\">32</span>:     GetMessageResult getResult = <span class=\"keyword\">new</span> GetMessageResult();</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffsetPy = <span class=\"keyword\">this</span>.commitLog.getMaxOffset();</div><div class=\"line\"> <span class=\"number\">35</span>: </div><div class=\"line\"> <span class=\"number\">36</span>:     <span class=\"comment\">// 获取消费队列</span></div><div class=\"line\"> <span class=\"number\">37</span>:     ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</div><div class=\"line\"> <span class=\"number\">38</span>:     <span class=\"keyword\">if</span> (consumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">39</span>:         minOffset = consumeQueue.getMinOffsetInQueue(); <span class=\"comment\">// 消费队列 最小队列编号</span></div><div class=\"line\"> <span class=\"number\">40</span>:         maxOffset = consumeQueue.getMaxOffsetInQueue(); <span class=\"comment\">// 消费队列 最大队列编号</span></div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         <span class=\"comment\">// 判断 队列位置(offset)</span></div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">if</span> (maxOffset == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 消费队列无消息</span></div><div class=\"line\"> <span class=\"number\">44</span>:             status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</div><div class=\"line\"> <span class=\"number\">45</span>:             nextBeginOffset = nextOffsetCorrection(offset, <span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"number\">46</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset &lt; minOffset) &#123; <span class=\"comment\">// 查询offset 太小</span></div><div class=\"line\"> <span class=\"number\">47</span>:             status = GetMessageStatus.OFFSET_TOO_SMALL;</div><div class=\"line\"> <span class=\"number\">48</span>:             nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class=\"line\"> <span class=\"number\">49</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset == maxOffset) &#123; <span class=\"comment\">// 查询offset 超过 消费队列 一个位置</span></div><div class=\"line\"> <span class=\"number\">50</span>:             status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</div><div class=\"line\"> <span class=\"number\">51</span>:             nextBeginOffset = nextOffsetCorrection(offset, offset);</div><div class=\"line\"> <span class=\"number\">52</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (offset &gt; maxOffset) &#123; <span class=\"comment\">// 查询offset 超过 消费队列 太多(大于一个位置)</span></div><div class=\"line\"> <span class=\"number\">53</span>:             status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == minOffset) &#123; <span class=\"comment\">// TODO blog 这里是？？为啥0 == minOffset做了特殊判断</span></div><div class=\"line\"> <span class=\"number\">55</span>:                 nextBeginOffset = nextOffsetCorrection(offset, minOffset);</div><div class=\"line\"> <span class=\"number\">56</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">57</span>:                 nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 获得 映射Buffer结果(MappedFile)</span></div><div class=\"line\"> <span class=\"number\">61</span>:             SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</div><div class=\"line\"> <span class=\"number\">62</span>:             <span class=\"keyword\">if</span> (bufferConsumeQueue != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:                     status = GetMessageStatus.NO_MATCHED_MESSAGE;</div><div class=\"line\"> <span class=\"number\">65</span>: </div><div class=\"line\"> <span class=\"number\">66</span>:                     <span class=\"keyword\">long</span> nextPhyFileStartOffset = Long.MIN_VALUE; <span class=\"comment\">// commitLog下一个文件(MappedFile)对应的开始offset。</span></div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">long</span> maxPhyOffsetPulling = <span class=\"number\">0</span>; <span class=\"comment\">// 消息物理位置拉取到的最大offset</span></div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxFilterMessageCount = <span class=\"number\">16000</span>;</div><div class=\"line\"> <span class=\"number\">71</span>:                     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> diskFallRecorded = <span class=\"keyword\">this</span>.messageStoreConfig.isDiskFallRecorded();</div><div class=\"line\"> <span class=\"number\">72</span>:                     <span class=\"comment\">// 循环获取 消息位置信息</span></div><div class=\"line\"> <span class=\"number\">73</span>:                     <span class=\"keyword\">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:                         <span class=\"keyword\">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); <span class=\"comment\">// 消息物理位置offset</span></div><div class=\"line\"> <span class=\"number\">75</span>:                         <span class=\"keyword\">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt(); <span class=\"comment\">// 消息长度</span></div><div class=\"line\"> <span class=\"number\">76</span>:                         <span class=\"keyword\">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); <span class=\"comment\">// 消息tagsCode</span></div><div class=\"line\"> <span class=\"number\">77</span>:                         <span class=\"comment\">// 设置消息物理位置拉取到的最大offset</span></div><div class=\"line\"> <span class=\"number\">78</span>:                         maxPhyOffsetPulling = offsetPy;</div><div class=\"line\"> <span class=\"number\">79</span>:                         <span class=\"comment\">// 当 offsetPy 小于 nextPhyFileStartOffset 时，意味着对应的 Message 已经移除，所以直接continue，直到可读取的Message。</span></div><div class=\"line\"> <span class=\"number\">80</span>:                         <span class=\"keyword\">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</div><div class=\"line\"> <span class=\"number\">81</span>:                             <span class=\"keyword\">if</span> (offsetPy &lt; nextPhyFileStartOffset)</div><div class=\"line\"> <span class=\"number\">82</span>:                                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"> <span class=\"number\">83</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">84</span>:                         <span class=\"comment\">// 校验 commitLog 是否需要硬盘，无法全部放在内存</span></div><div class=\"line\"> <span class=\"number\">85</span>:                         <span class=\"keyword\">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</div><div class=\"line\"> <span class=\"number\">86</span>:                         <span class=\"comment\">// 是否已经获得足够消息</span></div><div class=\"line\"> <span class=\"number\">87</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</div><div class=\"line\"> <span class=\"number\">88</span>:                             isInDisk)) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:                             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">90</span>:                         &#125;</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 判断消息是否符合条件</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageFilter.isMessageMatched(subscriptionData, tagsCode)) &#123;</div><div class=\"line\"> <span class=\"number\">93</span>:                             <span class=\"comment\">// 从commitLog获取对应消息ByteBuffer</span></div><div class=\"line\"> <span class=\"number\">94</span>:                             SelectMappedBufferResult selectResult = <span class=\"keyword\">this</span>.commitLog.getMessage(offsetPy, sizePy);</div><div class=\"line\"> <span class=\"number\">95</span>:                             <span class=\"keyword\">if</span> (selectResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:                                 <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</div><div class=\"line\"> <span class=\"number\">97</span>:                                 getResult.addMessage(selectResult);</div><div class=\"line\"> <span class=\"number\">98</span>:                                 status = GetMessageStatus.FOUND;</div><div class=\"line\"> <span class=\"number\">99</span>:                                 nextPhyFileStartOffset = Long.MIN_VALUE;</div><div class=\"line\"><span class=\"number\">100</span>:                             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">101</span>:                                 <span class=\"comment\">// 从commitLog无法读取到消息，说明该消息对应的文件（MappedFile）已经删除，计算下一个MappedFile的起始位置</span></div><div class=\"line\"><span class=\"number\">102</span>:                                 <span class=\"keyword\">if</span> (getResult.getBufferTotalSize() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">103</span>:                                     status = GetMessageStatus.MESSAGE_WAS_REMOVING;</div><div class=\"line\"><span class=\"number\">104</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">105</span>:                                 nextPhyFileStartOffset = <span class=\"keyword\">this</span>.commitLog.rollNextFile(offsetPy);</div><div class=\"line\"><span class=\"number\">106</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">107</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">108</span>:                             <span class=\"keyword\">if</span> (getResult.getBufferTotalSize() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">109</span>:                                 status = GetMessageStatus.NO_MATCHED_MESSAGE;</div><div class=\"line\"><span class=\"number\">110</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:                             <span class=\"keyword\">if</span> (log.isDebugEnabled()) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:                                 log.debug(<span class=\"string\">\"message type not matched, client: \"</span> + subscriptionData + <span class=\"string\">\" server: \"</span> + tagsCode);</div><div class=\"line\"><span class=\"number\">114</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">115</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">116</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">117</span>:                     <span class=\"comment\">// 统计剩余可拉取消息字节数</span></div><div class=\"line\"><span class=\"number\">118</span>:                     <span class=\"keyword\">if</span> (diskFallRecorded) &#123;</div><div class=\"line\"><span class=\"number\">119</span>:                         <span class=\"keyword\">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</div><div class=\"line\"><span class=\"number\">120</span>:                         brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</div><div class=\"line\"><span class=\"number\">121</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">122</span>:                     <span class=\"comment\">// 计算下次拉取消息的消息队列编号</span></div><div class=\"line\"><span class=\"number\">123</span>:                     nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</div><div class=\"line\"><span class=\"number\">124</span>:                     <span class=\"comment\">// 根据剩余可拉取消息字节数与内存判断是否建议读取从节点</span></div><div class=\"line\"><span class=\"number\">125</span>:                     <span class=\"keyword\">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</div><div class=\"line\"><span class=\"number\">126</span>:                     <span class=\"keyword\">long</span> memory = (<span class=\"keyword\">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</div><div class=\"line\"><span class=\"number\">127</span>:                             * (<span class=\"keyword\">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class=\"number\">100.0</span>));</div><div class=\"line\"><span class=\"number\">128</span>:                     getResult.setSuggestPullingFromSlave(diff &gt; memory);</div><div class=\"line\"><span class=\"number\">129</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">130</span>:                     bufferConsumeQueue.release();</div><div class=\"line\"><span class=\"number\">131</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">132</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">133</span>:                 status = GetMessageStatus.OFFSET_FOUND_NULL;</div><div class=\"line\"><span class=\"number\">134</span>:                 nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</div><div class=\"line\"><span class=\"number\">135</span>:                 log.warn(<span class=\"string\">\"consumer request topic: \"</span> + topic + <span class=\"string\">\"offset: \"</span> + offset + <span class=\"string\">\" minOffset: \"</span> + minOffset + <span class=\"string\">\" maxOffset: \"</span></div><div class=\"line\"><span class=\"number\">136</span>:                     + maxOffset + <span class=\"string\">\", but access logic queue failed.\"</span>);</div><div class=\"line\"><span class=\"number\">137</span>:             &#125;</div><div class=\"line\"><span class=\"number\">138</span>:         &#125;</div><div class=\"line\"><span class=\"number\">139</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">140</span>:         status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</div><div class=\"line\"><span class=\"number\">141</span>:         nextBeginOffset = nextOffsetCorrection(offset, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">142</span>:     &#125;</div><div class=\"line\"><span class=\"number\">143</span>:     <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">144</span>:     <span class=\"keyword\">if</span> (GetMessageStatus.FOUND == status) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:         <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</div><div class=\"line\"><span class=\"number\">146</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">147</span>:         <span class=\"keyword\">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</div><div class=\"line\"><span class=\"number\">148</span>:     &#125;</div><div class=\"line\"><span class=\"number\">149</span>:     <span class=\"keyword\">long</span> eclipseTime = <span class=\"keyword\">this</span>.getSystemClock().now() - beginTime;</div><div class=\"line\"><span class=\"number\">150</span>:     <span class=\"keyword\">this</span>.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);</div><div class=\"line\"><span class=\"number\">151</span>:     <span class=\"comment\">// 设置返回结果</span></div><div class=\"line\"><span class=\"number\">152</span>:     getResult.setStatus(status);</div><div class=\"line\"><span class=\"number\">153</span>:     getResult.setNextBeginOffset(nextBeginOffset);</div><div class=\"line\"><span class=\"number\">154</span>:     getResult.setMaxOffset(maxOffset);</div><div class=\"line\"><span class=\"number\">155</span>:     getResult.setMinOffset(minOffset);</div><div class=\"line\"><span class=\"number\">156</span>:     <span class=\"keyword\">return</span> getResult;</div><div class=\"line\"><span class=\"number\">157</span>: &#125;</div><div class=\"line\"><span class=\"number\">158</span>: </div><div class=\"line\"><span class=\"number\">159</span>: <span class=\"comment\">/**</span></div><div class=\"line\">160:  * 根据 主题 + 队列编号 获取 消费队列</div><div class=\"line\">161:  *</div><div class=\"line\">162:  * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">163:  * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">164:  * <span class=\"doctag\">@return</span> 消费队列</div><div class=\"line\">165:  */</div><div class=\"line\"><span class=\"number\">166</span>: <span class=\"function\"><span class=\"keyword\">public</span> ConsumeQueue <span class=\"title\">findConsumeQueue</span><span class=\"params\">(String topic, <span class=\"keyword\">int</span> queueId)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">167</span>:     <span class=\"comment\">// 获取 topic 对应的 所有消费队列</span></div><div class=\"line\"><span class=\"number\">168</span>:     ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; map = consumeQueueTable.get(topic);</div><div class=\"line\"><span class=\"number\">169</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == map) &#123;</div><div class=\"line\"><span class=\"number\">170</span>:         ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; newMap = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">128</span>);</div><div class=\"line\"><span class=\"number\">171</span>:         ConcurrentHashMap&lt;Integer, ConsumeQueue&gt; oldMap = consumeQueueTable.putIfAbsent(topic, newMap);</div><div class=\"line\"><span class=\"number\">172</span>:         <span class=\"keyword\">if</span> (oldMap != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">173</span>:             map = oldMap;</div><div class=\"line\"><span class=\"number\">174</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:             map = newMap;</div><div class=\"line\"><span class=\"number\">176</span>:         &#125;</div><div class=\"line\"><span class=\"number\">177</span>:     &#125;</div><div class=\"line\"><span class=\"number\">178</span>:     <span class=\"comment\">// 获取 queueId 对应的 消费队列</span></div><div class=\"line\"><span class=\"number\">179</span>:     ConsumeQueue logic = map.get(queueId);</div><div class=\"line\"><span class=\"number\">180</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == logic) &#123;</div><div class=\"line\"><span class=\"number\">181</span>:         ConsumeQueue newLogic = <span class=\"keyword\">new</span> ConsumeQueue(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">182</span>:             topic, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">183</span>:             queueId, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">184</span>:             StorePathConfigHelper.getStorePathConsumeQueue(<span class=\"keyword\">this</span>.messageStoreConfig.getStorePathRootDir()), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">185</span>:             <span class=\"keyword\">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">186</span>:             <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">187</span>:         ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);</div><div class=\"line\"><span class=\"number\">188</span>:         <span class=\"keyword\">if</span> (oldLogic != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">189</span>:             logic = oldLogic;</div><div class=\"line\"><span class=\"number\">190</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">191</span>:             logic = newLogic;</div><div class=\"line\"><span class=\"number\">192</span>:         &#125;</div><div class=\"line\"><span class=\"number\">193</span>:     &#125;</div><div class=\"line\"><span class=\"number\">194</span>: </div><div class=\"line\"><span class=\"number\">195</span>:     <span class=\"keyword\">return</span> logic;</div><div class=\"line\"><span class=\"number\">196</span>: &#125;</div><div class=\"line\"><span class=\"number\">197</span>: </div><div class=\"line\"><span class=\"number\">198</span>: <span class=\"comment\">/**</span></div><div class=\"line\">199:  * 下一个获取队列offset修正</div><div class=\"line\">200:  * 修正条件：主节点 或者 从节点开启校验offset开关</div><div class=\"line\">201:  *</div><div class=\"line\">202:  * <span class=\"doctag\">@param</span> oldOffset 老队列offset</div><div class=\"line\">203:  * <span class=\"doctag\">@param</span> newOffset 新队列offset</div><div class=\"line\">204:  * <span class=\"doctag\">@return</span> 修正后的队列offset</div><div class=\"line\">205:  */</div><div class=\"line\"><span class=\"number\">206</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">nextOffsetCorrection</span><span class=\"params\">(<span class=\"keyword\">long</span> oldOffset, <span class=\"keyword\">long</span> newOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">207</span>:     <span class=\"keyword\">long</span> nextOffset = oldOffset;</div><div class=\"line\"><span class=\"number\">208</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || <span class=\"keyword\">this</span>.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</div><div class=\"line\"><span class=\"number\">209</span>:         nextOffset = newOffset;</div><div class=\"line\"><span class=\"number\">210</span>:     &#125;</div><div class=\"line\"><span class=\"number\">211</span>:     <span class=\"keyword\">return</span> nextOffset;</div><div class=\"line\"><span class=\"number\">212</span>: &#125;</div><div class=\"line\"><span class=\"number\">213</span>: </div><div class=\"line\"><span class=\"number\">214</span>: <span class=\"comment\">/**</span></div><div class=\"line\">215:  * 校验 commitLog 是否需要硬盘，无法全部放在内存</div><div class=\"line\">216:  *</div><div class=\"line\">217:  * <span class=\"doctag\">@param</span> offsetPy commitLog 指定offset</div><div class=\"line\">218:  * <span class=\"doctag\">@param</span> maxOffsetPy commitLog 最大offset</div><div class=\"line\">219:  * <span class=\"doctag\">@return</span> 是否需要硬盘</div><div class=\"line\">220:  */</div><div class=\"line\"><span class=\"number\">221</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">checkInDiskByCommitOffset</span><span class=\"params\">(<span class=\"keyword\">long</span> offsetPy, <span class=\"keyword\">long</span> maxOffsetPy)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">222</span>:     <span class=\"keyword\">long</span> memory = (<span class=\"keyword\">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (<span class=\"keyword\">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class=\"number\">100.0</span>));</div><div class=\"line\"><span class=\"number\">223</span>:     <span class=\"keyword\">return</span> (maxOffsetPy - offsetPy) &gt; memory;</div><div class=\"line\"><span class=\"number\">224</span>: &#125;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>: <span class=\"comment\">/**</span></div><div class=\"line\">227:  * 判断获取消息是否已经满</div><div class=\"line\">228:  *</div><div class=\"line\">229:  * <span class=\"doctag\">@param</span> sizePy 字节数</div><div class=\"line\">230:  * <span class=\"doctag\">@param</span> maxMsgNums 最大消息数</div><div class=\"line\">231:  * <span class=\"doctag\">@param</span> bufferTotal 目前已经计算字节数</div><div class=\"line\">232:  * <span class=\"doctag\">@param</span> messageTotal 目前已经计算消息数</div><div class=\"line\">233:  * <span class=\"doctag\">@param</span> isInDisk 是否在硬盘中</div><div class=\"line\">234:  * <span class=\"doctag\">@return</span> 是否已满</div><div class=\"line\">235:  */</div><div class=\"line\"><span class=\"number\">236</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isTheBatchFull</span><span class=\"params\">(<span class=\"keyword\">int</span> sizePy, <span class=\"keyword\">int</span> maxMsgNums, <span class=\"keyword\">int</span> bufferTotal, <span class=\"keyword\">int</span> messageTotal, <span class=\"keyword\">boolean</span> isInDisk)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">237</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == bufferTotal || <span class=\"number\">0</span> == messageTotal) &#123;</div><div class=\"line\"><span class=\"number\">238</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">239</span>:     &#125;</div><div class=\"line\"><span class=\"number\">240</span>:     <span class=\"comment\">// 消息数量已经满足请求数量(maxMsgNums)</span></div><div class=\"line\"><span class=\"number\">241</span>:     <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt;= maxMsgNums) &#123;</div><div class=\"line\"><span class=\"number\">242</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">243</span>:     &#125;</div><div class=\"line\"><span class=\"number\">244</span>:     <span class=\"comment\">// 根据消息存储配置的最大传输字节数、最大传输消息数是否已满</span></div><div class=\"line\"><span class=\"number\">245</span>:     <span class=\"keyword\">if</span> (isInDisk) &#123;</div><div class=\"line\"><span class=\"number\">246</span>:         <span class=\"keyword\">if</span> ((bufferTotal + sizePy) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferBytesOnMessageInDisk()) &#123;</div><div class=\"line\"><span class=\"number\">247</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">248</span>:         &#125;</div><div class=\"line\"><span class=\"number\">249</span>: </div><div class=\"line\"><span class=\"number\">250</span>:         <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferCountOnMessageInDisk()) &#123;</div><div class=\"line\"><span class=\"number\">251</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">252</span>:         &#125;</div><div class=\"line\"><span class=\"number\">253</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">254</span>:         <span class=\"keyword\">if</span> ((bufferTotal + sizePy) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferBytesOnMessageInMemory()) &#123;</div><div class=\"line\"><span class=\"number\">255</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">256</span>:         &#125;</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>:         <span class=\"keyword\">if</span> ((messageTotal + <span class=\"number\">1</span>) &gt; <span class=\"keyword\">this</span>.messageStoreConfig.getMaxTransferCountOnMessageInMemory()) &#123;</div><div class=\"line\"><span class=\"number\">259</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">260</span>:         &#125;</div><div class=\"line\"><span class=\"number\">261</span>:     &#125;</div><div class=\"line\"><span class=\"number\">262</span>: </div><div class=\"line\"><span class=\"number\">263</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">264</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：根据 消息分组(<code>group</code>) + 主题(<code>Topic</code>) + 队列编号(<code>queueId</code>) + 队列位置(<code>offset</code>) + 订阅信息(<code>subscriptionData</code>) 获取 指定条数(<code>maxMsgNums</code>) 消息(<code>Message</code>)。</li>\n<li>第 14 至 18 行 ：判断 <code>Store</code> 是否处于关闭状态，若关闭，则无法获取消息。</li>\n<li>第 19 至 23 行 ：判断当前运行状态是否可读，若不可读，则无法获取消息。</li>\n<li>第 37 行 ：根据 主题(<code>Topic</code>) + 队列编号(<code>queueId</code>) 获取 消息队列(<code>ConsumeQueue</code>)。<ul>\n<li><code>#findConsumeQueue(...)</code> ：第 159 至 196 行。</li>\n</ul>\n</li>\n<li>第 43 至 58 行 ：各种队列位置(<code>offset</code>) 无法读取消息，并针对对应的情况，计算下一次 <code>Client</code> 队列拉取位置。<ul>\n<li>第 43 至 45 行 ：消息队列无消息。</li>\n<li>第 46 至 48 行 ：查询的消息队列位置（<code>offset</code>） 太小。</li>\n<li>第 49 至 51 行 ：查询的消息队列位置（<code>offset</code>） 恰好等于 消息队列最大的队列位置。该情况是正常现象，相当于查询最新的消息。</li>\n<li>第 52 至 58 行 ：查询的消息队列位置（<code>offset</code>） 超过过多。</li>\n<li><code>#nextOffsetCorrection(...)</code> ：第 198 至 212 行。</li>\n</ul>\n</li>\n<li>第 61 行 ：根据 消费队列位置(<code>offset</code>) 获取 对应的<code>MappedFile</code>。</li>\n<li>第 72 至 128 行 ：<strong>循环</strong>获取 <code>消息位置信息</code>。<ul>\n<li>第 74 至 76 行 ：读取每一个 <code>消息位置信息</code>。</li>\n<li>第 79 至 83 行 ：当 <code>offsetPy</code> 小于 <code>nextPhyFileStartOffset</code> 时，意味着对<br>应的 <code>Message</code> 已经移除，所以直接continue，直到可读取的 <code>Message</code>。</li>\n<li>第 84 至 90 行 ：判断是否已经获得足够的消息。<ul>\n<li><code>#checkInDiskByCommitOffset(...)</code> ：第 214 至 224 行。</li>\n<li><code>#isTheBatchFull(...)</code> ：第 226 至 264 行。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第 92 行 ：判断消息是否符合条件。详细解析见：<a href=\"defaultmessagefilterismessagematched\">DefaultMessageFilter#isMessageMatched(…)</a>。</li>\n<li>第 94 行 ：从 <code>CommitLog</code> 获取对应 消息的<code>MappedByteBuffer</code>。</li>\n<li>第 95 至 99 行 ：获取 <code>消息MappedByteBuffer</code> 成功。</li>\n<li>第 100 至 106 行 ：获取 <code>消息MappedByteBuffer</code> 失败。从 <code>CommitLog</code> 无法读取到消息，说明 该消息对应的文件(<code>MappedFile</code>) 已经删除，此时计算下一个<code>MappedFile</code>的起始位置。<strong>该逻辑需要配合（第 79 至 83 行）一起理解。</strong></li>\n<li>第 117 至 120 行 ：统计剩余可拉取消息字节数。</li>\n<li>第 123 行 ：计算下次拉取消息的消息队列编号。</li>\n<li>第 124 至 128 行 ：根据剩余可拉取消息字节数与内存判断是否建议读取从节点。</li>\n<li>第 130 行 ：释放 <code>bufferConsumeQueue</code> 对 <code>MappedFile</code> 的指向。此处 <code>MappedFile</code> 是 <code>ConsumeQueue</code> 里的文件，不是 <code>CommitLog</code> 下的文件。</li>\n<li>第 133 至 136 行 ：获得消费队列位置(<code>offset</code>) 获取 对应的<code>MappedFile</code> 为<strong>空</strong>，计算<code>ConsumeQueue</code> 从 <code>offset</code> 开始的下一个 <code>MappedFile</code> 对应的位置。</li>\n<li>第 143 至 150 行 ：记录统计信息：消耗时间、拉取到消息/未拉取到消息次数。</li>\n<li>第 151 至 156 行 ：设置返回结果并返回。 </li>\n</ul>\n<h2 id=\"DefaultMessageFilter-isMessageMatched-…\"><a href=\"#DefaultMessageFilter-isMessageMatched-…\" class=\"headerlink\" title=\"DefaultMessageFilter#isMessageMatched(…)\"></a>DefaultMessageFilter#isMessageMatched(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultMessageFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageFilter</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMessageMatched</span><span class=\"params\">(SubscriptionData subscriptionData, Long tagsCode)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"comment\">// 消息tagsCode 空</span></div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">if</span> (tagsCode == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">8</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"comment\">// 订阅数据 空</span></div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         &#125;</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"comment\">// classFilter</span></div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (subscriptionData.isClassFilterMode())</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 订阅表达式 全匹配</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">if</span> (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) &#123;</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 订阅数据code数组 是否包含 消息tagsCode</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">return</span> subscriptionData.getCodeSet().contains(tagsCode.intValue());</div><div class=\"line\"><span class=\"number\">22</span>:     &#125;</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消息过滤器默认实现。</li>\n</ul>\n<h2 id=\"PullRequestHoldService\"><a href=\"#PullRequestHoldService\" class=\"headerlink\" title=\"PullRequestHoldService\"></a>PullRequestHoldService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullRequestHoldService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);</div><div class=\"line\">  <span class=\"number\">4</span>: </div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOPIC_QUEUEID_SEPARATOR = <span class=\"string\">\"@\"</span>;</div><div class=\"line\">  <span class=\"number\">6</span>: </div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BrokerController brokerController;</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SystemClock systemClock = <span class=\"keyword\">new</span> SystemClock();</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 11:      * 消息过滤器</div><div class=\"line\"> 12:      */</div><div class=\"line\"> <span class=\"number\">13</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageFilter messageFilter = <span class=\"keyword\">new</span> DefaultMessageFilter();</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 15:      * 拉取消息请求集合</div><div class=\"line\"> 16:      */</div><div class=\"line\"> <span class=\"number\">17</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* topic@queueId */</span>, ManyPullRequest&gt; pullRequestTable =</div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">1024</span>);</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PullRequestHoldService</span><span class=\"params\">(<span class=\"keyword\">final</span> BrokerController brokerController)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">21</span>:         <span class=\"keyword\">this</span>.brokerController = brokerController;</div><div class=\"line\"> <span class=\"number\">22</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">23</span>: </div><div class=\"line\"> <span class=\"number\">24</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 25:      * 添加拉取消息挂起请求</div><div class=\"line\"> 26:      *</div><div class=\"line\"> 27:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\"> 28:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\"> 29:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 30:      */</div><div class=\"line\"> <span class=\"number\">31</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">suspendPullRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">32</span>:         String key = <span class=\"keyword\">this</span>.buildKey(topic, queueId);</div><div class=\"line\"> <span class=\"number\">33</span>:         ManyPullRequest mpr = <span class=\"keyword\">this</span>.pullRequestTable.get(key);</div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mpr) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:             mpr = <span class=\"keyword\">new</span> ManyPullRequest();</div><div class=\"line\"> <span class=\"number\">36</span>:             ManyPullRequest prev = <span class=\"keyword\">this</span>.pullRequestTable.putIfAbsent(key, mpr);</div><div class=\"line\"> <span class=\"number\">37</span>:             <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">38</span>:                 mpr = prev;</div><div class=\"line\"> <span class=\"number\">39</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">40</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:         mpr.addPullRequest(pullRequest);</div><div class=\"line\"> <span class=\"number\">43</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">44</span>: </div><div class=\"line\"> <span class=\"number\">45</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 46:      * 根据 主题 + 队列编号 创建唯一标识</div><div class=\"line\"> 47:      *</div><div class=\"line\"> 48:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\"> 49:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\"> 50:      * <span class=\"doctag\">@return</span> key</div><div class=\"line\"> 51:      */</div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">buildKey</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">53</span>:         StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</div><div class=\"line\"> <span class=\"number\">54</span>:         sb.append(topic);</div><div class=\"line\"> <span class=\"number\">55</span>:         sb.append(TOPIC_QUEUEID_SEPARATOR);</div><div class=\"line\"> <span class=\"number\">56</span>:         sb.append(queueId);</div><div class=\"line\"> <span class=\"number\">57</span>:         <span class=\"keyword\">return</span> sb.toString();</div><div class=\"line\"> <span class=\"number\">58</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">62</span>:         log.info(<span class=\"string\">\"&#123;&#125; service started\"</span>, <span class=\"keyword\">this</span>.getServiceName());</div><div class=\"line\"> <span class=\"number\">63</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">64</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"comment\">// 根据 长轮训 还是 短轮训 设置不同的等待时间</span></div><div class=\"line\"> <span class=\"number\">66</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</div><div class=\"line\"> <span class=\"number\">67</span>:                     <span class=\"keyword\">this</span>.waitForRunning(<span class=\"number\">5</span> * <span class=\"number\">1000</span>);</div><div class=\"line\"> <span class=\"number\">68</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">69</span>:                     <span class=\"keyword\">this</span>.waitForRunning(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</div><div class=\"line\"> <span class=\"number\">70</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">71</span>:                 <span class=\"comment\">// 检查挂起请求是否有需要通知的</span></div><div class=\"line\"> <span class=\"number\">72</span>:                 <span class=\"keyword\">long</span> beginLockTimestamp = <span class=\"keyword\">this</span>.systemClock.now();</div><div class=\"line\"> <span class=\"number\">73</span>:                 <span class=\"keyword\">this</span>.checkHoldRequest();</div><div class=\"line\"> <span class=\"number\">74</span>:                 <span class=\"keyword\">long</span> costTime = <span class=\"keyword\">this</span>.systemClock.now() - beginLockTimestamp;</div><div class=\"line\"> <span class=\"number\">75</span>:                 <span class=\"keyword\">if</span> (costTime &gt; <span class=\"number\">5</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"> <span class=\"number\">76</span>:                     log.info(<span class=\"string\">\"[NOTIFYME] check hold request cost &#123;&#125; ms.\"</span>, costTime);</div><div class=\"line\"> <span class=\"number\">77</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">79</span>:                 log.warn(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service has exception. \"</span>, e);</div><div class=\"line\"> <span class=\"number\">80</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">82</span>: </div><div class=\"line\"> <span class=\"number\">83</span>:         log.info(<span class=\"string\">\"&#123;&#125; service end\"</span>, <span class=\"keyword\">this</span>.getServiceName());</div><div class=\"line\"> <span class=\"number\">84</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">85</span>: </div><div class=\"line\"> <span class=\"number\">86</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">87</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">return</span> PullRequestHoldService.class.getSimpleName();</div><div class=\"line\"> <span class=\"number\">89</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 92:      * 遍历挂起请求，检查是否有需要通知的请求。</div><div class=\"line\"> 93:      */</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkHoldRequest</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">95</span>:         <span class=\"keyword\">for</span> (String key : <span class=\"keyword\">this</span>.pullRequestTable.keySet()) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:             String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</div><div class=\"line\"> <span class=\"number\">97</span>:             <span class=\"keyword\">if</span> (<span class=\"number\">2</span> == kArray.length) &#123;</div><div class=\"line\"> <span class=\"number\">98</span>:                 String topic = kArray[<span class=\"number\">0</span>];</div><div class=\"line\"> <span class=\"number\">99</span>:                 <span class=\"keyword\">int</span> queueId = Integer.parseInt(kArray[<span class=\"number\">1</span>]);</div><div class=\"line\"><span class=\"number\">100</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);</div><div class=\"line\"><span class=\"number\">101</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">102</span>:                     <span class=\"keyword\">this</span>.notifyMessageArriving(topic, queueId, offset);</div><div class=\"line\"><span class=\"number\">103</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                     log.error(<span class=\"string\">\"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;\"</span>, topic, queueId, e);</div><div class=\"line\"><span class=\"number\">105</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">106</span>:             &#125;</div><div class=\"line\"><span class=\"number\">107</span>:         &#125;</div><div class=\"line\"><span class=\"number\">108</span>:     &#125;</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">111:      * 检查是否有需要通知的请求</div><div class=\"line\">112:      *</div><div class=\"line\">113:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">114:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">115:      * <span class=\"doctag\">@param</span> maxOffset 消费队列最大offset</div><div class=\"line\">116:      */</div><div class=\"line\"><span class=\"number\">117</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyMessageArriving</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">118</span>:         notifyMessageArriving(topic, queueId, maxOffset, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">119</span>:     &#125;</div><div class=\"line\"><span class=\"number\">120</span>: </div><div class=\"line\"><span class=\"number\">121</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">122:      * 检查是否有需要通知的请求</div><div class=\"line\">123:      *</div><div class=\"line\">124:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">125:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">126:      * <span class=\"doctag\">@param</span> maxOffset 消费队列最大offset</div><div class=\"line\">127:      * <span class=\"doctag\">@param</span> tagsCode 过滤tagsCode</div><div class=\"line\">128:      */</div><div class=\"line\"><span class=\"number\">129</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyMessageArriving</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> maxOffset, <span class=\"keyword\">final</span> Long tagsCode)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">130</span>:         String key = <span class=\"keyword\">this</span>.buildKey(topic, queueId);</div><div class=\"line\"><span class=\"number\">131</span>:         ManyPullRequest mpr = <span class=\"keyword\">this</span>.pullRequestTable.get(key);</div><div class=\"line\"><span class=\"number\">132</span>:         <span class=\"keyword\">if</span> (mpr != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">133</span>:             <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">134</span>:             List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</div><div class=\"line\"><span class=\"number\">135</span>:             <span class=\"keyword\">if</span> (requestList != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">136</span>:                 List&lt;PullRequest&gt; replayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 不符合唤醒的请求数组</span></div><div class=\"line\"><span class=\"number\">137</span>: </div><div class=\"line\"><span class=\"number\">138</span>:                 <span class=\"keyword\">for</span> (PullRequest request : requestList) &#123;</div><div class=\"line\"><span class=\"number\">139</span>:                     <span class=\"comment\">// 如果 maxOffset 过小，则重新读取一次。</span></div><div class=\"line\"><span class=\"number\">140</span>:                     <span class=\"keyword\">long</span> newestOffset = maxOffset;</div><div class=\"line\"><span class=\"number\">141</span>:                     <span class=\"keyword\">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</div><div class=\"line\"><span class=\"number\">142</span>:                         newestOffset = <span class=\"keyword\">this</span>.brokerController.getMessageStore().getMaxOffsetInQuque(topic, queueId);</div><div class=\"line\"><span class=\"number\">143</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">144</span>:                     <span class=\"comment\">// 有新的匹配消息，唤醒请求，即再次拉取消息。</span></div><div class=\"line\"><span class=\"number\">145</span>:                     <span class=\"keyword\">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</div><div class=\"line\"><span class=\"number\">146</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.messageFilter.isMessageMatched(request.getSubscriptionData(), tagsCode)) &#123;</div><div class=\"line\"><span class=\"number\">147</span>:                             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">148</span>:                                 <span class=\"keyword\">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class=\"line\"><span class=\"number\">149</span>:                                     request.getRequestCommand());</div><div class=\"line\"><span class=\"number\">150</span>:                             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">151</span>:                                 log.error(<span class=\"string\">\"execute request when wakeup failed.\"</span>, e);</div><div class=\"line\"><span class=\"number\">152</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">153</span>:                             <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">154</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">155</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">156</span>:                     <span class=\"comment\">// 超过挂起时间，唤醒请求，即再次拉取消息。</span></div><div class=\"line\"><span class=\"number\">157</span>:                     <span class=\"keyword\">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</div><div class=\"line\"><span class=\"number\">158</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">159</span>:                             <span class=\"keyword\">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</div><div class=\"line\"><span class=\"number\">160</span>:                                 request.getRequestCommand());</div><div class=\"line\"><span class=\"number\">161</span>:                         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">162</span>:                             log.error(<span class=\"string\">\"execute request when wakeup failed.\"</span>, e);</div><div class=\"line\"><span class=\"number\">163</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">164</span>:                         <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">165</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">166</span>:                     <span class=\"comment\">// 不符合再次拉取的请求，再次添加回去</span></div><div class=\"line\"><span class=\"number\">167</span>:                     replayList.add(request);</div><div class=\"line\"><span class=\"number\">168</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">169</span>:                 <span class=\"comment\">// 添加回去</span></div><div class=\"line\"><span class=\"number\">170</span>:                 <span class=\"keyword\">if</span> (!replayList.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">171</span>:                     mpr.addPullRequest(replayList);</div><div class=\"line\"><span class=\"number\">172</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">173</span>:             &#125;</div><div class=\"line\"><span class=\"number\">174</span>:         &#125;</div><div class=\"line\"><span class=\"number\">175</span>:     &#125;</div><div class=\"line\"><span class=\"number\">176</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>PullRequestHoldService</code> 说明 ：拉取消息请求挂起维护线程服务。<ul>\n<li>当拉取消息请求获得不了消息时，则会将请求进行挂起，添加到该服务。</li>\n<li>当有符合条件信息时 或 挂起超时时，重新执行获取消息逻辑。</li>\n</ul>\n</li>\n<li><code>#suspendPullRequest(...)</code> 说明 ：添加拉取消息挂起请求到集合( <code>pullRequestTable</code> )。</li>\n<li><code>#run(...)</code> 说明 ：<strong>定时</strong>检查挂起请求是否有需要通知重新拉取消息并进行通知。<ul>\n<li>第 65 至 70 行 ：根据<code>长轮训</code>or<code>短轮训</code>设置不同的等待时间。</li>\n<li>第 71 至 77 行 ：检查挂起请求是否有需要通知的。</li>\n</ul>\n</li>\n<li><code>#checkHoldRequest(...)</code> 说明 ：遍历挂起请求，检查是否有需要通知的。</li>\n<li><code>#notifyMessageArriving(...)</code> 说明 ：检查<strong>指定队列</strong>是否有需要通知的请求。<ul>\n<li>第 139 至 143 行 ：如果 <code>maxOffset</code> 过小，重新获取一次最新的。</li>\n<li>第 144 至 155 行 ：有新的匹配消息，唤醒请求，即再次拉取消息。</li>\n<li>第 156 至 165 行 ：超过挂起时间，唤醒请求，即再次拉取消息。</li>\n<li>第 148 || 159 行 ：唤醒请求，再次拉取消息。原先担心拉取消息时间过长，导致影响整个挂起请求的遍历，后面查看<code>#executeRequestWhenWakeup(...)</code>，实际是丢到线程池进行一步的消息拉取，不会有性能上的问题。详细解析见：<a href=\"pullmessageprocessorexecuterequestwhenwakeup\">PullMessageProcessor#executeRequestWhenWakeup(…)</a>。</li>\n<li>第 166 至 172 行 ：不符合唤醒的请求重新添加到集合(<code>pullRequestTable</code>)。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PullMessageProcessor-executeRequestWhenWakeup-…\"><a href=\"#PullMessageProcessor-executeRequestWhenWakeup-…\" class=\"headerlink\" title=\"PullMessageProcessor#executeRequestWhenWakeup(…)\"></a>PullMessageProcessor#executeRequestWhenWakeup(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeRequestWhenWakeup</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel channel, <span class=\"keyword\">final</span> RemotingCommand request)</span> <span class=\"keyword\">throws</span> RemotingCommandException </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     Runnable run = <span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 <span class=\"comment\">// 调用拉取请求。本次调用，设置不挂起请求。</span></div><div class=\"line\"> <span class=\"number\">7</span>:                 <span class=\"keyword\">final</span> RemotingCommand response = PullMessageProcessor.<span class=\"keyword\">this</span>.processRequest(channel, request, <span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:                 <span class=\"keyword\">if</span> (response != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                     response.setOpaque(request.getOpaque());</div><div class=\"line\"><span class=\"number\">11</span>:                     response.markResponseType();</div><div class=\"line\"><span class=\"number\">12</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                         channel.writeAndFlush(response).addListener(<span class=\"keyword\">new</span> ChannelFutureListener() &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">15</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:                                 <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                                     LOG.error(<span class=\"string\">\"ProcessRequestWrapper response to &#123;&#125; failed\"</span>, future.channel().remoteAddress(), future.cause());</div><div class=\"line\"><span class=\"number\">18</span>:                                     LOG.error(request.toString());</div><div class=\"line\"><span class=\"number\">19</span>:                                     LOG.error(response.toString());</div><div class=\"line\"><span class=\"number\">20</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">22</span>:                         &#125;);</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                         LOG.error(<span class=\"string\">\"ProcessRequestWrapper process request over, but response failed\"</span>, e);</div><div class=\"line\"><span class=\"number\">25</span>:                         LOG.error(request.toString());</div><div class=\"line\"><span class=\"number\">26</span>:                         LOG.error(response.toString());</div><div class=\"line\"><span class=\"number\">27</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">28</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">29</span>:             &#125; <span class=\"keyword\">catch</span> (RemotingCommandException e1) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                 LOG.error(<span class=\"string\">\"ExecuteRequestWhenWakeup run\"</span>, e1);</div><div class=\"line\"><span class=\"number\">31</span>:             &#125;</div><div class=\"line\"><span class=\"number\">32</span>:         &#125;</div><div class=\"line\"><span class=\"number\">33</span>:     &#125;;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 提交拉取请求到线程池</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">this</span>.brokerController.getPullMessageExecutor().submit(<span class=\"keyword\">new</span> RequestTask(run, channel, request));</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：执行请求唤醒，即再次拉取消息。该方法调用线程池，因此，不会阻塞。</li>\n<li>第 7 行 ：调用拉取消息请求。本次调用，设置即使请求不到消息，也不挂起请求。如果不设置，请求可能被无限挂起，被 <code>Broker</code> 无限循环。</li>\n<li>第 35 行 ：<strong>提交拉取消息请求到线程池</strong>。</li>\n</ul>\n<h1 id=\"5、Broker-提供-更新消费进度-接口\"><a href=\"#5、Broker-提供-更新消费进度-接口\" class=\"headerlink\" title=\"5、Broker 提供[更新消费进度]接口\"></a>5、Broker 提供[更新消费进度]接口</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ <span class=\"built_in\">pwd</span></div><div class=\"line\">/Users/yunai/store/config</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ ls -ls</div><div class=\"line\">total 40</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 consumerOffset.json.bak</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff    21  4 28 16:58 delayOffset.json.bak</div><div class=\"line\">8 -rw-r--r--  1 yunai  staff  1401  4 27 21:51 topics.json</div><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ cat consumerOffset.json</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"offsetTable\"</span>:&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"%RETRY%please_rename_unique_group_name_4@please_rename_unique_group_name_4\"</span>:&#123;0:0</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\t<span class=\"string\">\"TopicRead3@please_rename_unique_group_name_4\"</span>:&#123;1:5</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>consumerOffset.json</code> ：消费进度存储文件。</li>\n<li><code>consumerOffset.json.bak</code> ：消费进度存储文件备份。</li>\n<li>每次写入 <code>consumerOffset.json</code>，将原内容备份到 <code>consumerOffset.json.bak</code>。实现见：<a href=\"mixallstring2file\">MixAll#string2File(…)</a>。</li>\n</ul>\n<h2 id=\"BrokerController-initialize-…\"><a href=\"#BrokerController-initialize-…\" class=\"headerlink\" title=\"BrokerController#initialize(…)\"></a>BrokerController#initialize(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>:<span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">2</span>:    <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">3</span>:    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">4</span>:        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:            BrokerController.<span class=\"keyword\">this</span>.consumerOffsetManager.persist();</div><div class=\"line\"> <span class=\"number\">6</span>:        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:            log.error(<span class=\"string\">\"schedule persist consumerOffset error.\"</span>, e);</div><div class=\"line\"> <span class=\"number\">8</span>:        &#125;</div><div class=\"line\"> <span class=\"number\">9</span>:    &#125;</div><div class=\"line\"><span class=\"number\">10</span>:&#125;, <span class=\"number\">1000</span> * <span class=\"number\">10</span>, <span class=\"keyword\">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：每 5s 执行一次持久化逻辑。</li>\n</ul>\n<h2 id=\"ConfigManager\"><a href=\"#ConfigManager\" class=\"headerlink\" title=\"ConfigManager\"></a>ConfigManager</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConfigManager</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger PLOG = LoggerFactory.getLogger(LoggerName.COMMON_LOGGER_NAME);</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 5:  * 编码内容</div><div class=\"line\"> 6:  * <span class=\"doctag\">@return</span> 编码后的内容</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">encode</span><span class=\"params\">()</span></span>;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"comment\">/**</span></div><div class=\"line\">11:  * 加载文件</div><div class=\"line\">12:  *</div><div class=\"line\">13:  * <span class=\"doctag\">@return</span> 加载是否成功</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:     String fileName = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:         fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">19</span>:         String jsonString = MixAll.file2String(fileName);</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 如果内容不存在，则加载备份文件</span></div><div class=\"line\"><span class=\"number\">21</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == jsonString || jsonString.length() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loadBak();</div><div class=\"line\"><span class=\"number\">23</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">this</span>.decode(jsonString);</div><div class=\"line\"><span class=\"number\">25</span>:             PLOG.info(<span class=\"string\">\"load &#123;&#125; OK\"</span>, fileName);</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">27</span>:         &#125;</div><div class=\"line\"><span class=\"number\">28</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:         PLOG.error(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" Failed, and try to load backup file\"</span>, e);</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.loadBak();</div><div class=\"line\"><span class=\"number\">31</span>:     &#125;</div><div class=\"line\"><span class=\"number\">32</span>: &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>: <span class=\"comment\">/**</span></div><div class=\"line\">35:  * 配置文件地址</div><div class=\"line\">36:  *</div><div class=\"line\">37:  * <span class=\"doctag\">@return</span> 配置文件地址</div><div class=\"line\">38:  */</div><div class=\"line\"><span class=\"number\">39</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">configFilePath</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"number\">40</span>: </div><div class=\"line\"><span class=\"number\">41</span>: <span class=\"comment\">/**</span></div><div class=\"line\">42:  * 加载备份文件</div><div class=\"line\">43:  *</div><div class=\"line\">44:  * <span class=\"doctag\">@return</span> 是否成功</div><div class=\"line\">45:  */</div><div class=\"line\"><span class=\"number\">46</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">loadBak</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">47</span>:     String fileName = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">48</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">49</span>:         fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">50</span>:         String jsonString = MixAll.file2String(fileName + <span class=\"string\">\".bak\"</span>);</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span> &amp;&amp; jsonString.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">52</span>:             <span class=\"keyword\">this</span>.decode(jsonString);</div><div class=\"line\"><span class=\"number\">53</span>:             PLOG.info(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" OK\"</span>);</div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">55</span>:         &#125;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">57</span>:         PLOG.error(<span class=\"string\">\"load \"</span> + fileName + <span class=\"string\">\" Failed\"</span>, e);</div><div class=\"line\"><span class=\"number\">58</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">59</span>:     &#125;</div><div class=\"line\"><span class=\"number\">60</span>: </div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">62</span>: &#125;</div><div class=\"line\"><span class=\"number\">63</span>: </div><div class=\"line\"><span class=\"number\">64</span>: <span class=\"comment\">/**</span></div><div class=\"line\">65:  * 解码内容</div><div class=\"line\">66:  *</div><div class=\"line\">67:  * <span class=\"doctag\">@param</span> jsonString 内容</div><div class=\"line\">68:  */</div><div class=\"line\"><span class=\"number\">69</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(<span class=\"keyword\">final</span> String jsonString)</span></span>;</div><div class=\"line\"><span class=\"number\">70</span>: </div><div class=\"line\"><span class=\"number\">71</span>: <span class=\"comment\">/**</span></div><div class=\"line\">72:  * 持久化</div><div class=\"line\">73:  */</div><div class=\"line\"><span class=\"number\">74</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">persist</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">75</span>:     String jsonString = <span class=\"keyword\">this</span>.encode(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">76</span>:     <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">77</span>:         String fileName = <span class=\"keyword\">this</span>.configFilePath();</div><div class=\"line\"><span class=\"number\">78</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">79</span>:             MixAll.string2File(jsonString, fileName);</div><div class=\"line\"><span class=\"number\">80</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">81</span>:             PLOG.error(<span class=\"string\">\"persist file Exception, \"</span> + fileName, e);</div><div class=\"line\"><span class=\"number\">82</span>:         &#125;</div><div class=\"line\"><span class=\"number\">83</span>:     &#125;</div><div class=\"line\"><span class=\"number\">84</span>: &#125;</div><div class=\"line\"><span class=\"number\">85</span>: </div><div class=\"line\"><span class=\"number\">86</span>: <span class=\"comment\">/**</span></div><div class=\"line\">87:  * 编码存储内容</div><div class=\"line\">88:  *</div><div class=\"line\">89:  * <span class=\"doctag\">@param</span> prettyFormat 是否格式化</div><div class=\"line\">90:  * <span class=\"doctag\">@return</span> 内容</div><div class=\"line\">91:  */</div><div class=\"line\"><span class=\"number\">92</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">encode</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> prettyFormat)</span></span>;</div><div class=\"line\"><span class=\"number\">93</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"MixAll-string2File-…\"><a href=\"#MixAll-string2File-…\" class=\"headerlink\" title=\"MixAll#string2File(…)\"></a>MixAll#string2File(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 将内容写到文件</div><div class=\"line\"> 3:  * 安全写</div><div class=\"line\"> 4:  * 1. 写到.tmp文件</div><div class=\"line\"> 5:  * 2. 备份准备写入文件到.bak文件</div><div class=\"line\"> 6:  * 3. 删除原文件，将.tmp修改成文件</div><div class=\"line\"> 7:  *</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> str 内容</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> fileName 文件名</div><div class=\"line\">10:  * <span class=\"doctag\">@throws</span> IOException 当IO发生异常时</div><div class=\"line\">11:  */</div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">string2File</span><span class=\"params\">(<span class=\"keyword\">final</span> String str, <span class=\"keyword\">final</span> String fileName)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"comment\">// 写到 tmp文件</span></div><div class=\"line\"><span class=\"number\">14</span>:     String tmpFile = fileName + <span class=\"string\">\".tmp\"</span>;</div><div class=\"line\"><span class=\"number\">15</span>:     string2FileNotSafe(str, tmpFile);</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">17</span>:     String bakFile = fileName + <span class=\"string\">\".bak\"</span>;</div><div class=\"line\"><span class=\"number\">18</span>:     String prevContent = file2String(fileName);</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (prevContent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:         string2FileNotSafe(prevContent, bakFile);</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>:     File file = <span class=\"keyword\">new</span> File(fileName);</div><div class=\"line\"><span class=\"number\">24</span>:     file.delete();</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     file = <span class=\"keyword\">new</span> File(tmpFile);</div><div class=\"line\"><span class=\"number\">27</span>:     file.renameTo(<span class=\"keyword\">new</span> File(fileName));</div><div class=\"line\"><span class=\"number\">28</span>: &#125;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">/**</span></div><div class=\"line\">31:  * 将内容写到文件</div><div class=\"line\">32:  * 非安全写</div><div class=\"line\">33:  *</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> str 内容</div><div class=\"line\">35:  * <span class=\"doctag\">@param</span> fileName 文件内容</div><div class=\"line\">36:  * <span class=\"doctag\">@throws</span> IOException 当IO发生异常时</div><div class=\"line\">37:  */</div><div class=\"line\"><span class=\"number\">38</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">string2FileNotSafe</span><span class=\"params\">(<span class=\"keyword\">final</span> String str, <span class=\"keyword\">final</span> String fileName)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</div><div class=\"line\"><span class=\"number\">39</span>:     File file = <span class=\"keyword\">new</span> File(fileName);</div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"comment\">// 创建上级目录</span></div><div class=\"line\"><span class=\"number\">41</span>:     File fileParent = file.getParentFile();</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">if</span> (fileParent != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">43</span>:         fileParent.mkdirs();</div><div class=\"line\"><span class=\"number\">44</span>:     &#125;</div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 写内容</span></div><div class=\"line\"><span class=\"number\">46</span>:     FileWriter fileWriter = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:         fileWriter = <span class=\"keyword\">new</span> FileWriter(file);</div><div class=\"line\"><span class=\"number\">49</span>:         fileWriter.write(str);</div><div class=\"line\"><span class=\"number\">50</span>:     &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:         <span class=\"keyword\">throw</span> e;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>:         <span class=\"keyword\">if</span> (fileWriter != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">54</span>:             fileWriter.close();</div><div class=\"line\"><span class=\"number\">55</span>:         &#125;</div><div class=\"line\"><span class=\"number\">56</span>:     &#125;</div><div class=\"line\"><span class=\"number\">57</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ConsumerOffsetManager\"><a href=\"#ConsumerOffsetManager\" class=\"headerlink\" title=\"ConsumerOffsetManager\"></a>ConsumerOffsetManager</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumerOffsetManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ConfigManager</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger log = LoggerFactory.getLogger(LoggerName.BROKER_LOGGER_NAME);</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TOPIC_GROUP_SEPARATOR = <span class=\"string\">\"@\"</span>;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 6:      * 消费进度集合</div><div class=\"line\"> 7:      */</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* topic@group */</span>, ConcurrentHashMap&lt;Integer, Long&gt;&gt; offsetTable = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">512</span>);</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> BrokerController brokerController;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumerOffsetManager</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumerOffsetManager</span><span class=\"params\">(BrokerController brokerController)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.brokerController = brokerController;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">20:      * 提交消费进度</div><div class=\"line\">21:      *</div><div class=\"line\">22:      * <span class=\"doctag\">@param</span> clientHost 提交client地址</div><div class=\"line\">23:      * <span class=\"doctag\">@param</span> group 消费分组</div><div class=\"line\">24:      * <span class=\"doctag\">@param</span> topic 主题</div><div class=\"line\">25:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">26:      * <span class=\"doctag\">@param</span> offset 进度（队列位置）</div><div class=\"line\">27:      */</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">commitOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> String clientHost, <span class=\"keyword\">final</span> String group, <span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"comment\">// topic@group</span></div><div class=\"line\"><span class=\"number\">30</span>:         String key = topic + TOPIC_GROUP_SEPARATOR + group;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">this</span>.commitOffset(clientHost, key, queueId, offset);</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">35:      * 提交消费进度</div><div class=\"line\">36:      *</div><div class=\"line\">37:      * <span class=\"doctag\">@param</span> clientHost 提交client地址</div><div class=\"line\">38:      * <span class=\"doctag\">@param</span> key 主题@消费分组</div><div class=\"line\">39:      * <span class=\"doctag\">@param</span> queueId 队列编号</div><div class=\"line\">40:      * <span class=\"doctag\">@param</span> offset 进度（队列位置）</div><div class=\"line\">41:      */</div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">commitOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> String clientHost, <span class=\"keyword\">final</span> String key, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> queueId, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">43</span>:         ConcurrentHashMap&lt;Integer, Long&gt; map = <span class=\"keyword\">this</span>.offsetTable.get(key);</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == map) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:             map = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;(<span class=\"number\">32</span>);</div><div class=\"line\"><span class=\"number\">46</span>:             map.put(queueId, offset);</div><div class=\"line\"><span class=\"number\">47</span>:             <span class=\"keyword\">this</span>.offsetTable.put(key, map);</div><div class=\"line\"><span class=\"number\">48</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">49</span>:             Long storeOffset = map.put(queueId, offset);</div><div class=\"line\"><span class=\"number\">50</span>:             <span class=\"keyword\">if</span> (storeOffset != <span class=\"keyword\">null</span> &amp;&amp; offset &lt; storeOffset) &#123;</div><div class=\"line\"><span class=\"number\">51</span>:                 log.warn(<span class=\"string\">\"[NOTIFYME]update consumer offset less than store. clientHost=&#123;&#125;, key=&#123;&#125;, queueId=&#123;&#125;, requestOffset=&#123;&#125;, storeOffset=&#123;&#125;\"</span>, clientHost, key, queueId, offset, storeOffset);</div><div class=\"line\"><span class=\"number\">52</span>:             &#125;</div><div class=\"line\"><span class=\"number\">53</span>:         &#125;</div><div class=\"line\"><span class=\"number\">54</span>:     &#125;</div><div class=\"line\"><span class=\"number\">55</span>: </div><div class=\"line\"><span class=\"number\">56</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">57</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.encode(<span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">58</span>:     &#125;</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">configFilePath</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">62</span>:         <span class=\"keyword\">return</span> BrokerPathConfigHelper.getConsumerOffsetPath(<span class=\"keyword\">this</span>.brokerController.getMessageStoreConfig().getStorePathRootDir());</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">66:      * 解码内容</div><div class=\"line\">67:      * 格式:JSON</div><div class=\"line\">68:      *</div><div class=\"line\">69:      * <span class=\"doctag\">@param</span> jsonString 内容</div><div class=\"line\">70:      */</div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">72</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">decode</span><span class=\"params\">(String jsonString)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:             ConsumerOffsetManager obj = RemotingSerializable.fromJson(jsonString, ConsumerOffsetManager.class);</div><div class=\"line\"><span class=\"number\">75</span>:             <span class=\"keyword\">if</span> (obj != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">76</span>:                 <span class=\"keyword\">this</span>.offsetTable = obj.offsetTable;</div><div class=\"line\"><span class=\"number\">77</span>:             &#125;</div><div class=\"line\"><span class=\"number\">78</span>:         &#125;</div><div class=\"line\"><span class=\"number\">79</span>:     &#125;</div><div class=\"line\"><span class=\"number\">80</span>: </div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">82:      * 编码内容</div><div class=\"line\">83:      * 格式为JSON</div><div class=\"line\">84:      *</div><div class=\"line\">85:      * <span class=\"doctag\">@param</span> prettyFormat 是否格式化</div><div class=\"line\">86:      * <span class=\"doctag\">@return</span> 编码后的内容</div><div class=\"line\">87:      */</div><div class=\"line\"><span class=\"number\">88</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">encode</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> prettyFormat)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">89</span>:         <span class=\"keyword\">return</span> RemotingSerializable.toJson(<span class=\"keyword\">this</span>, prettyFormat);</div><div class=\"line\"><span class=\"number\">90</span>:     &#125;</div><div class=\"line\"><span class=\"number\">91</span>: </div><div class=\"line\"><span class=\"number\">92</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消费进度管理器。</li>\n</ul>\n<h1 id=\"6、Broker-提供-发回消息-接口\"><a href=\"#6、Broker-提供-发回消息-接口\" class=\"headerlink\" title=\"6、Broker 提供[发回消息]接口\"></a>6、Broker 提供[发回消息]接口</h1><p>大部分逻辑和 <a href=\"http://www.yunai.me/RocketMQ/message-send-and-receive/#3、Broker-接收消息\"><code>Broker</code> 提供[接收消息]接口</a> 类似，可以先看下相关内容。</p>\n<h2 id=\"SendMessageProcessor-consumerSendMsgBack-…\"><a href=\"#SendMessageProcessor-consumerSendMsgBack-…\" class=\"headerlink\" title=\"SendMessageProcessor#consumerSendMsgBack(…)\"></a>SendMessageProcessor#consumerSendMsgBack(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> RemotingCommand <span class=\"title\">consumerSendMsgBack</span><span class=\"params\">(<span class=\"keyword\">final</span> ChannelHandlerContext ctx, <span class=\"keyword\">final</span> RemotingCommand request)</span></span></div><div class=\"line\">  2:     <span class=\"keyword\">throws</span> RemotingCommandException &#123;</div><div class=\"line\">  <span class=\"number\">3</span>: </div><div class=\"line\">  <span class=\"number\">4</span>:     <span class=\"comment\">// 初始化响应</span></div><div class=\"line\">  <span class=\"number\">5</span>:     <span class=\"keyword\">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class=\"keyword\">null</span>);</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</div><div class=\"line\">  <span class=\"number\">7</span>:         (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</div><div class=\"line\">  <span class=\"number\">8</span>: </div><div class=\"line\">  <span class=\"number\">9</span>:     <span class=\"comment\">// hook（独有）</span></div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</div><div class=\"line\"> <span class=\"number\">11</span>: </div><div class=\"line\"> <span class=\"number\">12</span>:         ConsumeMessageContext context = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"> <span class=\"number\">13</span>:         context.setConsumerGroup(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">14</span>:         context.setTopic(requestHeader.getOriginTopic());</div><div class=\"line\"> <span class=\"number\">15</span>:         context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</div><div class=\"line\"> <span class=\"number\">16</span>:         context.setCommercialRcvTimes(<span class=\"number\">1</span>);</div><div class=\"line\"> <span class=\"number\">17</span>:         context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</div><div class=\"line\"> <span class=\"number\">18</span>: </div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">this</span>.executeConsumeMessageHookAfter(context);</div><div class=\"line\"> <span class=\"number\">20</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"comment\">// 判断消费分组是否存在（独有）</span></div><div class=\"line\"> <span class=\"number\">23</span>:     SubscriptionGroupConfig subscriptionGroupConfig =</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"keyword\">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">25</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionGroupConfig) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:         response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</div><div class=\"line\"> <span class=\"number\">27</span>:         response.setRemark(<span class=\"string\">\"subscription group not exist, \"</span> + requestHeader.getGroup() + <span class=\"string\">\" \"</span></div><div class=\"line\"> <span class=\"number\">28</span>:             + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</div><div class=\"line\"> <span class=\"number\">29</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">30</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">31</span>: </div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"comment\">// 检查 broker 是否有写入权限</span></div><div class=\"line\"> <span class=\"number\">33</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(<span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</div><div class=\"line\"> <span class=\"number\">34</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">35</span>:         response.setRemark(<span class=\"string\">\"the broker[\"</span> + <span class=\"keyword\">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class=\"string\">\"] sending message is forbidden\"</span>);</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">37</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"comment\">// 检查 重试队列数 是否大于0（独有）</span></div><div class=\"line\"> <span class=\"number\">40</span>:     <span class=\"keyword\">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:         response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"> <span class=\"number\">42</span>:         response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">44</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:     <span class=\"comment\">// 计算retry Topic</span></div><div class=\"line\"> <span class=\"number\">47</span>:     String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</div><div class=\"line\"> <span class=\"number\">48</span>: </div><div class=\"line\"> <span class=\"number\">49</span>:     <span class=\"comment\">// 计算队列编号（独有）</span></div><div class=\"line\"> <span class=\"number\">50</span>:     <span class=\"keyword\">int</span> queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</div><div class=\"line\"> <span class=\"number\">51</span>: </div><div class=\"line\"> <span class=\"number\">52</span>:     <span class=\"comment\">// 计算sysFlag（独有）</span></div><div class=\"line\"> <span class=\"number\">53</span>:     <span class=\"keyword\">int</span> topicSysFlag = <span class=\"number\">0</span>;</div><div class=\"line\"> <span class=\"number\">54</span>:     <span class=\"keyword\">if</span> (requestHeader.isUnitMode()) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:         topicSysFlag = TopicSysFlag.buildSysFlag(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">56</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:     <span class=\"comment\">// 获取topicConfig。如果获取不到，则进行创建</span></div><div class=\"line\"> <span class=\"number\">59</span>:     TopicConfig topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">60</span>:         newTopic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">61</span>:         subscriptionGroupConfig.getRetryQueueNums(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">62</span>:         PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</div><div class=\"line\"> <span class=\"number\">63</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123; <span class=\"comment\">// 没有配置</span></div><div class=\"line\"> <span class=\"number\">64</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">65</span>:         response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">67</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">68</span>:     <span class=\"keyword\">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123; <span class=\"comment\">// 不允许写入</span></div><div class=\"line\"> <span class=\"number\">69</span>:         response.setCode(ResponseCode.NO_PERMISSION);</div><div class=\"line\"> <span class=\"number\">70</span>:         response.setRemark(String.format(<span class=\"string\">\"the topic[%s] sending message is forbidden\"</span>, newTopic));</div><div class=\"line\"> <span class=\"number\">71</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">72</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">73</span>: </div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"comment\">// 查询消息。若不存在，返回异常错误。（独有）</span></div><div class=\"line\"> <span class=\"number\">75</span>:     MessageExt msgExt = <span class=\"keyword\">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</div><div class=\"line\"> <span class=\"number\">76</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == msgExt) &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"> <span class=\"number\">78</span>:         response.setRemark(<span class=\"string\">\"look message by offset failed, \"</span> + requestHeader.getOffset());</div><div class=\"line\"> <span class=\"number\">79</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"> <span class=\"number\">80</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:     <span class=\"comment\">// 设置retryTopic到拓展属性（独有）</span></div><div class=\"line\"> <span class=\"number\">83</span>:     <span class=\"keyword\">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == retryTopic) &#123;</div><div class=\"line\"> <span class=\"number\">85</span>:         MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</div><div class=\"line\"> <span class=\"number\">86</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:     <span class=\"comment\">// 设置消息不等待存储完成（独有） TODO 疑问：如果设置成不等待存储，broker设置成同步落盘，岂不是不能批量提交了？</span></div><div class=\"line\"> <span class=\"number\">89</span>:     msgExt.setWaitStoreMsgOK(<span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">90</span>: </div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"comment\">// 处理 delayLevel（独有）。</span></div><div class=\"line\"> <span class=\"number\">92</span>:     <span class=\"keyword\">int</span> delayLevel = requestHeader.getDelayLevel();</div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"keyword\">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</div><div class=\"line\"> <span class=\"number\">94</span>:     <span class=\"keyword\">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</div><div class=\"line\"> <span class=\"number\">95</span>:         maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</div><div class=\"line\"> <span class=\"number\">96</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">97</span>:     <span class=\"keyword\">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">98</span>:         || delayLevel &lt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果超过最大消费次数，则topic修改成\"%DLQ%\" + 分组名，即加入 死信队列(Dead Letter Queue)</span></div><div class=\"line\"> <span class=\"number\">99</span>:         newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</div><div class=\"line\"><span class=\"number\">100</span>:         queueIdInt = Math.abs(<span class=\"keyword\">this</span>.random.nextInt() % <span class=\"number\">99999999</span>) % DLQ_NUMS_PER_GROUP;</div><div class=\"line\"><span class=\"number\">101</span>: </div><div class=\"line\"><span class=\"number\">102</span>:         topicConfig = <span class=\"keyword\">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">103</span>:             DLQ_NUMS_PER_GROUP, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">104</span>:             PermName.PERM_WRITE, <span class=\"number\">0</span></div><div class=\"line\"><span class=\"number\">105</span>:         );</div><div class=\"line\"><span class=\"number\">106</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == topicConfig) &#123;</div><div class=\"line\"><span class=\"number\">107</span>:             response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">108</span>:             response.setRemark(<span class=\"string\">\"topic[\"</span> + newTopic + <span class=\"string\">\"] not exist\"</span>);</div><div class=\"line\"><span class=\"number\">109</span>:             <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">110</span>:         &#125;</div><div class=\"line\"><span class=\"number\">111</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == delayLevel) &#123;</div><div class=\"line\"><span class=\"number\">113</span>:             delayLevel = <span class=\"number\">3</span> + msgExt.getReconsumeTimes();</div><div class=\"line\"><span class=\"number\">114</span>:         &#125;</div><div class=\"line\"><span class=\"number\">115</span>:         msgExt.setDelayTimeLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">116</span>:     &#125;</div><div class=\"line\"><span class=\"number\">117</span>: </div><div class=\"line\"><span class=\"number\">118</span>:     <span class=\"comment\">// 创建MessageExtBrokerInner</span></div><div class=\"line\"><span class=\"number\">119</span>:     MessageExtBrokerInner msgInner = <span class=\"keyword\">new</span> MessageExtBrokerInner();</div><div class=\"line\"><span class=\"number\">120</span>:     msgInner.setTopic(newTopic);</div><div class=\"line\"><span class=\"number\">121</span>:     msgInner.setBody(msgExt.getBody());</div><div class=\"line\"><span class=\"number\">122</span>:     msgInner.setFlag(msgExt.getFlag());</div><div class=\"line\"><span class=\"number\">123</span>:     MessageAccessor.setProperties(msgInner, msgExt.getProperties());</div><div class=\"line\"><span class=\"number\">124</span>:     msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</div><div class=\"line\"><span class=\"number\">125</span>:     msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class=\"keyword\">null</span>, msgExt.getTags()));</div><div class=\"line\"><span class=\"number\">126</span>:     msgInner.setQueueId(queueIdInt);</div><div class=\"line\"><span class=\"number\">127</span>:     msgInner.setSysFlag(msgExt.getSysFlag());</div><div class=\"line\"><span class=\"number\">128</span>:     msgInner.setBornTimestamp(msgExt.getBornTimestamp());</div><div class=\"line\"><span class=\"number\">129</span>:     msgInner.setBornHost(msgExt.getBornHost());</div><div class=\"line\"><span class=\"number\">130</span>:     msgInner.setStoreHost(<span class=\"keyword\">this</span>.getStoreHost());</div><div class=\"line\"><span class=\"number\">131</span>:     msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">132</span>: </div><div class=\"line\"><span class=\"number\">133</span>:     <span class=\"comment\">// 设置原始消息编号到拓展字段（独有）</span></div><div class=\"line\"><span class=\"number\">134</span>:     String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</div><div class=\"line\"><span class=\"number\">135</span>:     MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:     <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">138</span>:     PutMessageResult putMessageResult = <span class=\"keyword\">this</span>.brokerController.getMessageStore().putMessage(msgInner);</div><div class=\"line\"><span class=\"number\">139</span>:     <span class=\"keyword\">if</span> (putMessageResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">140</span>:         <span class=\"keyword\">switch</span> (putMessageResult.getPutMessageStatus()) &#123;</div><div class=\"line\"><span class=\"number\">141</span>:             <span class=\"keyword\">case</span> PUT_OK:</div><div class=\"line\"><span class=\"number\">142</span>:                 String backTopic = msgExt.getTopic();</div><div class=\"line\"><span class=\"number\">143</span>:                 String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</div><div class=\"line\"><span class=\"number\">144</span>:                 <span class=\"keyword\">if</span> (correctTopic != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                     backTopic = correctTopic;</div><div class=\"line\"><span class=\"number\">146</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">147</span>: </div><div class=\"line\"><span class=\"number\">148</span>:                 <span class=\"keyword\">this</span>.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic);</div><div class=\"line\"><span class=\"number\">149</span>: </div><div class=\"line\"><span class=\"number\">150</span>:                 response.setCode(ResponseCode.SUCCESS);</div><div class=\"line\"><span class=\"number\">151</span>:                 response.setRemark(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">152</span>: </div><div class=\"line\"><span class=\"number\">153</span>:                 <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">154</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">155</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">156</span>:         &#125;</div><div class=\"line\"><span class=\"number\">157</span>: </div><div class=\"line\"><span class=\"number\">158</span>:         response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">159</span>:         response.setRemark(putMessageResult.getPutMessageStatus().name());</div><div class=\"line\"><span class=\"number\">160</span>:         <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">161</span>:     &#125;</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:     response.setCode(ResponseCode.SYSTEM_ERROR);</div><div class=\"line\"><span class=\"number\">164</span>:     response.setRemark(<span class=\"string\">\"putMessageResult is null\"</span>);</div><div class=\"line\"><span class=\"number\">165</span>:     <span class=\"keyword\">return</span> response;</div><div class=\"line\"><span class=\"number\">166</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：当 <code>Consumer</code> 消费某条消息失败时，会调用该接口发回消息。<code>Broker</code> 会存储发回的消息。这样，下次 <code>Consumer</code> 拉取该消息，能够从 <code>CommitLog</code> 和 <code>ConsumeQueue</code> 顺序读取。</li>\n<li>[x] 因为大多数逻辑和 <strong><code>Broker</code> 接收普通消息</strong> 很相似，时候 <code>TODO</code> 标记成独有的逻辑。</li>\n<li>第 4 至 7 行 ：初始化响应。</li>\n<li>[x] 第 9 至 20 行 ：Hook逻辑。</li>\n<li>[x] 第22 至 30 行 ：判断消费分组是否存在。</li>\n<li>第 32 至 37 行 ：检查 <code>Broker</code> 是否有写入权限。</li>\n<li>[x] 第 39 至 44 行 ：检查重试队列数是否大于0。</li>\n<li>第 47 行 ：计算 retry topic。</li>\n<li>[x] 第 50 行 ：随机分配队列编号，依赖 <code>retryQueueNums</code>。</li>\n<li>[x] 第 52 至 56 行 ：计算 <code>sysFlag</code>。</li>\n<li>第 58 至 72 行 ：获取 <code>TopicConfig</code>。如果不存在，则创建。</li>\n<li>[x] 第 74 至 80 行 ：查询消息。若不存在，返回异常错误。</li>\n<li>[x] 第 82 至 86 行 ：设置 <code>retryTopic</code> 到消息拓展属性。</li>\n<li>[x] 第 89 行 ：设置消息不等待存储完成。<ul>\n<li>当 <code>Broker</code> 刷盘方式为同步，会导致同步落盘不能批量提交，这样会不会存在问题？有知道的同学麻烦告知下。😈。</li>\n</ul>\n</li>\n<li>[x] 第 91 至 116 行 ：处理 <code>delayLevel</code> 。</li>\n<li>第 118 至 131 行 ：创建 <code>MessageExtBrokerInner</code> 。</li>\n<li>[x] 第 133 至 135 行 ：设置原始消息编号到拓展属性。</li>\n<li>第 137 至 161 行 ：添加消息。</li>\n</ul>\n<h1 id=\"7、结尾\"><a href=\"#7、结尾\" class=\"headerlink\" title=\"7、结尾\"></a>7、结尾</h1><p>感谢同学们对本文的阅读、收藏、点赞。</p>\n<p>😈如果解析存在问题或者表达误解的，表示抱歉。如果方便的话，可以加下 <strong>QQ：7685413</strong>。让我们来一场 1 ：1 交流（搞基）。</p>\n<p>再次表示十分感谢。</p>\n"},{"title":"RocketMQ 源码分析 —— Message 拉取与消费（下）","date":"2017-05-10T16:00:00.000Z","_content":"\n>  原文地址：[http://www.yunai.me/RocketMQ/message-pull-and-consume-second/](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、Consumer](#)\n- [3、PushConsumer 一览](#)\n- [4、PushConsumer 订阅](#)\n\t- [DefaultMQPushConsumerImpl#subscribe(...)](#)\n\t\t- [FilterAPI.buildSubscriptionData(...)](#)\n\t- [DefaultMQPushConsumer#registerMessageListener(...)](#)\n- [5、PushConsumer 消息队列分配](#)\n\t- [RebalanceService](#)\n\t- [MQClientInstance#doRebalance(...)](#)\n\t- [DefaultMQPushConsumerImpl#doRebalance(...)](#)\n\t- [RebalanceImpl#doRebalance(...)](#)\n\t\t- [RebalanceImpl#rebalanceByTopic(...)](#)\n\t\t- [RebalanceImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t\t- [RebalancePushImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t\t- [[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t- [RebalancePushImpl#dispatchPullRequest(...)](#)\n\t\t\t- [DefaultMQPushConsumerImpl#executePullRequestImmediately(...)](#)\n\t\t- [AllocateMessageQueueStrategy](#)\n\t\t\t- [AllocateMessageQueueAveragely](#)\n\t\t\t- [AllocateMessageQueueByMachineRoom](#)\n\t\t\t- [AllocateMessageQueueAveragelyByCircle](#)\n\t\t\t- [AllocateMessageQueueByConfig](#)\n- [5、PushConsumer 消费进度读取](#)\n\t- [RebalancePushImpl#computePullFromWhere(...)](#)\n\t- [[PullConsumer] RebalancePullImpl#computePullFromWhere(...)](#)\n- [6、PushConsumer 拉取消息](#)\n\t- [PullMessageService](#)\n\t- [DefaultMQPushConsumerImpl#pullMessage(...)](#)\n\t\t- [PullAPIWrapper#pullKernelImpl(...)](#)\n\t\t\t- [PullAPIWrapper#recalculatePullFromWhichNode(...)](#)\n\t\t\t- [MQClientInstance#findBrokerAddressInSubscribe(...)](#)\n\t\t- [PullAPIWrapper#processPullResult(...)](#)\n\t\t- [ProcessQueue#putMessage(...)](#)\n\t- [总结](#)\n- [6、PushConsumer 消费消息](#)\n\t- [ConsumeMessageConcurrentlyService 提交消费请求](#)\n\t\t- [ConsumeMessageConcurrentlyService#submitConsumeRequest(...)](#)\n\t\t- [ConsumeMessageConcurrentlyService#submitConsumeRequestLater](#)\n\t- [ConsumeRequest](#)\n\t- [ConsumeMessageConcurrentlyService#processConsumeResult(...)](#)\n\t\t- [ProcessQueue#removeMessage(...)](#)\n\t- [ConsumeMessageConcurrentlyService#cleanExpireMsg(...)](#)\n\t\t- [ProcessQueue#cleanExpiredMsg(...)](#)\n- [7、PushConsumer 发回消费失败消息](#)\n\t- [DefaultMQPushConsumerImpl#sendMessageBack(...)](#)\n\t\t- [MQClientAPIImpl#consumerSendMessageBack(...)](#)\n- [8、Consumer 消费进度](#)\n\t- [OffsetStore](#)\n\t\t- [OffsetStore#load(...)](#)\n\t\t\t- [LocalFileOffsetStore#load(...)](#)\n\t\t\t\t- [OffsetSerializeWrapper](#)\n\t\t\t- [RemoteBrokerOffsetStore#load(...)](#)\n\t\t- [OffsetStore#readOffset(...)](#)\n\t\t\t- [LocalFileOffsetStore#readOffset(...)](#)\n\t\t\t- [RemoteBrokerOffsetStore#readOffset(...)](#)\n\t\t- [OffsetStore#updateOffset(...)](#)\n\t\t- [OffsetStore#persistAll(...)](#)\n\t\t\t- [LocalFileOffsetStore#persistAll(...)](#)\n\t\t\t- [RemoteBrokerOffsetStore#persistAll(...)](#)\n\t\t\t- [MQClientInstance#persistAllConsumerOffset(...)](#)\n- [9、结尾](#)\n\n-------\n\n# 1、概述\n\n本文接：[《RocketMQ 源码分析 —— Message 拉取与消费（上）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/)。\n\n主要解析 `Consumer` 在 **消费** 逻辑涉及到的源码。\n\n# 2、Consumer\n\nMQ 提供了两类消费者：\n\n* PushConsumer：\n    * 在大多数场景下使用。\n    * 名字虽然是 `Push` 开头，实际在实现时，使用 `Pull` 方式实现。通过 `Pull` **不断不断不断**轮询 `Broker` 获取消息。当不存在新消息时，`Broker` 会**挂起请求**，直到有新消息产生，取消挂起，返回新消息。这样，基本和 `Broker` 主动 `Push` 做到**接近**的实时性（当然，还是有相应的实时性损失）。原理类似 **[长轮询( `Long-Polling` )](https://www.ibm.com/developerworks/cn/web/wa-lo-comet/)**。\n* PullConsumer\n\n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n\n# 3、PushConsumer 一览\n\n先看一张 `PushConsumer` 包含的组件以及组件之间的交互图：\n\n![PushConsumer手绘图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/09.png)\n\n* `RebalanceService`：均衡消息队列服务，负责分配当前 `Consumer` 可消费的消息队列( `MessageQueue` )。当有新的 `Consumer` 的加入或移除，都会重新分配消息队列。\n* `PullMessageService`：拉取消息服务，**不断不断不断**从 `Broker` 拉取消息，并提交消费任务到 `ConsumeMessageService`。\n* `ConsumeMessageService`：消费消息服务，**不断不断不断**消费消息，并处理消费结果。\n* `RemoteBrokerOffsetStore`：`Consumer` 消费进度管理，负责从 `Broker` 获取消费进度，同步消费进度到 `Broker`。\n* `ProcessQueue` ：消息处理队列。\n* `MQClientInstance` ：封装对 `Namesrv`，`Broker` 的 API调用，提供给 `Producer`、`Consumer` 使用。\n\n# 4、PushConsumer 订阅\n\n## DefaultMQPushConsumerImpl#subscribe(...)\n\n```Java\n  1: public void subscribe(String topic, String subExpression) throws MQClientException {\n  2:     try {\n  3:         // 创建订阅数据\n  4:         SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //\n  5:             topic, subExpression);\n  6:         this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n  7:         // 通过心跳同步Consumer信息到Broker\n  8:         if (this.mQClientFactory != null) {\n  9:             this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n 10:         }\n 11:     } catch (Exception e) {\n 12:         throw new MQClientException(\"subscription exception\", e);\n 13:     }\n 14: }\n```\n\n* 说明 ：订阅 `Topic` 。\n* 第 3 至 6 行 ：创建订阅数据。详细解析见：[FilterAPI.buildSubscriptionData(...)](#filterapibuildsubscriptiondata)。\n* 第 7 至 10 行 ：通过心跳同步 `Consumer` 信息到 `Broker`。\n\n### FilterAPI.buildSubscriptionData(...)\n\n```Java\n  1: public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,\n  2:     String subString) throws Exception {\n  3:     SubscriptionData subscriptionData = new SubscriptionData();\n  4:     subscriptionData.setTopic(topic);\n  5:     subscriptionData.setSubString(subString);\n  6:     // 处理订阅表达式\n  7:     if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {\n  8:         subscriptionData.setSubString(SubscriptionData.SUB_ALL);\n  9:     } else {\n 10:         String[] tags = subString.split(\"\\\\|\\\\|\");\n 11:         if (tags.length > 0) {\n 12:             for (String tag : tags) {\n 13:                 if (tag.length() > 0) {\n 14:                     String trimString = tag.trim();\n 15:                     if (trimString.length() > 0) {\n 16:                         subscriptionData.getTagsSet().add(trimString);\n 17:                         subscriptionData.getCodeSet().add(trimString.hashCode());\n 18:                     }\n 19:                 }\n 20:             }\n 21:         } else {\n 22:             throw new Exception(\"subString split error\");\n 23:         }\n 24:     }\n 25: \n 26:     return subscriptionData;\n 27: }\n```\n\n* 说明 ：根据 `Topic` 和 订阅表达式 创建订阅数据\n* subscriptionData.subVersion = System.currentTimeMillis()。\n\n## DefaultMQPushConsumer#registerMessageListener(...)\n\n```Java\n  1: public void registerMessageListener(MessageListenerConcurrently messageListener) {\n  2:     this.messageListener = messageListener;\n  3:     this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);\n  4: }\n```\n\n* 说明 ：注册消息监听器。\n\n# 5、PushConsumer 消息队列分配\n\n![RebalanceService&PushConsumer分配队列](http://www.yunai.me/images/RocketMQ/2017_05_04/10.png)\n\n## RebalanceService\n\n```Java\n  1: public class RebalanceService extends ServiceThread {\n  2: \n  3:     /**\n  4:      * 等待间隔，单位：毫秒\n  5:      */\n  6:     private static long waitInterval =\n  7:         Long.parseLong(System.getProperty(\n  8:             \"rocketmq.client.rebalance.waitInterval\", \"20000\"));\n  9: \n 10:     private final Logger log = ClientLogger.getLog();\n 11:     /**\n 12:      * MQClient对象\n 13:      */\n 14:     private final MQClientInstance mqClientFactory;\n 15: \n 16:     public RebalanceService(MQClientInstance mqClientFactory) {\n 17:         this.mqClientFactory = mqClientFactory;\n 18:     }\n 19: \n 20:     @Override\n 21:     public void run() {\n 22:         log.info(this.getServiceName() + \" service started\");\n 23: \n 24:         while (!this.isStopped()) {\n 25:             this.waitForRunning(waitInterval);\n 26:             this.mqClientFactory.doRebalance();\n 27:         }\n 28: \n 29:         log.info(this.getServiceName() + \" service end\");\n 30:     }\n 31: \n 32:     @Override\n 33:     public String getServiceName() {\n 34:         return RebalanceService.class.getSimpleName();\n 35:     }\n 36: }\n```\n\n* 说明 ：均衡消息队列服务，负责分配当前 `Consumer` 可消费的消息队列( `MessageQueue` )。\n* 第 26 行 ：调用 `MQClientInstance#doRebalance(...)` 分配消息队列。目前有三种情况情况下触发：\n    * 如 `第 25 行` 等待超时，每 20s 调用一次。\n    * `PushConsumer` 启动时，调用 `rebalanceService#wakeup(...)` 触发。\n    * `Broker` 通知 `Consumer` 加入 或 移除时，`Consumer` 响应通知，调用 `rebalanceService#wakeup(...)` 触发。\n\n 详细解析见：[MQClientInstance#doRebalance(...)](#mqclientinstancedorebalance)。\n\n## MQClientInstance#doRebalance(...)\n\n```Java\n  1: public void doRebalance() {\n  2:     for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {\n  3:         MQConsumerInner impl = entry.getValue();\n  4:         if (impl != null) {\n  5:             try {\n  6:                 impl.doRebalance();\n  7:             } catch (Throwable e) {\n  8:                 log.error(\"doRebalance exception\", e);\n  9:             }\n 10:         }\n 11:     }\n 12: }\n```\n\n* 说明 ：遍历当前 `Client` 包含的 `consumerTable`( `Consumer`集合 )，执行消息队列分配。\n* **疑问**：目前代码调试下来，`consumerTable` 只包含 `Consumer` 自己。😈有大大对这个疑问有解答的，烦请解答下。\n* 第 6 行 ：调用 `MQConsumerInner#doRebalance(...)` 进行队列分配。`DefaultMQPushConsumerImpl`、`DefaultMQPullConsumerImpl` 分别对该接口方法进行了实现。`DefaultMQPushConsumerImpl#doRebalance(...)` 详细解析见：[DefaultMQPushConsumerImpl#doRebalance(...)](defaultmqpushconsumerimpldorebalance)。\n\n## DefaultMQPushConsumerImpl#doRebalance(...)\n\n```Java\n  1: public void doRebalance() {\n  2:     if (!this.pause) {\n  3:         this.rebalanceImpl.doRebalance(this.isConsumeOrderly());\n  4:     }\n  5: }\n```\n\n* 说明：执行消息队列分配。\n* 第 3 行 ：调用 `RebalanceImpl#doRebalance(...)` 进行队列分配。详细解析见：[RebalancePushImpl#doRebalance(...)](#rebalancepushimpldorebalance)。\n\n## RebalanceImpl#doRebalance(...)\n\n```Java\n  1: /**\n  2:  * 执行分配消息队列\n  3:  *\n  4:  * @param isOrder 是否顺序消息\n  5:  */\n  6: public void doRebalance(final boolean isOrder) {\n  7:     // 分配每个 topic 的消息队列\n  8:     Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n  9:     if (subTable != null) {\n 10:         for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {\n 11:             final String topic = entry.getKey();\n 12:             try {\n 13:                 this.rebalanceByTopic(topic, isOrder);\n 14:             } catch (Throwable e) {\n 15:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 16:                     log.warn(\"rebalanceByTopic Exception\", e);\n 17:                 }\n 18:             }\n 19:         }\n 20:     }\n 21:     // 移除未订阅的topic对应的消息队列\n 22:     this.truncateMessageQueueNotMyTopic();\n 23: }\n 24: \n 25: /**\n 26:  * 移除未订阅的消息队列\n 27:  */\n 28: private void truncateMessageQueueNotMyTopic() {\n 29:     Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n 30:     for (MessageQueue mq : this.processQueueTable.keySet()) {\n 31:         if (!subTable.containsKey(mq.getTopic())) {\n 32: \n 33:             ProcessQueue pq = this.processQueueTable.remove(mq);\n 34:             if (pq != null) {\n 35:                 pq.setDropped(true);\n 36:                 log.info(\"doRebalance, {}, truncateMessageQueueNotMyTopic remove unnecessary mq, {}\", consumerGroup, mq);\n 37:             }\n 38:         }\n 39:     }\n 40: }\n```\n\n* `#doRebalance(...)` 说明 ：执行分配消息队列。\n    * 第 7 至 20 行 ：循环订阅主题集合( `subscriptionInner` )，分配每一个 `Topic` 的消息队列。\n    * 第 22 行 ：移除未订阅的 `Topic` 的消息队列。\n* `#truncateMessageQueueNotMyTopic(...)` 说明 ：移除未订阅的消息队列。**当调用 `DefaultMQPushConsumer#unsubscribe(topic)` 时，只移除订阅主题集合( `subscriptionInner` )，对应消息队列移除在该方法。**\n\n### RebalanceImpl#rebalanceByTopic(...)\n\n```Java\n  1: private void rebalanceByTopic(final String topic, final boolean isOrder) {\n  2:     switch (messageModel) {\n  3:         case BROADCASTING: {\n  4:             Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);\n  5:             if (mqSet != null) {\n  6:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);\n  7:                 if (changed) {\n  8:                     this.messageQueueChanged(topic, mqSet, mqSet);\n  9:                     log.info(\"messageQueueChanged {} {} {} {}\", //\n 10:                         consumerGroup, //\n 11:                         topic, //\n 12:                         mqSet, //\n 13:                         mqSet);\n 14:                 }\n 15:             } else {\n 16:                 log.warn(\"doRebalance, {}, but the topic[{}] not exist.\", consumerGroup, topic);\n 17:             }\n 18:             break;\n 19:         }\n 20:         case CLUSTERING: {\n 21:             // 获取 topic 对应的 队列 和 consumer信息\n 22:             Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);\n 23:             List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);\n 24:             if (null == mqSet) {\n 25:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 26:                     log.warn(\"doRebalance, {}, but the topic[{}] not exist.\", consumerGroup, topic);\n 27:                 }\n 28:             }\n 29: \n 30:             if (null == cidAll) {\n 31:                 log.warn(\"doRebalance, {} {}, get consumer id list failed\", consumerGroup, topic);\n 32:             }\n 33: \n 34:             if (mqSet != null && cidAll != null) {\n 35:                 // 排序 消息队列 和 消费者数组。因为是在Client进行分配队列，排序后，各Client的顺序才能保持一致。\n 36:                 List<MessageQueue> mqAll = new ArrayList<>();\n 37:                 mqAll.addAll(mqSet);\n 38: \n 39:                 Collections.sort(mqAll);\n 40:                 Collections.sort(cidAll);\n 41: \n 42:                 AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;\n 43: \n 44:                 // 根据 队列分配策略 分配消息队列\n 45:                 List<MessageQueue> allocateResult;\n 46:                 try {\n 47:                     allocateResult = strategy.allocate(//\n 48:                         this.consumerGroup, //\n 49:                         this.mQClientFactory.getClientId(), //\n 50:                         mqAll, //\n 51:                         cidAll);\n 52:                 } catch (Throwable e) {\n 53:                     log.error(\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}\", strategy.getName(),\n 54:                         e);\n 55:                     return;\n 56:                 }\n 57: \n 58:                 Set<MessageQueue> allocateResultSet = new HashSet<>();\n 59:                 if (allocateResult != null) {\n 60:                     allocateResultSet.addAll(allocateResult);\n 61:                 }\n 62: \n 63:                 // 更新消息队列\n 64:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);\n 65:                 if (changed) {\n 66:                     log.info(\n 67:                         \"rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}\",\n 68:                         strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),\n 69:                         allocateResultSet.size(), allocateResultSet);\n 70:                     this.messageQueueChanged(topic, mqSet, allocateResultSet);\n 71:                 }\n 72:             }\n 73:             break;\n 74:         }\n 75:         default:\n 76:             break;\n 77:     }\n 78: }\n 79: \n 80: /**\n 81:  * 当负载均衡时，更新 消息处理队列\n 82:  * - 移除 在processQueueTable && 不存在于 mqSet 里的消息队列\n 83:  * - 增加 不在processQueueTable && 存在于mqSet 里的消息队列\n 84:  *\n 85:  * @param topic Topic\n 86:  * @param mqSet 负载均衡结果后的消息队列数组\n 87:  * @param isOrder 是否顺序\n 88:  * @return 是否变更\n 89:  */\n 90: private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) {\n 91:     boolean changed = false;\n 92: \n 93:     // 移除 在processQueueTable && 不存在于 mqSet 里的消息队列\n 94:     Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();\n 95:     while (it.hasNext()) { // TODO 待读：\n 96:         Entry<MessageQueue, ProcessQueue> next = it.next();\n 97:         MessageQueue mq = next.getKey();\n 98:         ProcessQueue pq = next.getValue();\n 99: \n100:         if (mq.getTopic().equals(topic)) {\n101:             if (!mqSet.contains(mq)) { // 不包含的队列\n102:                 pq.setDropped(true);\n103:                 if (this.removeUnnecessaryMessageQueue(mq, pq)) {\n104:                     it.remove();\n105:                     changed = true;\n106:                     log.info(\"doRebalance, {}, remove unnecessary mq, {}\", consumerGroup, mq);\n107:                 }\n108:             } else if (pq.isPullExpired()) { // 队列拉取超时，进行清理\n109:                 switch (this.consumeType()) {\n110:                     case CONSUME_ACTIVELY:\n111:                         break;\n112:                     case CONSUME_PASSIVELY:\n113:                         pq.setDropped(true);\n114:                         if (this.removeUnnecessaryMessageQueue(mq, pq)) {\n115:                             it.remove();\n116:                             changed = true;\n117:                             log.error(\"[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it\",\n118:                                 consumerGroup, mq);\n119:                         }\n120:                         break;\n121:                     default:\n122:                         break;\n123:                 }\n124:             }\n125:         }\n126:     }\n127: \n128:     // 增加 不在processQueueTable && 存在于mqSet 里的消息队列。\n129:     List<PullRequest> pullRequestList = new ArrayList<>(); // 拉消息请求数组\n130:     for (MessageQueue mq : mqSet) {\n131:         if (!this.processQueueTable.containsKey(mq)) {\n132:             if (isOrder && !this.lock(mq)) {\n133:                 log.warn(\"doRebalance, {}, add a new mq failed, {}, because lock failed\", consumerGroup, mq);\n134:                 continue;\n135:             }\n136: \n137:             this.removeDirtyOffset(mq);\n138:             ProcessQueue pq = new ProcessQueue();\n139:             long nextOffset = this.computePullFromWhere(mq);\n140:             if (nextOffset >= 0) {\n141:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);\n142:                 if (pre != null) {\n143:                     log.info(\"doRebalance, {}, mq already exists, {}\", consumerGroup, mq);\n144:                 } else {\n145:                     log.info(\"doRebalance, {}, add a new mq, {}\", consumerGroup, mq);\n146:                     PullRequest pullRequest = new PullRequest();\n147:                     pullRequest.setConsumerGroup(consumerGroup);\n148:                     pullRequest.setNextOffset(nextOffset);\n149:                     pullRequest.setMessageQueue(mq);\n150:                     pullRequest.setProcessQueue(pq);\n151:                     pullRequestList.add(pullRequest);\n152:                     changed = true;\n153:                 }\n154:             } else {\n155:                 log.warn(\"doRebalance, {}, add new mq failed, {}\", consumerGroup, mq);\n156:             }\n157:         }\n158:     }\n159: \n160:     // 发起消息拉取请求\n161:     this.dispatchPullRequest(pullRequestList);\n162: \n163:     return changed;\n164: }\n```\n\n* `#rebalanceByTopic(...)` 说明 ：分配 `Topic` 的消息队列。\n    * 第 3 至 19 行 ：广播模式( `BROADCASTING` ) 下，分配 `Topic` 对应的**所有**消息队列。   \n    * 第 20 至 74 行 ：集群模式( `CLUSTERING` ) 下，分配 `Topic` 对应的**部分**消息队列。\n        * 第 21 至 40 行 ：获取 `Topic` 对应的消息队列和消费者们，并对其进行排序。因为各 `Consumer` 是在本地分配消息队列，排序后才能保证各 `Consumer` 顺序一致。\n        *  第 42 至 61 行 ：根据 队列分配策略( `AllocateMessageQueueStrategy` ) 分配消息队列。详细解析见：[AllocateMessageQueueStrategy](#allocatemessagequeuestrategy)。\n        *  第 63 至 72 行 ：更新 `Topic` 对应的消息队列。\n* `#updateProcessQueueTableInRebalance(...)` 说明 ：当分配队列时，更新 `Topic` 对应的消息队列，并返回是否有变更。\n    * 第 93 至 126 行 ：移除不存在于分配的消息队列( `mqSet` ) 的 消息处理队列( `processQueueTable` )。\n        * 第 103 行 ：移除不需要的消息队列。详细解析见：[RebalancePushImpl#removeUnnecessaryMessageQueue(...)](#rebalancepushimplremoveunnecessarymessagequeue)。\n        * 第 108 至 120 行 ：队列拉取超时，即 `当前时间 - 最后一次拉取消息时间 > 120s` ( 120s 可配置)，判定发生 **BUG**，过久未进行消息拉取，移除消息队列。移除后，下面**#新增队列逻辑#**可以重新加入新的该消息队列。\n    * 第 128 至 158 行 ：增加 分配的消息队列( `mqSet` ) 新增的消息队列。\n        * 第 132 至 135 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n        * 第 137 行 ：移除消息队列的消费进度。\n        * 第 139 行 ：获取队列消费进度。详细解析见：[RebalancePushImpl#computePullFromWhere(...)](#rebalancepushimplcomputepullfromwhere)。\n        * 第 140 至 156 行 ：**添加新消费处理队列，添加消费拉取消息请求**。\n    * 第 161 行 ：**发起新增的消息队列消息拉取请求**。详细解析见：[RebalancePushImpl#dispatchPullRequest(...)](#rebalancepushimpldispatchpullrequest)。\n\n### RebalanceImpl#removeUnnecessaryMessageQueue(...)\n\n#### RebalancePushImpl#removeUnnecessaryMessageQueue(...)\n\n```Java\n  1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n  2:     // 同步队列的消费进度，并移除之。\n  3:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);\n  4:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);\n  5:     // TODO 顺序消费\n  6:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()\n  7:         && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {\n  8:         try {\n  9:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {\n 10:                 try {\n 11:                     return this.unlockDelay(mq, pq);\n 12:                 } finally {\n 13:                     pq.getLockConsume().unlock();\n 14:                 }\n 15:             } else {\n 16:                 log.warn(\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\", //\n 17:                     mq, //\n 18:                     pq.getTryUnlockTimes());\n 19: \n 20:                 pq.incTryUnlockTimes();\n 21:             }\n 22:         } catch (Exception e) {\n 23:             log.error(\"removeUnnecessaryMessageQueue Exception\", e);\n 24:         }\n 25: \n 26:         return false;\n 27:     }\n 28:     return true;\n 29: }\n```\n\n* 说明 ：移除不需要的消息队列相关的信息，并返回是否移除成功。\n* 第 2 至 4 行 ：**同步**队列的消费进度，并移除之。\n* 第 5 至 27 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n\n#### `[PullConsumer]` RebalancePullImpl#removeUnnecessaryMessageQueue(...)\n\n```Java\n  1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n  2:     this.defaultMQPullConsumerImpl.getOffsetStore().persist(mq);\n  3:     this.defaultMQPullConsumerImpl.getOffsetStore().removeOffset(mq);\n  4:     return true;\n  5: }\n```\n\n* 说明 ：移除不需要的消息队列相关的信息，并返回移除成功。**和`RebalancePushImpl#removeUnnecessaryMessageQueue(...)`基本一致。**\n\n### RebalancePushImpl#dispatchPullRequest(...)\n\n```Java\n  1: public void dispatchPullRequest(List<PullRequest> pullRequestList) {\n  2:     for (PullRequest pullRequest : pullRequestList) {\n  3:         this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);\n  4:         log.info(\"doRebalance, {}, add a new pull request {}\", consumerGroup, pullRequest);\n  5:     }\n  6: }\n```\n\n* 说明 ：发起消息拉取请求。**该调用是`PushConsumer`不断不断不断拉取消息的起点**。\n\n#### DefaultMQPushConsumerImpl#executePullRequestImmediately(...)\n\n```Java\n  1: public void executePullRequestImmediately(final PullRequest pullRequest) {\n  2:     this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);\n  3: }\n```\n\n* 说明 ：提交拉取请求。提交后，`PullMessageService` **异步执行**，**非阻塞**。详细解析见：[PullMessageService](pullmessageservice)。\n\n### AllocateMessageQueueStrategy\n\n![AllocateMessageQueueStrategy类图](http://www.yunai.me/images/RocketMQ/2017_05_04/01.png)\n\n#### AllocateMessageQueueAveragely\n\n```Java\n  1: public class AllocateMessageQueueAveragely implements AllocateMessageQueueStrategy {\n  2:     private final Logger log = ClientLogger.getLog();\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         // 校验参数是否正确\n  8:         if (currentCID == null || currentCID.length() < 1) {\n  9:             throw new IllegalArgumentException(\"currentCID is empty\");\n 10:         }\n 11:         if (mqAll == null || mqAll.isEmpty()) {\n 12:             throw new IllegalArgumentException(\"mqAll is null or mqAll empty\");\n 13:         }\n 14:         if (cidAll == null || cidAll.isEmpty()) {\n 15:             throw new IllegalArgumentException(\"cidAll is null or cidAll empty\");\n 16:         }\n 17: \n 18:         List<MessageQueue> result = new ArrayList<>();\n 19:         if (!cidAll.contains(currentCID)) {\n 20:             log.info(\"[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}\",\n 21:                 consumerGroup,\n 22:                 currentCID,\n 23:                 cidAll);\n 24:             return result;\n 25:         }\n 26:         // 平均分配\n 27:         int index = cidAll.indexOf(currentCID); // 第几个consumer。\n 28:         int mod = mqAll.size() % cidAll.size(); // 余数，即多少消息队列无法平均分配。\n 29:         int averageSize =\n 30:             mqAll.size() <= cidAll.size() ? 1 : (mod > 0 && index < mod ? mqAll.size() / cidAll.size()\n 31:                 + 1 : mqAll.size() / cidAll.size());\n 32:         int startIndex = (mod > 0 && index < mod) ? index * averageSize : index * averageSize + mod; // 有余数的情况下，[0, mod) 平分余数，即每consumer多分配一个节点；第index开始，跳过前mod余数。\n 33:         int range = Math.min(averageSize, mqAll.size() - startIndex); // 分配队列数量。之所以要Math.min()的原因是，mqAll.size() <= cidAll.size()，部分consumer分配不到消息队列。\n 34:         for (int i = 0; i < range; i++) {\n 35:             result.add(mqAll.get((startIndex + i) % mqAll.size()));\n 36:         }\n 37:         return result;\n 38:     }\n 39: \n 40:     @Override\n 41:     public String getName() {\n 42:         return \"AVG\";\n 43:     }\n 44: }\n```\n\n* 说明 ：**平均**分配队列策略。\n* 第 7 至 25 行 ：参数校验。\n* 第 26 至 36 行 ：平均分配消息队列。\n    * 第 27 行 ：`index` ：当前 `Consumer` 在消费集群里是第几个。这里就是为什么需要对传入的 `cidAll` 参数必须进行排序的原因。如果不排序，`Consumer` 在本地计算出来的 `index` 无法一致，影响计算结果。\n    * 第 28 行 ：`mod` ：余数，即多少消息队列无法平均分配。\n    * 第 29 至 31 行 ：`averageSize` ：代码可以简化成 `(mod > 0 && index < mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size())`。\n        * `[ 0, mod )` ：`mqAll.size() / cidAll.size() + 1`。前面 `mod` 个 `Consumer` 平分余数，多获得 1 个消息队列。\n        * `[ mod, cidAll.size() )` ：`mqAll.size() / cidAll.size()`。\n    * 第 32 行 ：`startIndex` ：`Consumer` 分配消息队列开始位置。\n    * 第 33 行 ：`range` ：分配队列数量。之所以要 `Math#min(...)` 的原因：当 `mqAll.size() <= cidAll.size()` 时，最后几个 `Consumer` 分配不到消息队列。\n    * 第 34 至 36 行 ：生成分配消息队列结果。\n* 举个例子：\n\n固定消息队列长度为**4**。\n\n|   | Consumer * 2 *可以整除* | Consumer * 3 *不可整除* | Consumer * 5 *无法都分配* |\n| --- | --- | --- | --- |\n| 消息队列[0] | Consumer[0] | Consumer[0] | Consumer[0] |\n| 消息队列[1] | Consumer[0] | Consumer[0] | Consumer[1] |\n| 消息队列[2] | Consumer[1] | Consumer[1] | Consumer[2] |\n| 消息队列[3] | Consumer[1] | Consumer[2] | Consumer[3] |\n\n#### AllocateMessageQueueByMachineRoom\n\n```Java\n  1: public class AllocateMessageQueueByMachineRoom implements AllocateMessageQueueStrategy {\n  2:     /**\n  3:      * 消费者消费brokerName集合\n  4:      */\n  5:     private Set<String> consumeridcs;\n  6: \n  7:     @Override\n  8:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  9:         List<String> cidAll) {\n 10:         // 参数校验\n 11:         List<MessageQueue> result = new ArrayList<MessageQueue>();\n 12:         int currentIndex = cidAll.indexOf(currentCID);\n 13:         if (currentIndex < 0) {\n 14:             return result;\n 15:         }\n 16:         // 计算符合当前配置的消费者数组('consumeridcs')对应的消息队列\n 17:         List<MessageQueue> premqAll = new ArrayList<MessageQueue>();\n 18:         for (MessageQueue mq : mqAll) {\n 19:             String[] temp = mq.getBrokerName().split(\"@\");\n 20:             if (temp.length == 2 && consumeridcs.contains(temp[0])) {\n 21:                 premqAll.add(mq);\n 22:             }\n 23:         }\n 24:         // 平均分配\n 25:         int mod = premqAll.size() / cidAll.size();\n 26:         int rem = premqAll.size() % cidAll.size();\n 27:         int startIndex = mod * currentIndex;\n 28:         int endIndex = startIndex + mod;\n 29:         for (int i = startIndex; i < endIndex; i++) {\n 30:             result.add(mqAll.get(i));\n 31:         }\n 32:         if (rem > currentIndex) {\n 33:             result.add(premqAll.get(currentIndex + mod * cidAll.size()));\n 34:         }\n 35:         return result;\n 36:     }\n 37: \n 38:     @Override\n 39:     public String getName() {\n 40:         return \"MACHINE_ROOM\";\n 41:     }\n 42: \n 43:     public Set<String> getConsumeridcs() {\n 44:         return consumeridcs;\n 45:     }\n 46: \n 47:     public void setConsumeridcs(Set<String> consumeridcs) {\n 48:         this.consumeridcs = consumeridcs;\n 49:     }\n 50: }\n```\n\n* 说明 ：**平均**分配**可消费的** `Broker` 对应的消息队列。\n* 第 7 至 15 行 ：参数校验。\n* 第 16 至 23 行 ：计算**可消费的** `Broker` 对应的消息队列。\n* 第 25 至 34 行 ：平均分配消息队列。该**平均分配**方式和 `AllocateMessageQueueAveragely` 略有不同，其是将多余的结尾部分分配给前 `rem` 个 `Consumer`。\n* 疑问：*使用该分配策略时，`Consumer` 和 `Broker` 分配需要怎么配置*。😈等研究**主从**相关源码时，仔细考虑下。\n\n#### AllocateMessageQueueAveragelyByCircle\n\n ```Java\n   1: public class AllocateMessageQueueAveragelyByCircle implements AllocateMessageQueueStrategy {\n  2:     private final Logger log = ClientLogger.getLog();\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         // 校验参数是否正确\n  8:         if (currentCID == null || currentCID.length() < 1) {\n  9:             throw new IllegalArgumentException(\"currentCID is empty\");\n 10:         }\n 11:         if (mqAll == null || mqAll.isEmpty()) {\n 12:             throw new IllegalArgumentException(\"mqAll is null or mqAll empty\");\n 13:         }\n 14:         if (cidAll == null || cidAll.isEmpty()) {\n 15:             throw new IllegalArgumentException(\"cidAll is null or cidAll empty\");\n 16:         }\n 17: \n 18:         List<MessageQueue> result = new ArrayList<MessageQueue>();\n 19:         if (!cidAll.contains(currentCID)) {\n 20:             log.info(\"[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}\",\n 21:                 consumerGroup,\n 22:                 currentCID,\n 23:                 cidAll);\n 24:             return result;\n 25:         }\n 26: \n 27:         // 环状分配\n 28:         int index = cidAll.indexOf(currentCID);\n 29:         for (int i = index; i < mqAll.size(); i++) {\n 30:             if (i % cidAll.size() == index) {\n 31:                 result.add(mqAll.get(i));\n 32:             }\n 33:         }\n 34:         return result;\n 35:     }\n 36: \n 37:     @Override\n 38:     public String getName() {\n 39:         return \"AVG_BY_CIRCLE\";\n 40:     }\n 41: }\n ```\n \n * 说明 ：环状分配消息队列。\n\n#### AllocateMessageQueueByConfig\n\n```Java\n  1: public class AllocateMessageQueueByConfig implements AllocateMessageQueueStrategy {\n  2:     private List<MessageQueue> messageQueueList;\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         return this.messageQueueList;\n  8:     }\n  9: \n 10:     @Override\n 11:     public String getName() {\n 12:         return \"CONFIG\";\n 13:     }\n 14: \n 15:     public List<MessageQueue> getMessageQueueList() {\n 16:         return messageQueueList;\n 17:     }\n 18: \n 19:     public void setMessageQueueList(List<MessageQueue> messageQueueList) {\n 20:         this.messageQueueList = messageQueueList;\n 21:     }\n 22: }\n```\n\n* 说明 ：分配**配置的**消息队列。\n* 疑问 ：*该分配策略的使用场景。*\n\n# 5、PushConsumer 消费进度读取\n\n## RebalancePushImpl#computePullFromWhere(...)\n\n```Java\n  1: public long computePullFromWhere(MessageQueue mq) {\n  2:     long result = -1;\n  3:     final ConsumeFromWhere consumeFromWhere = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();\n  4:     final OffsetStore offsetStore = this.defaultMQPushConsumerImpl.getOffsetStore();\n  5:     switch (consumeFromWhere) {\n  6:         case CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST: // 废弃\n  7:         case CONSUME_FROM_MIN_OFFSET: // 废弃\n  8:         case CONSUME_FROM_MAX_OFFSET: // 废弃\n  9:         case CONSUME_FROM_LAST_OFFSET: {\n 10:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 11:             if (lastOffset >= 0) {\n 12:                 result = lastOffset;\n 13:             }\n 14:             // First start,no offset\n 15:             else if (-1 == lastOffset) {\n 16:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 17:                     result = 0L;\n 18:                 } else {\n 19:                     try {\n 20:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);\n 21:                     } catch (MQClientException e) {\n 22:                         result = -1;\n 23:                     }\n 24:                 }\n 25:             } else {\n 26:                 result = -1;\n 27:             }\n 28:             break;\n 29:         }\n 30:         case CONSUME_FROM_FIRST_OFFSET: {\n 31:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 32:             if (lastOffset >= 0) {\n 33:                 result = lastOffset;\n 34:             } else if (-1 == lastOffset) {\n 35:                 result = 0L;\n 36:             } else {\n 37:                 result = -1;\n 38:             }\n 39:             break;\n 40:         }\n 41:         case CONSUME_FROM_TIMESTAMP: {\n 42:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 43:             if (lastOffset >= 0) {\n 44:                 result = lastOffset;\n 45:             } else if (-1 == lastOffset) {\n 46:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 47:                     try {\n 48:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);\n 49:                     } catch (MQClientException e) {\n 50:                         result = -1;\n 51:                     }\n 52:                 } else {\n 53:                     try {\n 54:                         long timestamp = UtilAll.parseDate(this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),\n 55:                             UtilAll.YYYY_MMDD_HHMMSS).getTime();\n 56:                         result = this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);\n 57:                     } catch (MQClientException e) {\n 58:                         result = -1;\n 59:                     }\n 60:                 }\n 61:             } else {\n 62:                 result = -1;\n 63:             }\n 64:             break;\n 65:         }\n 66: \n 67:         default:\n 68:             break;\n 69:     }\n 70: \n 71:     return result;\n 72: }\n```\n\n* 说明 ：计算消息队列开始消费位置。\n* `PushConsumer` 读取消费进度有三种选项：\n    * `CONSUME_FROM_LAST_OFFSET` ：第 6 至 29 行 ：一个新的消费集群第一次启动从**队列的最后位置**开始消费。**后续再启动接着上次消费的进度开始消费**。\n    * `CONSUME_FROM_FIRST_OFFSET` ：第 30 至 40 行 ：一个新的消费集群第一次启动从队列的**最前位置**开始消费。**后续再启动接着上次消费的进度开始消费**。\n    * `CONSUME_FROM_TIMESTAMP` ：第 41 至 65 行 ：一个新的消费集群第一次启动从**指定时间点**开始消费。**后续再启动接着上次消费的进度开始消费**。\n\n\n## `[PullConsumer]` RebalancePullImpl#computePullFromWhere(...)\n\n暂时跳过。😈\n\n# 6、PushConsumer 拉取消息\n\n![DefaultMQPushConsumerImpl拉取消息](http://www.yunai.me/images/RocketMQ/2017_05_04/05.png)\n\n## PullMessageService\n\n```Java\n  1: public class PullMessageService extends ServiceThread {\n  2:     private final Logger log = ClientLogger.getLog();\n  3:     /**\n  4:      * 拉取消息请求队列\n  5:      */\n  6:     private final LinkedBlockingQueue<PullRequest> pullRequestQueue = new LinkedBlockingQueue<>();\n  7:     /**\n  8:      * MQClient对象\n  9:      */\n 10:     private final MQClientInstance mQClientFactory;\n 11:     /**\n 12:      * 定时器。用于延迟提交拉取请求\n 13:      */\n 14:     private final ScheduledExecutorService scheduledExecutorService = Executors\n 15:         .newSingleThreadScheduledExecutor(new ThreadFactory() {\n 16:             @Override\n 17:             public Thread newThread(Runnable r) {\n 18:                 return new Thread(r, \"PullMessageServiceScheduledThread\");\n 19:             }\n 20:         });\n 21: \n 22:     public PullMessageService(MQClientInstance mQClientFactory) {\n 23:         this.mQClientFactory = mQClientFactory;\n 24:     }\n 25: \n 26:     /**\n 27:      * 执行延迟拉取消息请求\n 28:      *\n 29:      * @param pullRequest 拉取消息请求\n 30:      * @param timeDelay 延迟时长\n 31:      */\n 32:     public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {\n 33:         this.scheduledExecutorService.schedule(new Runnable() {\n 34: \n 35:             @Override\n 36:             public void run() {\n 37:                 PullMessageService.this.executePullRequestImmediately(pullRequest);\n 38:             }\n 39:         }, timeDelay, TimeUnit.MILLISECONDS);\n 40:     }\n 41: \n 42:     /**\n 43:      * 执行立即拉取消息请求\n 44:      *\n 45:      * @param pullRequest 拉取消息请求\n 46:      */\n 47:     public void executePullRequestImmediately(final PullRequest pullRequest) {\n 48:         try {\n 49:             this.pullRequestQueue.put(pullRequest);\n 50:         } catch (InterruptedException e) {\n 51:             log.error(\"executePullRequestImmediately pullRequestQueue.put\", e);\n 52:         }\n 53:     }\n 54: \n 55:     /**\n 56:      * 执行延迟任务\n 57:      *\n 58:      * @param r 任务\n 59:      * @param timeDelay 延迟时长\n 60:      */\n 61:     public void executeTaskLater(final Runnable r, final long timeDelay) {\n 62:         this.scheduledExecutorService.schedule(r, timeDelay, TimeUnit.MILLISECONDS);\n 63:     }\n 64: \n 65:     public ScheduledExecutorService getScheduledExecutorService() {\n 66:         return scheduledExecutorService;\n 67:     }\n 68: \n 69:     /**\n 70:      * 拉取消息\n 71:      *\n 72:      * @param pullRequest 拉取消息请求\n 73:      */\n 74:     private void pullMessage(final PullRequest pullRequest) {\n 75:         final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());\n 76:         if (consumer != null) {\n 77:             DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;\n 78:             impl.pullMessage(pullRequest);\n 79:         } else {\n 80:             log.warn(\"No matched consumer for the PullRequest {}, drop it\", pullRequest);\n 81:         }\n 82:     }\n 83: \n 84:     @Override\n 85:     public void run() {\n 86:         log.info(this.getServiceName() + \" service started\");\n 87: \n 88:         while (!this.isStopped()) {\n 89:             try {\n 90:                 PullRequest pullRequest = this.pullRequestQueue.take();\n 91:                 if (pullRequest != null) {\n 92:                     this.pullMessage(pullRequest);\n 93:                 }\n 94:             } catch (InterruptedException e) {\n 95:             } catch (Exception e) {\n 96:                 log.error(\"Pull Message Service Run Method exception\", e);\n 97:             }\n 98:         }\n 99: \n100:         log.info(this.getServiceName() + \" service end\");\n101:     }\n102: \n103:     @Override\n104:     public String getServiceName() {\n105:         return PullMessageService.class.getSimpleName();\n106:     }\n107: \n108: }\n```\n\n* 说明 ：拉取消息服务，不断不断不断从 `Broker` 拉取消息，并提交消费任务到 `ConsumeMessageService`。\n* `#executePullRequestLater(...)` ：第 26 至 40 行 ： 提交**延迟**拉取消息请求。\n* `#executePullRequestImmediately(...)` ：第 42 至 53 行 ：提交**立即**拉取消息请求。\n* `#executeTaskLater(...)` ：第 55 至 63 行 ：提交**延迟任务**。\n* `#pullMessage(...)` ：第 69 至 82 行 ：执行拉取消息逻辑。详细解析见：[DefaultMQPushConsumerImpl#pullMessage(...)](#defaultmqpushconsumerimplpullmessage)。\n* `#run(...)` ：第 84 至 101 行 ：循环拉取消息请求队列( `pullRequestQueue` )，进行消息拉取。\n\n## DefaultMQPushConsumerImpl#pullMessage(...)\n\n```Java\n  1: public void pullMessage(final PullRequest pullRequest) {\n  2:     final ProcessQueue processQueue = pullRequest.getProcessQueue();\n  3:     if (processQueue.isDropped()) {\n  4:         log.info(\"the pull request[{}] is dropped.\", pullRequest.toString());\n  5:         return;\n  6:     }\n  7: \n  8:     // 设置队列最后拉取消息时间\n  9:     pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());\n 10: \n 11:     // 判断consumer状态是否运行中。如果不是，则延迟拉取消息。\n 12:     try {\n 13:         this.makeSureStateOK();\n 14:     } catch (MQClientException e) {\n 15:         log.warn(\"pullMessage exception, consumer state not ok\", e);\n 16:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 17:         return;\n 18:     }\n 19: \n 20:     // 判断是否暂停中。\n 21:     if (this.isPause()) {\n 22:         log.warn(\"consumer was paused, execute pull request later. instanceName={}, group={}\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());\n 23:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);\n 24:         return;\n 25:     }\n 26: \n 27:     // 判断是否超过最大持有消息数量。默认最大值为1000。\n 28:     long size = processQueue.getMsgCount().get();\n 29:     if (size > this.defaultMQPushConsumer.getPullThresholdForQueue()) {\n 30:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。\n 31:         if ((flowControlTimes1++ % 1000) == 0) {\n 32:             log.warn(\n 33:                 \"the consumer message buffer is full, so do flow control, minOffset={}, maxOffset={}, size={}, pullRequest={}, flowControlTimes={}\",\n 34:                 processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);\n 35:         }\n 36:         return;\n 37:     }\n 38: \n 39:     if (!this.consumeOrderly) { // 判断消息跨度是否过大。\n 40:         if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {\n 41:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。\n 42:             if ((flowControlTimes2++ % 1000) == 0) {\n 43:                 log.warn(\n 44:                     \"the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}\",\n 45:                     processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),\n 46:                     pullRequest, flowControlTimes2);\n 47:             }\n 48:             return;\n 49:         }\n 50:     } else { // TODO 顺序消费\n 51:         if (processQueue.isLocked()) {\n 52:             if (!pullRequest.isLockedFirst()) {\n 53:                 final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());\n 54:                 boolean brokerBusy = offset < pullRequest.getNextOffset();\n 55:                 log.info(\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\",\n 56:                     pullRequest, offset, brokerBusy);\n 57:                 if (brokerBusy) {\n 58:                     log.info(\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\",\n 59:                         pullRequest, offset);\n 60:                 }\n 61: \n 62:                 pullRequest.setLockedFirst(true);\n 63:                 pullRequest.setNextOffset(offset);\n 64:             }\n 65:         } else {\n 66:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 67:             log.info(\"pull message later because not locked in broker, {}\", pullRequest);\n 68:             return;\n 69:         }\n 70:     }\n 71: \n 72:     // 获取Topic 对应的订阅信息。若不存在，则延迟拉取消息\n 73:     final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());\n 74:     if (null == subscriptionData) {\n 75:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 76:         log.warn(\"find the consumer's subscription failed, {}\", pullRequest);\n 77:         return;\n 78:     }\n 79: \n 80:     final long beginTimestamp = System.currentTimeMillis();\n 81: \n 82:     PullCallback pullCallback = new PullCallback() {\n 83:         @Override\n 84:         public void onSuccess(PullResult pullResult) {\n 85:             if (pullResult != null) {\n 86:                 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,\n 87:                     subscriptionData);\n 88: \n 89:                 switch (pullResult.getPullStatus()) {\n 90:                     case FOUND:\n 91:                         // 设置下次拉取消息队列位置\n 92:                         long prevRequestOffset = pullRequest.getNextOffset();\n 93:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n 94: \n 95:                         // 统计\n 96:                         long pullRT = System.currentTimeMillis() - beginTimestamp;\n 97:                         DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),\n 98:                             pullRequest.getMessageQueue().getTopic(), pullRT);\n 99: \n100:                         long firstMsgOffset = Long.MAX_VALUE;\n101:                         if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {\n102:                             DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n103:                         } else {\n104:                             firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();\n105: \n106:                             // 统计\n107:                             DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),\n108:                                 pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());\n109: \n110:                             // 提交拉取到的消息到消息处理队列\n111:                             boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());\n112: \n113:                             // 提交消费请求\n114:                             DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//\n115:                                 pullResult.getMsgFoundList(), //\n116:                                 processQueue, //\n117:                                 pullRequest.getMessageQueue(), //\n118:                                 dispathToConsume);\n119: \n120:                             // 提交下次拉取消息请求\n121:                             if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {\n122:                                 DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,\n123:                                     DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());\n124:                             } else {\n125:                                 DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n126:                             }\n127:                         }\n128: \n129:                         // 下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为BUG，输出log\n130:                         if (pullResult.getNextBeginOffset() < prevRequestOffset//\n131:                             || firstMsgOffset < prevRequestOffset) {\n132:                             log.warn(\n133:                                 \"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\", //\n134:                                 pullResult.getNextBeginOffset(), //\n135:                                 firstMsgOffset, //\n136:                                 prevRequestOffset);\n137:                         }\n138: \n139:                         break;\n140:                     case NO_NEW_MSG:\n141:                         // 设置下次拉取消息队列位置\n142:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n143: \n144:                         // 持久化消费进度\n145:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);\n146: \n147:                         // 立即提交拉取消息请求\n148:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n149:                         break;\n150:                     case NO_MATCHED_MSG:\n151:                         // 设置下次拉取消息队列位置\n152:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n153: \n154:                         // 持久化消费进度\n155:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);\n156: \n157:                         // 提交立即拉取消息请求\n158:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n159:                         break;\n160:                     case OFFSET_ILLEGAL:\n161:                         log.warn(\"the pull request offset illegal, {} {}\", //\n162:                             pullRequest.toString(), pullResult.toString());\n163:                         // 设置下次拉取消息队列位置\n164:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n165: \n166:                         // 设置消息处理队列为dropped\n167:                         pullRequest.getProcessQueue().setDropped(true);\n168: \n169:                         // 提交延迟任务，进行消费处理队列移除。不立即移除的原因：可能有地方正在使用，避免受到影响。\n170:                         DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {\n171: \n172:                             @Override\n173:                             public void run() {\n174:                                 try {\n175:                                     // 更新消费进度，同步消费进度到Broker\n176:                                     DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),\n177:                                         pullRequest.getNextOffset(), false);\n178:                                     DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());\n179: \n180:                                     // 移除消费处理队列\n181:                                     DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());\n182: \n183:                                     log.warn(\"fix the pull request offset, {}\", pullRequest);\n184:                                 } catch (Throwable e) {\n185:                                     log.error(\"executeTaskLater Exception\", e);\n186:                                 }\n187:                             }\n188:                         }, 10000);\n189:                         break;\n190:                     default:\n191:                         break;\n192:                 }\n193:             }\n194:         }\n195: \n196:         @Override\n197:         public void onException(Throwable e) {\n198:             if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n199:                 log.warn(\"execute the pull request exception\", e);\n200:             }\n201: \n202:             // 提交延迟拉取消息请求\n203:             DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n204:         }\n205:     };\n206: \n207:     // 集群消息模型下，计算提交的消费进度。\n208:     boolean commitOffsetEnable = false;\n209:     long commitOffsetValue = 0L;\n210:     if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {\n211:         commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);\n212:         if (commitOffsetValue > 0) {\n213:             commitOffsetEnable = true;\n214:         }\n215:     }\n216: \n217:     // 计算请求的 订阅表达式 和 是否进行filtersrv过滤消息\n218:     String subExpression = null;\n219:     boolean classFilter = false;\n220:     SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());\n221:     if (sd != null) {\n222:         if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) {\n223:             subExpression = sd.getSubString();\n224:         }\n225: \n226:         classFilter = sd.isClassFilterMode();\n227:     }\n228: \n229:     // 计算拉取消息系统标识\n230:     int sysFlag = PullSysFlag.buildSysFlag(//\n231:         commitOffsetEnable, // commitOffset\n232:         true, // suspend\n233:         subExpression != null, // subscription\n234:         classFilter // class filter\n235:     );\n236: \n237:     // 执行拉取。如果拉取请求发生异常时，提交延迟拉取消息请求。\n238:     try {\n239:         this.pullAPIWrapper.pullKernelImpl(//\n240:             pullRequest.getMessageQueue(), // 1\n241:             subExpression, // 2\n242:             subscriptionData.getSubVersion(), // 3\n243:             pullRequest.getNextOffset(), // 4\n244:             this.defaultMQPushConsumer.getPullBatchSize(), // 5\n245:             sysFlag, // 6\n246:             commitOffsetValue, // 7\n247:             BROKER_SUSPEND_MAX_TIME_MILLIS, // 8\n248:             CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 9\n249:             CommunicationMode.ASYNC, // 10\n250:             pullCallback// 11\n251:         );\n252:     } catch (Exception e) {\n253:         log.error(\"pullKernelImpl exception\", e);\n254:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n255:     }\n256: }\n257: \n258: private void correctTagsOffset(final PullRequest pullRequest) {\n259:     if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {\n260:         this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);\n261:     }\n262: }\n```\n\n* `#pullMessage(...)` 说明 ：拉取消息。\n    * 第 3 至 6 行 ：消息处理队列已经终止，不进行消息拉取。\n    * 第 9 行 ：设置消息处理队列最后拉取消息时间。\n    * 第 11 至 18 行 ：`Consumer` 未处于运行中状态，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 20 至 25 行 ： `Consumer` 处于暂停中，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 27 至 37 行 ：消息处理队列持有消息超过最大允许值（默认：1000条），不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 39 至 49 行 ：`Consumer` 为**并发消费** 并且 消息队列持有消息跨度过大（消息跨度 = 持有消息最后一条和第一条的消息位置差，默认：2000），不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 50 至 70 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n    * 第 72 至 78 行 ：`Topic` 对应的订阅信息不存在，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 222 至 224 行 ：判断请求是否使用 `Consumer` **本地**的订阅信息( `SubscriptionData` )，而不使用 `Broker` 里的订阅信息。详细解析见：[PullMessageProcessor#processRequest(...) 第 64 至 110 行代码](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…)。\n    * 第 226 行 ：是否开启过滤类过滤模式。详细解析见：[《RocketMQ 源码分析 —— Filtersrv》](http://www.yunai.me/RocketMQ/filtersrv/)。\n    * 第 229 至 235 行 ：计算拉取消息请求系统标识。详细解析见：[PullMessageRequestHeader.sysFlag](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageRequestHeader)。\n    * 第 237 至 255 行 ：\n        * 执行消息拉取**异步**请求。详细解析见：[PullAPIWrapper#pullKernelImpl(...)](#pullapiwrapperpullkernelimpl)。\n        * 当发起请求产生异常时，提交**延迟**拉取消息请求。对应 `Broker` 处理拉取消息逻辑见：[PullMessageProcessor#processRequest(...)](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…)。\n* `PullCallback` ：拉取消息回调：\n   * 第 86 行 ：处理拉取结果。详细逻辑见：[PullAPIWrapper#processPullResult(...)](#pullapiwrapperprocesspullresult)。\n   * 第 89 至 192 行 ：处理拉取状态结果：\n        * 第 90 至 139 行 ：拉取到消息( `FOUND` ) ：\n            * 第 91 至 93 行 ：设置下次拉取消息队列位置。\n            * 第 95 至 97 行 ：统计。\n            * 第 101 至 102 行 ：拉取到消息的消息列表为空，提交**立即**拉取消息请求。为什么会存在拉取到消息，但是消息结果未空呢？原因见：[PullAPIWrapper#processPullResult(...)](#pullapiwrapperprocesspullresult)。\n            * 第 106 至 108 行 ：统计。\n            * 第 111 行 ：提交拉取到的消息到消息处理队列。详细解析见：[ProcessQueue#putMessage(...)](#processqueueputmessage)。\n            * 第 113 至 118 行 ：提交消费请求到 `ConsumeMessageService`。详细解析见：[ConsumeMessageConcurrentlyService](#consumemessageconcurrentlyservice)。\n            * 第 120 至 126 行 ：根据拉取频率( `pullInterval` )，提交**立即或者延迟**拉取消息请求。默认拉取频率为 0ms ，提交**立即**拉取消息请求。\n            * 第 129 至 137 行 ：下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为**BUG**，输出警告日志。\n       * 第 140 至 149 行 ：没有新消息( `NO_NEW_MSG` ) ：\n            * 第 142 行 ： 设置下次拉取消息队列位置。\n            * 第 145 行 ：更正消费进度。详细解析见：`#correctTagsOffset(...)`。\n            * 第 148 行 ：提交**立即**拉取消息请求。\n       * 第 150 至 159 行 ：有新消息但是不匹配( `NO_MATCHED_MSG` )。逻辑同 `NO_NEW_MSG` 。\n       * 第 160 至 189 行 ：拉取请求的消息队列位置不合法 (`OFFSET_ILLEGAL`)。\n            * 第 164 行 ：设置下次拉取消息队列位置。\n            * 第 167 行 ：设置消息处理队列为 `dropped`。\n            * 第 169 至 188 行 ：提交延迟任务，进行队列移除。\n                * 第 175 至 178 行 ：更新消费进度，同步消费进度到 `Broker`。\n                * 第 181 行 ：移除消费处理队列。\n                    * 疑问：为什么不立即移除？？？ \n  * 第 196 至 204 行 ：发生异常，提交**延迟**拉取消息请求。\n* `#correctTagsOffset(...)` ：更正消费进度。\n    * 第 258 至 261 行 ： 当消费处理队列持有消息数量为 **0** 时，更新消费进度为拉取请求的拉取消息队列位置。\n\n### PullAPIWrapper#pullKernelImpl(...)\n\n```Java\n  1: /**\n  2:  * 拉取消息核心方法\n  3:  *\n  4:  * @param mq 消息队列\n  5:  * @param subExpression 订阅表达式\n  6:  * @param subVersion 订阅版本号\n  7:  * @param offset 拉取队列开始位置\n  8:  * @param maxNums 拉取消息数量\n  9:  * @param sysFlag 拉取请求系统标识\n 10:  * @param commitOffset 提交消费进度\n 11:  * @param brokerSuspendMaxTimeMillis broker挂起请求最大时间\n 12:  * @param timeoutMillis 请求broker超时时长\n 13:  * @param communicationMode 通讯模式\n 14:  * @param pullCallback 拉取回调\n 15:  * @return 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。\n 16:  * @throws MQClientException 当寻找不到 broker 时，或发生其他client异常\n 17:  * @throws RemotingException 当远程调用发生异常时\n 18:  * @throws MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。\n 19:  * @throws InterruptedException 当发生中断异常时\n 20:  */\n 21: protected PullResult pullKernelImpl(\n 22:     final MessageQueue mq,\n 23:     final String subExpression,\n 24:     final long subVersion,\n 25:     final long offset,\n 26:     final int maxNums,\n 27:     final int sysFlag,\n 28:     final long commitOffset,\n 29:     final long brokerSuspendMaxTimeMillis,\n 30:     final long timeoutMillis,\n 31:     final CommunicationMode communicationMode,\n 32:     final PullCallback pullCallback\n 33: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 34:     // 获取Broker信息\n 35:     FindBrokerResult findBrokerResult =\n 36:         this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n 37:             this.recalculatePullFromWhichNode(mq), false);\n 38:     if (null == findBrokerResult) {\n 39:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());\n 40:         findBrokerResult =\n 41:             this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n 42:                 this.recalculatePullFromWhichNode(mq), false);\n 43:     }\n 44: \n 45:     // 请求拉取消息\n 46:     if (findBrokerResult != null) {\n 47:         int sysFlagInner = sysFlag;\n 48: \n 49:         if (findBrokerResult.isSlave()) {\n 50:             sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);\n 51:         }\n 52: \n 53:         PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();\n 54:         requestHeader.setConsumerGroup(this.consumerGroup);\n 55:         requestHeader.setTopic(mq.getTopic());\n 56:         requestHeader.setQueueId(mq.getQueueId());\n 57:         requestHeader.setQueueOffset(offset);\n 58:         requestHeader.setMaxMsgNums(maxNums);\n 59:         requestHeader.setSysFlag(sysFlagInner);\n 60:         requestHeader.setCommitOffset(commitOffset);\n 61:         requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);\n 62:         requestHeader.setSubscription(subExpression);\n 63:         requestHeader.setSubVersion(subVersion);\n 64: \n 65:         String brokerAddr = findBrokerResult.getBrokerAddr();\n 66:         if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) { // TODO filtersrv\n 67:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n 68:         }\n 69: \n 70:         PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(\n 71:             brokerAddr,\n 72:             requestHeader,\n 73:             timeoutMillis,\n 74:             communicationMode,\n 75:             pullCallback);\n 76: \n 77:         return pullResult;\n 78:     }\n 79: \n 80:     // Broker信息不存在，则抛出异常\n 81:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n 82: }\n```\n\n* 说明 ：拉取消息核心方法。**该方法参数较多，可以看下代码注释上每个参数的说明**😈。\n* 第 34 至 43 行 ：获取 `Broker` 信息(`Broker` 地址、是否为从节点)。\n    * [#recalculatePullFromWhichNode(...)](#pullapiwrapperrecalculatepullfromwhichnode)\n    * [#MQClientInstance#findBrokerAddressInSubscribe(...)](#mqclientinstancefindbrokeraddressinsubscribe)\n* 第 45 至 78 行 ：**请求拉取消息**。\n* 第 81 行 ：当 `Broker` 信息不存在，则抛出异常。\n\n#### PullAPIWrapper#recalculatePullFromWhichNode(...)\n\n```Java\n  1: /**\n  2:  * 消息队列 与 拉取Broker 的映射\n  3:  * 当拉取消息时，会通过该映射获取拉取请求对应的Broker\n  4:  */\n  5: private ConcurrentHashMap<MessageQueue, AtomicLong/* brokerId */> pullFromWhichNodeTable =\n  6:     new ConcurrentHashMap<MessageQueue, AtomicLong>(32);\n  7: /**\n  8:  * 是否使用默认Broker\n  9:  */\n 10: private volatile boolean connectBrokerByUser = false;\n 11: /**\n 12:  * 默认Broker编号\n 13:  */\n 14: private volatile long defaultBrokerId = MixAll.MASTER_ID;\n 15: \n 16: /**\n 17:  * 计算消息队列拉取消息对应的Broker编号\n 18:  *\n 19:  * @param mq 消息队列\n 20:  * @return Broker编号\n 21:  */\n 22: public long recalculatePullFromWhichNode(final MessageQueue mq) {\n 23:     // 若开启默认Broker开关，则返回默认Broker编号\n 24:     if (this.isConnectBrokerByUser()) {\n 25:         return this.defaultBrokerId;\n 26:     }\n 27: \n 28:     // 若消息队列映射拉取Broker存在，则返回映射Broker编号\n 29:     AtomicLong suggest = this.pullFromWhichNodeTable.get(mq);\n 30:     if (suggest != null) {\n 31:         return suggest.get();\n 32:     }\n 33: \n 34:     // 返回Broker主节点编号\n 35:     return MixAll.MASTER_ID;\n 36: }\n```\n\n* 说明 ：计算消息队列拉取消息对应的 `Broker` 编号。\n\n#### MQClientInstance#findBrokerAddressInSubscribe(...)\n\n```Java\n  1: /**\n  2:  * Broker名字 和 Broker地址相关 Map\n  3:  */\n  4: private final ConcurrentHashMap<String/* Broker Name */, HashMap<Long/* brokerId */, String/* address */>> brokerAddrTable =\n  5:         new ConcurrentHashMap<>();\n  6: \n  7: /**\n  8:  * 获得Broker信息\n  9:  *\n 10:  * @param brokerName broker名字\n 11:  * @param brokerId broker编号\n 12:  * @param onlyThisBroker 是否必须是该broker\n 13:  * @return Broker信息\n 14:  */\n 15: public FindBrokerResult findBrokerAddressInSubscribe(//\n 16:     final String brokerName, //\n 17:     final long brokerId, //\n 18:     final boolean onlyThisBroker//\n 19: ) {\n 20:     String brokerAddr = null; // broker地址\n 21:     boolean slave = false; // 是否为从节点\n 22:     boolean found = false; // 是否找到\n 23: \n 24:     // 获得Broker信息\n 25:     HashMap<Long/* brokerId */, String/* address */> map = this.brokerAddrTable.get(brokerName);\n 26:     if (map != null && !map.isEmpty()) {\n 27:         brokerAddr = map.get(brokerId);\n 28:         slave = brokerId != MixAll.MASTER_ID;\n 29:         found = brokerAddr != null;\n 30: \n 31:         // 如果不强制获得，选择一个Broker\n 32:         if (!found && !onlyThisBroker) {\n 33:             Entry<Long, String> entry = map.entrySet().iterator().next();\n 34:             brokerAddr = entry.getValue();\n 35:             slave = entry.getKey() != MixAll.MASTER_ID;\n 36:             found = true;\n 37:         }\n 38:     }\n 39: \n 40:     // 找到broker，则返回信息\n 41:     if (found) {\n 42:         return new FindBrokerResult(brokerAddr, slave);\n 43:     }\n 44: \n 45:     // 找不到，则返回空\n 46:     return null;\n 47: }\n```\n\n* 说明 ：获取 `Broker` 信息(`Broker` 地址、是否为从节点)。\n\n### PullAPIWrapper#processPullResult(...)\n\n```Java\n  1: /**\n  2:  * 处理拉取结果\n  3:  * 1. 更新消息队列拉取消息Broker编号的映射\n  4:  * 2. 解析消息，并根据订阅信息消息tagCode匹配合适消息\n  5:  *\n  6:  * @param mq 消息队列\n  7:  * @param pullResult 拉取结果\n  8:  * @param subscriptionData 订阅信息\n  9:  * @return 拉取结果\n 10:  */\n 11: public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult,\n 12:     final SubscriptionData subscriptionData) {\n 13:     PullResultExt pullResultExt = (PullResultExt) pullResult;\n 14: \n 15:     // 更新消息队列拉取消息Broker编号的映射\n 16:     this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());\n 17: \n 18:     // 解析消息，并根据订阅信息消息tagCode匹配合适消息\n 19:     if (PullStatus.FOUND == pullResult.getPullStatus()) {\n 20:         // 解析消息\n 21:         ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());\n 22:         List<MessageExt> msgList = MessageDecoder.decodes(byteBuffer);\n 23: \n 24:         // 根据订阅信息消息tagCode匹配合适消息\n 25:         List<MessageExt> msgListFilterAgain = msgList;\n 26:         if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()) {\n 27:             msgListFilterAgain = new ArrayList<>(msgList.size());\n 28:             for (MessageExt msg : msgList) {\n 29:                 if (msg.getTags() != null) {\n 30:                     if (subscriptionData.getTagsSet().contains(msg.getTags())) {\n 31:                         msgListFilterAgain.add(msg);\n 32:                     }\n 33:                 }\n 34:             }\n 35:         }\n 36: \n 37:         // Hook\n 38:         if (this.hasHook()) {\n 39:             FilterMessageContext filterMessageContext = new FilterMessageContext();\n 40:             filterMessageContext.setUnitMode(unitMode);\n 41:             filterMessageContext.setMsgList(msgListFilterAgain);\n 42:             this.executeHook(filterMessageContext);\n 43:         }\n 44: \n 45:         // 设置消息队列当前最小/最大位置到消息拓展字段\n 46:         for (MessageExt msg : msgListFilterAgain) {\n 47:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,\n 48:                 Long.toString(pullResult.getMinOffset()));\n 49:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,\n 50:                 Long.toString(pullResult.getMaxOffset()));\n 51:         }\n 52: \n 53:         // 设置消息列表\n 54:         pullResultExt.setMsgFoundList(msgListFilterAgain);\n 55:     }\n 56: \n 57:     // 清空消息二进制数组\n 58:     pullResultExt.setMessageBinary(null);\n 59: \n 60:     return pullResult;\n 61: }\n```\n\n* 说明 ：处理拉取结果。\n    *  更新消息队列拉取消息 `Broker` 编号的映射。\n    *  解析消息，并根据订阅信息消息 `tagCode `匹配合适消息。\n* 第 16 行 ：更新消息队列拉取消息 `Broker` 编号的映射。下次拉取消息时，如果未设置默认拉取的 `Broker` 编号，会使用更新后的 `Broker` 编号。\n* 第 18 至 55 行 ：解析消息，并根据订阅信息消息 `tagCode` 匹配合适消息。\n    * 第 20 至 22 行 ：解析消息。详细解析见：[《RocketMQ 源码分析 —— Message基础》](http://www.yunai.me/RocketMQ/message/) 。\n    * 第 24 至 35 行 ：根据订阅信息`tagCode` 匹配消息。\n    * 第 37 至 43 行 ：`Hook`。\n    * 第 45 至 51 行 ：设置消息队列当前最小/最大位置到消息拓展字段。\n    * 第 54 行 ：设置消息队列。\n* 第 58 行 ：清空消息二进制数组。\n\n### ProcessQueue#putMessage(...)\n\n```Java\n  1:  /**\n  2:  * 消息映射读写锁\n  3:  */\n  4: private final ReadWriteLock lockTreeMap = new ReentrantReadWriteLock();\n  5: /**\n  6:  * 消息映射\n  7:  * key：消息队列位置\n  8:  */\n  9: private final TreeMap<Long, MessageExt> msgTreeMap = new TreeMap<>();\n 10: /**\n 11:  * 消息数\n 12:  */\n 13: private final AtomicLong msgCount = new AtomicLong();\n 14: /**\n 15:  * 添加消息最大队列位置\n 16:  */\n 17: private volatile long queueOffsetMax = 0L;\n 18: /**\n 19:  * 是否正在消费\n 20:  */\n 21: private volatile boolean consuming = false;\n 22: /**\n 23:  * Broker累计消息数量\n 24:  * 计算公式 = queueMaxOffset - 新添加消息数组[n - 1].queueOffset\n 25:  * Acc = Accumulation\n 26:  * cnt = （猜测）对比度\n 27:  */\n 28: private volatile long msgAccCnt = 0;\n 29: \n 30: /**\n 31:  * 添加消息，并返回是否提交给消费者\n 32:  * 返回true，当有新消息添加成功时，\n 33:  *\n 34:  * @param msgs 消息\n 35:  * @return 是否提交给消费者\n 36:  */\n 37: public boolean putMessage(final List<MessageExt> msgs) {\n 38:     boolean dispatchToConsume = false;\n 39:     try {\n 40:         this.lockTreeMap.writeLock().lockInterruptibly();\n 41:         try {\n 42:             // 添加消息\n 43:             int validMsgCnt = 0;\n 44:             for (MessageExt msg : msgs) {\n 45:                 MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);\n 46:                 if (null == old) {\n 47:                     validMsgCnt++;\n 48:                     this.queueOffsetMax = msg.getQueueOffset();\n 49:                 }\n 50:             }\n 51:             msgCount.addAndGet(validMsgCnt);\n 52: \n 53:             // 计算是否正在消费\n 54:             if (!msgTreeMap.isEmpty() && !this.consuming) {\n 55:                 dispatchToConsume = true;\n 56:                 this.consuming = true;\n 57:             }\n 58: \n 59:             // Broker累计消息数量\n 60:             if (!msgs.isEmpty()) {\n 61:                 MessageExt messageExt = msgs.get(msgs.size() - 1);\n 62:                 String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);\n 63:                 if (property != null) {\n 64:                     long accTotal = Long.parseLong(property) - messageExt.getQueueOffset();\n 65:                     if (accTotal > 0) {\n 66:                         this.msgAccCnt = accTotal;\n 67:                     }\n 68:                 }\n 69:             }\n 70:         } finally {\n 71:             this.lockTreeMap.writeLock().unlock();\n 72:         }\n 73:     } catch (InterruptedException e) {\n 74:         log.error(\"putMessage exception\", e);\n 75:     }\n 76: \n 77:     return dispatchToConsume;\n 78: }\n```\n\n## 总结\n\n如果用最简单粗暴的方式描述 `PullConsumer` 拉取消息的过程，那就是如下的代码：\n\n```Java\nwhile (true) {\n    if (不满足拉取消息) {\n        Thread.sleep(间隔);\n        continue;\n    }\n    主动拉取消息();\n}\n```\n\n# 6、PushConsumer 消费消息\n\n![DefaultMQPushConsumerImpl消费消息](http://www.yunai.me/images/RocketMQ/2017_05_04/06.png)\n\n## ConsumeMessageConcurrentlyService 提交消费请求\n\n### ConsumeMessageConcurrentlyService#submitConsumeRequest(...)\n\n```Java\n  1: /**\n  2:  * 消费线程池队列\n  3:  */\n  4: private final BlockingQueue<Runnable> consumeRequestQueue;\n  5: /**\n  6:  * 消费线程池\n  7:  */\n  8: private final ThreadPoolExecutor consumeExecutor;\n  9: \n 10: public void submitConsumeRequest(//\n 11:     final List<MessageExt> msgs, //\n 12:     final ProcessQueue processQueue, //\n 13:     final MessageQueue messageQueue, //\n 14:     final boolean dispatchToConsume) {\n 15:     final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n 16:     if (msgs.size() <= consumeBatchSize) { // 提交消息小于批量消息数，直接提交消费请求\n 17:         ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);\n 18:         try {\n 19:             this.consumeExecutor.submit(consumeRequest);\n 20:         } catch (RejectedExecutionException e) {\n 21:             this.submitConsumeRequestLater(consumeRequest);\n 22:         }\n 23:     } else { // 提交消息大于批量消息数，进行分拆成多个消费请求\n 24:         for (int total = 0; total < msgs.size(); ) {\n 25:             // 计算当前拆分请求包含的消息\n 26:             List<MessageExt> msgThis = new ArrayList<>(consumeBatchSize);\n 27:             for (int i = 0; i < consumeBatchSize; i++, total++) {\n 28:                 if (total < msgs.size()) {\n 29:                     msgThis.add(msgs.get(total));\n 30:                 } else {\n 31:                     break;\n 32:                 }\n 33:             }\n 34: \n 35:             // 提交拆分消费请求\n 36:             ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);\n 37:             try {\n 38:                 this.consumeExecutor.submit(consumeRequest);\n 39:             } catch (RejectedExecutionException e) {\n 40:                 // 如果被拒绝，则将当前拆分消息+剩余消息提交延迟消费请求。\n 41:                 for (; total < msgs.size(); total++) {\n 42:                     msgThis.add(msgs.get(total));\n 43:                 }\n 44:                 this.submitConsumeRequestLater(consumeRequest);\n 45:             }\n 46:         }\n 47:     }\n 48: }\n```\n\n* 说明 ：提交**立即**消费请求。\n* 第 16 至 22 行 ：提交消息小于等于批量消费数，直接提交消费请求。\n* 第 23 至 47 行 ：当提交消息大于批量消费数，进行分拆成多个请求。\n    * 第 25 至 33 行 ：计算当前拆分请求包含的消息。\n    * 第 35 至 38 行 ：提交拆分消费请求。\n    * 第 39 至 44 行 ：提交请求被拒绝，则将当前拆分消息 + 剩余消息提交延迟消费请求，结束拆分循环。\n\n### ConsumeMessageConcurrentlyService#submitConsumeRequestLater\n \n ```Java\n   1: /**\n  2:  * 提交延迟消费请求\n  3:  *\n  4:  * @param msgs 消息列表\n  5:  * @param processQueue 消息处理队列\n  6:  * @param messageQueue 消息队列\n  7:  */\n  8: private void submitConsumeRequestLater(//\n  9:     final List<MessageExt> msgs, //\n 10:     final ProcessQueue processQueue, //\n 11:     final MessageQueue messageQueue//\n 12: ) {\n 13: \n 14:     this.scheduledExecutorService.schedule(new Runnable() {\n 15: \n 16:         @Override\n 17:         public void run() {\n 18:             ConsumeMessageConcurrentlyService.this.submitConsumeRequest(msgs, processQueue, messageQueue, true);\n 19:         }\n 20:     }, 5000, TimeUnit.MILLISECONDS);\n 21: }\n 22: \n 23: /**\n 24:  * 提交延迟消费请求\n 25:  * @param consumeRequest 消费请求\n 26:  */\n 27: private void submitConsumeRequestLater(final ConsumeRequest consumeRequest//\n 28: ) {\n 29: \n 30:     this.scheduledExecutorService.schedule(new Runnable() {\n 31: \n 32:         @Override\n 33:         public void run() {\n 34:             ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest); // TODO BUG ?\n 35:         }\n 36:     }, 5000, TimeUnit.MILLISECONDS);\n 37: }\n ```\n \n* 说明 ：提交延迟消费请求。\n* 第 34 行 ：直接调用 `ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);`。如果消息数超过批量消费上限，会不会是**BUG**。\n \n## ConsumeRequest\n\n```Java\n  1: class ConsumeRequest implements Runnable {\n  2: \n  3:     /**\n  4:      * 消费消息列表\n  5:      */\n  6:     private final List<MessageExt> msgs;\n  7:     /**\n  8:      * 消息处理队列\n  9:      */\n 10:     private final ProcessQueue processQueue;\n 11:     /**\n 12:      * 消息队列\n 13:      */\n 14:     private final MessageQueue messageQueue;\n 15: \n 16:     public ConsumeRequest(List<MessageExt> msgs, ProcessQueue processQueue, MessageQueue messageQueue) {\n 17:         this.msgs = msgs;\n 18:         this.processQueue = processQueue;\n 19:         this.messageQueue = messageQueue;\n 20:     }\n 21: \n 22:     @Override\n 23:     public void run() {\n 24:         // 废弃队列不进行消费\n 25:         if (this.processQueue.isDropped()) {\n 26:             log.info(\"the message queue not be able to consume, because it's dropped. group={} {}\", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);\n 27:             return;\n 28:         }\n 29: \n 30:         MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener; // 监听器\n 31:         ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue); // 消费Context\n 32:         ConsumeConcurrentlyStatus status = null; // 消费结果状态\n 33: \n 34:         // Hook\n 35:         ConsumeMessageContext consumeMessageContext = null;\n 36:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n 37:             consumeMessageContext = new ConsumeMessageContext();\n 38:             consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());\n 39:             consumeMessageContext.setProps(new HashMap<String, String>());\n 40:             consumeMessageContext.setMq(messageQueue);\n 41:             consumeMessageContext.setMsgList(msgs);\n 42:             consumeMessageContext.setSuccess(false);\n 43:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n 44:         }\n 45: \n 46:         long beginTimestamp = System.currentTimeMillis();\n 47:         boolean hasException = false;\n 48:         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; // 消费返回结果类型\n 49:         try {\n 50:             // 当消息为重试消息，设置Topic为原始Topic\n 51:             ConsumeMessageConcurrentlyService.this.resetRetryTopic(msgs);\n 52: \n 53:             // 设置开始消费时间\n 54:             if (msgs != null && !msgs.isEmpty()) {\n 55:                 for (MessageExt msg : msgs) {\n 56:                     MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));\n 57:                 }\n 58:             }\n 59: \n 60:             // 进行消费\n 61:             status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);\n 62:         } catch (Throwable e) {\n 63:             log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",\n 64:                 RemotingHelper.exceptionSimpleDesc(e), //\n 65:                 ConsumeMessageConcurrentlyService.this.consumerGroup,\n 66:                 msgs,\n 67:                 messageQueue);\n 68:             hasException = true;\n 69:         }\n 70: \n 71:         // 解析消费返回结果类型\n 72:         long consumeRT = System.currentTimeMillis() - beginTimestamp;\n 73:         if (null == status) {\n 74:             if (hasException) {\n 75:                 returnType = ConsumeReturnType.EXCEPTION;\n 76:             } else {\n 77:                 returnType = ConsumeReturnType.RETURNNULL;\n 78:             }\n 79:         } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n 80:             returnType = ConsumeReturnType.TIME_OUT;\n 81:         } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) {\n 82:             returnType = ConsumeReturnType.FAILED;\n 83:         } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) {\n 84:             returnType = ConsumeReturnType.SUCCESS;\n 85:         }\n 86: \n 87:         // Hook\n 88:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n 89:             consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());\n 90:         }\n 91: \n 92:         // 消费结果状态为空时，则设置为稍后重新消费\n 93:         if (null == status) {\n 94:             log.warn(\"consumeMessage return null, Group: {} Msgs: {} MQ: {}\",\n 95:                 ConsumeMessageConcurrentlyService.this.consumerGroup,\n 96:                 msgs,\n 97:                 messageQueue);\n 98:             status = ConsumeConcurrentlyStatus.RECONSUME_LATER;\n 99:         }\n100: \n101:         // Hook\n102:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n103:             consumeMessageContext.setStatus(status.toString());\n104:             consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);\n105:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n106:         }\n107: \n108:         // 统计\n109:         ConsumeMessageConcurrentlyService.this.getConsumerStatsManager()\n110:             .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);\n111: \n112:         // 处理消费结果\n113:         if (!processQueue.isDropped()) {\n114:             ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);\n115:         } else {\n116:             log.warn(\"processQueue is dropped without process consume result. messageQueue={}, msgs={}\", messageQueue, msgs);\n117:         }\n118:     }\n119: \n120: }\n```\n\n* 说明 ：消费请求。提交请求执行消费。\n* 第 24 至 28 行 ：废弃处理队列不进行消费。\n* 第 34 至 44 行 ：Hook。\n* 第 51 行 ：当消息为重试消息，设置 `Topic`为原始 `Topic`。例如：原始 `Topic` 为 `TopicTest`，重试时 `Topic` 为 `%RETRY%please_rename_unique_group_name_4`，经过该方法，`Topic` 设置回 `TopicTest`。\n* 第 53 至 58 行 ：设置开始消费时间。\n* 第 61 行 ：**进行消费**。\n* 第 71 至 85 行 ：解析消费返回结果类型\n* 第 87 至 90 行 ：`Hook`。\n* 第 92 至 99 行 ：消费结果状态未空时，则设置消费结果状态为稍后消费。\n* 第 101 至 106 行 ：`Hook`。\n* 第 108 至 110 行 ：统计。\n* 第 112 至 117 行 ：处理消费结果。**如果消费处理队列被移除，恰好消息被消费，则可能导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性**。详细解析见：[ConsumeMessageConcurrentlyService#processConsumeResult(...)](#consumemessageconcurrentlyserviceprocessconsumeresult)。\n\n## ConsumeMessageConcurrentlyService#processConsumeResult(...)\n\n```Java\n  1: public void processConsumeResult(//\n  2:     final ConsumeConcurrentlyStatus status, //\n  3:     final ConsumeConcurrentlyContext context, //\n  4:     final ConsumeRequest consumeRequest//\n  5: ) {\n  6:     int ackIndex = context.getAckIndex();\n  7: \n  8:     // 消息为空，直接返回\n  9:     if (consumeRequest.getMsgs().isEmpty())\n 10:         return;\n 11: \n 12:     // 计算从consumeRequest.msgs[0]到consumeRequest.msgs[ackIndex]的消息消费成功\n 13:     switch (status) {\n 14:         case CONSUME_SUCCESS:\n 15:             if (ackIndex >= consumeRequest.getMsgs().size()) {\n 16:                 ackIndex = consumeRequest.getMsgs().size() - 1;\n 17:             }\n 18:             // 统计成功/失败数量\n 19:             int ok = ackIndex + 1;\n 20:             int failed = consumeRequest.getMsgs().size() - ok;\n 21:             this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);\n 22:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);\n 23:             break;\n 24:         case RECONSUME_LATER:\n 25:             ackIndex = -1;\n 26:             // 统计成功/失败数量\n 27:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),\n 28:                 consumeRequest.getMsgs().size());\n 29:             break;\n 30:         default:\n 31:             break;\n 32:     }\n 33: \n 34:     // 处理消费失败的消息\n 35:     switch (this.defaultMQPushConsumer.getMessageModel()) {\n 36:         case BROADCASTING: // 广播模式，无论是否消费失败，不发回消息到Broker，只打印Log\n 37:             for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {\n 38:                 MessageExt msg = consumeRequest.getMsgs().get(i);\n 39:                 log.warn(\"BROADCASTING, the message consume failed, drop it, {}\", msg.toString());\n 40:             }\n 41:             break;\n 42:         case CLUSTERING:\n 43:             // 发回消息失败到Broker。\n 44:             List<MessageExt> msgBackFailed = new ArrayList<>(consumeRequest.getMsgs().size());\n 45:             for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {\n 46:                 MessageExt msg = consumeRequest.getMsgs().get(i);\n 47:                 boolean result = this.sendMessageBack(msg, context);\n 48:                 if (!result) {\n 49:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n 50:                     msgBackFailed.add(msg);\n 51:                 }\n 52:             }\n 53: \n 54:             // 发回Broker失败的消息，直接提交延迟重新消费\n 55:             if (!msgBackFailed.isEmpty()) {\n 56:                 consumeRequest.getMsgs().removeAll(msgBackFailed);\n 57: \n 58:                 this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());\n 59:             }\n 60:             break;\n 61:         default:\n 62:             break;\n 63:     }\n 64: \n 65:     // 移除消费成功消息，并更新最新消费进度\n 66:     long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());\n 67:     if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {\n 68:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);\n 69:     }\n 70: }\n```\n\n* 说明 ：处理消费结果。\n* 第 8 至 10 行 ：消费请求消息未空时，直接返回。\n* 第 12 至 32 行 ：计算 `ackIndex` 值。`consumeRequest.msgs[0 - ackIndex]`为消费成功，需要进行 `ack` 确认。\n    * 第 14 至 23 行 ：`CONSUME_SUCCESS` ：`ackIndex = context.getAckIndex()`。\n    * 第 24 至 29 行 ：`RECONSUME_LATER` ：`ackIndex = -1`。\n* 第34 至 63 行 ：处理消费失败的消息。\n    * 第 36 至 41 行 ：`BROADCASTING` ：广播模式，无论是否消费失败，不发回消息到 `Broker`，只打印日志。\n    * 第 42 至 60 行 ：`CLUSTERING` ：集群模式，消费失败的消息发回到 `Broker`。\n        * 第 43 至 52 行 ：发回消费失败的消息到 `Broker`。详细解析见：[DefaultMQPushConsumerImpl#sendMessageBack(...)](#defaultmqpushconsumerimplsendmessageback)。\n        * 第 54 至 59 行 ：发回 `Broker` 失败的消息，直接提交延迟重新消费。\n        * **如果发回 `Broker` 成功，结果因为例如网络异常，导致 `Consumer`以为发回失败，判定消费发回失败，会导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性。**\n* 第 65 至 69 行 ：移除**【消费成功】**和**【消费失败但发回`Broker`成功】**的消息，并更新最新消费进度。\n    * 为什么会有**【消费失败但发回`Broker`成功】**的消息？见**第 56 行**。\n    * [ProcessQueue#removeMessage(...)](#processqueueremovemessage)\n\n### ProcessQueue#removeMessage(...)\n\n```Java\n  1: /**\n  2:  * 移除消息，并返回第一条消息队列位置\n  3:  *\n  4:  * @param msgs 消息\n  5:  * @return 消息队列位置\n  6:  */\n  7: public long removeMessage(final List<MessageExt> msgs) {\n  8:     long result = -1;\n  9:     final long now = System.currentTimeMillis();\n 10:     try {\n 11:         this.lockTreeMap.writeLock().lockInterruptibly();\n 12:         this.lastConsumeTimestamp = now;\n 13:         try {\n 14:             if (!msgTreeMap.isEmpty()) {\n 15:                 result = this.queueOffsetMax + 1; // 这里+1的原因是：如果msgTreeMap为空时，下一条获得的消息位置为queueOffsetMax+1\n 16: \n 17:                 // 移除消息\n 18:                 int removedCnt = 0;\n 19:                 for (MessageExt msg : msgs) {\n 20:                     MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());\n 21:                     if (prev != null) {\n 22:                         removedCnt--;\n 23:                     }\n 24:                 }\n 25:                 msgCount.addAndGet(removedCnt);\n 26: \n 27:                 if (!msgTreeMap.isEmpty()) {\n 28:                     result = msgTreeMap.firstKey();\n 29:                 }\n 30:             }\n 31:         } finally {\n 32:             this.lockTreeMap.writeLock().unlock();\n 33:         }\n 34:     } catch (Throwable t) {\n 35:         log.error(\"removeMessage exception\", t);\n 36:     }\n 37: \n 38:     return result;\n 39: }\n```\n\n## ConsumeMessageConcurrentlyService#cleanExpireMsg(...)\n\n```Java\n  1: public void start() {\n  2:     this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() {\n  3: \n  4:         @Override\n  5:         public void run() {\n  6:             cleanExpireMsg();\n  7:         }\n  8: \n  9:     }, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);\n 10: }\n 11: \n 12: /**\n 13:  * 清理过期消息\n 14:  */\n 15: private void cleanExpireMsg() {\n 16:     Iterator<Map.Entry<MessageQueue, ProcessQueue>> it =\n 17:         this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();\n 18:     while (it.hasNext()) {\n 19:         Map.Entry<MessageQueue, ProcessQueue> next = it.next();\n 20:         ProcessQueue pq = next.getValue();\n 21:         pq.cleanExpiredMsg(this.defaultMQPushConsumer);\n 22:     }\n 23: }\n```\n\n* 说明 ：定时清理过期消息，默认周期：15min。\n\n### ProcessQueue#cleanExpiredMsg(...)\n\n```Java\n  1: public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) {\n  2:     // 顺序消费时，直接返回\n  3:     if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) {\n  4:         return;\n  5:     }\n  6: \n  7:     // 循环移除消息\n  8:     int loop = msgTreeMap.size() < 16 ? msgTreeMap.size() : 16; // 每次循环最多移除16条\n  9:     for (int i = 0; i < loop; i++) {\n 10:         // 获取第一条消息。判断是否超时，若不超时，则结束循环\n 11:         MessageExt msg = null;\n 12:         try {\n 13:             this.lockTreeMap.readLock().lockInterruptibly();\n 14:             try {\n 15:                 if (!msgTreeMap.isEmpty() && System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) > pushConsumer.getConsumeTimeout() * 60 * 1000) {\n 16:                     msg = msgTreeMap.firstEntry().getValue();\n 17:                 } else {\n 18:                     break;\n 19:                 }\n 20:             } finally {\n 21:                 this.lockTreeMap.readLock().unlock();\n 22:             }\n 23:         } catch (InterruptedException e) {\n 24:             log.error(\"getExpiredMsg exception\", e);\n 25:         }\n 26: \n 27:         try {\n 28:             // 发回超时消息\n 29:             pushConsumer.sendMessageBack(msg, 3);\n 30:             log.info(\"send expire msg back. topic={}, msgId={}, storeHost={}, queueId={}, queueOffset={}\", msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());\n 31: \n 32:             // 判断此时消息是否依然是第一条，若是，则进行移除\n 33:             try {\n 34:                 this.lockTreeMap.writeLock().lockInterruptibly();\n 35:                 try {\n 36:                     if (!msgTreeMap.isEmpty() && msg.getQueueOffset() == msgTreeMap.firstKey()) {\n 37:                         try {\n 38:                             msgTreeMap.remove(msgTreeMap.firstKey());\n 39:                         } catch (Exception e) {\n 40:                             log.error(\"send expired msg exception\", e);\n 41:                         }\n 42:                     }\n 43:                 } finally {\n 44:                     this.lockTreeMap.writeLock().unlock();\n 45:                 }\n 46:             } catch (InterruptedException e) {\n 47:                 log.error(\"getExpiredMsg exception\", e);\n 48:             }\n 49:         } catch (Exception e) {\n 50:             log.error(\"send expired msg exception\", e);\n 51:         }\n 52:     }\n 53: }\n```\n\n* 说明 ：移除过期消息。\n* 第 2 至 5 行 ：顺序消费时，直接返回。\n* 第 7 至 9 行 ：循环移除消息。默认最大循环次数：16次。\n* 第 10 至 25 行 ：获取第一条消息。判断是否超时，若不超时，则结束循环。\n* 第 29 行 ：**发回超时消息到`Broker`**。\n* 第 32 至 48 行 ：判断此时消息是否依然是第一条，若是，则进行移除。\n\n# 7、PushConsumer 发回消费失败消息\n\n## DefaultMQPushConsumerImpl#sendMessageBack(...)\n\n```Java\n  1: public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)\n  2:     throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n  3:     try {\n  4:         // Consumer发回消息\n  5:         String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)\n  6:             : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());\n  7:         this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,\n  8:             this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());\n  9:     } catch (Exception e) { // TODO 疑问：什么情况下会发生异常\n 10:         // 异常时，使用Client内置Producer发回消息\n 11:         log.error(\"sendMessageBack Exception, \" + this.defaultMQPushConsumer.getConsumerGroup(), e);\n 12: \n 13:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());\n 14: \n 15:         String originMsgId = MessageAccessor.getOriginMessageId(msg);\n 16:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);\n 17: \n 18:         newMsg.setFlag(msg.getFlag());\n 19:         MessageAccessor.setProperties(newMsg, msg.getProperties());\n 20:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());\n 21:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));\n 22:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));\n 23:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());\n 24: \n 25:         this.mQClientFactory.getDefaultMQProducer().send(newMsg);\n 26:     }\n 27: }\n```\n\n* 说明 ：发回消息。\n* 第 4 至 8 行 ：`Consumer` 发回消息。详细解析见：[MQClientAPIImpl#consumerSendMessageBack(...)](#mqclientapiimplconsumersendmessageback)。\n* 第 10 至 25 行 ：发生异常时，`Consumer` 内置默认 `Producer` 发送消息。\n    * 😈疑问：什么样的情况下会发生异常呢？\n\n### MQClientAPIImpl#consumerSendMessageBack(...)\n\n```Java\n  1: /**\n  2:  * Consumer发回消息\n  3:  * @param addr Broker地址\n  4:  * @param msg 消息\n  5:  * @param consumerGroup 消费分组\n  6:  * @param delayLevel 延迟级别\n  7:  * @param timeoutMillis 超时\n  8:  * @param maxConsumeRetryTimes 消费最大重试次数\n  9:  * @throws RemotingException 当远程调用发生异常时\n 10:  * @throws MQBrokerException 当Broker发生异常时\n 11:  * @throws InterruptedException 当线程中断时\n 12:  */\n 13: public void consumerSendMessageBack(\n 14:     final String addr,\n 15:     final MessageExt msg,\n 16:     final String consumerGroup,\n 17:     final int delayLevel,\n 18:     final long timeoutMillis,\n 19:     final int maxConsumeRetryTimes\n 20: ) throws RemotingException, MQBrokerException, InterruptedException {\n 21:     ConsumerSendMsgBackRequestHeader requestHeader = new ConsumerSendMsgBackRequestHeader();\n 22:     RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);\n 23: \n 24:     requestHeader.setGroup(consumerGroup);\n 25:     requestHeader.setOriginTopic(msg.getTopic());\n 26:     requestHeader.setOffset(msg.getCommitLogOffset());\n 27:     requestHeader.setDelayLevel(delayLevel);\n 28:     requestHeader.setOriginMsgId(msg.getMsgId());\n 29:     requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);\n 30: \n 31:     RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(this.clientConfig.isVipChannelEnabled(), addr),\n 32:         request, timeoutMillis);\n 33:     assert response != null;\n 34:     switch (response.getCode()) {\n 35:         case ResponseCode.SUCCESS: {\n 36:             return;\n 37:         }\n 38:         default:\n 39:             break;\n 40:     }\n 41: \n 42:     throw new MQBrokerException(response.getCode(), response.getRemark());\n 43: }\n```\n\n# 8、Consumer 消费进度\n\n## OffsetStore\n\n![OffsetStore类图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/07.png)\n\n* `RemoteBrokerOffsetStore` ：`Consumer` **集群模式** 下，使用远程 `Broker` 消费进度。\n* `LocalFileOffsetStore` ：`Consumer` **广播模式**下，使用本地 `文件` 消费进度。\n\n### OffsetStore#load(...)\n\n#### LocalFileOffsetStore#load(...)\n\n```Java\n  1: @Override\n  2: public void load() throws MQClientException {\n  3:     // 从本地硬盘读取消费进度\n  4:     OffsetSerializeWrapper offsetSerializeWrapper = this.readLocalOffset();\n  5:     if (offsetSerializeWrapper != null && offsetSerializeWrapper.getOffsetTable() != null) {\n  6:         offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());\n  7: \n  8:         // 打印每个消息队列的消费进度\n  9:         for (MessageQueue mq : offsetSerializeWrapper.getOffsetTable().keySet()) {\n 10:             AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);\n 11:             log.info(\"load consumer's offset, {} {} {}\",\n 12:                 this.groupName,\n 13:                 mq,\n 14:                 offset.get());\n 15:         }\n 16:     }\n 17: }\n```\n\n* 说明 ：从本地文件加载消费进度到内存。\n\n##### OffsetSerializeWrapper\n\n```Java\n  1: public class OffsetSerializeWrapper extends RemotingSerializable {\n  2:     private ConcurrentHashMap<MessageQueue, AtomicLong> offsetTable =\n  3:             new ConcurrentHashMap<>();\n  4: \n  5:     public ConcurrentHashMap<MessageQueue, AtomicLong> getOffsetTable() {\n  6:         return offsetTable;\n  7:     }\n  8: \n  9:     public void setOffsetTable(ConcurrentHashMap<MessageQueue, AtomicLong> offsetTable) {\n 10:         this.offsetTable = offsetTable;\n 11:     }\n 12: }\n```\n\n* 说明 ：本地 `Offset` 存储序列化。\n\n```Bash\nYunai-MacdeMacBook-Pro-2:config yunai$ cat /Users/yunai/.rocketmq_offsets/192.168.17.0@DEFAULT/please_rename_unique_group_name_1/offsets.json\n{\n\t\"offsetTable\":{{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":3,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":2,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1471,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":1,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":0,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470\n\t}\n}\n```\n\n#### RemoteBrokerOffsetStore#load(...)\n\n```Java\n  1: @Override\n  2: public void load() {\n  3: }\n```\n\n* 说明 ：不进行加载，实际读取消费进度时，从 `Broker` 获取。\n\n### OffsetStore#readOffset(...)\n\n读取消费进度类型：\n\n* `READ_FROM_MEMORY` ：从内存读取。\n* `READ_FROM_STORE` ：从存储( `Broker` 或 `文件` )读取。\n* `MEMORY_FIRST_THEN_STORE` ：优先从内存读取，读取不到，从存储读取。\n\n#### LocalFileOffsetStore#readOffset(...)\n\n```Java\n  1: @Override\n  2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {\n  3:     if (mq != null) {\n  4:         switch (type) {\n  5:             case MEMORY_FIRST_THEN_STORE:\n  6:             case READ_FROM_MEMORY: {\n  7:                 AtomicLong offset = this.offsetTable.get(mq);\n  8:                 if (offset != null) {\n  9:                     return offset.get();\n 10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {\n 11:                     return -1;\n 12:                 }\n 13:             }\n 14:             case READ_FROM_STORE: {\n 15:                 OffsetSerializeWrapper offsetSerializeWrapper;\n 16:                 try {\n 17:                     offsetSerializeWrapper = this.readLocalOffset();\n 18:                 } catch (MQClientException e) {\n 19:                     return -1;\n 20:                 }\n 21:                 if (offsetSerializeWrapper != null && offsetSerializeWrapper.getOffsetTable() != null) {\n 22:                     AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);\n 23:                     if (offset != null) {\n 24:                         this.updateOffset(mq, offset.get(), false);\n 25:                         return offset.get();\n 26:                     }\n 27:                 }\n 28:             }\n 29:             default:\n 30:                 break;\n 31:         }\n 32:     }\n 33: \n 34:     return -1;\n 35: }\n```\n\n* 第 16 行 ：从 `文件` 读取消费进度。\n\n#### RemoteBrokerOffsetStore#readOffset(...)\n\n```Java\n  1: @Override\n  2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {\n  3:     if (mq != null) {\n  4:         switch (type) {\n  5:             case MEMORY_FIRST_THEN_STORE:\n  6:             case READ_FROM_MEMORY: {\n  7:                 AtomicLong offset = this.offsetTable.get(mq);\n  8:                 if (offset != null) {\n  9:                     return offset.get();\n 10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {\n 11:                     return -1;\n 12:                 }\n 13:             }\n 14:             case READ_FROM_STORE: {\n 15:                 try {\n 16:                     long brokerOffset = this.fetchConsumeOffsetFromBroker(mq);\n 17:                     AtomicLong offset = new AtomicLong(brokerOffset);\n 18:                     this.updateOffset(mq, offset.get(), false);\n 19:                     return brokerOffset;\n 20:                 }\n 21:                 // No offset in broker\n 22:                 catch (MQBrokerException e) {\n 23:                     return -1;\n 24:                 }\n 25:                 //Other exceptions\n 26:                 catch (Exception e) {\n 27:                     log.warn(\"fetchConsumeOffsetFromBroker exception, \" + mq, e);\n 28:                     return -2;\n 29:                 }\n 30:             }\n 31:             default:\n 32:                 break;\n 33:         }\n 34:     }\n 35: \n 36:     return -1;\n 37: }\n```\n\n* 第 16 行 ：从 `Broker` 读取消费进度。\n\n### OffsetStore#updateOffset(...)\n\n该方法 `RemoteBrokerOffsetStore` 与 `LocalFileOffsetStore` 实现相同。\n\n```Java\n  1: @Override\n  2: public void updateOffset(MessageQueue mq, long offset, boolean increaseOnly) {\n  3:     if (mq != null) {\n  4:         AtomicLong offsetOld = this.offsetTable.get(mq);\n  5:         if (null == offsetOld) {\n  6:             offsetOld = this.offsetTable.putIfAbsent(mq, new AtomicLong(offset));\n  7:         }\n  8: \n  9:         if (null != offsetOld) {\n 10:             if (increaseOnly) {\n 11:                 MixAll.compareAndIncreaseOnly(offsetOld, offset);\n 12:             } else {\n 13:                 offsetOld.set(offset);\n 14:             }\n 15:         }\n 16:     }\n 17: }\n```\n\n### OffsetStore#persistAll(...)\n\n#### LocalFileOffsetStore#persistAll(...)\n\n```Java\n  1: @Override\n  2: public void persistAll(Set<MessageQueue> mqs) {\n  3:     if (null == mqs || mqs.isEmpty())\n  4:         return;\n  5: \n  6:     OffsetSerializeWrapper offsetSerializeWrapper = new OffsetSerializeWrapper();\n  7:     for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) {\n  8:         if (mqs.contains(entry.getKey())) {\n  9:             AtomicLong offset = entry.getValue();\n 10:             offsetSerializeWrapper.getOffsetTable().put(entry.getKey(), offset);\n 11:         }\n 12:     }\n 13: \n 14:     String jsonString = offsetSerializeWrapper.toJson(true);\n 15:     if (jsonString != null) {\n 16:         try {\n 17:             MixAll.string2File(jsonString, this.storePath);\n 18:         } catch (IOException e) {\n 19:             log.error(\"persistAll consumer offset Exception, \" + this.storePath, e);\n 20:         }\n 21:     }\n 22: }\n```\n\n* 说明 ：持久化消费进度。**将消费进度写入文件**。\n\n#### RemoteBrokerOffsetStore#persistAll(...)\n\n```Java\n  1: @Override\n  2: public void persistAll(Set<MessageQueue> mqs) {\n  3:     if (null == mqs || mqs.isEmpty())\n  4:         return;\n  5: \n  6:     // 持久化消息队列\n  7:     final HashSet<MessageQueue> unusedMQ = new HashSet<>();\n  8:     if (!mqs.isEmpty()) {\n  9:         for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) {\n 10:             MessageQueue mq = entry.getKey();\n 11:             AtomicLong offset = entry.getValue();\n 12:             if (offset != null) {\n 13:                 if (mqs.contains(mq)) {\n 14:                     try {\n 15:                         this.updateConsumeOffsetToBroker(mq, offset.get());\n 16:                         log.info(\"[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}\",\n 17:                             this.groupName,\n 18:                             this.mQClientFactory.getClientId(),\n 19:                             mq,\n 20:                             offset.get());\n 21:                     } catch (Exception e) {\n 22:                         log.error(\"updateConsumeOffsetToBroker exception, \" + mq.toString(), e);\n 23:                     }\n 24:                 } else {\n 25:                     unusedMQ.add(mq);\n 26:                 }\n 27:             }\n 28:         }\n 29:     }\n 30: \n 31:     // 移除不适用的消息队列\n 32:     if (!unusedMQ.isEmpty()) {\n 33:         for (MessageQueue mq : unusedMQ) {\n 34:             this.offsetTable.remove(mq);\n 35:             log.info(\"remove unused mq, {}, {}\", mq, this.groupName);\n 36:         }\n 37:     }\n 38: }\n```\n\n* 说明 ：持久化指定消息队列数组的消费进度到 `Broker`，并移除非指定消息队列。\n\n#### MQClientInstance#persistAllConsumerOffset(...)\n\n```Java\n  1: private void startScheduledTask() {\n  2:     // 定时同步消费进度\n  3:     this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  4: \n  5:         @Override\n  6:         public void run() {\n  7:             try {\n  8:                 MQClientInstance.this.cleanOfflineBroker();\n  9:                 MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();\n 10:             } catch (Exception e) {\n 11:                 log.error(\"ScheduledTask sendHeartbeatToAllBroker exception\", e);\n 12:             }\n 13:         }\n 14:     }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);\n 15: }\n```\n\n* 说明 ：定时进行持久化，默认周期：5000ms。\n* **重要说明 ：**\n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n\n# 9、结尾\n\n😈可能是本系列最长的一篇文章，如有表达错误和不清晰，请多多见谅。  \n感谢对本系列的阅读、收藏、点赞、分享，特别是翻到结尾。😜真的有丢丢长。\n\n\n","source":"_posts/RocketMQ/2017_05_11_RocketMQ源码分析——Message拉取与消费（下）.md","raw":"title: RocketMQ 源码分析 —— Message 拉取与消费（下）\ndate: 2017-05-11\ntags:\ncategories: RocketMQ\npermalink: RocketMQ/message-pull-and-consume-second\n\n-------\n\n>  原文地址：[http://www.yunai.me/RocketMQ/message-pull-and-consume-second/](http://www.yunai.me/RocketMQ/message-pull-and-consume-second/)  \n> `RocketMQ` **带注释源码**地址 ：[https://github.com/YunaiV/incubator-rocketmq](https://github.com/YunaiV/incubator-rocketmq)  \n> **😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号**  \n\n![wechat_mp](http://www.yunai.me/images/common/wechat_mp.jpeg)\n\n-------\n\n- [1、概述](#)\n- [2、Consumer](#)\n- [3、PushConsumer 一览](#)\n- [4、PushConsumer 订阅](#)\n\t- [DefaultMQPushConsumerImpl#subscribe(...)](#)\n\t\t- [FilterAPI.buildSubscriptionData(...)](#)\n\t- [DefaultMQPushConsumer#registerMessageListener(...)](#)\n- [5、PushConsumer 消息队列分配](#)\n\t- [RebalanceService](#)\n\t- [MQClientInstance#doRebalance(...)](#)\n\t- [DefaultMQPushConsumerImpl#doRebalance(...)](#)\n\t- [RebalanceImpl#doRebalance(...)](#)\n\t\t- [RebalanceImpl#rebalanceByTopic(...)](#)\n\t\t- [RebalanceImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t\t- [RebalancePushImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t\t- [[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(...)](#)\n\t\t- [RebalancePushImpl#dispatchPullRequest(...)](#)\n\t\t\t- [DefaultMQPushConsumerImpl#executePullRequestImmediately(...)](#)\n\t\t- [AllocateMessageQueueStrategy](#)\n\t\t\t- [AllocateMessageQueueAveragely](#)\n\t\t\t- [AllocateMessageQueueByMachineRoom](#)\n\t\t\t- [AllocateMessageQueueAveragelyByCircle](#)\n\t\t\t- [AllocateMessageQueueByConfig](#)\n- [5、PushConsumer 消费进度读取](#)\n\t- [RebalancePushImpl#computePullFromWhere(...)](#)\n\t- [[PullConsumer] RebalancePullImpl#computePullFromWhere(...)](#)\n- [6、PushConsumer 拉取消息](#)\n\t- [PullMessageService](#)\n\t- [DefaultMQPushConsumerImpl#pullMessage(...)](#)\n\t\t- [PullAPIWrapper#pullKernelImpl(...)](#)\n\t\t\t- [PullAPIWrapper#recalculatePullFromWhichNode(...)](#)\n\t\t\t- [MQClientInstance#findBrokerAddressInSubscribe(...)](#)\n\t\t- [PullAPIWrapper#processPullResult(...)](#)\n\t\t- [ProcessQueue#putMessage(...)](#)\n\t- [总结](#)\n- [6、PushConsumer 消费消息](#)\n\t- [ConsumeMessageConcurrentlyService 提交消费请求](#)\n\t\t- [ConsumeMessageConcurrentlyService#submitConsumeRequest(...)](#)\n\t\t- [ConsumeMessageConcurrentlyService#submitConsumeRequestLater](#)\n\t- [ConsumeRequest](#)\n\t- [ConsumeMessageConcurrentlyService#processConsumeResult(...)](#)\n\t\t- [ProcessQueue#removeMessage(...)](#)\n\t- [ConsumeMessageConcurrentlyService#cleanExpireMsg(...)](#)\n\t\t- [ProcessQueue#cleanExpiredMsg(...)](#)\n- [7、PushConsumer 发回消费失败消息](#)\n\t- [DefaultMQPushConsumerImpl#sendMessageBack(...)](#)\n\t\t- [MQClientAPIImpl#consumerSendMessageBack(...)](#)\n- [8、Consumer 消费进度](#)\n\t- [OffsetStore](#)\n\t\t- [OffsetStore#load(...)](#)\n\t\t\t- [LocalFileOffsetStore#load(...)](#)\n\t\t\t\t- [OffsetSerializeWrapper](#)\n\t\t\t- [RemoteBrokerOffsetStore#load(...)](#)\n\t\t- [OffsetStore#readOffset(...)](#)\n\t\t\t- [LocalFileOffsetStore#readOffset(...)](#)\n\t\t\t- [RemoteBrokerOffsetStore#readOffset(...)](#)\n\t\t- [OffsetStore#updateOffset(...)](#)\n\t\t- [OffsetStore#persistAll(...)](#)\n\t\t\t- [LocalFileOffsetStore#persistAll(...)](#)\n\t\t\t- [RemoteBrokerOffsetStore#persistAll(...)](#)\n\t\t\t- [MQClientInstance#persistAllConsumerOffset(...)](#)\n- [9、结尾](#)\n\n-------\n\n# 1、概述\n\n本文接：[《RocketMQ 源码分析 —— Message 拉取与消费（上）》](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/)。\n\n主要解析 `Consumer` 在 **消费** 逻辑涉及到的源码。\n\n# 2、Consumer\n\nMQ 提供了两类消费者：\n\n* PushConsumer：\n    * 在大多数场景下使用。\n    * 名字虽然是 `Push` 开头，实际在实现时，使用 `Pull` 方式实现。通过 `Pull` **不断不断不断**轮询 `Broker` 获取消息。当不存在新消息时，`Broker` 会**挂起请求**，直到有新消息产生，取消挂起，返回新消息。这样，基本和 `Broker` 主动 `Push` 做到**接近**的实时性（当然，还是有相应的实时性损失）。原理类似 **[长轮询( `Long-Polling` )](https://www.ibm.com/developerworks/cn/web/wa-lo-comet/)**。\n* PullConsumer\n\n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n**本文主要讲解`PushConsumer`，部分讲解`PullConsumer`，跳过`顺序消费`。**  \n\n# 3、PushConsumer 一览\n\n先看一张 `PushConsumer` 包含的组件以及组件之间的交互图：\n\n![PushConsumer手绘图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/09.png)\n\n* `RebalanceService`：均衡消息队列服务，负责分配当前 `Consumer` 可消费的消息队列( `MessageQueue` )。当有新的 `Consumer` 的加入或移除，都会重新分配消息队列。\n* `PullMessageService`：拉取消息服务，**不断不断不断**从 `Broker` 拉取消息，并提交消费任务到 `ConsumeMessageService`。\n* `ConsumeMessageService`：消费消息服务，**不断不断不断**消费消息，并处理消费结果。\n* `RemoteBrokerOffsetStore`：`Consumer` 消费进度管理，负责从 `Broker` 获取消费进度，同步消费进度到 `Broker`。\n* `ProcessQueue` ：消息处理队列。\n* `MQClientInstance` ：封装对 `Namesrv`，`Broker` 的 API调用，提供给 `Producer`、`Consumer` 使用。\n\n# 4、PushConsumer 订阅\n\n## DefaultMQPushConsumerImpl#subscribe(...)\n\n```Java\n  1: public void subscribe(String topic, String subExpression) throws MQClientException {\n  2:     try {\n  3:         // 创建订阅数据\n  4:         SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(), //\n  5:             topic, subExpression);\n  6:         this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);\n  7:         // 通过心跳同步Consumer信息到Broker\n  8:         if (this.mQClientFactory != null) {\n  9:             this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n 10:         }\n 11:     } catch (Exception e) {\n 12:         throw new MQClientException(\"subscription exception\", e);\n 13:     }\n 14: }\n```\n\n* 说明 ：订阅 `Topic` 。\n* 第 3 至 6 行 ：创建订阅数据。详细解析见：[FilterAPI.buildSubscriptionData(...)](#filterapibuildsubscriptiondata)。\n* 第 7 至 10 行 ：通过心跳同步 `Consumer` 信息到 `Broker`。\n\n### FilterAPI.buildSubscriptionData(...)\n\n```Java\n  1: public static SubscriptionData buildSubscriptionData(final String consumerGroup, String topic,\n  2:     String subString) throws Exception {\n  3:     SubscriptionData subscriptionData = new SubscriptionData();\n  4:     subscriptionData.setTopic(topic);\n  5:     subscriptionData.setSubString(subString);\n  6:     // 处理订阅表达式\n  7:     if (null == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == 0) {\n  8:         subscriptionData.setSubString(SubscriptionData.SUB_ALL);\n  9:     } else {\n 10:         String[] tags = subString.split(\"\\\\|\\\\|\");\n 11:         if (tags.length > 0) {\n 12:             for (String tag : tags) {\n 13:                 if (tag.length() > 0) {\n 14:                     String trimString = tag.trim();\n 15:                     if (trimString.length() > 0) {\n 16:                         subscriptionData.getTagsSet().add(trimString);\n 17:                         subscriptionData.getCodeSet().add(trimString.hashCode());\n 18:                     }\n 19:                 }\n 20:             }\n 21:         } else {\n 22:             throw new Exception(\"subString split error\");\n 23:         }\n 24:     }\n 25: \n 26:     return subscriptionData;\n 27: }\n```\n\n* 说明 ：根据 `Topic` 和 订阅表达式 创建订阅数据\n* subscriptionData.subVersion = System.currentTimeMillis()。\n\n## DefaultMQPushConsumer#registerMessageListener(...)\n\n```Java\n  1: public void registerMessageListener(MessageListenerConcurrently messageListener) {\n  2:     this.messageListener = messageListener;\n  3:     this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);\n  4: }\n```\n\n* 说明 ：注册消息监听器。\n\n# 5、PushConsumer 消息队列分配\n\n![RebalanceService&PushConsumer分配队列](http://www.yunai.me/images/RocketMQ/2017_05_04/10.png)\n\n## RebalanceService\n\n```Java\n  1: public class RebalanceService extends ServiceThread {\n  2: \n  3:     /**\n  4:      * 等待间隔，单位：毫秒\n  5:      */\n  6:     private static long waitInterval =\n  7:         Long.parseLong(System.getProperty(\n  8:             \"rocketmq.client.rebalance.waitInterval\", \"20000\"));\n  9: \n 10:     private final Logger log = ClientLogger.getLog();\n 11:     /**\n 12:      * MQClient对象\n 13:      */\n 14:     private final MQClientInstance mqClientFactory;\n 15: \n 16:     public RebalanceService(MQClientInstance mqClientFactory) {\n 17:         this.mqClientFactory = mqClientFactory;\n 18:     }\n 19: \n 20:     @Override\n 21:     public void run() {\n 22:         log.info(this.getServiceName() + \" service started\");\n 23: \n 24:         while (!this.isStopped()) {\n 25:             this.waitForRunning(waitInterval);\n 26:             this.mqClientFactory.doRebalance();\n 27:         }\n 28: \n 29:         log.info(this.getServiceName() + \" service end\");\n 30:     }\n 31: \n 32:     @Override\n 33:     public String getServiceName() {\n 34:         return RebalanceService.class.getSimpleName();\n 35:     }\n 36: }\n```\n\n* 说明 ：均衡消息队列服务，负责分配当前 `Consumer` 可消费的消息队列( `MessageQueue` )。\n* 第 26 行 ：调用 `MQClientInstance#doRebalance(...)` 分配消息队列。目前有三种情况情况下触发：\n    * 如 `第 25 行` 等待超时，每 20s 调用一次。\n    * `PushConsumer` 启动时，调用 `rebalanceService#wakeup(...)` 触发。\n    * `Broker` 通知 `Consumer` 加入 或 移除时，`Consumer` 响应通知，调用 `rebalanceService#wakeup(...)` 触发。\n\n 详细解析见：[MQClientInstance#doRebalance(...)](#mqclientinstancedorebalance)。\n\n## MQClientInstance#doRebalance(...)\n\n```Java\n  1: public void doRebalance() {\n  2:     for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {\n  3:         MQConsumerInner impl = entry.getValue();\n  4:         if (impl != null) {\n  5:             try {\n  6:                 impl.doRebalance();\n  7:             } catch (Throwable e) {\n  8:                 log.error(\"doRebalance exception\", e);\n  9:             }\n 10:         }\n 11:     }\n 12: }\n```\n\n* 说明 ：遍历当前 `Client` 包含的 `consumerTable`( `Consumer`集合 )，执行消息队列分配。\n* **疑问**：目前代码调试下来，`consumerTable` 只包含 `Consumer` 自己。😈有大大对这个疑问有解答的，烦请解答下。\n* 第 6 行 ：调用 `MQConsumerInner#doRebalance(...)` 进行队列分配。`DefaultMQPushConsumerImpl`、`DefaultMQPullConsumerImpl` 分别对该接口方法进行了实现。`DefaultMQPushConsumerImpl#doRebalance(...)` 详细解析见：[DefaultMQPushConsumerImpl#doRebalance(...)](defaultmqpushconsumerimpldorebalance)。\n\n## DefaultMQPushConsumerImpl#doRebalance(...)\n\n```Java\n  1: public void doRebalance() {\n  2:     if (!this.pause) {\n  3:         this.rebalanceImpl.doRebalance(this.isConsumeOrderly());\n  4:     }\n  5: }\n```\n\n* 说明：执行消息队列分配。\n* 第 3 行 ：调用 `RebalanceImpl#doRebalance(...)` 进行队列分配。详细解析见：[RebalancePushImpl#doRebalance(...)](#rebalancepushimpldorebalance)。\n\n## RebalanceImpl#doRebalance(...)\n\n```Java\n  1: /**\n  2:  * 执行分配消息队列\n  3:  *\n  4:  * @param isOrder 是否顺序消息\n  5:  */\n  6: public void doRebalance(final boolean isOrder) {\n  7:     // 分配每个 topic 的消息队列\n  8:     Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n  9:     if (subTable != null) {\n 10:         for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {\n 11:             final String topic = entry.getKey();\n 12:             try {\n 13:                 this.rebalanceByTopic(topic, isOrder);\n 14:             } catch (Throwable e) {\n 15:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 16:                     log.warn(\"rebalanceByTopic Exception\", e);\n 17:                 }\n 18:             }\n 19:         }\n 20:     }\n 21:     // 移除未订阅的topic对应的消息队列\n 22:     this.truncateMessageQueueNotMyTopic();\n 23: }\n 24: \n 25: /**\n 26:  * 移除未订阅的消息队列\n 27:  */\n 28: private void truncateMessageQueueNotMyTopic() {\n 29:     Map<String, SubscriptionData> subTable = this.getSubscriptionInner();\n 30:     for (MessageQueue mq : this.processQueueTable.keySet()) {\n 31:         if (!subTable.containsKey(mq.getTopic())) {\n 32: \n 33:             ProcessQueue pq = this.processQueueTable.remove(mq);\n 34:             if (pq != null) {\n 35:                 pq.setDropped(true);\n 36:                 log.info(\"doRebalance, {}, truncateMessageQueueNotMyTopic remove unnecessary mq, {}\", consumerGroup, mq);\n 37:             }\n 38:         }\n 39:     }\n 40: }\n```\n\n* `#doRebalance(...)` 说明 ：执行分配消息队列。\n    * 第 7 至 20 行 ：循环订阅主题集合( `subscriptionInner` )，分配每一个 `Topic` 的消息队列。\n    * 第 22 行 ：移除未订阅的 `Topic` 的消息队列。\n* `#truncateMessageQueueNotMyTopic(...)` 说明 ：移除未订阅的消息队列。**当调用 `DefaultMQPushConsumer#unsubscribe(topic)` 时，只移除订阅主题集合( `subscriptionInner` )，对应消息队列移除在该方法。**\n\n### RebalanceImpl#rebalanceByTopic(...)\n\n```Java\n  1: private void rebalanceByTopic(final String topic, final boolean isOrder) {\n  2:     switch (messageModel) {\n  3:         case BROADCASTING: {\n  4:             Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);\n  5:             if (mqSet != null) {\n  6:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);\n  7:                 if (changed) {\n  8:                     this.messageQueueChanged(topic, mqSet, mqSet);\n  9:                     log.info(\"messageQueueChanged {} {} {} {}\", //\n 10:                         consumerGroup, //\n 11:                         topic, //\n 12:                         mqSet, //\n 13:                         mqSet);\n 14:                 }\n 15:             } else {\n 16:                 log.warn(\"doRebalance, {}, but the topic[{}] not exist.\", consumerGroup, topic);\n 17:             }\n 18:             break;\n 19:         }\n 20:         case CLUSTERING: {\n 21:             // 获取 topic 对应的 队列 和 consumer信息\n 22:             Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);\n 23:             List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);\n 24:             if (null == mqSet) {\n 25:                 if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 26:                     log.warn(\"doRebalance, {}, but the topic[{}] not exist.\", consumerGroup, topic);\n 27:                 }\n 28:             }\n 29: \n 30:             if (null == cidAll) {\n 31:                 log.warn(\"doRebalance, {} {}, get consumer id list failed\", consumerGroup, topic);\n 32:             }\n 33: \n 34:             if (mqSet != null && cidAll != null) {\n 35:                 // 排序 消息队列 和 消费者数组。因为是在Client进行分配队列，排序后，各Client的顺序才能保持一致。\n 36:                 List<MessageQueue> mqAll = new ArrayList<>();\n 37:                 mqAll.addAll(mqSet);\n 38: \n 39:                 Collections.sort(mqAll);\n 40:                 Collections.sort(cidAll);\n 41: \n 42:                 AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;\n 43: \n 44:                 // 根据 队列分配策略 分配消息队列\n 45:                 List<MessageQueue> allocateResult;\n 46:                 try {\n 47:                     allocateResult = strategy.allocate(//\n 48:                         this.consumerGroup, //\n 49:                         this.mQClientFactory.getClientId(), //\n 50:                         mqAll, //\n 51:                         cidAll);\n 52:                 } catch (Throwable e) {\n 53:                     log.error(\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}\", strategy.getName(),\n 54:                         e);\n 55:                     return;\n 56:                 }\n 57: \n 58:                 Set<MessageQueue> allocateResultSet = new HashSet<>();\n 59:                 if (allocateResult != null) {\n 60:                     allocateResultSet.addAll(allocateResult);\n 61:                 }\n 62: \n 63:                 // 更新消息队列\n 64:                 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);\n 65:                 if (changed) {\n 66:                     log.info(\n 67:                         \"rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}\",\n 68:                         strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),\n 69:                         allocateResultSet.size(), allocateResultSet);\n 70:                     this.messageQueueChanged(topic, mqSet, allocateResultSet);\n 71:                 }\n 72:             }\n 73:             break;\n 74:         }\n 75:         default:\n 76:             break;\n 77:     }\n 78: }\n 79: \n 80: /**\n 81:  * 当负载均衡时，更新 消息处理队列\n 82:  * - 移除 在processQueueTable && 不存在于 mqSet 里的消息队列\n 83:  * - 增加 不在processQueueTable && 存在于mqSet 里的消息队列\n 84:  *\n 85:  * @param topic Topic\n 86:  * @param mqSet 负载均衡结果后的消息队列数组\n 87:  * @param isOrder 是否顺序\n 88:  * @return 是否变更\n 89:  */\n 90: private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) {\n 91:     boolean changed = false;\n 92: \n 93:     // 移除 在processQueueTable && 不存在于 mqSet 里的消息队列\n 94:     Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();\n 95:     while (it.hasNext()) { // TODO 待读：\n 96:         Entry<MessageQueue, ProcessQueue> next = it.next();\n 97:         MessageQueue mq = next.getKey();\n 98:         ProcessQueue pq = next.getValue();\n 99: \n100:         if (mq.getTopic().equals(topic)) {\n101:             if (!mqSet.contains(mq)) { // 不包含的队列\n102:                 pq.setDropped(true);\n103:                 if (this.removeUnnecessaryMessageQueue(mq, pq)) {\n104:                     it.remove();\n105:                     changed = true;\n106:                     log.info(\"doRebalance, {}, remove unnecessary mq, {}\", consumerGroup, mq);\n107:                 }\n108:             } else if (pq.isPullExpired()) { // 队列拉取超时，进行清理\n109:                 switch (this.consumeType()) {\n110:                     case CONSUME_ACTIVELY:\n111:                         break;\n112:                     case CONSUME_PASSIVELY:\n113:                         pq.setDropped(true);\n114:                         if (this.removeUnnecessaryMessageQueue(mq, pq)) {\n115:                             it.remove();\n116:                             changed = true;\n117:                             log.error(\"[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it\",\n118:                                 consumerGroup, mq);\n119:                         }\n120:                         break;\n121:                     default:\n122:                         break;\n123:                 }\n124:             }\n125:         }\n126:     }\n127: \n128:     // 增加 不在processQueueTable && 存在于mqSet 里的消息队列。\n129:     List<PullRequest> pullRequestList = new ArrayList<>(); // 拉消息请求数组\n130:     for (MessageQueue mq : mqSet) {\n131:         if (!this.processQueueTable.containsKey(mq)) {\n132:             if (isOrder && !this.lock(mq)) {\n133:                 log.warn(\"doRebalance, {}, add a new mq failed, {}, because lock failed\", consumerGroup, mq);\n134:                 continue;\n135:             }\n136: \n137:             this.removeDirtyOffset(mq);\n138:             ProcessQueue pq = new ProcessQueue();\n139:             long nextOffset = this.computePullFromWhere(mq);\n140:             if (nextOffset >= 0) {\n141:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);\n142:                 if (pre != null) {\n143:                     log.info(\"doRebalance, {}, mq already exists, {}\", consumerGroup, mq);\n144:                 } else {\n145:                     log.info(\"doRebalance, {}, add a new mq, {}\", consumerGroup, mq);\n146:                     PullRequest pullRequest = new PullRequest();\n147:                     pullRequest.setConsumerGroup(consumerGroup);\n148:                     pullRequest.setNextOffset(nextOffset);\n149:                     pullRequest.setMessageQueue(mq);\n150:                     pullRequest.setProcessQueue(pq);\n151:                     pullRequestList.add(pullRequest);\n152:                     changed = true;\n153:                 }\n154:             } else {\n155:                 log.warn(\"doRebalance, {}, add new mq failed, {}\", consumerGroup, mq);\n156:             }\n157:         }\n158:     }\n159: \n160:     // 发起消息拉取请求\n161:     this.dispatchPullRequest(pullRequestList);\n162: \n163:     return changed;\n164: }\n```\n\n* `#rebalanceByTopic(...)` 说明 ：分配 `Topic` 的消息队列。\n    * 第 3 至 19 行 ：广播模式( `BROADCASTING` ) 下，分配 `Topic` 对应的**所有**消息队列。   \n    * 第 20 至 74 行 ：集群模式( `CLUSTERING` ) 下，分配 `Topic` 对应的**部分**消息队列。\n        * 第 21 至 40 行 ：获取 `Topic` 对应的消息队列和消费者们，并对其进行排序。因为各 `Consumer` 是在本地分配消息队列，排序后才能保证各 `Consumer` 顺序一致。\n        *  第 42 至 61 行 ：根据 队列分配策略( `AllocateMessageQueueStrategy` ) 分配消息队列。详细解析见：[AllocateMessageQueueStrategy](#allocatemessagequeuestrategy)。\n        *  第 63 至 72 行 ：更新 `Topic` 对应的消息队列。\n* `#updateProcessQueueTableInRebalance(...)` 说明 ：当分配队列时，更新 `Topic` 对应的消息队列，并返回是否有变更。\n    * 第 93 至 126 行 ：移除不存在于分配的消息队列( `mqSet` ) 的 消息处理队列( `processQueueTable` )。\n        * 第 103 行 ：移除不需要的消息队列。详细解析见：[RebalancePushImpl#removeUnnecessaryMessageQueue(...)](#rebalancepushimplremoveunnecessarymessagequeue)。\n        * 第 108 至 120 行 ：队列拉取超时，即 `当前时间 - 最后一次拉取消息时间 > 120s` ( 120s 可配置)，判定发生 **BUG**，过久未进行消息拉取，移除消息队列。移除后，下面**#新增队列逻辑#**可以重新加入新的该消息队列。\n    * 第 128 至 158 行 ：增加 分配的消息队列( `mqSet` ) 新增的消息队列。\n        * 第 132 至 135 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n        * 第 137 行 ：移除消息队列的消费进度。\n        * 第 139 行 ：获取队列消费进度。详细解析见：[RebalancePushImpl#computePullFromWhere(...)](#rebalancepushimplcomputepullfromwhere)。\n        * 第 140 至 156 行 ：**添加新消费处理队列，添加消费拉取消息请求**。\n    * 第 161 行 ：**发起新增的消息队列消息拉取请求**。详细解析见：[RebalancePushImpl#dispatchPullRequest(...)](#rebalancepushimpldispatchpullrequest)。\n\n### RebalanceImpl#removeUnnecessaryMessageQueue(...)\n\n#### RebalancePushImpl#removeUnnecessaryMessageQueue(...)\n\n```Java\n  1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n  2:     // 同步队列的消费进度，并移除之。\n  3:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);\n  4:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);\n  5:     // TODO 顺序消费\n  6:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()\n  7:         && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {\n  8:         try {\n  9:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {\n 10:                 try {\n 11:                     return this.unlockDelay(mq, pq);\n 12:                 } finally {\n 13:                     pq.getLockConsume().unlock();\n 14:                 }\n 15:             } else {\n 16:                 log.warn(\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\", //\n 17:                     mq, //\n 18:                     pq.getTryUnlockTimes());\n 19: \n 20:                 pq.incTryUnlockTimes();\n 21:             }\n 22:         } catch (Exception e) {\n 23:             log.error(\"removeUnnecessaryMessageQueue Exception\", e);\n 24:         }\n 25: \n 26:         return false;\n 27:     }\n 28:     return true;\n 29: }\n```\n\n* 说明 ：移除不需要的消息队列相关的信息，并返回是否移除成功。\n* 第 2 至 4 行 ：**同步**队列的消费进度，并移除之。\n* 第 5 至 27 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n\n#### `[PullConsumer]` RebalancePullImpl#removeUnnecessaryMessageQueue(...)\n\n```Java\n  1: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {\n  2:     this.defaultMQPullConsumerImpl.getOffsetStore().persist(mq);\n  3:     this.defaultMQPullConsumerImpl.getOffsetStore().removeOffset(mq);\n  4:     return true;\n  5: }\n```\n\n* 说明 ：移除不需要的消息队列相关的信息，并返回移除成功。**和`RebalancePushImpl#removeUnnecessaryMessageQueue(...)`基本一致。**\n\n### RebalancePushImpl#dispatchPullRequest(...)\n\n```Java\n  1: public void dispatchPullRequest(List<PullRequest> pullRequestList) {\n  2:     for (PullRequest pullRequest : pullRequestList) {\n  3:         this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);\n  4:         log.info(\"doRebalance, {}, add a new pull request {}\", consumerGroup, pullRequest);\n  5:     }\n  6: }\n```\n\n* 说明 ：发起消息拉取请求。**该调用是`PushConsumer`不断不断不断拉取消息的起点**。\n\n#### DefaultMQPushConsumerImpl#executePullRequestImmediately(...)\n\n```Java\n  1: public void executePullRequestImmediately(final PullRequest pullRequest) {\n  2:     this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);\n  3: }\n```\n\n* 说明 ：提交拉取请求。提交后，`PullMessageService` **异步执行**，**非阻塞**。详细解析见：[PullMessageService](pullmessageservice)。\n\n### AllocateMessageQueueStrategy\n\n![AllocateMessageQueueStrategy类图](http://www.yunai.me/images/RocketMQ/2017_05_04/01.png)\n\n#### AllocateMessageQueueAveragely\n\n```Java\n  1: public class AllocateMessageQueueAveragely implements AllocateMessageQueueStrategy {\n  2:     private final Logger log = ClientLogger.getLog();\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         // 校验参数是否正确\n  8:         if (currentCID == null || currentCID.length() < 1) {\n  9:             throw new IllegalArgumentException(\"currentCID is empty\");\n 10:         }\n 11:         if (mqAll == null || mqAll.isEmpty()) {\n 12:             throw new IllegalArgumentException(\"mqAll is null or mqAll empty\");\n 13:         }\n 14:         if (cidAll == null || cidAll.isEmpty()) {\n 15:             throw new IllegalArgumentException(\"cidAll is null or cidAll empty\");\n 16:         }\n 17: \n 18:         List<MessageQueue> result = new ArrayList<>();\n 19:         if (!cidAll.contains(currentCID)) {\n 20:             log.info(\"[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}\",\n 21:                 consumerGroup,\n 22:                 currentCID,\n 23:                 cidAll);\n 24:             return result;\n 25:         }\n 26:         // 平均分配\n 27:         int index = cidAll.indexOf(currentCID); // 第几个consumer。\n 28:         int mod = mqAll.size() % cidAll.size(); // 余数，即多少消息队列无法平均分配。\n 29:         int averageSize =\n 30:             mqAll.size() <= cidAll.size() ? 1 : (mod > 0 && index < mod ? mqAll.size() / cidAll.size()\n 31:                 + 1 : mqAll.size() / cidAll.size());\n 32:         int startIndex = (mod > 0 && index < mod) ? index * averageSize : index * averageSize + mod; // 有余数的情况下，[0, mod) 平分余数，即每consumer多分配一个节点；第index开始，跳过前mod余数。\n 33:         int range = Math.min(averageSize, mqAll.size() - startIndex); // 分配队列数量。之所以要Math.min()的原因是，mqAll.size() <= cidAll.size()，部分consumer分配不到消息队列。\n 34:         for (int i = 0; i < range; i++) {\n 35:             result.add(mqAll.get((startIndex + i) % mqAll.size()));\n 36:         }\n 37:         return result;\n 38:     }\n 39: \n 40:     @Override\n 41:     public String getName() {\n 42:         return \"AVG\";\n 43:     }\n 44: }\n```\n\n* 说明 ：**平均**分配队列策略。\n* 第 7 至 25 行 ：参数校验。\n* 第 26 至 36 行 ：平均分配消息队列。\n    * 第 27 行 ：`index` ：当前 `Consumer` 在消费集群里是第几个。这里就是为什么需要对传入的 `cidAll` 参数必须进行排序的原因。如果不排序，`Consumer` 在本地计算出来的 `index` 无法一致，影响计算结果。\n    * 第 28 行 ：`mod` ：余数，即多少消息队列无法平均分配。\n    * 第 29 至 31 行 ：`averageSize` ：代码可以简化成 `(mod > 0 && index < mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size())`。\n        * `[ 0, mod )` ：`mqAll.size() / cidAll.size() + 1`。前面 `mod` 个 `Consumer` 平分余数，多获得 1 个消息队列。\n        * `[ mod, cidAll.size() )` ：`mqAll.size() / cidAll.size()`。\n    * 第 32 行 ：`startIndex` ：`Consumer` 分配消息队列开始位置。\n    * 第 33 行 ：`range` ：分配队列数量。之所以要 `Math#min(...)` 的原因：当 `mqAll.size() <= cidAll.size()` 时，最后几个 `Consumer` 分配不到消息队列。\n    * 第 34 至 36 行 ：生成分配消息队列结果。\n* 举个例子：\n\n固定消息队列长度为**4**。\n\n|   | Consumer * 2 *可以整除* | Consumer * 3 *不可整除* | Consumer * 5 *无法都分配* |\n| --- | --- | --- | --- |\n| 消息队列[0] | Consumer[0] | Consumer[0] | Consumer[0] |\n| 消息队列[1] | Consumer[0] | Consumer[0] | Consumer[1] |\n| 消息队列[2] | Consumer[1] | Consumer[1] | Consumer[2] |\n| 消息队列[3] | Consumer[1] | Consumer[2] | Consumer[3] |\n\n#### AllocateMessageQueueByMachineRoom\n\n```Java\n  1: public class AllocateMessageQueueByMachineRoom implements AllocateMessageQueueStrategy {\n  2:     /**\n  3:      * 消费者消费brokerName集合\n  4:      */\n  5:     private Set<String> consumeridcs;\n  6: \n  7:     @Override\n  8:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  9:         List<String> cidAll) {\n 10:         // 参数校验\n 11:         List<MessageQueue> result = new ArrayList<MessageQueue>();\n 12:         int currentIndex = cidAll.indexOf(currentCID);\n 13:         if (currentIndex < 0) {\n 14:             return result;\n 15:         }\n 16:         // 计算符合当前配置的消费者数组('consumeridcs')对应的消息队列\n 17:         List<MessageQueue> premqAll = new ArrayList<MessageQueue>();\n 18:         for (MessageQueue mq : mqAll) {\n 19:             String[] temp = mq.getBrokerName().split(\"@\");\n 20:             if (temp.length == 2 && consumeridcs.contains(temp[0])) {\n 21:                 premqAll.add(mq);\n 22:             }\n 23:         }\n 24:         // 平均分配\n 25:         int mod = premqAll.size() / cidAll.size();\n 26:         int rem = premqAll.size() % cidAll.size();\n 27:         int startIndex = mod * currentIndex;\n 28:         int endIndex = startIndex + mod;\n 29:         for (int i = startIndex; i < endIndex; i++) {\n 30:             result.add(mqAll.get(i));\n 31:         }\n 32:         if (rem > currentIndex) {\n 33:             result.add(premqAll.get(currentIndex + mod * cidAll.size()));\n 34:         }\n 35:         return result;\n 36:     }\n 37: \n 38:     @Override\n 39:     public String getName() {\n 40:         return \"MACHINE_ROOM\";\n 41:     }\n 42: \n 43:     public Set<String> getConsumeridcs() {\n 44:         return consumeridcs;\n 45:     }\n 46: \n 47:     public void setConsumeridcs(Set<String> consumeridcs) {\n 48:         this.consumeridcs = consumeridcs;\n 49:     }\n 50: }\n```\n\n* 说明 ：**平均**分配**可消费的** `Broker` 对应的消息队列。\n* 第 7 至 15 行 ：参数校验。\n* 第 16 至 23 行 ：计算**可消费的** `Broker` 对应的消息队列。\n* 第 25 至 34 行 ：平均分配消息队列。该**平均分配**方式和 `AllocateMessageQueueAveragely` 略有不同，其是将多余的结尾部分分配给前 `rem` 个 `Consumer`。\n* 疑问：*使用该分配策略时，`Consumer` 和 `Broker` 分配需要怎么配置*。😈等研究**主从**相关源码时，仔细考虑下。\n\n#### AllocateMessageQueueAveragelyByCircle\n\n ```Java\n   1: public class AllocateMessageQueueAveragelyByCircle implements AllocateMessageQueueStrategy {\n  2:     private final Logger log = ClientLogger.getLog();\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         // 校验参数是否正确\n  8:         if (currentCID == null || currentCID.length() < 1) {\n  9:             throw new IllegalArgumentException(\"currentCID is empty\");\n 10:         }\n 11:         if (mqAll == null || mqAll.isEmpty()) {\n 12:             throw new IllegalArgumentException(\"mqAll is null or mqAll empty\");\n 13:         }\n 14:         if (cidAll == null || cidAll.isEmpty()) {\n 15:             throw new IllegalArgumentException(\"cidAll is null or cidAll empty\");\n 16:         }\n 17: \n 18:         List<MessageQueue> result = new ArrayList<MessageQueue>();\n 19:         if (!cidAll.contains(currentCID)) {\n 20:             log.info(\"[BUG] ConsumerGroup: {} The consumerId: {} not in cidAll: {}\",\n 21:                 consumerGroup,\n 22:                 currentCID,\n 23:                 cidAll);\n 24:             return result;\n 25:         }\n 26: \n 27:         // 环状分配\n 28:         int index = cidAll.indexOf(currentCID);\n 29:         for (int i = index; i < mqAll.size(); i++) {\n 30:             if (i % cidAll.size() == index) {\n 31:                 result.add(mqAll.get(i));\n 32:             }\n 33:         }\n 34:         return result;\n 35:     }\n 36: \n 37:     @Override\n 38:     public String getName() {\n 39:         return \"AVG_BY_CIRCLE\";\n 40:     }\n 41: }\n ```\n \n * 说明 ：环状分配消息队列。\n\n#### AllocateMessageQueueByConfig\n\n```Java\n  1: public class AllocateMessageQueueByConfig implements AllocateMessageQueueStrategy {\n  2:     private List<MessageQueue> messageQueueList;\n  3: \n  4:     @Override\n  5:     public List<MessageQueue> allocate(String consumerGroup, String currentCID, List<MessageQueue> mqAll,\n  6:         List<String> cidAll) {\n  7:         return this.messageQueueList;\n  8:     }\n  9: \n 10:     @Override\n 11:     public String getName() {\n 12:         return \"CONFIG\";\n 13:     }\n 14: \n 15:     public List<MessageQueue> getMessageQueueList() {\n 16:         return messageQueueList;\n 17:     }\n 18: \n 19:     public void setMessageQueueList(List<MessageQueue> messageQueueList) {\n 20:         this.messageQueueList = messageQueueList;\n 21:     }\n 22: }\n```\n\n* 说明 ：分配**配置的**消息队列。\n* 疑问 ：*该分配策略的使用场景。*\n\n# 5、PushConsumer 消费进度读取\n\n## RebalancePushImpl#computePullFromWhere(...)\n\n```Java\n  1: public long computePullFromWhere(MessageQueue mq) {\n  2:     long result = -1;\n  3:     final ConsumeFromWhere consumeFromWhere = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();\n  4:     final OffsetStore offsetStore = this.defaultMQPushConsumerImpl.getOffsetStore();\n  5:     switch (consumeFromWhere) {\n  6:         case CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST: // 废弃\n  7:         case CONSUME_FROM_MIN_OFFSET: // 废弃\n  8:         case CONSUME_FROM_MAX_OFFSET: // 废弃\n  9:         case CONSUME_FROM_LAST_OFFSET: {\n 10:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 11:             if (lastOffset >= 0) {\n 12:                 result = lastOffset;\n 13:             }\n 14:             // First start,no offset\n 15:             else if (-1 == lastOffset) {\n 16:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 17:                     result = 0L;\n 18:                 } else {\n 19:                     try {\n 20:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);\n 21:                     } catch (MQClientException e) {\n 22:                         result = -1;\n 23:                     }\n 24:                 }\n 25:             } else {\n 26:                 result = -1;\n 27:             }\n 28:             break;\n 29:         }\n 30:         case CONSUME_FROM_FIRST_OFFSET: {\n 31:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 32:             if (lastOffset >= 0) {\n 33:                 result = lastOffset;\n 34:             } else if (-1 == lastOffset) {\n 35:                 result = 0L;\n 36:             } else {\n 37:                 result = -1;\n 38:             }\n 39:             break;\n 40:         }\n 41:         case CONSUME_FROM_TIMESTAMP: {\n 42:             long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);\n 43:             if (lastOffset >= 0) {\n 44:                 result = lastOffset;\n 45:             } else if (-1 == lastOffset) {\n 46:                 if (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n 47:                     try {\n 48:                         result = this.mQClientFactory.getMQAdminImpl().maxOffset(mq);\n 49:                     } catch (MQClientException e) {\n 50:                         result = -1;\n 51:                     }\n 52:                 } else {\n 53:                     try {\n 54:                         long timestamp = UtilAll.parseDate(this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),\n 55:                             UtilAll.YYYY_MMDD_HHMMSS).getTime();\n 56:                         result = this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);\n 57:                     } catch (MQClientException e) {\n 58:                         result = -1;\n 59:                     }\n 60:                 }\n 61:             } else {\n 62:                 result = -1;\n 63:             }\n 64:             break;\n 65:         }\n 66: \n 67:         default:\n 68:             break;\n 69:     }\n 70: \n 71:     return result;\n 72: }\n```\n\n* 说明 ：计算消息队列开始消费位置。\n* `PushConsumer` 读取消费进度有三种选项：\n    * `CONSUME_FROM_LAST_OFFSET` ：第 6 至 29 行 ：一个新的消费集群第一次启动从**队列的最后位置**开始消费。**后续再启动接着上次消费的进度开始消费**。\n    * `CONSUME_FROM_FIRST_OFFSET` ：第 30 至 40 行 ：一个新的消费集群第一次启动从队列的**最前位置**开始消费。**后续再启动接着上次消费的进度开始消费**。\n    * `CONSUME_FROM_TIMESTAMP` ：第 41 至 65 行 ：一个新的消费集群第一次启动从**指定时间点**开始消费。**后续再启动接着上次消费的进度开始消费**。\n\n\n## `[PullConsumer]` RebalancePullImpl#computePullFromWhere(...)\n\n暂时跳过。😈\n\n# 6、PushConsumer 拉取消息\n\n![DefaultMQPushConsumerImpl拉取消息](http://www.yunai.me/images/RocketMQ/2017_05_04/05.png)\n\n## PullMessageService\n\n```Java\n  1: public class PullMessageService extends ServiceThread {\n  2:     private final Logger log = ClientLogger.getLog();\n  3:     /**\n  4:      * 拉取消息请求队列\n  5:      */\n  6:     private final LinkedBlockingQueue<PullRequest> pullRequestQueue = new LinkedBlockingQueue<>();\n  7:     /**\n  8:      * MQClient对象\n  9:      */\n 10:     private final MQClientInstance mQClientFactory;\n 11:     /**\n 12:      * 定时器。用于延迟提交拉取请求\n 13:      */\n 14:     private final ScheduledExecutorService scheduledExecutorService = Executors\n 15:         .newSingleThreadScheduledExecutor(new ThreadFactory() {\n 16:             @Override\n 17:             public Thread newThread(Runnable r) {\n 18:                 return new Thread(r, \"PullMessageServiceScheduledThread\");\n 19:             }\n 20:         });\n 21: \n 22:     public PullMessageService(MQClientInstance mQClientFactory) {\n 23:         this.mQClientFactory = mQClientFactory;\n 24:     }\n 25: \n 26:     /**\n 27:      * 执行延迟拉取消息请求\n 28:      *\n 29:      * @param pullRequest 拉取消息请求\n 30:      * @param timeDelay 延迟时长\n 31:      */\n 32:     public void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {\n 33:         this.scheduledExecutorService.schedule(new Runnable() {\n 34: \n 35:             @Override\n 36:             public void run() {\n 37:                 PullMessageService.this.executePullRequestImmediately(pullRequest);\n 38:             }\n 39:         }, timeDelay, TimeUnit.MILLISECONDS);\n 40:     }\n 41: \n 42:     /**\n 43:      * 执行立即拉取消息请求\n 44:      *\n 45:      * @param pullRequest 拉取消息请求\n 46:      */\n 47:     public void executePullRequestImmediately(final PullRequest pullRequest) {\n 48:         try {\n 49:             this.pullRequestQueue.put(pullRequest);\n 50:         } catch (InterruptedException e) {\n 51:             log.error(\"executePullRequestImmediately pullRequestQueue.put\", e);\n 52:         }\n 53:     }\n 54: \n 55:     /**\n 56:      * 执行延迟任务\n 57:      *\n 58:      * @param r 任务\n 59:      * @param timeDelay 延迟时长\n 60:      */\n 61:     public void executeTaskLater(final Runnable r, final long timeDelay) {\n 62:         this.scheduledExecutorService.schedule(r, timeDelay, TimeUnit.MILLISECONDS);\n 63:     }\n 64: \n 65:     public ScheduledExecutorService getScheduledExecutorService() {\n 66:         return scheduledExecutorService;\n 67:     }\n 68: \n 69:     /**\n 70:      * 拉取消息\n 71:      *\n 72:      * @param pullRequest 拉取消息请求\n 73:      */\n 74:     private void pullMessage(final PullRequest pullRequest) {\n 75:         final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());\n 76:         if (consumer != null) {\n 77:             DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;\n 78:             impl.pullMessage(pullRequest);\n 79:         } else {\n 80:             log.warn(\"No matched consumer for the PullRequest {}, drop it\", pullRequest);\n 81:         }\n 82:     }\n 83: \n 84:     @Override\n 85:     public void run() {\n 86:         log.info(this.getServiceName() + \" service started\");\n 87: \n 88:         while (!this.isStopped()) {\n 89:             try {\n 90:                 PullRequest pullRequest = this.pullRequestQueue.take();\n 91:                 if (pullRequest != null) {\n 92:                     this.pullMessage(pullRequest);\n 93:                 }\n 94:             } catch (InterruptedException e) {\n 95:             } catch (Exception e) {\n 96:                 log.error(\"Pull Message Service Run Method exception\", e);\n 97:             }\n 98:         }\n 99: \n100:         log.info(this.getServiceName() + \" service end\");\n101:     }\n102: \n103:     @Override\n104:     public String getServiceName() {\n105:         return PullMessageService.class.getSimpleName();\n106:     }\n107: \n108: }\n```\n\n* 说明 ：拉取消息服务，不断不断不断从 `Broker` 拉取消息，并提交消费任务到 `ConsumeMessageService`。\n* `#executePullRequestLater(...)` ：第 26 至 40 行 ： 提交**延迟**拉取消息请求。\n* `#executePullRequestImmediately(...)` ：第 42 至 53 行 ：提交**立即**拉取消息请求。\n* `#executeTaskLater(...)` ：第 55 至 63 行 ：提交**延迟任务**。\n* `#pullMessage(...)` ：第 69 至 82 行 ：执行拉取消息逻辑。详细解析见：[DefaultMQPushConsumerImpl#pullMessage(...)](#defaultmqpushconsumerimplpullmessage)。\n* `#run(...)` ：第 84 至 101 行 ：循环拉取消息请求队列( `pullRequestQueue` )，进行消息拉取。\n\n## DefaultMQPushConsumerImpl#pullMessage(...)\n\n```Java\n  1: public void pullMessage(final PullRequest pullRequest) {\n  2:     final ProcessQueue processQueue = pullRequest.getProcessQueue();\n  3:     if (processQueue.isDropped()) {\n  4:         log.info(\"the pull request[{}] is dropped.\", pullRequest.toString());\n  5:         return;\n  6:     }\n  7: \n  8:     // 设置队列最后拉取消息时间\n  9:     pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());\n 10: \n 11:     // 判断consumer状态是否运行中。如果不是，则延迟拉取消息。\n 12:     try {\n 13:         this.makeSureStateOK();\n 14:     } catch (MQClientException e) {\n 15:         log.warn(\"pullMessage exception, consumer state not ok\", e);\n 16:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 17:         return;\n 18:     }\n 19: \n 20:     // 判断是否暂停中。\n 21:     if (this.isPause()) {\n 22:         log.warn(\"consumer was paused, execute pull request later. instanceName={}, group={}\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());\n 23:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);\n 24:         return;\n 25:     }\n 26: \n 27:     // 判断是否超过最大持有消息数量。默认最大值为1000。\n 28:     long size = processQueue.getMsgCount().get();\n 29:     if (size > this.defaultMQPushConsumer.getPullThresholdForQueue()) {\n 30:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。\n 31:         if ((flowControlTimes1++ % 1000) == 0) {\n 32:             log.warn(\n 33:                 \"the consumer message buffer is full, so do flow control, minOffset={}, maxOffset={}, size={}, pullRequest={}, flowControlTimes={}\",\n 34:                 processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);\n 35:         }\n 36:         return;\n 37:     }\n 38: \n 39:     if (!this.consumeOrderly) { // 判断消息跨度是否过大。\n 40:         if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {\n 41:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); // 提交延迟消息拉取请求。50ms。\n 42:             if ((flowControlTimes2++ % 1000) == 0) {\n 43:                 log.warn(\n 44:                     \"the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}\",\n 45:                     processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),\n 46:                     pullRequest, flowControlTimes2);\n 47:             }\n 48:             return;\n 49:         }\n 50:     } else { // TODO 顺序消费\n 51:         if (processQueue.isLocked()) {\n 52:             if (!pullRequest.isLockedFirst()) {\n 53:                 final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());\n 54:                 boolean brokerBusy = offset < pullRequest.getNextOffset();\n 55:                 log.info(\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\",\n 56:                     pullRequest, offset, brokerBusy);\n 57:                 if (brokerBusy) {\n 58:                     log.info(\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\",\n 59:                         pullRequest, offset);\n 60:                 }\n 61: \n 62:                 pullRequest.setLockedFirst(true);\n 63:                 pullRequest.setNextOffset(offset);\n 64:             }\n 65:         } else {\n 66:             this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 67:             log.info(\"pull message later because not locked in broker, {}\", pullRequest);\n 68:             return;\n 69:         }\n 70:     }\n 71: \n 72:     // 获取Topic 对应的订阅信息。若不存在，则延迟拉取消息\n 73:     final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());\n 74:     if (null == subscriptionData) {\n 75:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n 76:         log.warn(\"find the consumer's subscription failed, {}\", pullRequest);\n 77:         return;\n 78:     }\n 79: \n 80:     final long beginTimestamp = System.currentTimeMillis();\n 81: \n 82:     PullCallback pullCallback = new PullCallback() {\n 83:         @Override\n 84:         public void onSuccess(PullResult pullResult) {\n 85:             if (pullResult != null) {\n 86:                 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,\n 87:                     subscriptionData);\n 88: \n 89:                 switch (pullResult.getPullStatus()) {\n 90:                     case FOUND:\n 91:                         // 设置下次拉取消息队列位置\n 92:                         long prevRequestOffset = pullRequest.getNextOffset();\n 93:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n 94: \n 95:                         // 统计\n 96:                         long pullRT = System.currentTimeMillis() - beginTimestamp;\n 97:                         DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),\n 98:                             pullRequest.getMessageQueue().getTopic(), pullRT);\n 99: \n100:                         long firstMsgOffset = Long.MAX_VALUE;\n101:                         if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {\n102:                             DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n103:                         } else {\n104:                             firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();\n105: \n106:                             // 统计\n107:                             DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),\n108:                                 pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());\n109: \n110:                             // 提交拉取到的消息到消息处理队列\n111:                             boolean dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());\n112: \n113:                             // 提交消费请求\n114:                             DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(//\n115:                                 pullResult.getMsgFoundList(), //\n116:                                 processQueue, //\n117:                                 pullRequest.getMessageQueue(), //\n118:                                 dispathToConsume);\n119: \n120:                             // 提交下次拉取消息请求\n121:                             if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) {\n122:                                 DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,\n123:                                     DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());\n124:                             } else {\n125:                                 DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n126:                             }\n127:                         }\n128: \n129:                         // 下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为BUG，输出log\n130:                         if (pullResult.getNextBeginOffset() < prevRequestOffset//\n131:                             || firstMsgOffset < prevRequestOffset) {\n132:                             log.warn(\n133:                                 \"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\", //\n134:                                 pullResult.getNextBeginOffset(), //\n135:                                 firstMsgOffset, //\n136:                                 prevRequestOffset);\n137:                         }\n138: \n139:                         break;\n140:                     case NO_NEW_MSG:\n141:                         // 设置下次拉取消息队列位置\n142:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n143: \n144:                         // 持久化消费进度\n145:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);\n146: \n147:                         // 立即提交拉取消息请求\n148:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n149:                         break;\n150:                     case NO_MATCHED_MSG:\n151:                         // 设置下次拉取消息队列位置\n152:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n153: \n154:                         // 持久化消费进度\n155:                         DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);\n156: \n157:                         // 提交立即拉取消息请求\n158:                         DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);\n159:                         break;\n160:                     case OFFSET_ILLEGAL:\n161:                         log.warn(\"the pull request offset illegal, {} {}\", //\n162:                             pullRequest.toString(), pullResult.toString());\n163:                         // 设置下次拉取消息队列位置\n164:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());\n165: \n166:                         // 设置消息处理队列为dropped\n167:                         pullRequest.getProcessQueue().setDropped(true);\n168: \n169:                         // 提交延迟任务，进行消费处理队列移除。不立即移除的原因：可能有地方正在使用，避免受到影响。\n170:                         DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {\n171: \n172:                             @Override\n173:                             public void run() {\n174:                                 try {\n175:                                     // 更新消费进度，同步消费进度到Broker\n176:                                     DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),\n177:                                         pullRequest.getNextOffset(), false);\n178:                                     DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());\n179: \n180:                                     // 移除消费处理队列\n181:                                     DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());\n182: \n183:                                     log.warn(\"fix the pull request offset, {}\", pullRequest);\n184:                                 } catch (Throwable e) {\n185:                                     log.error(\"executeTaskLater Exception\", e);\n186:                                 }\n187:                             }\n188:                         }, 10000);\n189:                         break;\n190:                     default:\n191:                         break;\n192:                 }\n193:             }\n194:         }\n195: \n196:         @Override\n197:         public void onException(Throwable e) {\n198:             if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {\n199:                 log.warn(\"execute the pull request exception\", e);\n200:             }\n201: \n202:             // 提交延迟拉取消息请求\n203:             DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n204:         }\n205:     };\n206: \n207:     // 集群消息模型下，计算提交的消费进度。\n208:     boolean commitOffsetEnable = false;\n209:     long commitOffsetValue = 0L;\n210:     if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {\n211:         commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);\n212:         if (commitOffsetValue > 0) {\n213:             commitOffsetEnable = true;\n214:         }\n215:     }\n216: \n217:     // 计算请求的 订阅表达式 和 是否进行filtersrv过滤消息\n218:     String subExpression = null;\n219:     boolean classFilter = false;\n220:     SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());\n221:     if (sd != null) {\n222:         if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) {\n223:             subExpression = sd.getSubString();\n224:         }\n225: \n226:         classFilter = sd.isClassFilterMode();\n227:     }\n228: \n229:     // 计算拉取消息系统标识\n230:     int sysFlag = PullSysFlag.buildSysFlag(//\n231:         commitOffsetEnable, // commitOffset\n232:         true, // suspend\n233:         subExpression != null, // subscription\n234:         classFilter // class filter\n235:     );\n236: \n237:     // 执行拉取。如果拉取请求发生异常时，提交延迟拉取消息请求。\n238:     try {\n239:         this.pullAPIWrapper.pullKernelImpl(//\n240:             pullRequest.getMessageQueue(), // 1\n241:             subExpression, // 2\n242:             subscriptionData.getSubVersion(), // 3\n243:             pullRequest.getNextOffset(), // 4\n244:             this.defaultMQPushConsumer.getPullBatchSize(), // 5\n245:             sysFlag, // 6\n246:             commitOffsetValue, // 7\n247:             BROKER_SUSPEND_MAX_TIME_MILLIS, // 8\n248:             CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 9\n249:             CommunicationMode.ASYNC, // 10\n250:             pullCallback// 11\n251:         );\n252:     } catch (Exception e) {\n253:         log.error(\"pullKernelImpl exception\", e);\n254:         this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);\n255:     }\n256: }\n257: \n258: private void correctTagsOffset(final PullRequest pullRequest) {\n259:     if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {\n260:         this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);\n261:     }\n262: }\n```\n\n* `#pullMessage(...)` 说明 ：拉取消息。\n    * 第 3 至 6 行 ：消息处理队列已经终止，不进行消息拉取。\n    * 第 9 行 ：设置消息处理队列最后拉取消息时间。\n    * 第 11 至 18 行 ：`Consumer` 未处于运行中状态，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 20 至 25 行 ： `Consumer` 处于暂停中，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 27 至 37 行 ：消息处理队列持有消息超过最大允许值（默认：1000条），不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 39 至 49 行 ：`Consumer` 为**并发消费** 并且 消息队列持有消息跨度过大（消息跨度 = 持有消息最后一条和第一条的消息位置差，默认：2000），不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 50 至 70 行 ：`顺序消费` 相关跳过，详细解析见：[《RocketMQ 源码分析 —— Message 顺序发送与消费》](http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/)。\n    * 第 72 至 78 行 ：`Topic` 对应的订阅信息不存在，不进行消息拉取，提交**延迟**拉取消息请求。\n    * 第 222 至 224 行 ：判断请求是否使用 `Consumer` **本地**的订阅信息( `SubscriptionData` )，而不使用 `Broker` 里的订阅信息。详细解析见：[PullMessageProcessor#processRequest(...) 第 64 至 110 行代码](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…)。\n    * 第 226 行 ：是否开启过滤类过滤模式。详细解析见：[《RocketMQ 源码分析 —— Filtersrv》](http://www.yunai.me/RocketMQ/filtersrv/)。\n    * 第 229 至 235 行 ：计算拉取消息请求系统标识。详细解析见：[PullMessageRequestHeader.sysFlag](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageRequestHeader)。\n    * 第 237 至 255 行 ：\n        * 执行消息拉取**异步**请求。详细解析见：[PullAPIWrapper#pullKernelImpl(...)](#pullapiwrapperpullkernelimpl)。\n        * 当发起请求产生异常时，提交**延迟**拉取消息请求。对应 `Broker` 处理拉取消息逻辑见：[PullMessageProcessor#processRequest(...)](http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…)。\n* `PullCallback` ：拉取消息回调：\n   * 第 86 行 ：处理拉取结果。详细逻辑见：[PullAPIWrapper#processPullResult(...)](#pullapiwrapperprocesspullresult)。\n   * 第 89 至 192 行 ：处理拉取状态结果：\n        * 第 90 至 139 行 ：拉取到消息( `FOUND` ) ：\n            * 第 91 至 93 行 ：设置下次拉取消息队列位置。\n            * 第 95 至 97 行 ：统计。\n            * 第 101 至 102 行 ：拉取到消息的消息列表为空，提交**立即**拉取消息请求。为什么会存在拉取到消息，但是消息结果未空呢？原因见：[PullAPIWrapper#processPullResult(...)](#pullapiwrapperprocesspullresult)。\n            * 第 106 至 108 行 ：统计。\n            * 第 111 行 ：提交拉取到的消息到消息处理队列。详细解析见：[ProcessQueue#putMessage(...)](#processqueueputmessage)。\n            * 第 113 至 118 行 ：提交消费请求到 `ConsumeMessageService`。详细解析见：[ConsumeMessageConcurrentlyService](#consumemessageconcurrentlyservice)。\n            * 第 120 至 126 行 ：根据拉取频率( `pullInterval` )，提交**立即或者延迟**拉取消息请求。默认拉取频率为 0ms ，提交**立即**拉取消息请求。\n            * 第 129 至 137 行 ：下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为**BUG**，输出警告日志。\n       * 第 140 至 149 行 ：没有新消息( `NO_NEW_MSG` ) ：\n            * 第 142 行 ： 设置下次拉取消息队列位置。\n            * 第 145 行 ：更正消费进度。详细解析见：`#correctTagsOffset(...)`。\n            * 第 148 行 ：提交**立即**拉取消息请求。\n       * 第 150 至 159 行 ：有新消息但是不匹配( `NO_MATCHED_MSG` )。逻辑同 `NO_NEW_MSG` 。\n       * 第 160 至 189 行 ：拉取请求的消息队列位置不合法 (`OFFSET_ILLEGAL`)。\n            * 第 164 行 ：设置下次拉取消息队列位置。\n            * 第 167 行 ：设置消息处理队列为 `dropped`。\n            * 第 169 至 188 行 ：提交延迟任务，进行队列移除。\n                * 第 175 至 178 行 ：更新消费进度，同步消费进度到 `Broker`。\n                * 第 181 行 ：移除消费处理队列。\n                    * 疑问：为什么不立即移除？？？ \n  * 第 196 至 204 行 ：发生异常，提交**延迟**拉取消息请求。\n* `#correctTagsOffset(...)` ：更正消费进度。\n    * 第 258 至 261 行 ： 当消费处理队列持有消息数量为 **0** 时，更新消费进度为拉取请求的拉取消息队列位置。\n\n### PullAPIWrapper#pullKernelImpl(...)\n\n```Java\n  1: /**\n  2:  * 拉取消息核心方法\n  3:  *\n  4:  * @param mq 消息队列\n  5:  * @param subExpression 订阅表达式\n  6:  * @param subVersion 订阅版本号\n  7:  * @param offset 拉取队列开始位置\n  8:  * @param maxNums 拉取消息数量\n  9:  * @param sysFlag 拉取请求系统标识\n 10:  * @param commitOffset 提交消费进度\n 11:  * @param brokerSuspendMaxTimeMillis broker挂起请求最大时间\n 12:  * @param timeoutMillis 请求broker超时时长\n 13:  * @param communicationMode 通讯模式\n 14:  * @param pullCallback 拉取回调\n 15:  * @return 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。\n 16:  * @throws MQClientException 当寻找不到 broker 时，或发生其他client异常\n 17:  * @throws RemotingException 当远程调用发生异常时\n 18:  * @throws MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。\n 19:  * @throws InterruptedException 当发生中断异常时\n 20:  */\n 21: protected PullResult pullKernelImpl(\n 22:     final MessageQueue mq,\n 23:     final String subExpression,\n 24:     final long subVersion,\n 25:     final long offset,\n 26:     final int maxNums,\n 27:     final int sysFlag,\n 28:     final long commitOffset,\n 29:     final long brokerSuspendMaxTimeMillis,\n 30:     final long timeoutMillis,\n 31:     final CommunicationMode communicationMode,\n 32:     final PullCallback pullCallback\n 33: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {\n 34:     // 获取Broker信息\n 35:     FindBrokerResult findBrokerResult =\n 36:         this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n 37:             this.recalculatePullFromWhichNode(mq), false);\n 38:     if (null == findBrokerResult) {\n 39:         this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());\n 40:         findBrokerResult =\n 41:             this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),\n 42:                 this.recalculatePullFromWhichNode(mq), false);\n 43:     }\n 44: \n 45:     // 请求拉取消息\n 46:     if (findBrokerResult != null) {\n 47:         int sysFlagInner = sysFlag;\n 48: \n 49:         if (findBrokerResult.isSlave()) {\n 50:             sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);\n 51:         }\n 52: \n 53:         PullMessageRequestHeader requestHeader = new PullMessageRequestHeader();\n 54:         requestHeader.setConsumerGroup(this.consumerGroup);\n 55:         requestHeader.setTopic(mq.getTopic());\n 56:         requestHeader.setQueueId(mq.getQueueId());\n 57:         requestHeader.setQueueOffset(offset);\n 58:         requestHeader.setMaxMsgNums(maxNums);\n 59:         requestHeader.setSysFlag(sysFlagInner);\n 60:         requestHeader.setCommitOffset(commitOffset);\n 61:         requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);\n 62:         requestHeader.setSubscription(subExpression);\n 63:         requestHeader.setSubVersion(subVersion);\n 64: \n 65:         String brokerAddr = findBrokerResult.getBrokerAddr();\n 66:         if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) { // TODO filtersrv\n 67:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);\n 68:         }\n 69: \n 70:         PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage(\n 71:             brokerAddr,\n 72:             requestHeader,\n 73:             timeoutMillis,\n 74:             communicationMode,\n 75:             pullCallback);\n 76: \n 77:         return pullResult;\n 78:     }\n 79: \n 80:     // Broker信息不存在，则抛出异常\n 81:     throw new MQClientException(\"The broker[\" + mq.getBrokerName() + \"] not exist\", null);\n 82: }\n```\n\n* 说明 ：拉取消息核心方法。**该方法参数较多，可以看下代码注释上每个参数的说明**😈。\n* 第 34 至 43 行 ：获取 `Broker` 信息(`Broker` 地址、是否为从节点)。\n    * [#recalculatePullFromWhichNode(...)](#pullapiwrapperrecalculatepullfromwhichnode)\n    * [#MQClientInstance#findBrokerAddressInSubscribe(...)](#mqclientinstancefindbrokeraddressinsubscribe)\n* 第 45 至 78 行 ：**请求拉取消息**。\n* 第 81 行 ：当 `Broker` 信息不存在，则抛出异常。\n\n#### PullAPIWrapper#recalculatePullFromWhichNode(...)\n\n```Java\n  1: /**\n  2:  * 消息队列 与 拉取Broker 的映射\n  3:  * 当拉取消息时，会通过该映射获取拉取请求对应的Broker\n  4:  */\n  5: private ConcurrentHashMap<MessageQueue, AtomicLong/* brokerId */> pullFromWhichNodeTable =\n  6:     new ConcurrentHashMap<MessageQueue, AtomicLong>(32);\n  7: /**\n  8:  * 是否使用默认Broker\n  9:  */\n 10: private volatile boolean connectBrokerByUser = false;\n 11: /**\n 12:  * 默认Broker编号\n 13:  */\n 14: private volatile long defaultBrokerId = MixAll.MASTER_ID;\n 15: \n 16: /**\n 17:  * 计算消息队列拉取消息对应的Broker编号\n 18:  *\n 19:  * @param mq 消息队列\n 20:  * @return Broker编号\n 21:  */\n 22: public long recalculatePullFromWhichNode(final MessageQueue mq) {\n 23:     // 若开启默认Broker开关，则返回默认Broker编号\n 24:     if (this.isConnectBrokerByUser()) {\n 25:         return this.defaultBrokerId;\n 26:     }\n 27: \n 28:     // 若消息队列映射拉取Broker存在，则返回映射Broker编号\n 29:     AtomicLong suggest = this.pullFromWhichNodeTable.get(mq);\n 30:     if (suggest != null) {\n 31:         return suggest.get();\n 32:     }\n 33: \n 34:     // 返回Broker主节点编号\n 35:     return MixAll.MASTER_ID;\n 36: }\n```\n\n* 说明 ：计算消息队列拉取消息对应的 `Broker` 编号。\n\n#### MQClientInstance#findBrokerAddressInSubscribe(...)\n\n```Java\n  1: /**\n  2:  * Broker名字 和 Broker地址相关 Map\n  3:  */\n  4: private final ConcurrentHashMap<String/* Broker Name */, HashMap<Long/* brokerId */, String/* address */>> brokerAddrTable =\n  5:         new ConcurrentHashMap<>();\n  6: \n  7: /**\n  8:  * 获得Broker信息\n  9:  *\n 10:  * @param brokerName broker名字\n 11:  * @param brokerId broker编号\n 12:  * @param onlyThisBroker 是否必须是该broker\n 13:  * @return Broker信息\n 14:  */\n 15: public FindBrokerResult findBrokerAddressInSubscribe(//\n 16:     final String brokerName, //\n 17:     final long brokerId, //\n 18:     final boolean onlyThisBroker//\n 19: ) {\n 20:     String brokerAddr = null; // broker地址\n 21:     boolean slave = false; // 是否为从节点\n 22:     boolean found = false; // 是否找到\n 23: \n 24:     // 获得Broker信息\n 25:     HashMap<Long/* brokerId */, String/* address */> map = this.brokerAddrTable.get(brokerName);\n 26:     if (map != null && !map.isEmpty()) {\n 27:         brokerAddr = map.get(brokerId);\n 28:         slave = brokerId != MixAll.MASTER_ID;\n 29:         found = brokerAddr != null;\n 30: \n 31:         // 如果不强制获得，选择一个Broker\n 32:         if (!found && !onlyThisBroker) {\n 33:             Entry<Long, String> entry = map.entrySet().iterator().next();\n 34:             brokerAddr = entry.getValue();\n 35:             slave = entry.getKey() != MixAll.MASTER_ID;\n 36:             found = true;\n 37:         }\n 38:     }\n 39: \n 40:     // 找到broker，则返回信息\n 41:     if (found) {\n 42:         return new FindBrokerResult(brokerAddr, slave);\n 43:     }\n 44: \n 45:     // 找不到，则返回空\n 46:     return null;\n 47: }\n```\n\n* 说明 ：获取 `Broker` 信息(`Broker` 地址、是否为从节点)。\n\n### PullAPIWrapper#processPullResult(...)\n\n```Java\n  1: /**\n  2:  * 处理拉取结果\n  3:  * 1. 更新消息队列拉取消息Broker编号的映射\n  4:  * 2. 解析消息，并根据订阅信息消息tagCode匹配合适消息\n  5:  *\n  6:  * @param mq 消息队列\n  7:  * @param pullResult 拉取结果\n  8:  * @param subscriptionData 订阅信息\n  9:  * @return 拉取结果\n 10:  */\n 11: public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult,\n 12:     final SubscriptionData subscriptionData) {\n 13:     PullResultExt pullResultExt = (PullResultExt) pullResult;\n 14: \n 15:     // 更新消息队列拉取消息Broker编号的映射\n 16:     this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());\n 17: \n 18:     // 解析消息，并根据订阅信息消息tagCode匹配合适消息\n 19:     if (PullStatus.FOUND == pullResult.getPullStatus()) {\n 20:         // 解析消息\n 21:         ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());\n 22:         List<MessageExt> msgList = MessageDecoder.decodes(byteBuffer);\n 23: \n 24:         // 根据订阅信息消息tagCode匹配合适消息\n 25:         List<MessageExt> msgListFilterAgain = msgList;\n 26:         if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()) {\n 27:             msgListFilterAgain = new ArrayList<>(msgList.size());\n 28:             for (MessageExt msg : msgList) {\n 29:                 if (msg.getTags() != null) {\n 30:                     if (subscriptionData.getTagsSet().contains(msg.getTags())) {\n 31:                         msgListFilterAgain.add(msg);\n 32:                     }\n 33:                 }\n 34:             }\n 35:         }\n 36: \n 37:         // Hook\n 38:         if (this.hasHook()) {\n 39:             FilterMessageContext filterMessageContext = new FilterMessageContext();\n 40:             filterMessageContext.setUnitMode(unitMode);\n 41:             filterMessageContext.setMsgList(msgListFilterAgain);\n 42:             this.executeHook(filterMessageContext);\n 43:         }\n 44: \n 45:         // 设置消息队列当前最小/最大位置到消息拓展字段\n 46:         for (MessageExt msg : msgListFilterAgain) {\n 47:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,\n 48:                 Long.toString(pullResult.getMinOffset()));\n 49:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,\n 50:                 Long.toString(pullResult.getMaxOffset()));\n 51:         }\n 52: \n 53:         // 设置消息列表\n 54:         pullResultExt.setMsgFoundList(msgListFilterAgain);\n 55:     }\n 56: \n 57:     // 清空消息二进制数组\n 58:     pullResultExt.setMessageBinary(null);\n 59: \n 60:     return pullResult;\n 61: }\n```\n\n* 说明 ：处理拉取结果。\n    *  更新消息队列拉取消息 `Broker` 编号的映射。\n    *  解析消息，并根据订阅信息消息 `tagCode `匹配合适消息。\n* 第 16 行 ：更新消息队列拉取消息 `Broker` 编号的映射。下次拉取消息时，如果未设置默认拉取的 `Broker` 编号，会使用更新后的 `Broker` 编号。\n* 第 18 至 55 行 ：解析消息，并根据订阅信息消息 `tagCode` 匹配合适消息。\n    * 第 20 至 22 行 ：解析消息。详细解析见：[《RocketMQ 源码分析 —— Message基础》](http://www.yunai.me/RocketMQ/message/) 。\n    * 第 24 至 35 行 ：根据订阅信息`tagCode` 匹配消息。\n    * 第 37 至 43 行 ：`Hook`。\n    * 第 45 至 51 行 ：设置消息队列当前最小/最大位置到消息拓展字段。\n    * 第 54 行 ：设置消息队列。\n* 第 58 行 ：清空消息二进制数组。\n\n### ProcessQueue#putMessage(...)\n\n```Java\n  1:  /**\n  2:  * 消息映射读写锁\n  3:  */\n  4: private final ReadWriteLock lockTreeMap = new ReentrantReadWriteLock();\n  5: /**\n  6:  * 消息映射\n  7:  * key：消息队列位置\n  8:  */\n  9: private final TreeMap<Long, MessageExt> msgTreeMap = new TreeMap<>();\n 10: /**\n 11:  * 消息数\n 12:  */\n 13: private final AtomicLong msgCount = new AtomicLong();\n 14: /**\n 15:  * 添加消息最大队列位置\n 16:  */\n 17: private volatile long queueOffsetMax = 0L;\n 18: /**\n 19:  * 是否正在消费\n 20:  */\n 21: private volatile boolean consuming = false;\n 22: /**\n 23:  * Broker累计消息数量\n 24:  * 计算公式 = queueMaxOffset - 新添加消息数组[n - 1].queueOffset\n 25:  * Acc = Accumulation\n 26:  * cnt = （猜测）对比度\n 27:  */\n 28: private volatile long msgAccCnt = 0;\n 29: \n 30: /**\n 31:  * 添加消息，并返回是否提交给消费者\n 32:  * 返回true，当有新消息添加成功时，\n 33:  *\n 34:  * @param msgs 消息\n 35:  * @return 是否提交给消费者\n 36:  */\n 37: public boolean putMessage(final List<MessageExt> msgs) {\n 38:     boolean dispatchToConsume = false;\n 39:     try {\n 40:         this.lockTreeMap.writeLock().lockInterruptibly();\n 41:         try {\n 42:             // 添加消息\n 43:             int validMsgCnt = 0;\n 44:             for (MessageExt msg : msgs) {\n 45:                 MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);\n 46:                 if (null == old) {\n 47:                     validMsgCnt++;\n 48:                     this.queueOffsetMax = msg.getQueueOffset();\n 49:                 }\n 50:             }\n 51:             msgCount.addAndGet(validMsgCnt);\n 52: \n 53:             // 计算是否正在消费\n 54:             if (!msgTreeMap.isEmpty() && !this.consuming) {\n 55:                 dispatchToConsume = true;\n 56:                 this.consuming = true;\n 57:             }\n 58: \n 59:             // Broker累计消息数量\n 60:             if (!msgs.isEmpty()) {\n 61:                 MessageExt messageExt = msgs.get(msgs.size() - 1);\n 62:                 String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);\n 63:                 if (property != null) {\n 64:                     long accTotal = Long.parseLong(property) - messageExt.getQueueOffset();\n 65:                     if (accTotal > 0) {\n 66:                         this.msgAccCnt = accTotal;\n 67:                     }\n 68:                 }\n 69:             }\n 70:         } finally {\n 71:             this.lockTreeMap.writeLock().unlock();\n 72:         }\n 73:     } catch (InterruptedException e) {\n 74:         log.error(\"putMessage exception\", e);\n 75:     }\n 76: \n 77:     return dispatchToConsume;\n 78: }\n```\n\n## 总结\n\n如果用最简单粗暴的方式描述 `PullConsumer` 拉取消息的过程，那就是如下的代码：\n\n```Java\nwhile (true) {\n    if (不满足拉取消息) {\n        Thread.sleep(间隔);\n        continue;\n    }\n    主动拉取消息();\n}\n```\n\n# 6、PushConsumer 消费消息\n\n![DefaultMQPushConsumerImpl消费消息](http://www.yunai.me/images/RocketMQ/2017_05_04/06.png)\n\n## ConsumeMessageConcurrentlyService 提交消费请求\n\n### ConsumeMessageConcurrentlyService#submitConsumeRequest(...)\n\n```Java\n  1: /**\n  2:  * 消费线程池队列\n  3:  */\n  4: private final BlockingQueue<Runnable> consumeRequestQueue;\n  5: /**\n  6:  * 消费线程池\n  7:  */\n  8: private final ThreadPoolExecutor consumeExecutor;\n  9: \n 10: public void submitConsumeRequest(//\n 11:     final List<MessageExt> msgs, //\n 12:     final ProcessQueue processQueue, //\n 13:     final MessageQueue messageQueue, //\n 14:     final boolean dispatchToConsume) {\n 15:     final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();\n 16:     if (msgs.size() <= consumeBatchSize) { // 提交消息小于批量消息数，直接提交消费请求\n 17:         ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);\n 18:         try {\n 19:             this.consumeExecutor.submit(consumeRequest);\n 20:         } catch (RejectedExecutionException e) {\n 21:             this.submitConsumeRequestLater(consumeRequest);\n 22:         }\n 23:     } else { // 提交消息大于批量消息数，进行分拆成多个消费请求\n 24:         for (int total = 0; total < msgs.size(); ) {\n 25:             // 计算当前拆分请求包含的消息\n 26:             List<MessageExt> msgThis = new ArrayList<>(consumeBatchSize);\n 27:             for (int i = 0; i < consumeBatchSize; i++, total++) {\n 28:                 if (total < msgs.size()) {\n 29:                     msgThis.add(msgs.get(total));\n 30:                 } else {\n 31:                     break;\n 32:                 }\n 33:             }\n 34: \n 35:             // 提交拆分消费请求\n 36:             ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);\n 37:             try {\n 38:                 this.consumeExecutor.submit(consumeRequest);\n 39:             } catch (RejectedExecutionException e) {\n 40:                 // 如果被拒绝，则将当前拆分消息+剩余消息提交延迟消费请求。\n 41:                 for (; total < msgs.size(); total++) {\n 42:                     msgThis.add(msgs.get(total));\n 43:                 }\n 44:                 this.submitConsumeRequestLater(consumeRequest);\n 45:             }\n 46:         }\n 47:     }\n 48: }\n```\n\n* 说明 ：提交**立即**消费请求。\n* 第 16 至 22 行 ：提交消息小于等于批量消费数，直接提交消费请求。\n* 第 23 至 47 行 ：当提交消息大于批量消费数，进行分拆成多个请求。\n    * 第 25 至 33 行 ：计算当前拆分请求包含的消息。\n    * 第 35 至 38 行 ：提交拆分消费请求。\n    * 第 39 至 44 行 ：提交请求被拒绝，则将当前拆分消息 + 剩余消息提交延迟消费请求，结束拆分循环。\n\n### ConsumeMessageConcurrentlyService#submitConsumeRequestLater\n \n ```Java\n   1: /**\n  2:  * 提交延迟消费请求\n  3:  *\n  4:  * @param msgs 消息列表\n  5:  * @param processQueue 消息处理队列\n  6:  * @param messageQueue 消息队列\n  7:  */\n  8: private void submitConsumeRequestLater(//\n  9:     final List<MessageExt> msgs, //\n 10:     final ProcessQueue processQueue, //\n 11:     final MessageQueue messageQueue//\n 12: ) {\n 13: \n 14:     this.scheduledExecutorService.schedule(new Runnable() {\n 15: \n 16:         @Override\n 17:         public void run() {\n 18:             ConsumeMessageConcurrentlyService.this.submitConsumeRequest(msgs, processQueue, messageQueue, true);\n 19:         }\n 20:     }, 5000, TimeUnit.MILLISECONDS);\n 21: }\n 22: \n 23: /**\n 24:  * 提交延迟消费请求\n 25:  * @param consumeRequest 消费请求\n 26:  */\n 27: private void submitConsumeRequestLater(final ConsumeRequest consumeRequest//\n 28: ) {\n 29: \n 30:     this.scheduledExecutorService.schedule(new Runnable() {\n 31: \n 32:         @Override\n 33:         public void run() {\n 34:             ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest); // TODO BUG ?\n 35:         }\n 36:     }, 5000, TimeUnit.MILLISECONDS);\n 37: }\n ```\n \n* 说明 ：提交延迟消费请求。\n* 第 34 行 ：直接调用 `ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);`。如果消息数超过批量消费上限，会不会是**BUG**。\n \n## ConsumeRequest\n\n```Java\n  1: class ConsumeRequest implements Runnable {\n  2: \n  3:     /**\n  4:      * 消费消息列表\n  5:      */\n  6:     private final List<MessageExt> msgs;\n  7:     /**\n  8:      * 消息处理队列\n  9:      */\n 10:     private final ProcessQueue processQueue;\n 11:     /**\n 12:      * 消息队列\n 13:      */\n 14:     private final MessageQueue messageQueue;\n 15: \n 16:     public ConsumeRequest(List<MessageExt> msgs, ProcessQueue processQueue, MessageQueue messageQueue) {\n 17:         this.msgs = msgs;\n 18:         this.processQueue = processQueue;\n 19:         this.messageQueue = messageQueue;\n 20:     }\n 21: \n 22:     @Override\n 23:     public void run() {\n 24:         // 废弃队列不进行消费\n 25:         if (this.processQueue.isDropped()) {\n 26:             log.info(\"the message queue not be able to consume, because it's dropped. group={} {}\", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);\n 27:             return;\n 28:         }\n 29: \n 30:         MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener; // 监听器\n 31:         ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue); // 消费Context\n 32:         ConsumeConcurrentlyStatus status = null; // 消费结果状态\n 33: \n 34:         // Hook\n 35:         ConsumeMessageContext consumeMessageContext = null;\n 36:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n 37:             consumeMessageContext = new ConsumeMessageContext();\n 38:             consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());\n 39:             consumeMessageContext.setProps(new HashMap<String, String>());\n 40:             consumeMessageContext.setMq(messageQueue);\n 41:             consumeMessageContext.setMsgList(msgs);\n 42:             consumeMessageContext.setSuccess(false);\n 43:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);\n 44:         }\n 45: \n 46:         long beginTimestamp = System.currentTimeMillis();\n 47:         boolean hasException = false;\n 48:         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; // 消费返回结果类型\n 49:         try {\n 50:             // 当消息为重试消息，设置Topic为原始Topic\n 51:             ConsumeMessageConcurrentlyService.this.resetRetryTopic(msgs);\n 52: \n 53:             // 设置开始消费时间\n 54:             if (msgs != null && !msgs.isEmpty()) {\n 55:                 for (MessageExt msg : msgs) {\n 56:                     MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));\n 57:                 }\n 58:             }\n 59: \n 60:             // 进行消费\n 61:             status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);\n 62:         } catch (Throwable e) {\n 63:             log.warn(\"consumeMessage exception: {} Group: {} Msgs: {} MQ: {}\",\n 64:                 RemotingHelper.exceptionSimpleDesc(e), //\n 65:                 ConsumeMessageConcurrentlyService.this.consumerGroup,\n 66:                 msgs,\n 67:                 messageQueue);\n 68:             hasException = true;\n 69:         }\n 70: \n 71:         // 解析消费返回结果类型\n 72:         long consumeRT = System.currentTimeMillis() - beginTimestamp;\n 73:         if (null == status) {\n 74:             if (hasException) {\n 75:                 returnType = ConsumeReturnType.EXCEPTION;\n 76:             } else {\n 77:                 returnType = ConsumeReturnType.RETURNNULL;\n 78:             }\n 79:         } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) {\n 80:             returnType = ConsumeReturnType.TIME_OUT;\n 81:         } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) {\n 82:             returnType = ConsumeReturnType.FAILED;\n 83:         } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) {\n 84:             returnType = ConsumeReturnType.SUCCESS;\n 85:         }\n 86: \n 87:         // Hook\n 88:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n 89:             consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());\n 90:         }\n 91: \n 92:         // 消费结果状态为空时，则设置为稍后重新消费\n 93:         if (null == status) {\n 94:             log.warn(\"consumeMessage return null, Group: {} Msgs: {} MQ: {}\",\n 95:                 ConsumeMessageConcurrentlyService.this.consumerGroup,\n 96:                 msgs,\n 97:                 messageQueue);\n 98:             status = ConsumeConcurrentlyStatus.RECONSUME_LATER;\n 99:         }\n100: \n101:         // Hook\n102:         if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) {\n103:             consumeMessageContext.setStatus(status.toString());\n104:             consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);\n105:             ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);\n106:         }\n107: \n108:         // 统计\n109:         ConsumeMessageConcurrentlyService.this.getConsumerStatsManager()\n110:             .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);\n111: \n112:         // 处理消费结果\n113:         if (!processQueue.isDropped()) {\n114:             ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this);\n115:         } else {\n116:             log.warn(\"processQueue is dropped without process consume result. messageQueue={}, msgs={}\", messageQueue, msgs);\n117:         }\n118:     }\n119: \n120: }\n```\n\n* 说明 ：消费请求。提交请求执行消费。\n* 第 24 至 28 行 ：废弃处理队列不进行消费。\n* 第 34 至 44 行 ：Hook。\n* 第 51 行 ：当消息为重试消息，设置 `Topic`为原始 `Topic`。例如：原始 `Topic` 为 `TopicTest`，重试时 `Topic` 为 `%RETRY%please_rename_unique_group_name_4`，经过该方法，`Topic` 设置回 `TopicTest`。\n* 第 53 至 58 行 ：设置开始消费时间。\n* 第 61 行 ：**进行消费**。\n* 第 71 至 85 行 ：解析消费返回结果类型\n* 第 87 至 90 行 ：`Hook`。\n* 第 92 至 99 行 ：消费结果状态未空时，则设置消费结果状态为稍后消费。\n* 第 101 至 106 行 ：`Hook`。\n* 第 108 至 110 行 ：统计。\n* 第 112 至 117 行 ：处理消费结果。**如果消费处理队列被移除，恰好消息被消费，则可能导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性**。详细解析见：[ConsumeMessageConcurrentlyService#processConsumeResult(...)](#consumemessageconcurrentlyserviceprocessconsumeresult)。\n\n## ConsumeMessageConcurrentlyService#processConsumeResult(...)\n\n```Java\n  1: public void processConsumeResult(//\n  2:     final ConsumeConcurrentlyStatus status, //\n  3:     final ConsumeConcurrentlyContext context, //\n  4:     final ConsumeRequest consumeRequest//\n  5: ) {\n  6:     int ackIndex = context.getAckIndex();\n  7: \n  8:     // 消息为空，直接返回\n  9:     if (consumeRequest.getMsgs().isEmpty())\n 10:         return;\n 11: \n 12:     // 计算从consumeRequest.msgs[0]到consumeRequest.msgs[ackIndex]的消息消费成功\n 13:     switch (status) {\n 14:         case CONSUME_SUCCESS:\n 15:             if (ackIndex >= consumeRequest.getMsgs().size()) {\n 16:                 ackIndex = consumeRequest.getMsgs().size() - 1;\n 17:             }\n 18:             // 统计成功/失败数量\n 19:             int ok = ackIndex + 1;\n 20:             int failed = consumeRequest.getMsgs().size() - ok;\n 21:             this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);\n 22:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);\n 23:             break;\n 24:         case RECONSUME_LATER:\n 25:             ackIndex = -1;\n 26:             // 统计成功/失败数量\n 27:             this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),\n 28:                 consumeRequest.getMsgs().size());\n 29:             break;\n 30:         default:\n 31:             break;\n 32:     }\n 33: \n 34:     // 处理消费失败的消息\n 35:     switch (this.defaultMQPushConsumer.getMessageModel()) {\n 36:         case BROADCASTING: // 广播模式，无论是否消费失败，不发回消息到Broker，只打印Log\n 37:             for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {\n 38:                 MessageExt msg = consumeRequest.getMsgs().get(i);\n 39:                 log.warn(\"BROADCASTING, the message consume failed, drop it, {}\", msg.toString());\n 40:             }\n 41:             break;\n 42:         case CLUSTERING:\n 43:             // 发回消息失败到Broker。\n 44:             List<MessageExt> msgBackFailed = new ArrayList<>(consumeRequest.getMsgs().size());\n 45:             for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) {\n 46:                 MessageExt msg = consumeRequest.getMsgs().get(i);\n 47:                 boolean result = this.sendMessageBack(msg, context);\n 48:                 if (!result) {\n 49:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);\n 50:                     msgBackFailed.add(msg);\n 51:                 }\n 52:             }\n 53: \n 54:             // 发回Broker失败的消息，直接提交延迟重新消费\n 55:             if (!msgBackFailed.isEmpty()) {\n 56:                 consumeRequest.getMsgs().removeAll(msgBackFailed);\n 57: \n 58:                 this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());\n 59:             }\n 60:             break;\n 61:         default:\n 62:             break;\n 63:     }\n 64: \n 65:     // 移除消费成功消息，并更新最新消费进度\n 66:     long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());\n 67:     if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) {\n 68:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true);\n 69:     }\n 70: }\n```\n\n* 说明 ：处理消费结果。\n* 第 8 至 10 行 ：消费请求消息未空时，直接返回。\n* 第 12 至 32 行 ：计算 `ackIndex` 值。`consumeRequest.msgs[0 - ackIndex]`为消费成功，需要进行 `ack` 确认。\n    * 第 14 至 23 行 ：`CONSUME_SUCCESS` ：`ackIndex = context.getAckIndex()`。\n    * 第 24 至 29 行 ：`RECONSUME_LATER` ：`ackIndex = -1`。\n* 第34 至 63 行 ：处理消费失败的消息。\n    * 第 36 至 41 行 ：`BROADCASTING` ：广播模式，无论是否消费失败，不发回消息到 `Broker`，只打印日志。\n    * 第 42 至 60 行 ：`CLUSTERING` ：集群模式，消费失败的消息发回到 `Broker`。\n        * 第 43 至 52 行 ：发回消费失败的消息到 `Broker`。详细解析见：[DefaultMQPushConsumerImpl#sendMessageBack(...)](#defaultmqpushconsumerimplsendmessageback)。\n        * 第 54 至 59 行 ：发回 `Broker` 失败的消息，直接提交延迟重新消费。\n        * **如果发回 `Broker` 成功，结果因为例如网络异常，导致 `Consumer`以为发回失败，判定消费发回失败，会导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性。**\n* 第 65 至 69 行 ：移除**【消费成功】**和**【消费失败但发回`Broker`成功】**的消息，并更新最新消费进度。\n    * 为什么会有**【消费失败但发回`Broker`成功】**的消息？见**第 56 行**。\n    * [ProcessQueue#removeMessage(...)](#processqueueremovemessage)\n\n### ProcessQueue#removeMessage(...)\n\n```Java\n  1: /**\n  2:  * 移除消息，并返回第一条消息队列位置\n  3:  *\n  4:  * @param msgs 消息\n  5:  * @return 消息队列位置\n  6:  */\n  7: public long removeMessage(final List<MessageExt> msgs) {\n  8:     long result = -1;\n  9:     final long now = System.currentTimeMillis();\n 10:     try {\n 11:         this.lockTreeMap.writeLock().lockInterruptibly();\n 12:         this.lastConsumeTimestamp = now;\n 13:         try {\n 14:             if (!msgTreeMap.isEmpty()) {\n 15:                 result = this.queueOffsetMax + 1; // 这里+1的原因是：如果msgTreeMap为空时，下一条获得的消息位置为queueOffsetMax+1\n 16: \n 17:                 // 移除消息\n 18:                 int removedCnt = 0;\n 19:                 for (MessageExt msg : msgs) {\n 20:                     MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());\n 21:                     if (prev != null) {\n 22:                         removedCnt--;\n 23:                     }\n 24:                 }\n 25:                 msgCount.addAndGet(removedCnt);\n 26: \n 27:                 if (!msgTreeMap.isEmpty()) {\n 28:                     result = msgTreeMap.firstKey();\n 29:                 }\n 30:             }\n 31:         } finally {\n 32:             this.lockTreeMap.writeLock().unlock();\n 33:         }\n 34:     } catch (Throwable t) {\n 35:         log.error(\"removeMessage exception\", t);\n 36:     }\n 37: \n 38:     return result;\n 39: }\n```\n\n## ConsumeMessageConcurrentlyService#cleanExpireMsg(...)\n\n```Java\n  1: public void start() {\n  2:     this.cleanExpireMsgExecutors.scheduleAtFixedRate(new Runnable() {\n  3: \n  4:         @Override\n  5:         public void run() {\n  6:             cleanExpireMsg();\n  7:         }\n  8: \n  9:     }, this.defaultMQPushConsumer.getConsumeTimeout(), this.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);\n 10: }\n 11: \n 12: /**\n 13:  * 清理过期消息\n 14:  */\n 15: private void cleanExpireMsg() {\n 16:     Iterator<Map.Entry<MessageQueue, ProcessQueue>> it =\n 17:         this.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();\n 18:     while (it.hasNext()) {\n 19:         Map.Entry<MessageQueue, ProcessQueue> next = it.next();\n 20:         ProcessQueue pq = next.getValue();\n 21:         pq.cleanExpiredMsg(this.defaultMQPushConsumer);\n 22:     }\n 23: }\n```\n\n* 说明 ：定时清理过期消息，默认周期：15min。\n\n### ProcessQueue#cleanExpiredMsg(...)\n\n```Java\n  1: public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer) {\n  2:     // 顺序消费时，直接返回\n  3:     if (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) {\n  4:         return;\n  5:     }\n  6: \n  7:     // 循环移除消息\n  8:     int loop = msgTreeMap.size() < 16 ? msgTreeMap.size() : 16; // 每次循环最多移除16条\n  9:     for (int i = 0; i < loop; i++) {\n 10:         // 获取第一条消息。判断是否超时，若不超时，则结束循环\n 11:         MessageExt msg = null;\n 12:         try {\n 13:             this.lockTreeMap.readLock().lockInterruptibly();\n 14:             try {\n 15:                 if (!msgTreeMap.isEmpty() && System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) > pushConsumer.getConsumeTimeout() * 60 * 1000) {\n 16:                     msg = msgTreeMap.firstEntry().getValue();\n 17:                 } else {\n 18:                     break;\n 19:                 }\n 20:             } finally {\n 21:                 this.lockTreeMap.readLock().unlock();\n 22:             }\n 23:         } catch (InterruptedException e) {\n 24:             log.error(\"getExpiredMsg exception\", e);\n 25:         }\n 26: \n 27:         try {\n 28:             // 发回超时消息\n 29:             pushConsumer.sendMessageBack(msg, 3);\n 30:             log.info(\"send expire msg back. topic={}, msgId={}, storeHost={}, queueId={}, queueOffset={}\", msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());\n 31: \n 32:             // 判断此时消息是否依然是第一条，若是，则进行移除\n 33:             try {\n 34:                 this.lockTreeMap.writeLock().lockInterruptibly();\n 35:                 try {\n 36:                     if (!msgTreeMap.isEmpty() && msg.getQueueOffset() == msgTreeMap.firstKey()) {\n 37:                         try {\n 38:                             msgTreeMap.remove(msgTreeMap.firstKey());\n 39:                         } catch (Exception e) {\n 40:                             log.error(\"send expired msg exception\", e);\n 41:                         }\n 42:                     }\n 43:                 } finally {\n 44:                     this.lockTreeMap.writeLock().unlock();\n 45:                 }\n 46:             } catch (InterruptedException e) {\n 47:                 log.error(\"getExpiredMsg exception\", e);\n 48:             }\n 49:         } catch (Exception e) {\n 50:             log.error(\"send expired msg exception\", e);\n 51:         }\n 52:     }\n 53: }\n```\n\n* 说明 ：移除过期消息。\n* 第 2 至 5 行 ：顺序消费时，直接返回。\n* 第 7 至 9 行 ：循环移除消息。默认最大循环次数：16次。\n* 第 10 至 25 行 ：获取第一条消息。判断是否超时，若不超时，则结束循环。\n* 第 29 行 ：**发回超时消息到`Broker`**。\n* 第 32 至 48 行 ：判断此时消息是否依然是第一条，若是，则进行移除。\n\n# 7、PushConsumer 发回消费失败消息\n\n## DefaultMQPushConsumerImpl#sendMessageBack(...)\n\n```Java\n  1: public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)\n  2:     throws RemotingException, MQBrokerException, InterruptedException, MQClientException {\n  3:     try {\n  4:         // Consumer发回消息\n  5:         String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)\n  6:             : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());\n  7:         this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,\n  8:             this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());\n  9:     } catch (Exception e) { // TODO 疑问：什么情况下会发生异常\n 10:         // 异常时，使用Client内置Producer发回消息\n 11:         log.error(\"sendMessageBack Exception, \" + this.defaultMQPushConsumer.getConsumerGroup(), e);\n 12: \n 13:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());\n 14: \n 15:         String originMsgId = MessageAccessor.getOriginMessageId(msg);\n 16:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);\n 17: \n 18:         newMsg.setFlag(msg.getFlag());\n 19:         MessageAccessor.setProperties(newMsg, msg.getProperties());\n 20:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());\n 21:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));\n 22:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));\n 23:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());\n 24: \n 25:         this.mQClientFactory.getDefaultMQProducer().send(newMsg);\n 26:     }\n 27: }\n```\n\n* 说明 ：发回消息。\n* 第 4 至 8 行 ：`Consumer` 发回消息。详细解析见：[MQClientAPIImpl#consumerSendMessageBack(...)](#mqclientapiimplconsumersendmessageback)。\n* 第 10 至 25 行 ：发生异常时，`Consumer` 内置默认 `Producer` 发送消息。\n    * 😈疑问：什么样的情况下会发生异常呢？\n\n### MQClientAPIImpl#consumerSendMessageBack(...)\n\n```Java\n  1: /**\n  2:  * Consumer发回消息\n  3:  * @param addr Broker地址\n  4:  * @param msg 消息\n  5:  * @param consumerGroup 消费分组\n  6:  * @param delayLevel 延迟级别\n  7:  * @param timeoutMillis 超时\n  8:  * @param maxConsumeRetryTimes 消费最大重试次数\n  9:  * @throws RemotingException 当远程调用发生异常时\n 10:  * @throws MQBrokerException 当Broker发生异常时\n 11:  * @throws InterruptedException 当线程中断时\n 12:  */\n 13: public void consumerSendMessageBack(\n 14:     final String addr,\n 15:     final MessageExt msg,\n 16:     final String consumerGroup,\n 17:     final int delayLevel,\n 18:     final long timeoutMillis,\n 19:     final int maxConsumeRetryTimes\n 20: ) throws RemotingException, MQBrokerException, InterruptedException {\n 21:     ConsumerSendMsgBackRequestHeader requestHeader = new ConsumerSendMsgBackRequestHeader();\n 22:     RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);\n 23: \n 24:     requestHeader.setGroup(consumerGroup);\n 25:     requestHeader.setOriginTopic(msg.getTopic());\n 26:     requestHeader.setOffset(msg.getCommitLogOffset());\n 27:     requestHeader.setDelayLevel(delayLevel);\n 28:     requestHeader.setOriginMsgId(msg.getMsgId());\n 29:     requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);\n 30: \n 31:     RemotingCommand response = this.remotingClient.invokeSync(MixAll.brokerVIPChannel(this.clientConfig.isVipChannelEnabled(), addr),\n 32:         request, timeoutMillis);\n 33:     assert response != null;\n 34:     switch (response.getCode()) {\n 35:         case ResponseCode.SUCCESS: {\n 36:             return;\n 37:         }\n 38:         default:\n 39:             break;\n 40:     }\n 41: \n 42:     throw new MQBrokerException(response.getCode(), response.getRemark());\n 43: }\n```\n\n# 8、Consumer 消费进度\n\n## OffsetStore\n\n![OffsetStore类图.png](http://www.yunai.me/images/RocketMQ/2017_05_04/07.png)\n\n* `RemoteBrokerOffsetStore` ：`Consumer` **集群模式** 下，使用远程 `Broker` 消费进度。\n* `LocalFileOffsetStore` ：`Consumer` **广播模式**下，使用本地 `文件` 消费进度。\n\n### OffsetStore#load(...)\n\n#### LocalFileOffsetStore#load(...)\n\n```Java\n  1: @Override\n  2: public void load() throws MQClientException {\n  3:     // 从本地硬盘读取消费进度\n  4:     OffsetSerializeWrapper offsetSerializeWrapper = this.readLocalOffset();\n  5:     if (offsetSerializeWrapper != null && offsetSerializeWrapper.getOffsetTable() != null) {\n  6:         offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());\n  7: \n  8:         // 打印每个消息队列的消费进度\n  9:         for (MessageQueue mq : offsetSerializeWrapper.getOffsetTable().keySet()) {\n 10:             AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);\n 11:             log.info(\"load consumer's offset, {} {} {}\",\n 12:                 this.groupName,\n 13:                 mq,\n 14:                 offset.get());\n 15:         }\n 16:     }\n 17: }\n```\n\n* 说明 ：从本地文件加载消费进度到内存。\n\n##### OffsetSerializeWrapper\n\n```Java\n  1: public class OffsetSerializeWrapper extends RemotingSerializable {\n  2:     private ConcurrentHashMap<MessageQueue, AtomicLong> offsetTable =\n  3:             new ConcurrentHashMap<>();\n  4: \n  5:     public ConcurrentHashMap<MessageQueue, AtomicLong> getOffsetTable() {\n  6:         return offsetTable;\n  7:     }\n  8: \n  9:     public void setOffsetTable(ConcurrentHashMap<MessageQueue, AtomicLong> offsetTable) {\n 10:         this.offsetTable = offsetTable;\n 11:     }\n 12: }\n```\n\n* 说明 ：本地 `Offset` 存储序列化。\n\n```Bash\nYunai-MacdeMacBook-Pro-2:config yunai$ cat /Users/yunai/.rocketmq_offsets/192.168.17.0@DEFAULT/please_rename_unique_group_name_1/offsets.json\n{\n\t\"offsetTable\":{{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":3,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":2,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1471,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":1,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470,{\n\t\t\t\"brokerName\":\"broker-a\",\n\t\t\t\"queueId\":0,\n\t\t\t\"topic\":\"TopicTest\"\n\t\t}:1470\n\t}\n}\n```\n\n#### RemoteBrokerOffsetStore#load(...)\n\n```Java\n  1: @Override\n  2: public void load() {\n  3: }\n```\n\n* 说明 ：不进行加载，实际读取消费进度时，从 `Broker` 获取。\n\n### OffsetStore#readOffset(...)\n\n读取消费进度类型：\n\n* `READ_FROM_MEMORY` ：从内存读取。\n* `READ_FROM_STORE` ：从存储( `Broker` 或 `文件` )读取。\n* `MEMORY_FIRST_THEN_STORE` ：优先从内存读取，读取不到，从存储读取。\n\n#### LocalFileOffsetStore#readOffset(...)\n\n```Java\n  1: @Override\n  2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {\n  3:     if (mq != null) {\n  4:         switch (type) {\n  5:             case MEMORY_FIRST_THEN_STORE:\n  6:             case READ_FROM_MEMORY: {\n  7:                 AtomicLong offset = this.offsetTable.get(mq);\n  8:                 if (offset != null) {\n  9:                     return offset.get();\n 10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {\n 11:                     return -1;\n 12:                 }\n 13:             }\n 14:             case READ_FROM_STORE: {\n 15:                 OffsetSerializeWrapper offsetSerializeWrapper;\n 16:                 try {\n 17:                     offsetSerializeWrapper = this.readLocalOffset();\n 18:                 } catch (MQClientException e) {\n 19:                     return -1;\n 20:                 }\n 21:                 if (offsetSerializeWrapper != null && offsetSerializeWrapper.getOffsetTable() != null) {\n 22:                     AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);\n 23:                     if (offset != null) {\n 24:                         this.updateOffset(mq, offset.get(), false);\n 25:                         return offset.get();\n 26:                     }\n 27:                 }\n 28:             }\n 29:             default:\n 30:                 break;\n 31:         }\n 32:     }\n 33: \n 34:     return -1;\n 35: }\n```\n\n* 第 16 行 ：从 `文件` 读取消费进度。\n\n#### RemoteBrokerOffsetStore#readOffset(...)\n\n```Java\n  1: @Override\n  2: public long readOffset(final MessageQueue mq, final ReadOffsetType type) {\n  3:     if (mq != null) {\n  4:         switch (type) {\n  5:             case MEMORY_FIRST_THEN_STORE:\n  6:             case READ_FROM_MEMORY: {\n  7:                 AtomicLong offset = this.offsetTable.get(mq);\n  8:                 if (offset != null) {\n  9:                     return offset.get();\n 10:                 } else if (ReadOffsetType.READ_FROM_MEMORY == type) {\n 11:                     return -1;\n 12:                 }\n 13:             }\n 14:             case READ_FROM_STORE: {\n 15:                 try {\n 16:                     long brokerOffset = this.fetchConsumeOffsetFromBroker(mq);\n 17:                     AtomicLong offset = new AtomicLong(brokerOffset);\n 18:                     this.updateOffset(mq, offset.get(), false);\n 19:                     return brokerOffset;\n 20:                 }\n 21:                 // No offset in broker\n 22:                 catch (MQBrokerException e) {\n 23:                     return -1;\n 24:                 }\n 25:                 //Other exceptions\n 26:                 catch (Exception e) {\n 27:                     log.warn(\"fetchConsumeOffsetFromBroker exception, \" + mq, e);\n 28:                     return -2;\n 29:                 }\n 30:             }\n 31:             default:\n 32:                 break;\n 33:         }\n 34:     }\n 35: \n 36:     return -1;\n 37: }\n```\n\n* 第 16 行 ：从 `Broker` 读取消费进度。\n\n### OffsetStore#updateOffset(...)\n\n该方法 `RemoteBrokerOffsetStore` 与 `LocalFileOffsetStore` 实现相同。\n\n```Java\n  1: @Override\n  2: public void updateOffset(MessageQueue mq, long offset, boolean increaseOnly) {\n  3:     if (mq != null) {\n  4:         AtomicLong offsetOld = this.offsetTable.get(mq);\n  5:         if (null == offsetOld) {\n  6:             offsetOld = this.offsetTable.putIfAbsent(mq, new AtomicLong(offset));\n  7:         }\n  8: \n  9:         if (null != offsetOld) {\n 10:             if (increaseOnly) {\n 11:                 MixAll.compareAndIncreaseOnly(offsetOld, offset);\n 12:             } else {\n 13:                 offsetOld.set(offset);\n 14:             }\n 15:         }\n 16:     }\n 17: }\n```\n\n### OffsetStore#persistAll(...)\n\n#### LocalFileOffsetStore#persistAll(...)\n\n```Java\n  1: @Override\n  2: public void persistAll(Set<MessageQueue> mqs) {\n  3:     if (null == mqs || mqs.isEmpty())\n  4:         return;\n  5: \n  6:     OffsetSerializeWrapper offsetSerializeWrapper = new OffsetSerializeWrapper();\n  7:     for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) {\n  8:         if (mqs.contains(entry.getKey())) {\n  9:             AtomicLong offset = entry.getValue();\n 10:             offsetSerializeWrapper.getOffsetTable().put(entry.getKey(), offset);\n 11:         }\n 12:     }\n 13: \n 14:     String jsonString = offsetSerializeWrapper.toJson(true);\n 15:     if (jsonString != null) {\n 16:         try {\n 17:             MixAll.string2File(jsonString, this.storePath);\n 18:         } catch (IOException e) {\n 19:             log.error(\"persistAll consumer offset Exception, \" + this.storePath, e);\n 20:         }\n 21:     }\n 22: }\n```\n\n* 说明 ：持久化消费进度。**将消费进度写入文件**。\n\n#### RemoteBrokerOffsetStore#persistAll(...)\n\n```Java\n  1: @Override\n  2: public void persistAll(Set<MessageQueue> mqs) {\n  3:     if (null == mqs || mqs.isEmpty())\n  4:         return;\n  5: \n  6:     // 持久化消息队列\n  7:     final HashSet<MessageQueue> unusedMQ = new HashSet<>();\n  8:     if (!mqs.isEmpty()) {\n  9:         for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) {\n 10:             MessageQueue mq = entry.getKey();\n 11:             AtomicLong offset = entry.getValue();\n 12:             if (offset != null) {\n 13:                 if (mqs.contains(mq)) {\n 14:                     try {\n 15:                         this.updateConsumeOffsetToBroker(mq, offset.get());\n 16:                         log.info(\"[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}\",\n 17:                             this.groupName,\n 18:                             this.mQClientFactory.getClientId(),\n 19:                             mq,\n 20:                             offset.get());\n 21:                     } catch (Exception e) {\n 22:                         log.error(\"updateConsumeOffsetToBroker exception, \" + mq.toString(), e);\n 23:                     }\n 24:                 } else {\n 25:                     unusedMQ.add(mq);\n 26:                 }\n 27:             }\n 28:         }\n 29:     }\n 30: \n 31:     // 移除不适用的消息队列\n 32:     if (!unusedMQ.isEmpty()) {\n 33:         for (MessageQueue mq : unusedMQ) {\n 34:             this.offsetTable.remove(mq);\n 35:             log.info(\"remove unused mq, {}, {}\", mq, this.groupName);\n 36:         }\n 37:     }\n 38: }\n```\n\n* 说明 ：持久化指定消息队列数组的消费进度到 `Broker`，并移除非指定消息队列。\n\n#### MQClientInstance#persistAllConsumerOffset(...)\n\n```Java\n  1: private void startScheduledTask() {\n  2:     // 定时同步消费进度\n  3:     this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n  4: \n  5:         @Override\n  6:         public void run() {\n  7:             try {\n  8:                 MQClientInstance.this.cleanOfflineBroker();\n  9:                 MQClientInstance.this.sendHeartbeatToAllBrokerWithLock();\n 10:             } catch (Exception e) {\n 11:                 log.error(\"ScheduledTask sendHeartbeatToAllBroker exception\", e);\n 12:             }\n 13:         }\n 14:     }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);\n 15: }\n```\n\n* 说明 ：定时进行持久化，默认周期：5000ms。\n* **重要说明 ：**\n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n    * **消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。** \n\n# 9、结尾\n\n😈可能是本系列最长的一篇文章，如有表达错误和不清晰，请多多见谅。  \n感谢对本系列的阅读、收藏、点赞、分享，特别是翻到结尾。😜真的有丢丢长。\n\n\n","slug":"RocketMQ/message-pull-and-consume-second","published":1,"updated":"2017-06-09T13:09:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj519kzb2001vag5dvm1j77uu","content":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">http://www.yunai.me/RocketMQ/message-pull-and-consume-second/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、Consumer</a></li>\n<li><a href=\"#\">3、PushConsumer 一览</a></li>\n<li><a href=\"#\">4、PushConsumer 订阅</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#subscribe(…)</a><ul>\n<li><a href=\"#\">FilterAPI.buildSubscriptionData(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMQPushConsumer#registerMessageListener(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5、PushConsumer 消息队列分配</a><ul>\n<li><a href=\"#\">RebalanceService</a></li>\n<li><a href=\"#\">MQClientInstance#doRebalance(…)</a></li>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#doRebalance(…)</a></li>\n<li><a href=\"#\">RebalanceImpl#doRebalance(…)</a><ul>\n<li><a href=\"#\">RebalanceImpl#rebalanceByTopic(…)</a></li>\n<li><a href=\"#\">RebalanceImpl#removeUnnecessaryMessageQueue(…)</a><ul>\n<li><a href=\"#\">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a></li>\n<li><a href=\"#\">[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">RebalancePushImpl#dispatchPullRequest(…)</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">AllocateMessageQueueStrategy</a><ul>\n<li><a href=\"#\">AllocateMessageQueueAveragely</a></li>\n<li><a href=\"#\">AllocateMessageQueueByMachineRoom</a></li>\n<li><a href=\"#\">AllocateMessageQueueAveragelyByCircle</a></li>\n<li><a href=\"#\">AllocateMessageQueueByConfig</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">5、PushConsumer 消费进度读取</a><ul>\n<li><a href=\"#\">RebalancePushImpl#computePullFromWhere(…)</a></li>\n<li><a href=\"#\">[PullConsumer] RebalancePullImpl#computePullFromWhere(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、PushConsumer 拉取消息</a><ul>\n<li><a href=\"#\">PullMessageService</a></li>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#pullMessage(…)</a><ul>\n<li><a href=\"#\">PullAPIWrapper#pullKernelImpl(…)</a><ul>\n<li><a href=\"#\">PullAPIWrapper#recalculatePullFromWhichNode(…)</a></li>\n<li><a href=\"#\">MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">PullAPIWrapper#processPullResult(…)</a></li>\n<li><a href=\"#\">ProcessQueue#putMessage(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、PushConsumer 消费消息</a><ul>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService 提交消费请求</a><ul>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</a></li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#submitConsumeRequestLater</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumeRequest</a></li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a><ul>\n<li><a href=\"#\">ProcessQueue#removeMessage(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</a><ul>\n<li><a href=\"#\">ProcessQueue#cleanExpiredMsg(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">7、PushConsumer 发回消费失败消息</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#sendMessageBack(…)</a><ul>\n<li><a href=\"#\">MQClientAPIImpl#consumerSendMessageBack(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">8、Consumer 消费进度</a><ul>\n<li><a href=\"#\">OffsetStore</a><ul>\n<li><a href=\"#\">OffsetStore#load(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#load(…)</a><ul>\n<li><a href=\"#\">OffsetSerializeWrapper</a></li>\n</ul>\n</li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#load(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">OffsetStore#readOffset(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#readOffset(…)</a></li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#readOffset(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">OffsetStore#updateOffset(…)</a></li>\n<li><a href=\"#\">OffsetStore#persistAll(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#persistAll(…)</a></li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#persistAll(…)</a></li>\n<li><a href=\"#\">MQClientInstance#persistAllConsumerOffset(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">9、结尾</a></li>\n</ul>\n<hr>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本文接：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">《RocketMQ 源码分析 —— Message 拉取与消费（上）》</a>。</p>\n<p>主要解析 <code>Consumer</code> 在 <strong>消费</strong> 逻辑涉及到的源码。</p>\n<h1 id=\"2、Consumer\"><a href=\"#2、Consumer\" class=\"headerlink\" title=\"2、Consumer\"></a>2、Consumer</h1><p>MQ 提供了两类消费者：</p>\n<ul>\n<li>PushConsumer：<ul>\n<li>在大多数场景下使用。</li>\n<li>名字虽然是 <code>Push</code> 开头，实际在实现时，使用 <code>Pull</code> 方式实现。通过 <code>Pull</code> <strong>不断不断不断</strong>轮询 <code>Broker</code> 获取消息。当不存在新消息时，<code>Broker</code> 会<strong>挂起请求</strong>，直到有新消息产生，取消挂起，返回新消息。这样，基本和 <code>Broker</code> 主动 <code>Push</code> 做到<strong>接近</strong>的实时性（当然，还是有相应的实时性损失）。原理类似 <strong><a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-comet/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">长轮询( <code>Long-Polling</code> )</a></strong>。</li>\n</ul>\n</li>\n<li>PullConsumer</li>\n</ul>\n<p><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong><br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong><br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong>  </p>\n<h1 id=\"3、PushConsumer-一览\"><a href=\"#3、PushConsumer-一览\" class=\"headerlink\" title=\"3、PushConsumer 一览\"></a>3、PushConsumer 一览</h1><p>先看一张 <code>PushConsumer</code> 包含的组件以及组件之间的交互图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/09.png\" alt=\"PushConsumer手绘图.png\"></p>\n<ul>\n<li><code>RebalanceService</code>：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。当有新的 <code>Consumer</code> 的加入或移除，都会重新分配消息队列。</li>\n<li><code>PullMessageService</code>：拉取消息服务，<strong>不断不断不断</strong>从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>\n<li><code>ConsumeMessageService</code>：消费消息服务，<strong>不断不断不断</strong>消费消息，并处理消费结果。</li>\n<li><code>RemoteBrokerOffsetStore</code>：<code>Consumer</code> 消费进度管理，负责从 <code>Broker</code> 获取消费进度，同步消费进度到 <code>Broker</code>。</li>\n<li><code>ProcessQueue</code> ：消息处理队列。</li>\n<li><code>MQClientInstance</code> ：封装对 <code>Namesrv</code>，<code>Broker</code> 的 API调用，提供给 <code>Producer</code>、<code>Consumer</code> 使用。</li>\n</ul>\n<h1 id=\"4、PushConsumer-订阅\"><a href=\"#4、PushConsumer-订阅\" class=\"headerlink\" title=\"4、PushConsumer 订阅\"></a>4、PushConsumer 订阅</h1><h2 id=\"DefaultMQPushConsumerImpl-subscribe-…\"><a href=\"#DefaultMQPushConsumerImpl-subscribe-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#subscribe(…)\"></a>DefaultMQPushConsumerImpl#subscribe(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(String topic, String subExpression)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         <span class=\"comment\">// 创建订阅数据</span></div><div class=\"line\"> <span class=\"number\">4</span>:         SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">5</span>:             topic, subExpression);</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 通过心跳同步Consumer信息到Broker</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mQClientFactory != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"subscription exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：订阅 <code>Topic</code> 。</li>\n<li>第 3 至 6 行 ：创建订阅数据。详细解析见：<a href=\"#filterapibuildsubscriptiondata\">FilterAPI.buildSubscriptionData(…)</a>。</li>\n<li>第 7 至 10 行 ：通过心跳同步 <code>Consumer</code> 信息到 <code>Broker</code>。</li>\n</ul>\n<h3 id=\"FilterAPI-buildSubscriptionData-…\"><a href=\"#FilterAPI-buildSubscriptionData-…\" class=\"headerlink\" title=\"FilterAPI.buildSubscriptionData(…)\"></a>FilterAPI.buildSubscriptionData(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SubscriptionData <span class=\"title\">buildSubscriptionData</span><span class=\"params\">(<span class=\"keyword\">final</span> String consumerGroup, String topic,</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:     String subString) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     SubscriptionData subscriptionData = <span class=\"keyword\">new</span> SubscriptionData();</div><div class=\"line\"> <span class=\"number\">4</span>:     subscriptionData.setTopic(topic);</div><div class=\"line\"> <span class=\"number\">5</span>:     subscriptionData.setSubString(subString);</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 处理订阅表达式</span></div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         subscriptionData.setSubString(SubscriptionData.SUB_ALL);</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         String[] tags = subString.split(<span class=\"string\">\"\\\\|\\\\|\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (tags.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">for</span> (String tag : tags) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (tag.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     String trimString = tag.trim();</div><div class=\"line\"><span class=\"number\">15</span>:                     <span class=\"keyword\">if</span> (trimString.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                         subscriptionData.getTagsSet().add(trimString);</div><div class=\"line\"><span class=\"number\">17</span>:                         subscriptionData.getCodeSet().add(trimString.hashCode());</div><div class=\"line\"><span class=\"number\">18</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">20</span>:             &#125;</div><div class=\"line\"><span class=\"number\">21</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"subString split error\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:     &#125;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">return</span> subscriptionData;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：根据 <code>Topic</code> 和 订阅表达式 创建订阅数据</li>\n<li>subscriptionData.subVersion = System.currentTimeMillis()。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumer-registerMessageListener-…\"><a href=\"#DefaultMQPushConsumer-registerMessageListener-…\" class=\"headerlink\" title=\"DefaultMQPushConsumer#registerMessageListener(…)\"></a>DefaultMQPushConsumer#registerMessageListener(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerMessageListener</span><span class=\"params\">(MessageListenerConcurrently messageListener)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.messageListener = messageListener;</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</div><div class=\"line\"><span class=\"number\">4</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：注册消息监听器。</li>\n</ul>\n<h1 id=\"5、PushConsumer-消息队列分配\"><a href=\"#5、PushConsumer-消息队列分配\" class=\"headerlink\" title=\"5、PushConsumer 消息队列分配\"></a>5、PushConsumer 消息队列分配</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/10.png\" alt=\"RebalanceService&amp;PushConsumer分配队列\"></p>\n<h2 id=\"RebalanceService\"><a href=\"#RebalanceService\" class=\"headerlink\" title=\"RebalanceService\"></a>RebalanceService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RebalanceService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 等待间隔，单位：毫秒</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> waitInterval =</div><div class=\"line\"> <span class=\"number\">7</span>:         Long.parseLong(System.getProperty(</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"string\">\"rocketmq.client.rebalance.waitInterval\"</span>, <span class=\"string\">\"20000\"</span>));</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">12:      * MQClient对象</div><div class=\"line\">13:      */</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MQClientInstance mqClientFactory;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RebalanceService</span><span class=\"params\">(MQClientInstance mqClientFactory)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.mqClientFactory = mqClientFactory;</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">22</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"keyword\">this</span>.waitForRunning(waitInterval);</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">this</span>.mqClientFactory.doRebalance();</div><div class=\"line\"><span class=\"number\">27</span>:         &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">30</span>:     &#125;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">return</span> RebalanceService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。</li>\n<li><p>第 26 行 ：调用 <code>MQClientInstance#doRebalance(...)</code> 分配消息队列。目前有三种情况情况下触发：</p>\n<ul>\n<li>如 <code>第 25 行</code> 等待超时，每 20s 调用一次。</li>\n<li><code>PushConsumer</code> 启动时，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>\n<li><code>Broker</code> 通知 <code>Consumer</code> 加入 或 移除时，<code>Consumer</code> 响应通知，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>\n</ul>\n<p>详细解析见：<a href=\"#mqclientinstancedorebalance\">MQClientInstance#doRebalance(…)</a>。</p>\n</li>\n</ul>\n<h2 id=\"MQClientInstance-doRebalance-…\"><a href=\"#MQClientInstance-doRebalance-…\" class=\"headerlink\" title=\"MQClientInstance#doRebalance(…)\"></a>MQClientInstance#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class=\"keyword\">this</span>.consumerTable.entrySet()) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         MQConsumerInner impl = entry.getValue();</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 impl.doRebalance();</div><div class=\"line\"> <span class=\"number\">7</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 log.error(<span class=\"string\">\"doRebalance exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">9</span>:             &#125;</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：遍历当前 <code>Client</code> 包含的 <code>consumerTable</code>( <code>Consumer</code>集合 )，执行消息队列分配。</li>\n<li><strong>疑问</strong>：目前代码调试下来，<code>consumerTable</code> 只包含 <code>Consumer</code> 自己。😈有大大对这个疑问有解答的，烦请解答下。</li>\n<li>第 6 行 ：调用 <code>MQConsumerInner#doRebalance(...)</code> 进行队列分配。<code>DefaultMQPushConsumerImpl</code>、<code>DefaultMQPullConsumerImpl</code> 分别对该接口方法进行了实现。<code>DefaultMQPushConsumerImpl#doRebalance(...)</code> 详细解析见：<a href=\"defaultmqpushconsumerimpldorebalance\">DefaultMQPushConsumerImpl#doRebalance(…)</a>。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumerImpl-doRebalance-…\"><a href=\"#DefaultMQPushConsumerImpl-doRebalance-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#doRebalance(…)\"></a>DefaultMQPushConsumerImpl#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.pause) &#123;</div><div class=\"line\"><span class=\"number\">3</span>:         <span class=\"keyword\">this</span>.rebalanceImpl.doRebalance(<span class=\"keyword\">this</span>.isConsumeOrderly());</div><div class=\"line\"><span class=\"number\">4</span>:     &#125;</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：执行消息队列分配。</li>\n<li>第 3 行 ：调用 <code>RebalanceImpl#doRebalance(...)</code> 进行队列分配。详细解析见：<a href=\"#rebalancepushimpldorebalance\">RebalancePushImpl#doRebalance(…)</a>。</li>\n</ul>\n<h2 id=\"RebalanceImpl-doRebalance-…\"><a href=\"#RebalanceImpl-doRebalance-…\" class=\"headerlink\" title=\"RebalanceImpl#doRebalance(…)\"></a>RebalanceImpl#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 执行分配消息队列</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> isOrder 是否顺序消息</div><div class=\"line\"> 5:  */</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 分配每个 topic 的消息队列</span></div><div class=\"line\"> <span class=\"number\">8</span>:     Map&lt;String, SubscriptionData&gt; subTable = <span class=\"keyword\">this</span>.getSubscriptionInner();</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (subTable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">final</span> String topic = entry.getKey();</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">this</span>.rebalanceByTopic(topic, isOrder);</div><div class=\"line\"><span class=\"number\">14</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     log.warn(<span class=\"string\">\"rebalanceByTopic Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">17</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">18</span>:             &#125;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"comment\">// 移除未订阅的topic对应的消息队列</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">this</span>.truncateMessageQueueNotMyTopic();</div><div class=\"line\"><span class=\"number\">23</span>: &#125;</div><div class=\"line\"><span class=\"number\">24</span>: </div><div class=\"line\"><span class=\"number\">25</span>: <span class=\"comment\">/**</span></div><div class=\"line\">26:  * 移除未订阅的消息队列</div><div class=\"line\">27:  */</div><div class=\"line\"><span class=\"number\">28</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">truncateMessageQueueNotMyTopic</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">29</span>:     Map&lt;String, SubscriptionData&gt; subTable = <span class=\"keyword\">this</span>.getSubscriptionInner();</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : <span class=\"keyword\">this</span>.processQueueTable.keySet()) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">if</span> (!subTable.containsKey(mq.getTopic())) &#123;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:             ProcessQueue pq = <span class=\"keyword\">this</span>.processQueueTable.remove(mq);</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (pq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">36</span>:                 log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, truncateMessageQueueNotMyTopic remove unnecessary mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">37</span>:             &#125;</div><div class=\"line\"><span class=\"number\">38</span>:         &#125;</div><div class=\"line\"><span class=\"number\">39</span>:     &#125;</div><div class=\"line\"><span class=\"number\">40</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#doRebalance(...)</code> 说明 ：执行分配消息队列。<ul>\n<li>第 7 至 20 行 ：循环订阅主题集合( <code>subscriptionInner</code> )，分配每一个 <code>Topic</code> 的消息队列。</li>\n<li>第 22 行 ：移除未订阅的 <code>Topic</code> 的消息队列。</li>\n</ul>\n</li>\n<li><code>#truncateMessageQueueNotMyTopic(...)</code> 说明 ：移除未订阅的消息队列。<strong>当调用 <code>DefaultMQPushConsumer#unsubscribe(topic)</code> 时，只移除订阅主题集合( <code>subscriptionInner</code> )，对应消息队列移除在该方法。</strong></li>\n</ul>\n<h3 id=\"RebalanceImpl-rebalanceByTopic-…\"><a href=\"#RebalanceImpl-rebalanceByTopic-…\" class=\"headerlink\" title=\"RebalanceImpl#rebalanceByTopic(…)\"></a>RebalanceImpl#rebalanceByTopic(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rebalanceByTopic</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">switch</span> (messageModel) &#123;</div><div class=\"line\">  <span class=\"number\">3</span>:         <span class=\"keyword\">case</span> BROADCASTING: &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:             Set&lt;MessageQueue&gt; mqSet = <span class=\"keyword\">this</span>.topicSubscribeInfoTable.get(topic);</div><div class=\"line\">  <span class=\"number\">5</span>:             <span class=\"keyword\">if</span> (mqSet != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  <span class=\"number\">6</span>:                 <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</div><div class=\"line\">  <span class=\"number\">7</span>:                 <span class=\"keyword\">if</span> (changed) &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:                     <span class=\"keyword\">this</span>.messageQueueChanged(topic, mqSet, mqSet);</div><div class=\"line\">  <span class=\"number\">9</span>:                     log.info(<span class=\"string\">\"messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">10</span>:                         consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">11</span>:                         topic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">12</span>:                         mqSet, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">13</span>:                         mqSet);</div><div class=\"line\"> <span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">15</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">17</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">19</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">case</span> CLUSTERING: &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"comment\">// 获取 topic 对应的 队列 和 consumer信息</span></div><div class=\"line\"> <span class=\"number\">22</span>:             Set&lt;MessageQueue&gt; mqSet = <span class=\"keyword\">this</span>.topicSubscribeInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">23</span>:             List&lt;String&gt; cidAll = <span class=\"keyword\">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqSet) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:                     log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">28</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">31</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">32</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (mqSet != <span class=\"keyword\">null</span> &amp;&amp; cidAll != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"comment\">// 排序 消息队列 和 消费者数组。因为是在Client进行分配队列，排序后，各Client的顺序才能保持一致。</span></div><div class=\"line\"> <span class=\"number\">36</span>:                 List&lt;MessageQueue&gt; mqAll = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">37</span>:                 mqAll.addAll(mqSet);</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:                 Collections.sort(mqAll);</div><div class=\"line\"> <span class=\"number\">40</span>:                 Collections.sort(cidAll);</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:                 AllocateMessageQueueStrategy strategy = <span class=\"keyword\">this</span>.allocateMessageQueueStrategy;</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:                 <span class=\"comment\">// 根据 队列分配策略 分配消息队列</span></div><div class=\"line\"> <span class=\"number\">45</span>:                 List&lt;MessageQueue&gt; allocateResult;</div><div class=\"line\"> <span class=\"number\">46</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:                     allocateResult = strategy.allocate(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">48</span>:                         <span class=\"keyword\">this</span>.consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">49</span>:                         <span class=\"keyword\">this</span>.mQClientFactory.getClientId(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">50</span>:                         mqAll, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">51</span>:                         cidAll);</div><div class=\"line\"> <span class=\"number\">52</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:                     log.error(<span class=\"string\">\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;\"</span>, strategy.getName(),</div><div class=\"line\"> <span class=\"number\">54</span>:                         e);</div><div class=\"line\"> <span class=\"number\">55</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:                 Set&lt;MessageQueue&gt; allocateResultSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"keyword\">if</span> (allocateResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                     allocateResultSet.addAll(allocateResult);</div><div class=\"line\"> <span class=\"number\">61</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"comment\">// 更新消息队列</span></div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"keyword\">if</span> (changed) &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:                     log.info(</div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"string\">\"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">68</span>:                         strategy.getName(), consumerGroup, topic, <span class=\"keyword\">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</div><div class=\"line\"> <span class=\"number\">69</span>:                         allocateResultSet.size(), allocateResultSet);</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"keyword\">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</div><div class=\"line\"> <span class=\"number\">71</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">72</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">73</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">74</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">78</span>: &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 81:  * 当负载均衡时，更新 消息处理队列</div><div class=\"line\"> 82:  * - 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列</div><div class=\"line\"> 83:  * - 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列</div><div class=\"line\"> 84:  *</div><div class=\"line\"> 85:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\"> 86:  * <span class=\"doctag\">@param</span> mqSet 负载均衡结果后的消息队列数组</div><div class=\"line\"> 87:  * <span class=\"doctag\">@param</span> isOrder 是否顺序</div><div class=\"line\"> 88:  * <span class=\"doctag\">@return</span> 是否变更</div><div class=\"line\"> 89:  */</div><div class=\"line\"> <span class=\"number\">90</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateProcessQueueTableInRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> Set&lt;MessageQueue&gt; mqSet, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"comment\">// 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列</span></div><div class=\"line\"> <span class=\"number\">94</span>:     Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class=\"keyword\">this</span>.processQueueTable.entrySet().iterator();</div><div class=\"line\"> <span class=\"number\">95</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123; <span class=\"comment\">// TODO 待读：</span></div><div class=\"line\"> <span class=\"number\">96</span>:         Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</div><div class=\"line\"> <span class=\"number\">97</span>:         MessageQueue mq = next.getKey();</div><div class=\"line\"> <span class=\"number\">98</span>:         ProcessQueue pq = next.getValue();</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:         <span class=\"keyword\">if</span> (mq.getTopic().equals(topic)) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:             <span class=\"keyword\">if</span> (!mqSet.contains(mq)) &#123; <span class=\"comment\">// 不包含的队列</span></div><div class=\"line\"><span class=\"number\">102</span>:                 pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">103</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                     it.remove();</div><div class=\"line\"><span class=\"number\">105</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">107</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">108</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pq.isPullExpired()) &#123; <span class=\"comment\">// 队列拉取超时，进行清理</span></div><div class=\"line\"><span class=\"number\">109</span>:                 <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.consumeType()) &#123;</div><div class=\"line\"><span class=\"number\">110</span>:                     <span class=\"keyword\">case</span> CONSUME_ACTIVELY:</div><div class=\"line\"><span class=\"number\">111</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">112</span>:                     <span class=\"keyword\">case</span> CONSUME_PASSIVELY:</div><div class=\"line\"><span class=\"number\">113</span>:                         pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">114</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</div><div class=\"line\"><span class=\"number\">115</span>:                             it.remove();</div><div class=\"line\"><span class=\"number\">116</span>:                             changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                             log.error(<span class=\"string\">\"[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it\"</span>,</div><div class=\"line\"><span class=\"number\">118</span>:                                 consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">119</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">120</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">121</span>:                     <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">122</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">123</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">124</span>:             &#125;</div><div class=\"line\"><span class=\"number\">125</span>:         &#125;</div><div class=\"line\"><span class=\"number\">126</span>:     &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。</span></div><div class=\"line\"><span class=\"number\">129</span>:     List&lt;PullRequest&gt; pullRequestList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 拉消息请求数组</span></div><div class=\"line\"><span class=\"number\">130</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : mqSet) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.processQueueTable.containsKey(mq)) &#123;</div><div class=\"line\"><span class=\"number\">132</span>:             <span class=\"keyword\">if</span> (isOrder &amp;&amp; !<span class=\"keyword\">this</span>.lock(mq)) &#123;</div><div class=\"line\"><span class=\"number\">133</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">134</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">135</span>:             &#125;</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:             <span class=\"keyword\">this</span>.removeDirtyOffset(mq);</div><div class=\"line\"><span class=\"number\">138</span>:             ProcessQueue pq = <span class=\"keyword\">new</span> ProcessQueue();</div><div class=\"line\"><span class=\"number\">139</span>:             <span class=\"keyword\">long</span> nextOffset = <span class=\"keyword\">this</span>.computePullFromWhere(mq);</div><div class=\"line\"><span class=\"number\">140</span>:             <span class=\"keyword\">if</span> (nextOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">141</span>:                 ProcessQueue pre = <span class=\"keyword\">this</span>.processQueueTable.putIfAbsent(mq, pq);</div><div class=\"line\"><span class=\"number\">142</span>:                 <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">144</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">146</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest();</div><div class=\"line\"><span class=\"number\">147</span>:                     pullRequest.setConsumerGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">148</span>:                     pullRequest.setNextOffset(nextOffset);</div><div class=\"line\"><span class=\"number\">149</span>:                     pullRequest.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">150</span>:                     pullRequest.setProcessQueue(pq);</div><div class=\"line\"><span class=\"number\">151</span>:                     pullRequestList.add(pullRequest);</div><div class=\"line\"><span class=\"number\">152</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">153</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">154</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">155</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">156</span>:             &#125;</div><div class=\"line\"><span class=\"number\">157</span>:         &#125;</div><div class=\"line\"><span class=\"number\">158</span>:     &#125;</div><div class=\"line\"><span class=\"number\">159</span>: </div><div class=\"line\"><span class=\"number\">160</span>:     <span class=\"comment\">// 发起消息拉取请求</span></div><div class=\"line\"><span class=\"number\">161</span>:     <span class=\"keyword\">this</span>.dispatchPullRequest(pullRequestList);</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:     <span class=\"keyword\">return</span> changed;</div><div class=\"line\"><span class=\"number\">164</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#rebalanceByTopic(...)</code> 说明 ：分配 <code>Topic</code> 的消息队列。<ul>\n<li>第 3 至 19 行 ：广播模式( <code>BROADCASTING</code> ) 下，分配 <code>Topic</code> 对应的<strong>所有</strong>消息队列。   </li>\n<li>第 20 至 74 行 ：集群模式( <code>CLUSTERING</code> ) 下，分配 <code>Topic</code> 对应的<strong>部分</strong>消息队列。<ul>\n<li>第 21 至 40 行 ：获取 <code>Topic</code> 对应的消息队列和消费者们，并对其进行排序。因为各 <code>Consumer</code> 是在本地分配消息队列，排序后才能保证各 <code>Consumer</code> 顺序一致。</li>\n<li>第 42 至 61 行 ：根据 队列分配策略( <code>AllocateMessageQueueStrategy</code> ) 分配消息队列。详细解析见：<a href=\"#allocatemessagequeuestrategy\">AllocateMessageQueueStrategy</a>。</li>\n<li>第 63 至 72 行 ：更新 <code>Topic</code> 对应的消息队列。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>#updateProcessQueueTableInRebalance(...)</code> 说明 ：当分配队列时，更新 <code>Topic</code> 对应的消息队列，并返回是否有变更。<ul>\n<li>第 93 至 126 行 ：移除不存在于分配的消息队列( <code>mqSet</code> ) 的 消息处理队列( <code>processQueueTable</code> )。<ul>\n<li>第 103 行 ：移除不需要的消息队列。详细解析见：<a href=\"#rebalancepushimplremoveunnecessarymessagequeue\">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a>。</li>\n<li>第 108 至 120 行 ：队列拉取超时，即 <code>当前时间 - 最后一次拉取消息时间 &gt; 120s</code> ( 120s 可配置)，判定发生 <strong>BUG</strong>，过久未进行消息拉取，移除消息队列。移除后，下面<strong>#新增队列逻辑#</strong>可以重新加入新的该消息队列。</li>\n</ul>\n</li>\n<li>第 128 至 158 行 ：增加 分配的消息队列( <code>mqSet</code> ) 新增的消息队列。<ul>\n<li>第 132 至 135 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n<li>第 137 行 ：移除消息队列的消费进度。</li>\n<li>第 139 行 ：获取队列消费进度。详细解析见：<a href=\"#rebalancepushimplcomputepullfromwhere\">RebalancePushImpl#computePullFromWhere(…)</a>。</li>\n<li>第 140 至 156 行 ：<strong>添加新消费处理队列，添加消费拉取消息请求</strong>。</li>\n</ul>\n</li>\n<li>第 161 行 ：<strong>发起新增的消息队列消息拉取请求</strong>。详细解析见：<a href=\"#rebalancepushimpldispatchpullrequest\">RebalancePushImpl#dispatchPullRequest(…)</a>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RebalanceImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#RebalanceImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"RebalanceImpl#removeUnnecessaryMessageQueue(…)\"></a>RebalanceImpl#removeUnnecessaryMessageQueue(…)</h3><h4 id=\"RebalancePushImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#RebalancePushImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"RebalancePushImpl#removeUnnecessaryMessageQueue(…)\"></a>RebalancePushImpl#removeUnnecessaryMessageQueue(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 同步队列的消费进度，并移除之。</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// TODO 顺序消费</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.isConsumeOrderly()</div><div class=\"line\"> <span class=\"number\">7</span>:         &amp;&amp; MessageModel.CLUSTERING.equals(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (pq.getLockConsume().tryLock(<span class=\"number\">1000</span>, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.unlockDelay(mq, pq);</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                     pq.getLockConsume().unlock();</div><div class=\"line\"><span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">15</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 log.warn(<span class=\"string\">\"[WRONG]mq is consuming, so can not unlock it, &#123;&#125;. maybe hanged for a while, &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">17</span>:                     mq, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">18</span>:                     pq.getTryUnlockTimes());</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:                 pq.incTryUnlockTimes();</div><div class=\"line\"><span class=\"number\">21</span>:             &#125;</div><div class=\"line\"><span class=\"number\">22</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             log.error(<span class=\"string\">\"removeUnnecessaryMessageQueue Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">24</span>:         &#125;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">27</span>:     &#125;</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">29</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除不需要的消息队列相关的信息，并返回是否移除成功。</li>\n<li>第 2 至 4 行 ：<strong>同步</strong>队列的消费进度，并移除之。</li>\n<li>第 5 至 27 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n</ul>\n<h4 id=\"PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)\"></a><code>[PullConsumer]</code> RebalancePullImpl#removeUnnecessaryMessageQueue(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.defaultMQPullConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPullConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"><span class=\"number\">4</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除不需要的消息队列相关的信息，并返回移除成功。<strong>和<code>RebalancePushImpl#removeUnnecessaryMessageQueue(...)</code>基本一致。</strong></li>\n</ul>\n<h3 id=\"RebalancePushImpl-dispatchPullRequest-…\"><a href=\"#RebalancePushImpl-dispatchPullRequest-…\" class=\"headerlink\" title=\"RebalancePushImpl#dispatchPullRequest(…)\"></a>RebalancePushImpl#dispatchPullRequest(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPullRequest</span><span class=\"params\">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">for</span> (PullRequest pullRequest : pullRequestList) &#123;</div><div class=\"line\"><span class=\"number\">3</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">4</span>:         log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;\"</span>, consumerGroup, pullRequest);</div><div class=\"line\"><span class=\"number\">5</span>:     &#125;</div><div class=\"line\"><span class=\"number\">6</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发起消息拉取请求。<strong>该调用是<code>PushConsumer</code>不断不断不断拉取消息的起点</strong>。</li>\n</ul>\n<h4 id=\"DefaultMQPushConsumerImpl-executePullRequestImmediately-…\"><a href=\"#DefaultMQPushConsumerImpl-executePullRequestImmediately-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#executePullRequestImmediately(…)\"></a>DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestImmediately</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">3</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交拉取请求。提交后，<code>PullMessageService</code> <strong>异步执行</strong>，<strong>非阻塞</strong>。详细解析见：<a href=\"pullmessageservice\">PullMessageService</a>。</li>\n</ul>\n<h3 id=\"AllocateMessageQueueStrategy\"><a href=\"#AllocateMessageQueueStrategy\" class=\"headerlink\" title=\"AllocateMessageQueueStrategy\"></a>AllocateMessageQueueStrategy</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/01.png\" alt=\"AllocateMessageQueueStrategy类图\"></p>\n<h4 id=\"AllocateMessageQueueAveragely\"><a href=\"#AllocateMessageQueueAveragely\" class=\"headerlink\" title=\"AllocateMessageQueueAveragely\"></a>AllocateMessageQueueAveragely</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueAveragely</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 校验参数是否正确</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (currentCID == <span class=\"keyword\">null</span> || currentCID.length() &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"currentCID is empty\"</span>);</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (mqAll == <span class=\"keyword\">null</span> || mqAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"mqAll is null or mqAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (cidAll == <span class=\"keyword\">null</span> || cidAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"cidAll is null or cidAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         &#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (!cidAll.contains(currentCID)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             log.info(<span class=\"string\">\"[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">21</span>:                 consumerGroup,</div><div class=\"line\"><span class=\"number\">22</span>:                 currentCID,</div><div class=\"line\"><span class=\"number\">23</span>:                 cidAll);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"comment\">// 平均分配</span></div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID); <span class=\"comment\">// 第几个consumer。</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> mod = mqAll.size() % cidAll.size(); <span class=\"comment\">// 余数，即多少消息队列无法平均分配。</span></div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">int</span> averageSize =</div><div class=\"line\"><span class=\"number\">30</span>:             mqAll.size() &lt;= cidAll.size() ? <span class=\"number\">1</span> : (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</div><div class=\"line\"><span class=\"number\">31</span>:                 + <span class=\"number\">1</span> : mqAll.size() / cidAll.size());</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">int</span> startIndex = (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod; <span class=\"comment\">// 有余数的情况下，[0, mod) 平分余数，即每consumer多分配一个节点；第index开始，跳过前mod余数。</span></div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"keyword\">int</span> range = Math.min(averageSize, mqAll.size() - startIndex); <span class=\"comment\">// 分配队列数量。之所以要Math.min()的原因是，mqAll.size() &lt;= cidAll.size()，部分consumer分配不到消息队列。</span></div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; range; i++) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:             result.add(mqAll.get((startIndex + i) % mqAll.size()));</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"AVG\"</span>;</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>平均</strong>分配队列策略。</li>\n<li>第 7 至 25 行 ：参数校验。</li>\n<li>第 26 至 36 行 ：平均分配消息队列。<ul>\n<li>第 27 行 ：<code>index</code> ：当前 <code>Consumer</code> 在消费集群里是第几个。这里就是为什么需要对传入的 <code>cidAll</code> 参数必须进行排序的原因。如果不排序，<code>Consumer</code> 在本地计算出来的 <code>index</code> 无法一致，影响计算结果。</li>\n<li>第 28 行 ：<code>mod</code> ：余数，即多少消息队列无法平均分配。</li>\n<li>第 29 至 31 行 ：<code>averageSize</code> ：代码可以简化成 <code>(mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size())</code>。<ul>\n<li><code>[ 0, mod )</code> ：<code>mqAll.size() / cidAll.size() + 1</code>。前面 <code>mod</code> 个 <code>Consumer</code> 平分余数，多获得 1 个消息队列。</li>\n<li><code>[ mod, cidAll.size() )</code> ：<code>mqAll.size() / cidAll.size()</code>。</li>\n</ul>\n</li>\n<li>第 32 行 ：<code>startIndex</code> ：<code>Consumer</code> 分配消息队列开始位置。</li>\n<li>第 33 行 ：<code>range</code> ：分配队列数量。之所以要 <code>Math#min(...)</code> 的原因：当 <code>mqAll.size() &lt;= cidAll.size()</code> 时，最后几个 <code>Consumer</code> 分配不到消息队列。</li>\n<li>第 34 至 36 行 ：生成分配消息队列结果。</li>\n</ul>\n</li>\n<li>举个例子：</li>\n</ul>\n<p>固定消息队列长度为<strong>4</strong>。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Consumer <em> 2 </em>可以整除*</th>\n<th>Consumer <em> 3 </em>不可整除*</th>\n<th>Consumer <em> 5 </em>无法都分配*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消息队列[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n</tr>\n<tr>\n<td>消息队列[1]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[1]</td>\n</tr>\n<tr>\n<td>消息队列[2]</td>\n<td>Consumer[1]</td>\n<td>Consumer[1]</td>\n<td>Consumer[2]</td>\n</tr>\n<tr>\n<td>消息队列[3]</td>\n<td>Consumer[1]</td>\n<td>Consumer[2]</td>\n<td>Consumer[3]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"AllocateMessageQueueByMachineRoom\"><a href=\"#AllocateMessageQueueByMachineRoom\" class=\"headerlink\" title=\"AllocateMessageQueueByMachineRoom\"></a>AllocateMessageQueueByMachineRoom</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueByMachineRoom</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 消费者消费brokerName集合</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> Set&lt;String&gt; consumeridcs;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">9</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 参数校验</span></div><div class=\"line\"><span class=\"number\">11</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">int</span> currentIndex = cidAll.indexOf(currentCID);</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">if</span> (currentIndex &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 计算符合当前配置的消费者数组('consumeridcs')对应的消息队列</span></div><div class=\"line\"><span class=\"number\">17</span>:         List&lt;MessageQueue&gt; premqAll = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : mqAll) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             String[] temp = mq.getBrokerName().split(<span class=\"string\">\"@\"</span>);</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (temp.length == <span class=\"number\">2</span> &amp;&amp; consumeridcs.contains(temp[<span class=\"number\">0</span>])) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 premqAll.add(mq);</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// 平均分配</span></div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">int</span> mod = premqAll.size() / cidAll.size();</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">int</span> rem = premqAll.size() % cidAll.size();</div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">int</span> startIndex = mod * currentIndex;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> endIndex = startIndex + mod;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             result.add(mqAll.get(i));</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (rem &gt; currentIndex) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:             result.add(premqAll.get(currentIndex + mod * cidAll.size()));</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"MACHINE_ROOM\"</span>;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getConsumeridcs</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">return</span> consumeridcs;</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConsumeridcs</span><span class=\"params\">(Set&lt;String&gt; consumeridcs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.consumeridcs = consumeridcs;</div><div class=\"line\"><span class=\"number\">49</span>:     &#125;</div><div class=\"line\"><span class=\"number\">50</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>平均</strong>分配<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>\n<li>第 7 至 15 行 ：参数校验。</li>\n<li>第 16 至 23 行 ：计算<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>\n<li>第 25 至 34 行 ：平均分配消息队列。该<strong>平均分配</strong>方式和 <code>AllocateMessageQueueAveragely</code> 略有不同，其是将多余的结尾部分分配给前 <code>rem</code> 个 <code>Consumer</code>。</li>\n<li>疑问：<em>使用该分配策略时，<code>Consumer</code> 和 <code>Broker</code> 分配需要怎么配置</em>。😈等研究<strong>主从</strong>相关源码时，仔细考虑下。</li>\n</ul>\n<h4 id=\"AllocateMessageQueueAveragelyByCircle\"><a href=\"#AllocateMessageQueueAveragelyByCircle\" class=\"headerlink\" title=\"AllocateMessageQueueAveragelyByCircle\"></a>AllocateMessageQueueAveragelyByCircle</h4> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueAveragelyByCircle</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 校验参数是否正确</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (currentCID == <span class=\"keyword\">null</span> || currentCID.length() &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"currentCID is empty\"</span>);</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (mqAll == <span class=\"keyword\">null</span> || mqAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"mqAll is null or mqAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (cidAll == <span class=\"keyword\">null</span> || cidAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"cidAll is null or cidAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         &#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (!cidAll.contains(currentCID)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             log.info(<span class=\"string\">\"[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">21</span>:                 consumerGroup,</div><div class=\"line\"><span class=\"number\">22</span>:                 currentCID,</div><div class=\"line\"><span class=\"number\">23</span>:                 cidAll);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"comment\">// 环状分配</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID);</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = index; i &lt; mqAll.size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">if</span> (i % cidAll.size() == index) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 result.add(mqAll.get(i));</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"AVG_BY_CIRCLE\"</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：环状分配消息队列。</li>\n</ul>\n<h4 id=\"AllocateMessageQueueByConfig\"><a href=\"#AllocateMessageQueueByConfig\" class=\"headerlink\" title=\"AllocateMessageQueueByConfig\"></a>AllocateMessageQueueByConfig</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueByConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> List&lt;MessageQueue&gt; messageQueueList;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.messageQueueList;</div><div class=\"line\"> <span class=\"number\">8</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"CONFIG\"</span>;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">getMessageQueueList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">return</span> messageQueueList;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMessageQueueList</span><span class=\"params\">(List&lt;MessageQueue&gt; messageQueueList)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"keyword\">this</span>.messageQueueList = messageQueueList;</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：分配<strong>配置的</strong>消息队列。</li>\n<li>疑问 ：<em>该分配策略的使用场景。</em></li>\n</ul>\n<h1 id=\"5、PushConsumer-消费进度读取\"><a href=\"#5、PushConsumer-消费进度读取\" class=\"headerlink\" title=\"5、PushConsumer 消费进度读取\"></a>5、PushConsumer 消费进度读取</h1><h2 id=\"RebalancePushImpl-computePullFromWhere-…\"><a href=\"#RebalancePushImpl-computePullFromWhere-…\" class=\"headerlink\" title=\"RebalancePushImpl#computePullFromWhere(…)\"></a>RebalancePushImpl#computePullFromWhere(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">computePullFromWhere</span><span class=\"params\">(MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">long</span> result = -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> ConsumeFromWhere consumeFromWhere = <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> OffsetStore offsetStore = <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">switch</span> (consumeFromWhere) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_MIN_OFFSET: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_MAX_OFFSET: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"comment\">// First start,no offset</span></div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     result = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</div><div class=\"line\"><span class=\"number\">21</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>:         &#125;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">34</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 result = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">36</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_TIMESTAMP: &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">44</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">45</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</div><div class=\"line\"><span class=\"number\">49</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">51</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">52</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">54</span>:                         <span class=\"keyword\">long</span> timestamp = UtilAll.parseDate(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</div><div class=\"line\"><span class=\"number\">55</span>:                             UtilAll.YYYY_MMDD_HHMMSS).getTime();</div><div class=\"line\"><span class=\"number\">56</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</div><div class=\"line\"><span class=\"number\">57</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">59</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">61</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">62</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">63</span>:             &#125;</div><div class=\"line\"><span class=\"number\">64</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">65</span>:         &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: </div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">72</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：计算消息队列开始消费位置。</li>\n<li><code>PushConsumer</code> 读取消费进度有三种选项：<ul>\n<li><code>CONSUME_FROM_LAST_OFFSET</code> ：第 6 至 29 行 ：一个新的消费集群第一次启动从<strong>队列的最后位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n<li><code>CONSUME_FROM_FIRST_OFFSET</code> ：第 30 至 40 行 ：一个新的消费集群第一次启动从队列的<strong>最前位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n<li><code>CONSUME_FROM_TIMESTAMP</code> ：第 41 至 65 行 ：一个新的消费集群第一次启动从<strong>指定时间点</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PullConsumer-RebalancePullImpl-computePullFromWhere-…\"><a href=\"#PullConsumer-RebalancePullImpl-computePullFromWhere-…\" class=\"headerlink\" title=\"[PullConsumer] RebalancePullImpl#computePullFromWhere(…)\"></a><code>[PullConsumer]</code> RebalancePullImpl#computePullFromWhere(…)</h2><p>暂时跳过。😈</p>\n<h1 id=\"6、PushConsumer-拉取消息\"><a href=\"#6、PushConsumer-拉取消息\" class=\"headerlink\" title=\"6、PushConsumer 拉取消息\"></a>6、PushConsumer 拉取消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/05.png\" alt=\"DefaultMQPushConsumerImpl拉取消息\"></p>\n<h2 id=\"PullMessageService\"><a href=\"#PullMessageService\" class=\"headerlink\" title=\"PullMessageService\"></a>PullMessageService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullMessageService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 拉取消息请求队列</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingQueue&lt;PullRequest&gt; pullRequestQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  8:      * MQClient对象</div><div class=\"line\">  9:      */</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MQClientInstance mQClientFactory;</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 定时器。用于延迟提交拉取请求</div><div class=\"line\"> 13:      */</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ScheduledExecutorService scheduledExecutorService = Executors</div><div class=\"line\"> <span class=\"number\">15</span>:         .newSingleThreadScheduledExecutor(<span class=\"keyword\">new</span> ThreadFactory() &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, <span class=\"string\">\"PullMessageServiceScheduledThread\"</span>);</div><div class=\"line\"> <span class=\"number\">19</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">20</span>:         &#125;);</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PullMessageService</span><span class=\"params\">(MQClientInstance mQClientFactory)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">this</span>.mQClientFactory = mQClientFactory;</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">25</span>: </div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 27:      * 执行延迟拉取消息请求</div><div class=\"line\"> 28:      *</div><div class=\"line\"> 29:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 30:      * <span class=\"doctag\">@param</span> timeDelay 延迟时长</div><div class=\"line\"> 31:      */</div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestLater</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeDelay)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">36</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                 PullMessageService.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"> <span class=\"number\">38</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">39</span>:         &#125;, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\"> <span class=\"number\">40</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 43:      * 执行立即拉取消息请求</div><div class=\"line\"> 44:      *</div><div class=\"line\"> 45:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 46:      */</div><div class=\"line\"> <span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestImmediately</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">49</span>:             <span class=\"keyword\">this</span>.pullRequestQueue.put(pullRequest);</div><div class=\"line\"> <span class=\"number\">50</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:             log.error(<span class=\"string\">\"executePullRequestImmediately pullRequestQueue.put\"</span>, e);</div><div class=\"line\"> <span class=\"number\">52</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">53</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 56:      * 执行延迟任务</div><div class=\"line\"> 57:      *</div><div class=\"line\"> 58:      * <span class=\"doctag\">@param</span> r 任务</div><div class=\"line\"> 59:      * <span class=\"doctag\">@param</span> timeDelay 延迟时长</div><div class=\"line\"> 60:      */</div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeTaskLater</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable r, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeDelay)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(r, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\"> <span class=\"number\">63</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">64</span>: </div><div class=\"line\"> <span class=\"number\">65</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ScheduledExecutorService <span class=\"title\">getScheduledExecutorService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">return</span> scheduledExecutorService;</div><div class=\"line\"> <span class=\"number\">67</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 70:      * 拉取消息</div><div class=\"line\"> 71:      *</div><div class=\"line\"> 72:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 73:      */</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pullMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">final</span> MQConsumerInner consumer = <span class=\"keyword\">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">76</span>:         <span class=\"keyword\">if</span> (consumer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:             DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</div><div class=\"line\"> <span class=\"number\">78</span>:             impl.pullMessage(pullRequest);</div><div class=\"line\"> <span class=\"number\">79</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             log.warn(<span class=\"string\">\"No matched consumer for the PullRequest &#123;&#125;, drop it\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">83</span>: </div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">86</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:                 PullRequest pullRequest = <span class=\"keyword\">this</span>.pullRequestQueue.take();</div><div class=\"line\"> <span class=\"number\">91</span>:                 <span class=\"keyword\">if</span> (pullRequest != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:                     <span class=\"keyword\">this</span>.pullMessage(pullRequest);</div><div class=\"line\"> <span class=\"number\">93</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">94</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">95</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:                 log.error(<span class=\"string\">\"Pull Message Service Run Method exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">97</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">101</span>:     &#125;</div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">return</span> PullMessageService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">106</span>:     &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：拉取消息服务，不断不断不断从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>\n<li><code>#executePullRequestLater(...)</code> ：第 26 至 40 行 ： 提交<strong>延迟</strong>拉取消息请求。</li>\n<li><code>#executePullRequestImmediately(...)</code> ：第 42 至 53 行 ：提交<strong>立即</strong>拉取消息请求。</li>\n<li><code>#executeTaskLater(...)</code> ：第 55 至 63 行 ：提交<strong>延迟任务</strong>。</li>\n<li><code>#pullMessage(...)</code> ：第 69 至 82 行 ：执行拉取消息逻辑。详细解析见：<a href=\"#defaultmqpushconsumerimplpullmessage\">DefaultMQPushConsumerImpl#pullMessage(…)</a>。</li>\n<li><code>#run(...)</code> ：第 84 至 101 行 ：循环拉取消息请求队列( <code>pullRequestQueue</code> )，进行消息拉取。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumerImpl-pullMessage-…\"><a href=\"#DefaultMQPushConsumerImpl-pullMessage-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#pullMessage(…)\"></a>DefaultMQPushConsumerImpl#pullMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pullMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (processQueue.isDropped()) &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:         log.info(<span class=\"string\">\"the pull request[&#123;&#125;] is dropped.\"</span>, pullRequest.toString());</div><div class=\"line\">  <span class=\"number\">5</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"number\">6</span>:     &#125;</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">// 设置队列最后拉取消息时间</span></div><div class=\"line\">  <span class=\"number\">9</span>:     pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">// 判断consumer状态是否运行中。如果不是，则延迟拉取消息。</span></div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         log.warn(<span class=\"string\">\"pullMessage exception, consumer state not ok\"</span>, e);</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"comment\">// 判断是否暂停中。</span></div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isPause()) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:         log.warn(<span class=\"string\">\"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;\"</span>, <span class=\"keyword\">this</span>.defaultMQPushConsumer.getInstanceName(), <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">25</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">// 判断是否超过最大持有消息数量。默认最大值为1000。</span></div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">long</span> size = processQueue.getMsgCount().get();</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">if</span> (size &gt; <span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); <span class=\"comment\">// 提交延迟消息拉取请求。50ms。</span></div><div class=\"line\"> <span class=\"number\">31</span>:         <span class=\"keyword\">if</span> ((flowControlTimes1++ % <span class=\"number\">1000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:             log.warn(</div><div class=\"line\"> <span class=\"number\">33</span>:                 <span class=\"string\">\"the consumer message buffer is full, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, size=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">34</span>:                 processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);</div><div class=\"line\"> <span class=\"number\">35</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">37</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.consumeOrderly) &#123; <span class=\"comment\">// 判断消息跨度是否过大。</span></div><div class=\"line\"> <span class=\"number\">40</span>:         <span class=\"keyword\">if</span> (processQueue.getMaxSpan() &gt; <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:             <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); <span class=\"comment\">// 提交延迟消息拉取请求。50ms。</span></div><div class=\"line\"> <span class=\"number\">42</span>:             <span class=\"keyword\">if</span> ((flowControlTimes2++ % <span class=\"number\">1000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                 log.warn(</div><div class=\"line\"> <span class=\"number\">44</span>:                     <span class=\"string\">\"the queue's messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">45</span>:                     processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</div><div class=\"line\"> <span class=\"number\">46</span>:                     pullRequest, flowControlTimes2);</div><div class=\"line\"> <span class=\"number\">47</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">48</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">49</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">50</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// TODO 顺序消费</span></div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (processQueue.isLocked()) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">if</span> (!pullRequest.isLockedFirst()) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset = <span class=\"keyword\">this</span>.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">54</span>:                 <span class=\"keyword\">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</div><div class=\"line\"> <span class=\"number\">55</span>:                 log.info(<span class=\"string\">\"the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">56</span>:                     pullRequest, offset, brokerBusy);</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">if</span> (brokerBusy) &#123;</div><div class=\"line\"> <span class=\"number\">58</span>:                     log.info(<span class=\"string\">\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">59</span>:                         pullRequest, offset);</div><div class=\"line\"> <span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">61</span>: </div><div class=\"line\"> <span class=\"number\">62</span>:                 pullRequest.setLockedFirst(<span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">63</span>:                 pullRequest.setNextOffset(offset);</div><div class=\"line\"> <span class=\"number\">64</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">65</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">67</span>:             log.info(<span class=\"string\">\"pull message later because not locked in broker, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">70</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"comment\">// 获取Topic 对应的订阅信息。若不存在，则延迟拉取消息</span></div><div class=\"line\"> <span class=\"number\">73</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData = <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">76</span>:         log.warn(<span class=\"string\">\"find the consumer's subscription failed, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">77</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:     PullCallback pullCallback = <span class=\"keyword\">new</span> PullCallback() &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(PullResult pullResult)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">85</span>:             <span class=\"keyword\">if</span> (pullResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">86</span>:                 pullResult = DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</div><div class=\"line\"> <span class=\"number\">87</span>:                     subscriptionData);</div><div class=\"line\"> <span class=\"number\">88</span>: </div><div class=\"line\"> <span class=\"number\">89</span>:                 <span class=\"keyword\">switch</span> (pullResult.getPullStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:                     <span class=\"keyword\">case</span> FOUND:</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">long</span> prevRequestOffset = pullRequest.getNextOffset();</div><div class=\"line\"> <span class=\"number\">93</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:                         <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">96</span>:                         <span class=\"keyword\">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</div><div class=\"line\"> <span class=\"number\">97</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</div><div class=\"line\"> <span class=\"number\">98</span>:                             pullRequest.getMessageQueue().getTopic(), pullRT);</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:                         <span class=\"keyword\">long</span> firstMsgOffset = Long.MAX_VALUE;</div><div class=\"line\"><span class=\"number\">101</span>:                         <span class=\"keyword\">if</span> (pullResult.getMsgFoundList() == <span class=\"keyword\">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">102</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">103</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                             firstMsgOffset = pullResult.getMsgFoundList().get(<span class=\"number\">0</span>).getQueueOffset();</div><div class=\"line\"><span class=\"number\">105</span>: </div><div class=\"line\"><span class=\"number\">106</span>:                             <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">107</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">108</span>:                                 pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                             <span class=\"comment\">// 提交拉取到的消息到消息处理队列</span></div><div class=\"line\"><span class=\"number\">111</span>:                             <span class=\"keyword\">boolean</span> dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</div><div class=\"line\"><span class=\"number\">112</span>: </div><div class=\"line\"><span class=\"number\">113</span>:                             <span class=\"comment\">// 提交消费请求</span></div><div class=\"line\"><span class=\"number\">114</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.consumeMessageService.submitConsumeRequest(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">115</span>:                                 pullResult.getMsgFoundList(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">116</span>:                                 processQueue, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">117</span>:                                 pullRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">118</span>:                                 dispathToConsume);</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:                             <span class=\"comment\">// 提交下次拉取消息请求</span></div><div class=\"line\"><span class=\"number\">121</span>:                             <span class=\"keyword\">if</span> (DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:                                 DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestLater(pullRequest,</div><div class=\"line\"><span class=\"number\">123</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullInterval());</div><div class=\"line\"><span class=\"number\">124</span>:                             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">125</span>:                                 DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">126</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">127</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">128</span>: </div><div class=\"line\"><span class=\"number\">129</span>:                         <span class=\"comment\">// 下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为BUG，输出log</span></div><div class=\"line\"><span class=\"number\">130</span>:                         <span class=\"keyword\">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">131</span>:                             || firstMsgOffset &lt; prevRequestOffset) &#123;</div><div class=\"line\"><span class=\"number\">132</span>:                             log.warn(</div><div class=\"line\"><span class=\"number\">133</span>:                                 <span class=\"string\">\"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">134</span>:                                 pullResult.getNextBeginOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">135</span>:                                 firstMsgOffset, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">136</span>:                                 prevRequestOffset);</div><div class=\"line\"><span class=\"number\">137</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">138</span>: </div><div class=\"line\"><span class=\"number\">139</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">140</span>:                     <span class=\"keyword\">case</span> NO_NEW_MSG:</div><div class=\"line\"><span class=\"number\">141</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">142</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">143</span>: </div><div class=\"line\"><span class=\"number\">144</span>:                         <span class=\"comment\">// 持久化消费进度</span></div><div class=\"line\"><span class=\"number\">145</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.correctTagsOffset(pullRequest);</div><div class=\"line\"><span class=\"number\">146</span>: </div><div class=\"line\"><span class=\"number\">147</span>:                         <span class=\"comment\">// 立即提交拉取消息请求</span></div><div class=\"line\"><span class=\"number\">148</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">149</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:                     <span class=\"keyword\">case</span> NO_MATCHED_MSG:</div><div class=\"line\"><span class=\"number\">151</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">152</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:                         <span class=\"comment\">// 持久化消费进度</span></div><div class=\"line\"><span class=\"number\">155</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.correctTagsOffset(pullRequest);</div><div class=\"line\"><span class=\"number\">156</span>: </div><div class=\"line\"><span class=\"number\">157</span>:                         <span class=\"comment\">// 提交立即拉取消息请求</span></div><div class=\"line\"><span class=\"number\">158</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">159</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">160</span>:                     <span class=\"keyword\">case</span> OFFSET_ILLEGAL:</div><div class=\"line\"><span class=\"number\">161</span>:                         log.warn(<span class=\"string\">\"the pull request offset illegal, &#123;&#125; &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">162</span>:                             pullRequest.toString(), pullResult.toString());</div><div class=\"line\"><span class=\"number\">163</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">164</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:                         <span class=\"comment\">// 设置消息处理队列为dropped</span></div><div class=\"line\"><span class=\"number\">167</span>:                         pullRequest.getProcessQueue().setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">168</span>: </div><div class=\"line\"><span class=\"number\">169</span>:                         <span class=\"comment\">// 提交延迟任务，进行消费处理队列移除。不立即移除的原因：可能有地方正在使用，避免受到影响。</span></div><div class=\"line\"><span class=\"number\">170</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executeTaskLater(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">171</span>: </div><div class=\"line\"><span class=\"number\">172</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">173</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">174</span>:                                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:                                     <span class=\"comment\">// 更新消费进度，同步消费进度到Broker</span></div><div class=\"line\"><span class=\"number\">176</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</div><div class=\"line\"><span class=\"number\">177</span>:                                         pullRequest.getNextOffset(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">178</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">179</span>: </div><div class=\"line\"><span class=\"number\">180</span>:                                     <span class=\"comment\">// 移除消费处理队列</span></div><div class=\"line\"><span class=\"number\">181</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">182</span>: </div><div class=\"line\"><span class=\"number\">183</span>:                                     log.warn(<span class=\"string\">\"fix the pull request offset, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"><span class=\"number\">184</span>:                                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">185</span>:                                     log.error(<span class=\"string\">\"executeTaskLater Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">186</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">187</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">188</span>:                         &#125;, <span class=\"number\">10000</span>);</div><div class=\"line\"><span class=\"number\">189</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">190</span>:                     <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">191</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">192</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">193</span>:             &#125;</div><div class=\"line\"><span class=\"number\">194</span>:         &#125;</div><div class=\"line\"><span class=\"number\">195</span>: </div><div class=\"line\"><span class=\"number\">196</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">197</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">198</span>:             <span class=\"keyword\">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">199</span>:                 log.warn(<span class=\"string\">\"execute the pull request exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">200</span>:             &#125;</div><div class=\"line\"><span class=\"number\">201</span>: </div><div class=\"line\"><span class=\"number\">202</span>:             <span class=\"comment\">// 提交延迟拉取消息请求</span></div><div class=\"line\"><span class=\"number\">203</span>:             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"><span class=\"number\">204</span>:         &#125;</div><div class=\"line\"><span class=\"number\">205</span>:     &#125;;</div><div class=\"line\"><span class=\"number\">206</span>: </div><div class=\"line\"><span class=\"number\">207</span>:     <span class=\"comment\">// 集群消息模型下，计算提交的消费进度。</span></div><div class=\"line\"><span class=\"number\">208</span>:     <span class=\"keyword\">boolean</span> commitOffsetEnable = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">209</span>:     <span class=\"keyword\">long</span> commitOffsetValue = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">210</span>:     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING == <span class=\"keyword\">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</div><div class=\"line\"><span class=\"number\">211</span>:         commitOffsetValue = <span class=\"keyword\">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</div><div class=\"line\"><span class=\"number\">212</span>:         <span class=\"keyword\">if</span> (commitOffsetValue &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">213</span>:             commitOffsetEnable = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">214</span>:         &#125;</div><div class=\"line\"><span class=\"number\">215</span>:     &#125;</div><div class=\"line\"><span class=\"number\">216</span>: </div><div class=\"line\"><span class=\"number\">217</span>:     <span class=\"comment\">// 计算请求的 订阅表达式 和 是否进行filtersrv过滤消息</span></div><div class=\"line\"><span class=\"number\">218</span>:     String subExpression = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">219</span>:     <span class=\"keyword\">boolean</span> classFilter = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">220</span>:     SubscriptionData sd = <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</div><div class=\"line\"><span class=\"number\">221</span>:     <span class=\"keyword\">if</span> (sd != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">222</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</div><div class=\"line\"><span class=\"number\">223</span>:             subExpression = sd.getSubString();</div><div class=\"line\"><span class=\"number\">224</span>:         &#125;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>:         classFilter = sd.isClassFilterMode();</div><div class=\"line\"><span class=\"number\">227</span>:     &#125;</div><div class=\"line\"><span class=\"number\">228</span>: </div><div class=\"line\"><span class=\"number\">229</span>:     <span class=\"comment\">// 计算拉取消息系统标识</span></div><div class=\"line\"><span class=\"number\">230</span>:     <span class=\"keyword\">int</span> sysFlag = PullSysFlag.buildSysFlag(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">231</span>:         commitOffsetEnable, <span class=\"comment\">// commitOffset</span></div><div class=\"line\"><span class=\"number\">232</span>:         <span class=\"keyword\">true</span>, <span class=\"comment\">// suspend</span></div><div class=\"line\"><span class=\"number\">233</span>:         subExpression != <span class=\"keyword\">null</span>, <span class=\"comment\">// subscription</span></div><div class=\"line\"><span class=\"number\">234</span>:         classFilter <span class=\"comment\">// class filter</span></div><div class=\"line\"><span class=\"number\">235</span>:     );</div><div class=\"line\"><span class=\"number\">236</span>: </div><div class=\"line\"><span class=\"number\">237</span>:     <span class=\"comment\">// 执行拉取。如果拉取请求发生异常时，提交延迟拉取消息请求。</span></div><div class=\"line\"><span class=\"number\">238</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">239</span>:         <span class=\"keyword\">this</span>.pullAPIWrapper.pullKernelImpl(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">240</span>:             pullRequest.getMessageQueue(), <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"number\">241</span>:             subExpression, <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"number\">242</span>:             subscriptionData.getSubVersion(), <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"number\">243</span>:             pullRequest.getNextOffset(), <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">244</span>:             <span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"number\">245</span>:             sysFlag, <span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"number\">246</span>:             commitOffsetValue, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">247</span>:             BROKER_SUSPEND_MAX_TIME_MILLIS, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">248</span>:             CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">249</span>:             CommunicationMode.ASYNC, <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">250</span>:             pullCallback<span class=\"comment\">// 11</span></div><div class=\"line\"><span class=\"number\">251</span>:         );</div><div class=\"line\"><span class=\"number\">252</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">253</span>:         log.error(<span class=\"string\">\"pullKernelImpl exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">254</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"><span class=\"number\">255</span>:     &#125;</div><div class=\"line\"><span class=\"number\">256</span>: &#125;</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">correctTagsOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">259</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0L</span> == pullRequest.getProcessQueue().getMsgCount().get()) &#123;</div><div class=\"line\"><span class=\"number\">260</span>:         <span class=\"keyword\">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">261</span>:     &#125;</div><div class=\"line\"><span class=\"number\">262</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#pullMessage(...)</code> 说明 ：拉取消息。<ul>\n<li>第 3 至 6 行 ：消息处理队列已经终止，不进行消息拉取。</li>\n<li>第 9 行 ：设置消息处理队列最后拉取消息时间。</li>\n<li>第 11 至 18 行 ：<code>Consumer</code> 未处于运行中状态，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 20 至 25 行 ： <code>Consumer</code> 处于暂停中，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 27 至 37 行 ：消息处理队列持有消息超过最大允许值（默认：1000条），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 39 至 49 行 ：<code>Consumer</code> 为<strong>并发消费</strong> 并且 消息队列持有消息跨度过大（消息跨度 = 持有消息最后一条和第一条的消息位置差，默认：2000），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 50 至 70 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n<li>第 72 至 78 行 ：<code>Topic</code> 对应的订阅信息不存在，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 222 至 224 行 ：判断请求是否使用 <code>Consumer</code> <strong>本地</strong>的订阅信息( <code>SubscriptionData</code> )，而不使用 <code>Broker</code> 里的订阅信息。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…\">PullMessageProcessor#processRequest(…) 第 64 至 110 行代码</a>。</li>\n<li>第 226 行 ：是否开启过滤类过滤模式。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/filtersrv/\">《RocketMQ 源码分析 —— Filtersrv》</a>。</li>\n<li>第 229 至 235 行 ：计算拉取消息请求系统标识。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageRequestHeader\">PullMessageRequestHeader.sysFlag</a>。</li>\n<li>第 237 至 255 行 ：<ul>\n<li>执行消息拉取<strong>异步</strong>请求。详细解析见：<a href=\"#pullapiwrapperpullkernelimpl\">PullAPIWrapper#pullKernelImpl(…)</a>。</li>\n<li>当发起请求产生异常时，提交<strong>延迟</strong>拉取消息请求。对应 <code>Broker</code> 处理拉取消息逻辑见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…\">PullMessageProcessor#processRequest(…)</a>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>PullCallback</code> ：拉取消息回调：<ul>\n<li>第 86 行 ：处理拉取结果。详细逻辑见：<a href=\"#pullapiwrapperprocesspullresult\">PullAPIWrapper#processPullResult(…)</a>。</li>\n<li>第 89 至 192 行 ：处理拉取状态结果：<ul>\n<li>第 90 至 139 行 ：拉取到消息( <code>FOUND</code> ) ：<ul>\n<li>第 91 至 93 行 ：设置下次拉取消息队列位置。</li>\n<li>第 95 至 97 行 ：统计。</li>\n<li>第 101 至 102 行 ：拉取到消息的消息列表为空，提交<strong>立即</strong>拉取消息请求。为什么会存在拉取到消息，但是消息结果未空呢？原因见：<a href=\"#pullapiwrapperprocesspullresult\">PullAPIWrapper#processPullResult(…)</a>。</li>\n<li>第 106 至 108 行 ：统计。</li>\n<li>第 111 行 ：提交拉取到的消息到消息处理队列。详细解析见：<a href=\"#processqueueputmessage\">ProcessQueue#putMessage(…)</a>。</li>\n<li>第 113 至 118 行 ：提交消费请求到 <code>ConsumeMessageService</code>。详细解析见：<a href=\"#consumemessageconcurrentlyservice\">ConsumeMessageConcurrentlyService</a>。</li>\n<li>第 120 至 126 行 ：根据拉取频率( <code>pullInterval</code> )，提交<strong>立即或者延迟</strong>拉取消息请求。默认拉取频率为 0ms ，提交<strong>立即</strong>拉取消息请求。</li>\n<li>第 129 至 137 行 ：下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为<strong>BUG</strong>，输出警告日志。<ul>\n<li>第 140 至 149 行 ：没有新消息( <code>NO_NEW_MSG</code> ) ：</li>\n</ul>\n</li>\n<li>第 142 行 ： 设置下次拉取消息队列位置。</li>\n<li>第 145 行 ：更正消费进度。详细解析见：<code>#correctTagsOffset(...)</code>。</li>\n<li>第 148 行 ：提交<strong>立即</strong>拉取消息请求。<ul>\n<li>第 150 至 159 行 ：有新消息但是不匹配( <code>NO_MATCHED_MSG</code> )。逻辑同 <code>NO_NEW_MSG</code> 。</li>\n<li>第 160 至 189 行 ：拉取请求的消息队列位置不合法 (<code>OFFSET_ILLEGAL</code>)。</li>\n</ul>\n</li>\n<li>第 164 行 ：设置下次拉取消息队列位置。</li>\n<li>第 167 行 ：设置消息处理队列为 <code>dropped</code>。</li>\n<li>第 169 至 188 行 ：提交延迟任务，进行队列移除。<ul>\n<li>第 175 至 178 行 ：更新消费进度，同步消费进度到 <code>Broker</code>。</li>\n<li>第 181 行 ：移除消费处理队列。<ul>\n<li>疑问：为什么不立即移除？？？ <ul>\n<li>第 196 至 204 行 ：发生异常，提交<strong>延迟</strong>拉取消息请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>#correctTagsOffset(...)</code> ：更正消费进度。<ul>\n<li>第 258 至 261 行 ： 当消费处理队列持有消息数量为 <strong>0</strong> 时，更新消费进度为拉取请求的拉取消息队列位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"PullAPIWrapper-pullKernelImpl-…\"><a href=\"#PullAPIWrapper-pullKernelImpl-…\" class=\"headerlink\" title=\"PullAPIWrapper#pullKernelImpl(…)\"></a>PullAPIWrapper#pullKernelImpl(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 拉取消息核心方法</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> subExpression 订阅表达式</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> subVersion 订阅版本号</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> offset 拉取队列开始位置</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> maxNums 拉取消息数量</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> sysFlag 拉取请求系统标识</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> commitOffset 提交消费进度</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> brokerSuspendMaxTimeMillis broker挂起请求最大时间</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> timeoutMillis 请求broker超时时长</div><div class=\"line\">13:  * <span class=\"doctag\">@param</span> communicationMode 通讯模式</div><div class=\"line\">14:  * <span class=\"doctag\">@param</span> pullCallback 拉取回调</div><div class=\"line\">15:  * <span class=\"doctag\">@return</span> 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。</div><div class=\"line\">16:  * <span class=\"doctag\">@throws</span> MQClientException 当寻找不到 broker 时，或发生其他client异常</div><div class=\"line\">17:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">18:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。</div><div class=\"line\">19:  * <span class=\"doctag\">@throws</span> InterruptedException 当发生中断异常时</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">protected</span> PullResult <span class=\"title\">pullKernelImpl</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">final</span> MessageQueue mq,</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">final</span> String subExpression,</div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> subVersion,</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset,</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxNums,</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sysFlag,</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> commitOffset,</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerSuspendMaxTimeMillis,</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode,</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback</div><div class=\"line\"><span class=\"number\">33</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 获取Broker信息</span></div><div class=\"line\"><span class=\"number\">35</span>:     FindBrokerResult findBrokerResult =</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">this</span>.recalculatePullFromWhichNode(mq), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findBrokerResult) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</div><div class=\"line\"><span class=\"number\">40</span>:         findBrokerResult =</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"keyword\">this</span>.recalculatePullFromWhichNode(mq), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 请求拉取消息</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:         <span class=\"keyword\">int</span> sysFlagInner = sysFlag;</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:         <span class=\"keyword\">if</span> (findBrokerResult.isSlave()) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:             sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:         PullMessageRequestHeader requestHeader = <span class=\"keyword\">new</span> PullMessageRequestHeader();</div><div class=\"line\"><span class=\"number\">54</span>:         requestHeader.setConsumerGroup(<span class=\"keyword\">this</span>.consumerGroup);</div><div class=\"line\"><span class=\"number\">55</span>:         requestHeader.setTopic(mq.getTopic());</div><div class=\"line\"><span class=\"number\">56</span>:         requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\"><span class=\"number\">57</span>:         requestHeader.setQueueOffset(offset);</div><div class=\"line\"><span class=\"number\">58</span>:         requestHeader.setMaxMsgNums(maxNums);</div><div class=\"line\"><span class=\"number\">59</span>:         requestHeader.setSysFlag(sysFlagInner);</div><div class=\"line\"><span class=\"number\">60</span>:         requestHeader.setCommitOffset(commitOffset);</div><div class=\"line\"><span class=\"number\">61</span>:         requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</div><div class=\"line\"><span class=\"number\">62</span>:         requestHeader.setSubscription(subExpression);</div><div class=\"line\"><span class=\"number\">63</span>:         requestHeader.setSubVersion(subVersion);</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:         String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\"><span class=\"number\">66</span>:         <span class=\"keyword\">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123; <span class=\"comment\">// TODO filtersrv</span></div><div class=\"line\"><span class=\"number\">67</span>:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\"><span class=\"number\">68</span>:         &#125;</div><div class=\"line\"><span class=\"number\">69</span>: </div><div class=\"line\"><span class=\"number\">70</span>:         PullResult pullResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(</div><div class=\"line\"><span class=\"number\">71</span>:             brokerAddr,</div><div class=\"line\"><span class=\"number\">72</span>:             requestHeader,</div><div class=\"line\"><span class=\"number\">73</span>:             timeoutMillis,</div><div class=\"line\"><span class=\"number\">74</span>:             communicationMode,</div><div class=\"line\"><span class=\"number\">75</span>:             pullCallback);</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:         <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">78</span>:     &#125;</div><div class=\"line\"><span class=\"number\">79</span>: </div><div class=\"line\"><span class=\"number\">80</span>:     <span class=\"comment\">// Broker信息不存在，则抛出异常</span></div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">82</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：拉取消息核心方法。<strong>该方法参数较多，可以看下代码注释上每个参数的说明</strong>😈。</li>\n<li>第 34 至 43 行 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。<ul>\n<li><a href=\"#pullapiwrapperrecalculatepullfromwhichnode\">#recalculatePullFromWhichNode(…)</a></li>\n<li><a href=\"#mqclientinstancefindbrokeraddressinsubscribe\">#MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>\n</ul>\n</li>\n<li>第 45 至 78 行 ：<strong>请求拉取消息</strong>。</li>\n<li>第 81 行 ：当 <code>Broker</code> 信息不存在，则抛出异常。</li>\n</ul>\n<h4 id=\"PullAPIWrapper-recalculatePullFromWhichNode-…\"><a href=\"#PullAPIWrapper-recalculatePullFromWhichNode-…\" class=\"headerlink\" title=\"PullAPIWrapper#recalculatePullFromWhichNode(…)\"></a>PullAPIWrapper#recalculatePullFromWhichNode(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消息队列 与 拉取Broker 的映射</div><div class=\"line\"> 3:  * 当拉取消息时，会通过该映射获取拉取请求对应的Broker</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">private</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong<span class=\"comment\">/* brokerId */</span>&gt; pullFromWhichNodeTable =</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">new</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;(<span class=\"number\">32</span>);</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 8:  * 是否使用默认Broker</div><div class=\"line\"> 9:  */</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> connectBrokerByUser = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"comment\">/**</span></div><div class=\"line\">12:  * 默认Broker编号</div><div class=\"line\">13:  */</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> defaultBrokerId = MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>: <span class=\"comment\">/**</span></div><div class=\"line\">17:  * 计算消息队列拉取消息对应的Broker编号</div><div class=\"line\">18:  *</div><div class=\"line\">19:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\">20:  * <span class=\"doctag\">@return</span> Broker编号</div><div class=\"line\">21:  */</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">recalculatePullFromWhichNode</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"comment\">// 若开启默认Broker开关，则返回默认Broker编号</span></div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isConnectBrokerByUser()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultBrokerId;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"comment\">// 若消息队列映射拉取Broker存在，则返回映射Broker编号</span></div><div class=\"line\"><span class=\"number\">29</span>:     AtomicLong suggest = <span class=\"keyword\">this</span>.pullFromWhichNodeTable.get(mq);</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (suggest != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">return</span> suggest.get();</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 返回Broker主节点编号</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">return</span> MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：计算消息队列拉取消息对应的 <code>Broker</code> 编号。</li>\n</ul>\n<h4 id=\"MQClientInstance-findBrokerAddressInSubscribe-…\"><a href=\"#MQClientInstance-findBrokerAddressInSubscribe-…\" class=\"headerlink\" title=\"MQClientInstance#findBrokerAddressInSubscribe(…)\"></a>MQClientInstance#findBrokerAddressInSubscribe(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * Broker名字 和 Broker地址相关 Map</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* Broker Name */</span>, HashMap&lt;Long<span class=\"comment\">/* brokerId */</span>, String<span class=\"comment\">/* address */</span>&gt;&gt; brokerAddrTable =</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 8:  * 获得Broker信息</div><div class=\"line\"> 9:  *</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> brokerName broker名字</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> brokerId broker编号</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> onlyThisBroker 是否必须是该broker</div><div class=\"line\">13:  * <span class=\"doctag\">@return</span> Broker信息</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> FindBrokerResult <span class=\"title\">findBrokerAddressInSubscribe</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">final</span> String brokerName, //</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerId, //</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> onlyThisBroker//</div><div class=\"line\"><span class=\"number\">19</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:     String brokerAddr = <span class=\"keyword\">null</span>; <span class=\"comment\">// broker地址</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">boolean</span> slave = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否为从节点</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">boolean</span> found = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否找到</span></div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"comment\">// 获得Broker信息</span></div><div class=\"line\"><span class=\"number\">25</span>:     HashMap&lt;Long<span class=\"comment\">/* brokerId */</span>, String<span class=\"comment\">/* address */</span>&gt; map = <span class=\"keyword\">this</span>.brokerAddrTable.get(brokerName);</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span> &amp;&amp; !map.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:         brokerAddr = map.get(brokerId);</div><div class=\"line\"><span class=\"number\">28</span>:         slave = brokerId != MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">29</span>:         found = brokerAddr != <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"comment\">// 如果不强制获得，选择一个Broker</span></div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (!found &amp;&amp; !onlyThisBroker) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:             Entry&lt;Long, String&gt; entry = map.entrySet().iterator().next();</div><div class=\"line\"><span class=\"number\">34</span>:             brokerAddr = entry.getValue();</div><div class=\"line\"><span class=\"number\">35</span>:             slave = entry.getKey() != MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">36</span>:             found = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"comment\">// 找到broker，则返回信息</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">if</span> (found) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FindBrokerResult(brokerAddr, slave);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 找不到，则返回空</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。</li>\n</ul>\n<h3 id=\"PullAPIWrapper-processPullResult-…\"><a href=\"#PullAPIWrapper-processPullResult-…\" class=\"headerlink\" title=\"PullAPIWrapper#processPullResult(…)\"></a>PullAPIWrapper#processPullResult(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 处理拉取结果</div><div class=\"line\"> 3:  * 1. 更新消息队列拉取消息Broker编号的映射</div><div class=\"line\"> 4:  * 2. 解析消息，并根据订阅信息消息tagCode匹配合适消息</div><div class=\"line\"> 5:  *</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> pullResult 拉取结果</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> subscriptionData 订阅信息</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 拉取结果</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> PullResult <span class=\"title\">processPullResult</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> PullResult pullResult,</span></span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:     PullResultExt pullResultExt = (PullResultExt) pullResult;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 更新消息队列拉取消息Broker编号的映射</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">this</span>.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"comment\">// 解析消息，并根据订阅信息消息tagCode匹配合适消息</span></div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (PullStatus.FOUND == pullResult.getPullStatus()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 解析消息</span></div><div class=\"line\"><span class=\"number\">21</span>:         ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());</div><div class=\"line\"><span class=\"number\">22</span>:         List&lt;MessageExt&gt; msgList = MessageDecoder.decodes(byteBuffer);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// 根据订阅信息消息tagCode匹配合适消息</span></div><div class=\"line\"><span class=\"number\">25</span>:         List&lt;MessageExt&gt; msgListFilterAgain = msgList;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">if</span> (!subscriptionData.getTagsSet().isEmpty() &amp;&amp; !subscriptionData.isClassFilterMode()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:             msgListFilterAgain = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(msgList.size());</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgList) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"keyword\">if</span> (msg.getTags() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (subscriptionData.getTagsSet().contains(msg.getTags())) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         msgListFilterAgain.add(msg);</div><div class=\"line\"><span class=\"number\">32</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">33</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             &#125;</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasHook()) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:             FilterMessageContext filterMessageContext = <span class=\"keyword\">new</span> FilterMessageContext();</div><div class=\"line\"><span class=\"number\">40</span>:             filterMessageContext.setUnitMode(unitMode);</div><div class=\"line\"><span class=\"number\">41</span>:             filterMessageContext.setMsgList(msgListFilterAgain);</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"keyword\">this</span>.executeHook(filterMessageContext);</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:         <span class=\"comment\">// 设置消息队列当前最小/最大位置到消息拓展字段</span></div><div class=\"line\"><span class=\"number\">46</span>:         <span class=\"keyword\">for</span> (MessageExt msg : msgListFilterAgain) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,</div><div class=\"line\"><span class=\"number\">48</span>:                 Long.toString(pullResult.getMinOffset()));</div><div class=\"line\"><span class=\"number\">49</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,</div><div class=\"line\"><span class=\"number\">50</span>:                 Long.toString(pullResult.getMaxOffset()));</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:         <span class=\"comment\">// 设置消息列表</span></div><div class=\"line\"><span class=\"number\">54</span>:         pullResultExt.setMsgFoundList(msgListFilterAgain);</div><div class=\"line\"><span class=\"number\">55</span>:     &#125;</div><div class=\"line\"><span class=\"number\">56</span>: </div><div class=\"line\"><span class=\"number\">57</span>:     <span class=\"comment\">// 清空消息二进制数组</span></div><div class=\"line\"><span class=\"number\">58</span>:     pullResultExt.setMessageBinary(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">61</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：处理拉取结果。<ul>\n<li>更新消息队列拉取消息 <code>Broker</code> 编号的映射。</li>\n<li>解析消息，并根据订阅信息消息 <code>tagCode</code>匹配合适消息。</li>\n</ul>\n</li>\n<li>第 16 行 ：更新消息队列拉取消息 <code>Broker</code> 编号的映射。下次拉取消息时，如果未设置默认拉取的 <code>Broker</code> 编号，会使用更新后的 <code>Broker</code> 编号。</li>\n<li>第 18 至 55 行 ：解析消息，并根据订阅信息消息 <code>tagCode</code> 匹配合适消息。<ul>\n<li>第 20 至 22 行 ：解析消息。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message基础》</a> 。</li>\n<li>第 24 至 35 行 ：根据订阅信息<code>tagCode</code> 匹配消息。</li>\n<li>第 37 至 43 行 ：<code>Hook</code>。</li>\n<li>第 45 至 51 行 ：设置消息队列当前最小/最大位置到消息拓展字段。</li>\n<li>第 54 行 ：设置消息队列。</li>\n</ul>\n</li>\n<li>第 58 行 ：清空消息二进制数组。</li>\n</ul>\n<h3 id=\"ProcessQueue-putMessage-…\"><a href=\"#ProcessQueue-putMessage-…\" class=\"headerlink\" title=\"ProcessQueue#putMessage(…)\"></a>ProcessQueue#putMessage(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>:  <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消息映射读写锁</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock lockTreeMap = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 6:  * 消息映射</div><div class=\"line\"> 7:  * key：消息队列位置</div><div class=\"line\"> 8:  */</div><div class=\"line\"> <span class=\"number\">9</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"comment\">/**</span></div><div class=\"line\">11:  * 消息数</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong msgCount = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"comment\">/**</span></div><div class=\"line\">15:  * 添加消息最大队列位置</div><div class=\"line\">16:  */</div><div class=\"line\"><span class=\"number\">17</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> queueOffsetMax = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">18</span>: <span class=\"comment\">/**</span></div><div class=\"line\">19:  * 是否正在消费</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> consuming = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"comment\">/**</span></div><div class=\"line\">23:  * Broker累计消息数量</div><div class=\"line\">24:  * 计算公式 = queueMaxOffset - 新添加消息数组[n - 1].queueOffset</div><div class=\"line\">25:  * Acc = Accumulation</div><div class=\"line\">26:  * cnt = （猜测）对比度</div><div class=\"line\">27:  */</div><div class=\"line\"><span class=\"number\">28</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> msgAccCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">/**</span></div><div class=\"line\">31:  * 添加消息，并返回是否提交给消费者</div><div class=\"line\">32:  * 返回true，当有新消息添加成功时，</div><div class=\"line\">33:  *</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">35:  * <span class=\"doctag\">@return</span> 是否提交给消费者</div><div class=\"line\">36:  */</div><div class=\"line\"><span class=\"number\">37</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">boolean</span> dispatchToConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">int</span> validMsgCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">44</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:                 MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == old) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                     validMsgCnt++;</div><div class=\"line\"><span class=\"number\">48</span>:                     <span class=\"keyword\">this</span>.queueOffsetMax = msg.getQueueOffset();</div><div class=\"line\"><span class=\"number\">49</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">50</span>:             &#125;</div><div class=\"line\"><span class=\"number\">51</span>:             msgCount.addAndGet(validMsgCnt);</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:             <span class=\"comment\">// 计算是否正在消费</span></div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; !<span class=\"keyword\">this</span>.consuming) &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                 dispatchToConsume = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">this</span>.consuming = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">57</span>:             &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:             <span class=\"comment\">// Broker累计消息数量</span></div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">if</span> (!msgs.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">61</span>:                 MessageExt messageExt = msgs.get(msgs.size() - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">62</span>:                 String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);</div><div class=\"line\"><span class=\"number\">63</span>:                 <span class=\"keyword\">if</span> (property != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">64</span>:                     <span class=\"keyword\">long</span> accTotal = Long.parseLong(property) - messageExt.getQueueOffset();</div><div class=\"line\"><span class=\"number\">65</span>:                     <span class=\"keyword\">if</span> (accTotal &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">66</span>:                         <span class=\"keyword\">this</span>.msgAccCnt = accTotal;</div><div class=\"line\"><span class=\"number\">67</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">68</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">69</span>:             &#125;</div><div class=\"line\"><span class=\"number\">70</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">71</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">72</span>:         &#125;</div><div class=\"line\"><span class=\"number\">73</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:         log.error(<span class=\"string\">\"putMessage exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> dispatchToConsume;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果用最简单粗暴的方式描述 <code>PullConsumer</code> 拉取消息的过程，那就是如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (不满足拉取消息) &#123;</div><div class=\"line\">        Thread.sleep(间隔);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    主动拉取消息();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"6、PushConsumer-消费消息\"><a href=\"#6、PushConsumer-消费消息\" class=\"headerlink\" title=\"6、PushConsumer 消费消息\"></a>6、PushConsumer 消费消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/06.png\" alt=\"DefaultMQPushConsumerImpl消费消息\"></p>\n<h2 id=\"ConsumeMessageConcurrentlyService-提交消费请求\"><a href=\"#ConsumeMessageConcurrentlyService-提交消费请求\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService 提交消费请求\"></a>ConsumeMessageConcurrentlyService 提交消费请求</h2><h3 id=\"ConsumeMessageConcurrentlyService-submitConsumeRequest-…\"><a href=\"#ConsumeMessageConcurrentlyService-submitConsumeRequest-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#submitConsumeRequest(…)\"></a>ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消费线程池队列</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 6:  * 消费线程池</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadPoolExecutor consumeExecutor;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequest</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue, //</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">final</span> MessageQueue messageQueue, //</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dispatchToConsume) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> consumeBatchSize = <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">if</span> (msgs.size() &lt;= consumeBatchSize) &#123; <span class=\"comment\">// 提交消息小于批量消息数，直接提交消费请求</span></div><div class=\"line\"><span class=\"number\">17</span>:         ConsumeRequest consumeRequest = <span class=\"keyword\">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest);</div><div class=\"line\"><span class=\"number\">20</span>:         &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 提交消息大于批量消息数，进行分拆成多个消费请求</span></div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> total = <span class=\"number\">0</span>; total &lt; msgs.size(); ) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// 计算当前拆分请求包含的消息</span></div><div class=\"line\"><span class=\"number\">26</span>:             List&lt;MessageExt&gt; msgThis = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(consumeBatchSize);</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                 <span class=\"keyword\">if</span> (total &lt; msgs.size()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                     msgThis.add(msgs.get(total));</div><div class=\"line\"><span class=\"number\">30</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:             <span class=\"comment\">// 提交拆分消费请求</span></div><div class=\"line\"><span class=\"number\">36</span>:             ConsumeRequest consumeRequest = <span class=\"keyword\">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest);</div><div class=\"line\"><span class=\"number\">39</span>:             &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"comment\">// 如果被拒绝，则将当前拆分消息+剩余消息提交延迟消费请求。</span></div><div class=\"line\"><span class=\"number\">41</span>:                 <span class=\"keyword\">for</span> (; total &lt; msgs.size(); total++) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:                     msgThis.add(msgs.get(total));</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class=\"line\"><span class=\"number\">45</span>:             &#125;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125;</div><div class=\"line\"><span class=\"number\">47</span>:     &#125;</div><div class=\"line\"><span class=\"number\">48</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交<strong>立即</strong>消费请求。</li>\n<li>第 16 至 22 行 ：提交消息小于等于批量消费数，直接提交消费请求。</li>\n<li>第 23 至 47 行 ：当提交消息大于批量消费数，进行分拆成多个请求。<ul>\n<li>第 25 至 33 行 ：计算当前拆分请求包含的消息。</li>\n<li>第 35 至 38 行 ：提交拆分消费请求。</li>\n<li>第 39 至 44 行 ：提交请求被拒绝，则将当前拆分消息 + 剩余消息提交延迟消费请求，结束拆分循环。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConsumeMessageConcurrentlyService-submitConsumeRequestLater\"><a href=\"#ConsumeMessageConcurrentlyService-submitConsumeRequestLater\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#submitConsumeRequestLater\"></a>ConsumeMessageConcurrentlyService#submitConsumeRequestLater</h3> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 提交延迟消费请求</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msgs 消息列表</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> processQueue 消息处理队列</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> messageQueue 消息队列</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequestLater</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue, //</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> MessageQueue messageQueue//</div><div class=\"line\"><span class=\"number\">12</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">18</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.submitConsumeRequest(msgs, processQueue, messageQueue, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;, <span class=\"number\">5000</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">21</span>: &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>: <span class=\"comment\">/**</span></div><div class=\"line\">24:  * 提交延迟消费请求</div><div class=\"line\">25:  * <span class=\"doctag\">@param</span> consumeRequest 消费请求</div><div class=\"line\">26:  */</div><div class=\"line\"><span class=\"number\">27</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequestLater</span><span class=\"params\">(<span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</span></span></div><div class=\"line\"><span class=\"number\">28</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">34</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest); <span class=\"comment\">// TODO BUG ?</span></div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;, <span class=\"number\">5000</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交延迟消费请求。</li>\n<li>第 34 行 ：直接调用 <code>ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);</code>。如果消息数超过批量消费上限，会不会是<strong>BUG</strong>。</li>\n</ul>\n<h2 id=\"ConsumeRequest\"><a href=\"#ConsumeRequest\" class=\"headerlink\" title=\"ConsumeRequest\"></a>ConsumeRequest</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeRequest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 消费消息列表</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  8:      * 消息处理队列</div><div class=\"line\">  9:      */</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ProcessQueue processQueue;</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 消息队列</div><div class=\"line\"> 13:      */</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageQueue messageQueue;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumeRequest</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.msgs = msgs;</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">this</span>.processQueue = processQueue;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">this</span>.messageQueue = messageQueue;</div><div class=\"line\"> <span class=\"number\">20</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"comment\">// 废弃队列不进行消费</span></div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:             log.info(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;\"</span>, ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:         MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.messageListener; <span class=\"comment\">// 监听器</span></div><div class=\"line\"> <span class=\"number\">31</span>:         ConsumeConcurrentlyContext context = <span class=\"keyword\">new</span> ConsumeConcurrentlyContext(messageQueue); <span class=\"comment\">// 消费Context</span></div><div class=\"line\"> <span class=\"number\">32</span>:         ConsumeConcurrentlyStatus status = <span class=\"keyword\">null</span>; <span class=\"comment\">// 消费结果状态</span></div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"> <span class=\"number\">35</span>:         ConsumeMessageContext consumeMessageContext = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:             consumeMessageContext = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"> <span class=\"number\">38</span>:             consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">39</span>:             consumeMessageContext.setProps(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;());</div><div class=\"line\"> <span class=\"number\">40</span>:             consumeMessageContext.setMq(messageQueue);</div><div class=\"line\"> <span class=\"number\">41</span>:             consumeMessageContext.setMsgList(msgs);</div><div class=\"line\"> <span class=\"number\">42</span>:             consumeMessageContext.setSuccess(<span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</div><div class=\"line\"> <span class=\"number\">44</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">boolean</span> hasException = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; <span class=\"comment\">// 消费返回结果类型</span></div><div class=\"line\"> <span class=\"number\">49</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:             <span class=\"comment\">// 当消息为重试消息，设置Topic为原始Topic</span></div><div class=\"line\"> <span class=\"number\">51</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.resetRetryTopic(msgs);</div><div class=\"line\"> <span class=\"number\">52</span>: </div><div class=\"line\"> <span class=\"number\">53</span>:             <span class=\"comment\">// 设置开始消费时间</span></div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (msgs != <span class=\"keyword\">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 进行消费</span></div><div class=\"line\"> <span class=\"number\">61</span>:             status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</div><div class=\"line\"> <span class=\"number\">62</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:             log.warn(<span class=\"string\">\"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">64</span>:                 RemotingHelper.exceptionSimpleDesc(e), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">65</span>:                 ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"> <span class=\"number\">66</span>:                 msgs,</div><div class=\"line\"> <span class=\"number\">67</span>:                 messageQueue);</div><div class=\"line\"> <span class=\"number\">68</span>:             hasException = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:         <span class=\"comment\">// 解析消费返回结果类型</span></div><div class=\"line\"> <span class=\"number\">72</span>:         <span class=\"keyword\">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == status) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">if</span> (hasException) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:                 returnType = ConsumeReturnType.EXCEPTION;</div><div class=\"line\"> <span class=\"number\">76</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:                 returnType = ConsumeReturnType.RETURNNULL;</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             returnType = ConsumeReturnType.TIME_OUT;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>:             returnType = ConsumeReturnType.FAILED;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:             returnType = ConsumeReturnType.SUCCESS;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>: </div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</div><div class=\"line\"> <span class=\"number\">90</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">91</span>: </div><div class=\"line\"> <span class=\"number\">92</span>:         <span class=\"comment\">// 消费结果状态为空时，则设置为稍后重新消费</span></div><div class=\"line\"> <span class=\"number\">93</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == status) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:             log.warn(<span class=\"string\">\"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">95</span>:                 ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"> <span class=\"number\">96</span>:                 msgs,</div><div class=\"line\"> <span class=\"number\">97</span>:                 messageQueue);</div><div class=\"line\"> <span class=\"number\">98</span>:             status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</div><div class=\"line\"> <span class=\"number\">99</span>:         &#125;</div><div class=\"line\"><span class=\"number\">100</span>: </div><div class=\"line\"><span class=\"number\">101</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"><span class=\"number\">102</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"><span class=\"number\">103</span>:             consumeMessageContext.setStatus(status.toString());</div><div class=\"line\"><span class=\"number\">104</span>:             consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</div><div class=\"line\"><span class=\"number\">105</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</div><div class=\"line\"><span class=\"number\">106</span>:         &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>:         <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">109</span>:         ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.getConsumerStatsManager()</div><div class=\"line\"><span class=\"number\">110</span>:             .incConsumeRT(ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"comment\">// 处理消费结果</span></div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"keyword\">if</span> (!processQueue.isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.processConsumeResult(status, context, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">115</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">116</span>:             log.warn(<span class=\"string\">\"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;\"</span>, messageQueue, msgs);</div><div class=\"line\"><span class=\"number\">117</span>:         &#125;</div><div class=\"line\"><span class=\"number\">118</span>:     &#125;</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消费请求。提交请求执行消费。</li>\n<li>第 24 至 28 行 ：废弃处理队列不进行消费。</li>\n<li>第 34 至 44 行 ：Hook。</li>\n<li>第 51 行 ：当消息为重试消息，设置 <code>Topic</code>为原始 <code>Topic</code>。例如：原始 <code>Topic</code> 为 <code>TopicTest</code>，重试时 <code>Topic</code> 为 <code>%RETRY%please_rename_unique_group_name_4</code>，经过该方法，<code>Topic</code> 设置回 <code>TopicTest</code>。</li>\n<li>第 53 至 58 行 ：设置开始消费时间。</li>\n<li>第 61 行 ：<strong>进行消费</strong>。</li>\n<li>第 71 至 85 行 ：解析消费返回结果类型</li>\n<li>第 87 至 90 行 ：<code>Hook</code>。</li>\n<li>第 92 至 99 行 ：消费结果状态未空时，则设置消费结果状态为稍后消费。</li>\n<li>第 101 至 106 行 ：<code>Hook</code>。</li>\n<li>第 108 至 110 行 ：统计。</li>\n<li>第 112 至 117 行 ：处理消费结果。<strong>如果消费处理队列被移除，恰好消息被消费，则可能导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性</strong>。详细解析见：<a href=\"#consumemessageconcurrentlyserviceprocessconsumeresult\">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a>。</li>\n</ul>\n<h2 id=\"ConsumeMessageConcurrentlyService-processConsumeResult-…\"><a href=\"#ConsumeMessageConcurrentlyService-processConsumeResult-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#processConsumeResult(…)\"></a>ConsumeMessageConcurrentlyService#processConsumeResult(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processConsumeResult</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> ConsumeConcurrentlyStatus status, //</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> ConsumeConcurrentlyContext context, //</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</div><div class=\"line\"> <span class=\"number\">5</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">int</span> ackIndex = context.getAckIndex();</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// 消息为空，直接返回</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (consumeRequest.getMsgs().isEmpty())</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">// 计算从consumeRequest.msgs[0]到consumeRequest.msgs[ackIndex]的消息消费成功</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">case</span> CONSUME_SUCCESS:</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 ackIndex = consumeRequest.getMsgs().size() - <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">17</span>:             &#125;</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"comment\">// 统计成功/失败数量</span></div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> ok = ackIndex + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">int</span> failed = consumeRequest.getMsgs().size() - ok;</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">case</span> RECONSUME_LATER:</div><div class=\"line\"><span class=\"number\">25</span>:             ackIndex = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"comment\">// 统计成功/失败数量</span></div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</div><div class=\"line\"><span class=\"number\">28</span>:                 consumeRequest.getMsgs().size());</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 处理消费失败的消息</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">case</span> BROADCASTING: <span class=\"comment\">// 广播模式，无论是否消费失败，不发回消息到Broker，只打印Log</span></div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = ackIndex + <span class=\"number\">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 MessageExt msg = consumeRequest.getMsgs().get(i);</div><div class=\"line\"><span class=\"number\">39</span>:                 log.warn(<span class=\"string\">\"BROADCASTING, the message consume failed, drop it, &#123;&#125;\"</span>, msg.toString());</div><div class=\"line\"><span class=\"number\">40</span>:             &#125;</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">case</span> CLUSTERING:</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"comment\">// 发回消息失败到Broker。</span></div><div class=\"line\"><span class=\"number\">44</span>:             List&lt;MessageExt&gt; msgBackFailed = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(consumeRequest.getMsgs().size());</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = ackIndex + <span class=\"number\">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:                 MessageExt msg = consumeRequest.getMsgs().get(i);</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.sendMessageBack(msg, context);</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">if</span> (!result) &#123;</div><div class=\"line\"><span class=\"number\">49</span>:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">50</span>:                     msgBackFailed.add(msg);</div><div class=\"line\"><span class=\"number\">51</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">52</span>:             &#125;</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"comment\">// 发回Broker失败的消息，直接提交延迟重新消费</span></div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"keyword\">if</span> (!msgBackFailed.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:                 consumeRequest.getMsgs().removeAll(msgBackFailed);</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">62</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"comment\">// 移除消费成功消息，并更新最新消费进度</span></div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"keyword\">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"keyword\">if</span> (offset &gt;= <span class=\"number\">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">68</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：处理消费结果。</li>\n<li>第 8 至 10 行 ：消费请求消息未空时，直接返回。</li>\n<li>第 12 至 32 行 ：计算 <code>ackIndex</code> 值。<code>consumeRequest.msgs[0 - ackIndex]</code>为消费成功，需要进行 <code>ack</code> 确认。<ul>\n<li>第 14 至 23 行 ：<code>CONSUME_SUCCESS</code> ：<code>ackIndex = context.getAckIndex()</code>。</li>\n<li>第 24 至 29 行 ：<code>RECONSUME_LATER</code> ：<code>ackIndex = -1</code>。</li>\n</ul>\n</li>\n<li>第34 至 63 行 ：处理消费失败的消息。<ul>\n<li>第 36 至 41 行 ：<code>BROADCASTING</code> ：广播模式，无论是否消费失败，不发回消息到 <code>Broker</code>，只打印日志。</li>\n<li>第 42 至 60 行 ：<code>CLUSTERING</code> ：集群模式，消费失败的消息发回到 <code>Broker</code>。<ul>\n<li>第 43 至 52 行 ：发回消费失败的消息到 <code>Broker</code>。详细解析见：<a href=\"#defaultmqpushconsumerimplsendmessageback\">DefaultMQPushConsumerImpl#sendMessageBack(…)</a>。</li>\n<li>第 54 至 59 行 ：发回 <code>Broker</code> 失败的消息，直接提交延迟重新消费。</li>\n<li><strong>如果发回 <code>Broker</code> 成功，结果因为例如网络异常，导致 <code>Consumer</code>以为发回失败，判定消费发回失败，会导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第 65 至 69 行 ：移除<strong>【消费成功】</strong>和<strong>【消费失败但发回<code>Broker</code>成功】</strong>的消息，并更新最新消费进度。<ul>\n<li>为什么会有<strong>【消费失败但发回<code>Broker</code>成功】</strong>的消息？见<strong>第 56 行</strong>。</li>\n<li><a href=\"#processqueueremovemessage\">ProcessQueue#removeMessage(…)</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ProcessQueue-removeMessage-…\"><a href=\"#ProcessQueue-removeMessage-…\" class=\"headerlink\" title=\"ProcessQueue#removeMessage(…)\"></a>ProcessQueue#removeMessage(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 移除消息，并返回第一条消息队列位置</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> 消息队列位置</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">removeMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">long</span> result = -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">this</span>.lastConsumeTimestamp = now;</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 result = <span class=\"keyword\">this</span>.queueOffsetMax + <span class=\"number\">1</span>; <span class=\"comment\">// 这里+1的原因是：如果msgTreeMap为空时，下一条获得的消息位置为queueOffsetMax+1</span></div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 移除消息</span></div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">int</span> removedCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         removedCnt--;</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:                 msgCount.addAndGet(removedCnt);</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:                 <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                     result = msgTreeMap.firstKey();</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:         log.error(<span class=\"string\">\"removeMessage exception\"</span>, t);</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">39</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ConsumeMessageConcurrentlyService-cleanExpireMsg-…\"><a href=\"#ConsumeMessageConcurrentlyService-cleanExpireMsg-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#cleanExpireMsg(…)\"></a>ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.cleanExpireMsgExecutors.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:             cleanExpireMsg();</div><div class=\"line\"> <span class=\"number\">7</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;, <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeTimeout(), <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</div><div class=\"line\"><span class=\"number\">10</span>: &#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"comment\">/**</span></div><div class=\"line\">13:  * 清理过期消息</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanExpireMsg</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:     Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it =</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         Map.Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</div><div class=\"line\"><span class=\"number\">20</span>:         ProcessQueue pq = next.getValue();</div><div class=\"line\"><span class=\"number\">21</span>:         pq.cleanExpiredMsg(<span class=\"keyword\">this</span>.defaultMQPushConsumer);</div><div class=\"line\"><span class=\"number\">22</span>:     &#125;</div><div class=\"line\"><span class=\"number\">23</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：定时清理过期消息，默认周期：15min。</li>\n</ul>\n<h3 id=\"ProcessQueue-cleanExpiredMsg-…\"><a href=\"#ProcessQueue-cleanExpiredMsg-…\" class=\"headerlink\" title=\"ProcessQueue#cleanExpiredMsg(…)\"></a>ProcessQueue#cleanExpiredMsg(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanExpiredMsg</span><span class=\"params\">(DefaultMQPushConsumer pushConsumer)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 顺序消费时，直接返回</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 循环移除消息</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">int</span> loop = msgTreeMap.size() &lt; <span class=\"number\">16</span> ? msgTreeMap.size() : <span class=\"number\">16</span>; <span class=\"comment\">// 每次循环最多移除16条</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; loop; i++) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 获取第一条消息。判断是否超时，若不超时，则结束循环</span></div><div class=\"line\"><span class=\"number\">11</span>:         MessageExt msg = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.lockTreeMap.readLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     msg = msgTreeMap.firstEntry().getValue();</div><div class=\"line\"><span class=\"number\">17</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">19</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">20</span>:             &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">this</span>.lockTreeMap.readLock().unlock();</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             log.error(<span class=\"string\">\"getExpiredMsg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"comment\">// 发回超时消息</span></div><div class=\"line\"><span class=\"number\">29</span>:             pushConsumer.sendMessageBack(msg, <span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"number\">30</span>:             log.info(<span class=\"string\">\"send expire msg back. topic=&#123;&#125;, msgId=&#123;&#125;, storeHost=&#123;&#125;, queueId=&#123;&#125;, queueOffset=&#123;&#125;\"</span>, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"comment\">// 判断此时消息是否依然是第一条，若是，则进行移除</span></div><div class=\"line\"><span class=\"number\">33</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">35</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey()) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                             msgTreeMap.remove(msgTreeMap.firstKey());</div><div class=\"line\"><span class=\"number\">39</span>:                         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                             log.error(<span class=\"string\">\"send expired msg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">41</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">42</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">44</span>:                     <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">45</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">46</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                 log.error(<span class=\"string\">\"getExpiredMsg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">48</span>:             &#125;</div><div class=\"line\"><span class=\"number\">49</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:             log.error(<span class=\"string\">\"send expired msg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除过期消息。</li>\n<li>第 2 至 5 行 ：顺序消费时，直接返回。</li>\n<li>第 7 至 9 行 ：循环移除消息。默认最大循环次数：16次。</li>\n<li>第 10 至 25 行 ：获取第一条消息。判断是否超时，若不超时，则结束循环。</li>\n<li>第 29 行 ：<strong>发回超时消息到<code>Broker</code></strong>。</li>\n<li>第 32 至 48 行 ：判断此时消息是否依然是第一条，若是，则进行移除。</li>\n</ul>\n<h1 id=\"7、PushConsumer-发回消费失败消息\"><a href=\"#7、PushConsumer-发回消费失败消息\" class=\"headerlink\" title=\"7、PushConsumer 发回消费失败消息\"></a>7、PushConsumer 发回消费失败消息</h1><h2 id=\"DefaultMQPushConsumerImpl-sendMessageBack-…\"><a href=\"#DefaultMQPushConsumerImpl-sendMessageBack-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#sendMessageBack(…)\"></a>DefaultMQPushConsumerImpl#sendMessageBack(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageBack</span><span class=\"params\">(MessageExt msg, <span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">final</span> String brokerName)</span></span></div><div class=\"line\"> 2:     <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"comment\">// Consumer发回消息</span></div><div class=\"line\"> <span class=\"number\">5</span>:         String brokerAddr = (<span class=\"keyword\">null</span> != brokerName) ? <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</div><div class=\"line\"> <span class=\"number\">6</span>:             : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class=\"number\">5000</span>, getMaxReconsumeTimes());</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// TODO 疑问：什么情况下会发生异常</span></div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 异常时，使用Client内置Producer发回消息</span></div><div class=\"line\"><span class=\"number\">11</span>:         log.error(<span class=\"string\">\"sendMessageBack Exception, \"</span> + <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:         Message newMsg = <span class=\"keyword\">new</span> Message(MixAll.getRetryTopic(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:         String originMsgId = MessageAccessor.getOriginMessageId(msg);</div><div class=\"line\"><span class=\"number\">16</span>:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         newMsg.setFlag(msg.getFlag());</div><div class=\"line\"><span class=\"number\">19</span>:         MessageAccessor.setProperties(newMsg, msg.getProperties());</div><div class=\"line\"><span class=\"number\">20</span>:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">21</span>:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class=\"number\">1</span>));</div><div class=\"line\"><span class=\"number\">22</span>:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">23</span>:         newMsg.setDelayTimeLevel(<span class=\"number\">3</span> + msg.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">24</span>: </div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发回消息。</li>\n<li>第 4 至 8 行 ：<code>Consumer</code> 发回消息。详细解析见：<a href=\"#mqclientapiimplconsumersendmessageback\">MQClientAPIImpl#consumerSendMessageBack(…)</a>。</li>\n<li>第 10 至 25 行 ：发生异常时，<code>Consumer</code> 内置默认 <code>Producer</code> 发送消息。<ul>\n<li>😈疑问：什么样的情况下会发生异常呢？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MQClientAPIImpl-consumerSendMessageBack-…\"><a href=\"#MQClientAPIImpl-consumerSendMessageBack-…\" class=\"headerlink\" title=\"MQClientAPIImpl#consumerSendMessageBack(…)\"></a>MQClientAPIImpl#consumerSendMessageBack(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * Consumer发回消息</div><div class=\"line\"> 3:  * <span class=\"doctag\">@param</span> addr Broker地址</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> consumerGroup 消费分组</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> timeoutMillis 超时</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> maxConsumeRetryTimes 消费最大重试次数</div><div class=\"line\"> 9:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">10:  * <span class=\"doctag\">@throws</span> MQBrokerException 当Broker发生异常时</div><div class=\"line\">11:  * <span class=\"doctag\">@throws</span> InterruptedException 当线程中断时</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">consumerSendMessageBack</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> String addr,</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">final</span> MessageExt msg,</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">final</span> String consumerGroup,</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel,</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConsumeRetryTimes</div><div class=\"line\"><span class=\"number\">20</span>: ) <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">21</span>:     ConsumerSendMsgBackRequestHeader requestHeader = <span class=\"keyword\">new</span> ConsumerSendMsgBackRequestHeader();</div><div class=\"line\"><span class=\"number\">22</span>:     RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:     requestHeader.setGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">25</span>:     requestHeader.setOriginTopic(msg.getTopic());</div><div class=\"line\"><span class=\"number\">26</span>:     requestHeader.setOffset(msg.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">27</span>:     requestHeader.setDelayLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">28</span>:     requestHeader.setOriginMsgId(msg.getMsgId());</div><div class=\"line\"><span class=\"number\">29</span>:     requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     RemotingCommand response = <span class=\"keyword\">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class=\"keyword\">this</span>.clientConfig.isVipChannelEnabled(), addr),</div><div class=\"line\"><span class=\"number\">32</span>:         request, timeoutMillis);</div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">assert</span> response != <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">case</span> ResponseCode.SUCCESS: &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQBrokerException(response.getCode(), response.getRemark());</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"8、Consumer-消费进度\"><a href=\"#8、Consumer-消费进度\" class=\"headerlink\" title=\"8、Consumer 消费进度\"></a>8、Consumer 消费进度</h1><h2 id=\"OffsetStore\"><a href=\"#OffsetStore\" class=\"headerlink\" title=\"OffsetStore\"></a>OffsetStore</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/07.png\" alt=\"OffsetStore类图.png\"></p>\n<ul>\n<li><code>RemoteBrokerOffsetStore</code> ：<code>Consumer</code> <strong>集群模式</strong> 下，使用远程 <code>Broker</code> 消费进度。</li>\n<li><code>LocalFileOffsetStore</code> ：<code>Consumer</code> <strong>广播模式</strong>下，使用本地 <code>文件</code> 消费进度。</li>\n</ul>\n<h3 id=\"OffsetStore-load-…\"><a href=\"#OffsetStore-load-…\" class=\"headerlink\" title=\"OffsetStore#load(…)\"></a>OffsetStore#load(…)</h3><h4 id=\"LocalFileOffsetStore-load-…\"><a href=\"#LocalFileOffsetStore-load-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#load(…)\"></a>LocalFileOffsetStore#load(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 从本地硬盘读取消费进度</span></div><div class=\"line\"> <span class=\"number\">4</span>:     OffsetSerializeWrapper offsetSerializeWrapper = <span class=\"keyword\">this</span>.readLocalOffset();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (offsetSerializeWrapper != <span class=\"keyword\">null</span> &amp;&amp; offsetSerializeWrapper.getOffsetTable() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"comment\">// 打印每个消息队列的消费进度</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : offsetSerializeWrapper.getOffsetTable().keySet()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);</div><div class=\"line\"><span class=\"number\">11</span>:             log.info(<span class=\"string\">\"load consumer's offset, &#123;&#125; &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">12</span>:                 <span class=\"keyword\">this</span>.groupName,</div><div class=\"line\"><span class=\"number\">13</span>:                 mq,</div><div class=\"line\"><span class=\"number\">14</span>:                 offset.get());</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:     &#125;</div><div class=\"line\"><span class=\"number\">17</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：从本地文件加载消费进度到内存。</li>\n</ul>\n<h5 id=\"OffsetSerializeWrapper\"><a href=\"#OffsetSerializeWrapper\" class=\"headerlink\" title=\"OffsetSerializeWrapper\"></a>OffsetSerializeWrapper</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OffsetSerializeWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">RemotingSerializable</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable =</div><div class=\"line\"> <span class=\"number\">3</span>:             <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; <span class=\"title\">getOffsetTable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">return</span> offsetTable;</div><div class=\"line\"> <span class=\"number\">7</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOffsetTable</span><span class=\"params\">(ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">this</span>.offsetTable = offsetTable;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：本地 <code>Offset</code> 存储序列化。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ cat /Users/yunai/.rocketmq_offsets/192.168.17.0@DEFAULT/please_rename_unique_group_name_1/offsets.json</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"offsetTable\"</span>:&#123;&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:3,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:2,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1471,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:1,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:0,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"RemoteBrokerOffsetStore-load-…\"><a href=\"#RemoteBrokerOffsetStore-load-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#load(…)\"></a>RemoteBrokerOffsetStore#load(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">3</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：不进行加载，实际读取消费进度时，从 <code>Broker</code> 获取。</li>\n</ul>\n<h3 id=\"OffsetStore-readOffset-…\"><a href=\"#OffsetStore-readOffset-…\" class=\"headerlink\" title=\"OffsetStore#readOffset(…)\"></a>OffsetStore#readOffset(…)</h3><p>读取消费进度类型：</p>\n<ul>\n<li><code>READ_FROM_MEMORY</code> ：从内存读取。</li>\n<li><code>READ_FROM_STORE</code> ：从存储( <code>Broker</code> 或 <code>文件</code> )读取。</li>\n<li><code>MEMORY_FIRST_THEN_STORE</code> ：优先从内存读取，读取不到，从存储读取。</li>\n</ul>\n<h4 id=\"LocalFileOffsetStore-readOffset-…\"><a href=\"#LocalFileOffsetStore-readOffset-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#readOffset(…)\"></a>LocalFileOffsetStore#readOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">readOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ReadOffsetType type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">case</span> MEMORY_FIRST_THEN_STORE:</div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"keyword\">case</span> READ_FROM_MEMORY: &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 AtomicLong offset = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">10</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> READ_FROM_STORE: &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 OffsetSerializeWrapper offsetSerializeWrapper;</div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     offsetSerializeWrapper = <span class=\"keyword\">this</span>.readLocalOffset();</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">if</span> (offsetSerializeWrapper != <span class=\"keyword\">null</span> &amp;&amp; offsetSerializeWrapper.getOffsetTable() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                     AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                         <span class=\"keyword\">this</span>.updateOffset(mq, offset.get(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">25</span>:                         <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">26</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">28</span>:             &#125;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：从 <code>文件</code> 读取消费进度。</li>\n</ul>\n<h4 id=\"RemoteBrokerOffsetStore-readOffset-…\"><a href=\"#RemoteBrokerOffsetStore-readOffset-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#readOffset(…)\"></a>RemoteBrokerOffsetStore#readOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">readOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ReadOffsetType type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">case</span> MEMORY_FIRST_THEN_STORE:</div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"keyword\">case</span> READ_FROM_MEMORY: &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 AtomicLong offset = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">10</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> READ_FROM_STORE: &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     <span class=\"keyword\">long</span> brokerOffset = <span class=\"keyword\">this</span>.fetchConsumeOffsetFromBroker(mq);</div><div class=\"line\"><span class=\"number\">17</span>:                     AtomicLong offset = <span class=\"keyword\">new</span> AtomicLong(brokerOffset);</div><div class=\"line\"><span class=\"number\">18</span>:                     <span class=\"keyword\">this</span>.updateOffset(mq, offset.get(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">return</span> brokerOffset;</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"comment\">// No offset in broker</span></div><div class=\"line\"><span class=\"number\">22</span>:                 <span class=\"keyword\">catch</span> (MQBrokerException e) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"comment\">//Other exceptions</span></div><div class=\"line\"><span class=\"number\">26</span>:                 <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                     log.warn(<span class=\"string\">\"fetchConsumeOffsetFromBroker exception, \"</span> + mq, e);</div><div class=\"line\"><span class=\"number\">28</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：从 <code>Broker</code> 读取消费进度。</li>\n</ul>\n<h3 id=\"OffsetStore-updateOffset-…\"><a href=\"#OffsetStore-updateOffset-…\" class=\"headerlink\" title=\"OffsetStore#updateOffset(…)\"></a>OffsetStore#updateOffset(…)</h3><p>该方法 <code>RemoteBrokerOffsetStore</code> 与 <code>LocalFileOffsetStore</code> 实现相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateOffset</span><span class=\"params\">(MessageQueue mq, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">boolean</span> increaseOnly)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         AtomicLong offsetOld = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == offsetOld) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:             offsetOld = <span class=\"keyword\">this</span>.offsetTable.putIfAbsent(mq, <span class=\"keyword\">new</span> AtomicLong(offset));</div><div class=\"line\"> <span class=\"number\">7</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != offsetOld) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">if</span> (increaseOnly) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                 MixAll.compareAndIncreaseOnly(offsetOld, offset);</div><div class=\"line\"><span class=\"number\">12</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 offsetOld.set(offset);</div><div class=\"line\"><span class=\"number\">14</span>:             &#125;</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:     &#125;</div><div class=\"line\"><span class=\"number\">17</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"OffsetStore-persistAll-…\"><a href=\"#OffsetStore-persistAll-…\" class=\"headerlink\" title=\"OffsetStore#persistAll(…)\"></a>OffsetStore#persistAll(…)</h3><h4 id=\"LocalFileOffsetStore-persistAll-…\"><a href=\"#LocalFileOffsetStore-persistAll-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#persistAll(…)\"></a>LocalFileOffsetStore#persistAll(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">persistAll</span><span class=\"params\">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqs || mqs.isEmpty())</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     OffsetSerializeWrapper offsetSerializeWrapper = <span class=\"keyword\">new</span> OffsetSerializeWrapper();</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class=\"keyword\">this</span>.offsetTable.entrySet()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (mqs.contains(entry.getKey())) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             AtomicLong offset = entry.getValue();</div><div class=\"line\"><span class=\"number\">10</span>:             offsetSerializeWrapper.getOffsetTable().put(entry.getKey(), offset);</div><div class=\"line\"><span class=\"number\">11</span>:         &#125;</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     String jsonString = offsetSerializeWrapper.toJson(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             MixAll.string2File(jsonString, <span class=\"keyword\">this</span>.storePath);</div><div class=\"line\"><span class=\"number\">18</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             log.error(<span class=\"string\">\"persistAll consumer offset Exception, \"</span> + <span class=\"keyword\">this</span>.storePath, e);</div><div class=\"line\"><span class=\"number\">20</span>:         &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：持久化消费进度。<strong>将消费进度写入文件</strong>。</li>\n</ul>\n<h4 id=\"RemoteBrokerOffsetStore-persistAll-…\"><a href=\"#RemoteBrokerOffsetStore-persistAll-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#persistAll(…)\"></a>RemoteBrokerOffsetStore#persistAll(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">persistAll</span><span class=\"params\">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqs || mqs.isEmpty())</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 持久化消息队列</span></div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> HashSet&lt;MessageQueue&gt; unusedMQ = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (!mqs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class=\"keyword\">this</span>.offsetTable.entrySet()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             MessageQueue mq = entry.getKey();</div><div class=\"line\"><span class=\"number\">11</span>:             AtomicLong offset = entry.getValue();</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (mqs.contains(mq)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                         <span class=\"keyword\">this</span>.updateConsumeOffsetToBroker(mq, offset.get());</div><div class=\"line\"><span class=\"number\">16</span>:                         log.info(<span class=\"string\">\"[persistAll] Group: &#123;&#125; ClientId: &#123;&#125; updateConsumeOffsetToBroker &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">17</span>:                             <span class=\"keyword\">this</span>.groupName,</div><div class=\"line\"><span class=\"number\">18</span>:                             <span class=\"keyword\">this</span>.mQClientFactory.getClientId(),</div><div class=\"line\"><span class=\"number\">19</span>:                             mq,</div><div class=\"line\"><span class=\"number\">20</span>:                             offset.get());</div><div class=\"line\"><span class=\"number\">21</span>:                     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         log.error(<span class=\"string\">\"updateConsumeOffsetToBroker exception, \"</span> + mq.toString(), e);</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                     unusedMQ.add(mq);</div><div class=\"line\"><span class=\"number\">26</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"comment\">// 移除不适用的消息队列</span></div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">if</span> (!unusedMQ.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : unusedMQ) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.offsetTable.remove(mq);</div><div class=\"line\"><span class=\"number\">35</span>:             log.info(<span class=\"string\">\"remove unused mq, &#123;&#125;, &#123;&#125;\"</span>, mq, <span class=\"keyword\">this</span>.groupName);</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>:     &#125;</div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：持久化指定消息队列数组的消费进度到 <code>Broker</code>，并移除非指定消息队列。</li>\n</ul>\n<h4 id=\"MQClientInstance-persistAllConsumerOffset-…\"><a href=\"#MQClientInstance-persistAllConsumerOffset-…\" class=\"headerlink\" title=\"MQClientInstance#persistAllConsumerOffset(…)\"></a>MQClientInstance#persistAllConsumerOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startScheduledTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 定时同步消费进度</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 MQClientInstance.<span class=\"keyword\">this</span>.cleanOfflineBroker();</div><div class=\"line\"> <span class=\"number\">9</span>:                 MQClientInstance.<span class=\"keyword\">this</span>.sendHeartbeatToAllBrokerWithLock();</div><div class=\"line\"><span class=\"number\">10</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                 log.error(<span class=\"string\">\"ScheduledTask sendHeartbeatToAllBroker exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">12</span>:             &#125;</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:     &#125;, <span class=\"number\">1000</span>, <span class=\"keyword\">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：定时进行持久化，默认周期：5000ms。</li>\n<li><strong>重要说明 ：</strong><ul>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"9、结尾\"><a href=\"#9、结尾\" class=\"headerlink\" title=\"9、结尾\"></a>9、结尾</h1><p>😈可能是本系列最长的一篇文章，如有表达错误和不清晰，请多多见谅。<br>感谢对本系列的阅读、收藏、点赞、分享，特别是翻到结尾。😜真的有丢丢长。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p> 原文地址：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-second/\">http://www.yunai.me/RocketMQ/message-pull-and-consume-second/</a><br><code>RocketMQ</code> <strong>带注释源码</strong>地址 ：<a href=\"https://github.com/YunaiV/incubator-rocketmq\" target=\"_blank\" rel=\"external\">https://github.com/YunaiV/incubator-rocketmq</a><br><strong>😈本系列每 1-2 周更新一篇，欢迎订阅、关注、收藏 公众号</strong>  </p>\n</blockquote>\n<p><img src=\"http://www.yunai.me/images/common/wechat_mp.jpeg\" alt=\"wechat_mp\"></p>\n<hr>\n<ul>\n<li><a href=\"#\">1、概述</a></li>\n<li><a href=\"#\">2、Consumer</a></li>\n<li><a href=\"#\">3、PushConsumer 一览</a></li>\n<li><a href=\"#\">4、PushConsumer 订阅</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#subscribe(…)</a><ul>\n<li><a href=\"#\">FilterAPI.buildSubscriptionData(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">DefaultMQPushConsumer#registerMessageListener(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">5、PushConsumer 消息队列分配</a><ul>\n<li><a href=\"#\">RebalanceService</a></li>\n<li><a href=\"#\">MQClientInstance#doRebalance(…)</a></li>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#doRebalance(…)</a></li>\n<li><a href=\"#\">RebalanceImpl#doRebalance(…)</a><ul>\n<li><a href=\"#\">RebalanceImpl#rebalanceByTopic(…)</a></li>\n<li><a href=\"#\">RebalanceImpl#removeUnnecessaryMessageQueue(…)</a><ul>\n<li><a href=\"#\">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a></li>\n<li><a href=\"#\">[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">RebalancePushImpl#dispatchPullRequest(…)</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">AllocateMessageQueueStrategy</a><ul>\n<li><a href=\"#\">AllocateMessageQueueAveragely</a></li>\n<li><a href=\"#\">AllocateMessageQueueByMachineRoom</a></li>\n<li><a href=\"#\">AllocateMessageQueueAveragelyByCircle</a></li>\n<li><a href=\"#\">AllocateMessageQueueByConfig</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">5、PushConsumer 消费进度读取</a><ul>\n<li><a href=\"#\">RebalancePushImpl#computePullFromWhere(…)</a></li>\n<li><a href=\"#\">[PullConsumer] RebalancePullImpl#computePullFromWhere(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、PushConsumer 拉取消息</a><ul>\n<li><a href=\"#\">PullMessageService</a></li>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#pullMessage(…)</a><ul>\n<li><a href=\"#\">PullAPIWrapper#pullKernelImpl(…)</a><ul>\n<li><a href=\"#\">PullAPIWrapper#recalculatePullFromWhichNode(…)</a></li>\n<li><a href=\"#\">MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">PullAPIWrapper#processPullResult(…)</a></li>\n<li><a href=\"#\">ProcessQueue#putMessage(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">总结</a></li>\n</ul>\n</li>\n<li><a href=\"#\">6、PushConsumer 消费消息</a><ul>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService 提交消费请求</a><ul>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</a></li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#submitConsumeRequestLater</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumeRequest</a></li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a><ul>\n<li><a href=\"#\">ProcessQueue#removeMessage(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</a><ul>\n<li><a href=\"#\">ProcessQueue#cleanExpiredMsg(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">7、PushConsumer 发回消费失败消息</a><ul>\n<li><a href=\"#\">DefaultMQPushConsumerImpl#sendMessageBack(…)</a><ul>\n<li><a href=\"#\">MQClientAPIImpl#consumerSendMessageBack(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">8、Consumer 消费进度</a><ul>\n<li><a href=\"#\">OffsetStore</a><ul>\n<li><a href=\"#\">OffsetStore#load(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#load(…)</a><ul>\n<li><a href=\"#\">OffsetSerializeWrapper</a></li>\n</ul>\n</li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#load(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">OffsetStore#readOffset(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#readOffset(…)</a></li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#readOffset(…)</a></li>\n</ul>\n</li>\n<li><a href=\"#\">OffsetStore#updateOffset(…)</a></li>\n<li><a href=\"#\">OffsetStore#persistAll(…)</a><ul>\n<li><a href=\"#\">LocalFileOffsetStore#persistAll(…)</a></li>\n<li><a href=\"#\">RemoteBrokerOffsetStore#persistAll(…)</a></li>\n<li><a href=\"#\">MQClientInstance#persistAllConsumerOffset(…)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#\">9、结尾</a></li>\n</ul>\n<hr>\n<h1 id=\"1、概述\"><a href=\"#1、概述\" class=\"headerlink\" title=\"1、概述\"></a>1、概述</h1><p>本文接：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/\">《RocketMQ 源码分析 —— Message 拉取与消费（上）》</a>。</p>\n<p>主要解析 <code>Consumer</code> 在 <strong>消费</strong> 逻辑涉及到的源码。</p>\n<h1 id=\"2、Consumer\"><a href=\"#2、Consumer\" class=\"headerlink\" title=\"2、Consumer\"></a>2、Consumer</h1><p>MQ 提供了两类消费者：</p>\n<ul>\n<li>PushConsumer：<ul>\n<li>在大多数场景下使用。</li>\n<li>名字虽然是 <code>Push</code> 开头，实际在实现时，使用 <code>Pull</code> 方式实现。通过 <code>Pull</code> <strong>不断不断不断</strong>轮询 <code>Broker</code> 获取消息。当不存在新消息时，<code>Broker</code> 会<strong>挂起请求</strong>，直到有新消息产生，取消挂起，返回新消息。这样，基本和 <code>Broker</code> 主动 <code>Push</code> 做到<strong>接近</strong>的实时性（当然，还是有相应的实时性损失）。原理类似 <strong><a href=\"https://www.ibm.com/developerworks/cn/web/wa-lo-comet/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">长轮询( <code>Long-Polling</code> )</a></strong>。</li>\n</ul>\n</li>\n<li>PullConsumer</li>\n</ul>\n<p><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong><br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong><br><strong>本文主要讲解<code>PushConsumer</code>，部分讲解<code>PullConsumer</code>，跳过<code>顺序消费</code>。</strong>  </p>\n<h1 id=\"3、PushConsumer-一览\"><a href=\"#3、PushConsumer-一览\" class=\"headerlink\" title=\"3、PushConsumer 一览\"></a>3、PushConsumer 一览</h1><p>先看一张 <code>PushConsumer</code> 包含的组件以及组件之间的交互图：</p>\n<p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/09.png\" alt=\"PushConsumer手绘图.png\"></p>\n<ul>\n<li><code>RebalanceService</code>：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。当有新的 <code>Consumer</code> 的加入或移除，都会重新分配消息队列。</li>\n<li><code>PullMessageService</code>：拉取消息服务，<strong>不断不断不断</strong>从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>\n<li><code>ConsumeMessageService</code>：消费消息服务，<strong>不断不断不断</strong>消费消息，并处理消费结果。</li>\n<li><code>RemoteBrokerOffsetStore</code>：<code>Consumer</code> 消费进度管理，负责从 <code>Broker</code> 获取消费进度，同步消费进度到 <code>Broker</code>。</li>\n<li><code>ProcessQueue</code> ：消息处理队列。</li>\n<li><code>MQClientInstance</code> ：封装对 <code>Namesrv</code>，<code>Broker</code> 的 API调用，提供给 <code>Producer</code>、<code>Consumer</code> 使用。</li>\n</ul>\n<h1 id=\"4、PushConsumer-订阅\"><a href=\"#4、PushConsumer-订阅\" class=\"headerlink\" title=\"4、PushConsumer 订阅\"></a>4、PushConsumer 订阅</h1><h2 id=\"DefaultMQPushConsumerImpl-subscribe-…\"><a href=\"#DefaultMQPushConsumerImpl-subscribe-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#subscribe(…)\"></a>DefaultMQPushConsumerImpl#subscribe(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(String topic, String subExpression)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         <span class=\"comment\">// 创建订阅数据</span></div><div class=\"line\"> <span class=\"number\">4</span>:         SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">5</span>:             topic, subExpression);</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 通过心跳同步Consumer信息到Broker</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mQClientFactory != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"subscription exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：订阅 <code>Topic</code> 。</li>\n<li>第 3 至 6 行 ：创建订阅数据。详细解析见：<a href=\"#filterapibuildsubscriptiondata\">FilterAPI.buildSubscriptionData(…)</a>。</li>\n<li>第 7 至 10 行 ：通过心跳同步 <code>Consumer</code> 信息到 <code>Broker</code>。</li>\n</ul>\n<h3 id=\"FilterAPI-buildSubscriptionData-…\"><a href=\"#FilterAPI-buildSubscriptionData-…\" class=\"headerlink\" title=\"FilterAPI.buildSubscriptionData(…)\"></a>FilterAPI.buildSubscriptionData(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SubscriptionData <span class=\"title\">buildSubscriptionData</span><span class=\"params\">(<span class=\"keyword\">final</span> String consumerGroup, String topic,</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:     String subString) <span class=\"keyword\">throws</span> Exception &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     SubscriptionData subscriptionData = <span class=\"keyword\">new</span> SubscriptionData();</div><div class=\"line\"> <span class=\"number\">4</span>:     subscriptionData.setTopic(topic);</div><div class=\"line\"> <span class=\"number\">5</span>:     subscriptionData.setSubString(subString);</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 处理订阅表达式</span></div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subString || subString.equals(SubscriptionData.SUB_ALL) || subString.length() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         subscriptionData.setSubString(SubscriptionData.SUB_ALL);</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         String[] tags = subString.split(<span class=\"string\">\"\\\\|\\\\|\"</span>);</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (tags.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">for</span> (String tag : tags) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (tag.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     String trimString = tag.trim();</div><div class=\"line\"><span class=\"number\">15</span>:                     <span class=\"keyword\">if</span> (trimString.length() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                         subscriptionData.getTagsSet().add(trimString);</div><div class=\"line\"><span class=\"number\">17</span>:                         subscriptionData.getCodeSet().add(trimString.hashCode());</div><div class=\"line\"><span class=\"number\">18</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">19</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">20</span>:             &#125;</div><div class=\"line\"><span class=\"number\">21</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"subString split error\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:     &#125;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">return</span> subscriptionData;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：根据 <code>Topic</code> 和 订阅表达式 创建订阅数据</li>\n<li>subscriptionData.subVersion = System.currentTimeMillis()。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumer-registerMessageListener-…\"><a href=\"#DefaultMQPushConsumer-registerMessageListener-…\" class=\"headerlink\" title=\"DefaultMQPushConsumer#registerMessageListener(…)\"></a>DefaultMQPushConsumer#registerMessageListener(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerMessageListener</span><span class=\"params\">(MessageListenerConcurrently messageListener)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.messageListener = messageListener;</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</div><div class=\"line\"><span class=\"number\">4</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：注册消息监听器。</li>\n</ul>\n<h1 id=\"5、PushConsumer-消息队列分配\"><a href=\"#5、PushConsumer-消息队列分配\" class=\"headerlink\" title=\"5、PushConsumer 消息队列分配\"></a>5、PushConsumer 消息队列分配</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/10.png\" alt=\"RebalanceService&amp;PushConsumer分配队列\"></p>\n<h2 id=\"RebalanceService\"><a href=\"#RebalanceService\" class=\"headerlink\" title=\"RebalanceService\"></a>RebalanceService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RebalanceService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>: </div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 4:      * 等待间隔，单位：毫秒</div><div class=\"line\"> 5:      */</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> waitInterval =</div><div class=\"line\"> <span class=\"number\">7</span>:         Long.parseLong(System.getProperty(</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"string\">\"rocketmq.client.rebalance.waitInterval\"</span>, <span class=\"string\">\"20000\"</span>));</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">12:      * MQClient对象</div><div class=\"line\">13:      */</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MQClientInstance mqClientFactory;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RebalanceService</span><span class=\"params\">(MQClientInstance mqClientFactory)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.mqClientFactory = mqClientFactory;</div><div class=\"line\"><span class=\"number\">18</span>:     &#125;</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">22</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"keyword\">this</span>.waitForRunning(waitInterval);</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"keyword\">this</span>.mqClientFactory.doRebalance();</div><div class=\"line\"><span class=\"number\">27</span>:         &#125;</div><div class=\"line\"><span class=\"number\">28</span>: </div><div class=\"line\"><span class=\"number\">29</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">30</span>:     &#125;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">return</span> RebalanceService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：均衡消息队列服务，负责分配当前 <code>Consumer</code> 可消费的消息队列( <code>MessageQueue</code> )。</li>\n<li><p>第 26 行 ：调用 <code>MQClientInstance#doRebalance(...)</code> 分配消息队列。目前有三种情况情况下触发：</p>\n<ul>\n<li>如 <code>第 25 行</code> 等待超时，每 20s 调用一次。</li>\n<li><code>PushConsumer</code> 启动时，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>\n<li><code>Broker</code> 通知 <code>Consumer</code> 加入 或 移除时，<code>Consumer</code> 响应通知，调用 <code>rebalanceService#wakeup(...)</code> 触发。</li>\n</ul>\n<p>详细解析见：<a href=\"#mqclientinstancedorebalance\">MQClientInstance#doRebalance(…)</a>。</p>\n</li>\n</ul>\n<h2 id=\"MQClientInstance-doRebalance-…\"><a href=\"#MQClientInstance-doRebalance-…\" class=\"headerlink\" title=\"MQClientInstance#doRebalance(…)\"></a>MQClientInstance#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class=\"keyword\">this</span>.consumerTable.entrySet()) &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:         MQConsumerInner impl = entry.getValue();</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:                 impl.doRebalance();</div><div class=\"line\"> <span class=\"number\">7</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 log.error(<span class=\"string\">\"doRebalance exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">9</span>:             &#125;</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：遍历当前 <code>Client</code> 包含的 <code>consumerTable</code>( <code>Consumer</code>集合 )，执行消息队列分配。</li>\n<li><strong>疑问</strong>：目前代码调试下来，<code>consumerTable</code> 只包含 <code>Consumer</code> 自己。😈有大大对这个疑问有解答的，烦请解答下。</li>\n<li>第 6 行 ：调用 <code>MQConsumerInner#doRebalance(...)</code> 进行队列分配。<code>DefaultMQPushConsumerImpl</code>、<code>DefaultMQPullConsumerImpl</code> 分别对该接口方法进行了实现。<code>DefaultMQPushConsumerImpl#doRebalance(...)</code> 详细解析见：<a href=\"defaultmqpushconsumerimpldorebalance\">DefaultMQPushConsumerImpl#doRebalance(…)</a>。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumerImpl-doRebalance-…\"><a href=\"#DefaultMQPushConsumerImpl-doRebalance-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#doRebalance(…)\"></a>DefaultMQPushConsumerImpl#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.pause) &#123;</div><div class=\"line\"><span class=\"number\">3</span>:         <span class=\"keyword\">this</span>.rebalanceImpl.doRebalance(<span class=\"keyword\">this</span>.isConsumeOrderly());</div><div class=\"line\"><span class=\"number\">4</span>:     &#125;</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明：执行消息队列分配。</li>\n<li>第 3 行 ：调用 <code>RebalanceImpl#doRebalance(...)</code> 进行队列分配。详细解析见：<a href=\"#rebalancepushimpldorebalance\">RebalancePushImpl#doRebalance(…)</a>。</li>\n</ul>\n<h2 id=\"RebalanceImpl-doRebalance-…\"><a href=\"#RebalanceImpl-doRebalance-…\" class=\"headerlink\" title=\"RebalanceImpl#doRebalance(…)\"></a>RebalanceImpl#doRebalance(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 执行分配消息队列</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> isOrder 是否顺序消息</div><div class=\"line\"> 5:  */</div><div class=\"line\"> <span class=\"number\">6</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 分配每个 topic 的消息队列</span></div><div class=\"line\"> <span class=\"number\">8</span>:     Map&lt;String, SubscriptionData&gt; subTable = <span class=\"keyword\">this</span>.getSubscriptionInner();</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (subTable != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">final</span> String topic = entry.getKey();</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">this</span>.rebalanceByTopic(topic, isOrder);</div><div class=\"line\"><span class=\"number\">14</span>:             &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     log.warn(<span class=\"string\">\"rebalanceByTopic Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">17</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">18</span>:             &#125;</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"comment\">// 移除未订阅的topic对应的消息队列</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">this</span>.truncateMessageQueueNotMyTopic();</div><div class=\"line\"><span class=\"number\">23</span>: &#125;</div><div class=\"line\"><span class=\"number\">24</span>: </div><div class=\"line\"><span class=\"number\">25</span>: <span class=\"comment\">/**</span></div><div class=\"line\">26:  * 移除未订阅的消息队列</div><div class=\"line\">27:  */</div><div class=\"line\"><span class=\"number\">28</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">truncateMessageQueueNotMyTopic</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">29</span>:     Map&lt;String, SubscriptionData&gt; subTable = <span class=\"keyword\">this</span>.getSubscriptionInner();</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : <span class=\"keyword\">this</span>.processQueueTable.keySet()) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">if</span> (!subTable.containsKey(mq.getTopic())) &#123;</div><div class=\"line\"><span class=\"number\">32</span>: </div><div class=\"line\"><span class=\"number\">33</span>:             ProcessQueue pq = <span class=\"keyword\">this</span>.processQueueTable.remove(mq);</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (pq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">36</span>:                 log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, truncateMessageQueueNotMyTopic remove unnecessary mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">37</span>:             &#125;</div><div class=\"line\"><span class=\"number\">38</span>:         &#125;</div><div class=\"line\"><span class=\"number\">39</span>:     &#125;</div><div class=\"line\"><span class=\"number\">40</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#doRebalance(...)</code> 说明 ：执行分配消息队列。<ul>\n<li>第 7 至 20 行 ：循环订阅主题集合( <code>subscriptionInner</code> )，分配每一个 <code>Topic</code> 的消息队列。</li>\n<li>第 22 行 ：移除未订阅的 <code>Topic</code> 的消息队列。</li>\n</ul>\n</li>\n<li><code>#truncateMessageQueueNotMyTopic(...)</code> 说明 ：移除未订阅的消息队列。<strong>当调用 <code>DefaultMQPushConsumer#unsubscribe(topic)</code> 时，只移除订阅主题集合( <code>subscriptionInner</code> )，对应消息队列移除在该方法。</strong></li>\n</ul>\n<h3 id=\"RebalanceImpl-rebalanceByTopic-…\"><a href=\"#RebalanceImpl-rebalanceByTopic-…\" class=\"headerlink\" title=\"RebalanceImpl#rebalanceByTopic(…)\"></a>RebalanceImpl#rebalanceByTopic(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rebalanceByTopic</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">switch</span> (messageModel) &#123;</div><div class=\"line\">  <span class=\"number\">3</span>:         <span class=\"keyword\">case</span> BROADCASTING: &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:             Set&lt;MessageQueue&gt; mqSet = <span class=\"keyword\">this</span>.topicSubscribeInfoTable.get(topic);</div><div class=\"line\">  <span class=\"number\">5</span>:             <span class=\"keyword\">if</span> (mqSet != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">  <span class=\"number\">6</span>:                 <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</div><div class=\"line\">  <span class=\"number\">7</span>:                 <span class=\"keyword\">if</span> (changed) &#123;</div><div class=\"line\">  <span class=\"number\">8</span>:                     <span class=\"keyword\">this</span>.messageQueueChanged(topic, mqSet, mqSet);</div><div class=\"line\">  <span class=\"number\">9</span>:                     log.info(<span class=\"string\">\"messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">10</span>:                         consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">11</span>:                         topic, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">12</span>:                         mqSet, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">13</span>:                         mqSet);</div><div class=\"line\"> <span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">15</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">17</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">18</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">19</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">20</span>:         <span class=\"keyword\">case</span> CLUSTERING: &#123;</div><div class=\"line\"> <span class=\"number\">21</span>:             <span class=\"comment\">// 获取 topic 对应的 队列 和 consumer信息</span></div><div class=\"line\"> <span class=\"number\">22</span>:             Set&lt;MessageQueue&gt; mqSet = <span class=\"keyword\">this</span>.topicSubscribeInfoTable.get(topic);</div><div class=\"line\"> <span class=\"number\">23</span>:             List&lt;String&gt; cidAll = <span class=\"keyword\">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</div><div class=\"line\"> <span class=\"number\">24</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqSet) &#123;</div><div class=\"line\"> <span class=\"number\">25</span>:                 <span class=\"keyword\">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:                     log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">28</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:             <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">31</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed\"</span>, consumerGroup, topic);</div><div class=\"line\"> <span class=\"number\">32</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:             <span class=\"keyword\">if</span> (mqSet != <span class=\"keyword\">null</span> &amp;&amp; cidAll != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">35</span>:                 <span class=\"comment\">// 排序 消息队列 和 消费者数组。因为是在Client进行分配队列，排序后，各Client的顺序才能保持一致。</span></div><div class=\"line\"> <span class=\"number\">36</span>:                 List&lt;MessageQueue&gt; mqAll = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">37</span>:                 mqAll.addAll(mqSet);</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:                 Collections.sort(mqAll);</div><div class=\"line\"> <span class=\"number\">40</span>:                 Collections.sort(cidAll);</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:                 AllocateMessageQueueStrategy strategy = <span class=\"keyword\">this</span>.allocateMessageQueueStrategy;</div><div class=\"line\"> <span class=\"number\">43</span>: </div><div class=\"line\"> <span class=\"number\">44</span>:                 <span class=\"comment\">// 根据 队列分配策略 分配消息队列</span></div><div class=\"line\"> <span class=\"number\">45</span>:                 List&lt;MessageQueue&gt; allocateResult;</div><div class=\"line\"> <span class=\"number\">46</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">47</span>:                     allocateResult = strategy.allocate(<span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">48</span>:                         <span class=\"keyword\">this</span>.consumerGroup, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">49</span>:                         <span class=\"keyword\">this</span>.mQClientFactory.getClientId(), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">50</span>:                         mqAll, <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">51</span>:                         cidAll);</div><div class=\"line\"> <span class=\"number\">52</span>:                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:                     log.error(<span class=\"string\">\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;\"</span>, strategy.getName(),</div><div class=\"line\"> <span class=\"number\">54</span>:                         e);</div><div class=\"line\"> <span class=\"number\">55</span>:                     <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">56</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">57</span>: </div><div class=\"line\"> <span class=\"number\">58</span>:                 Set&lt;MessageQueue&gt; allocateResultSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">59</span>:                 <span class=\"keyword\">if</span> (allocateResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">60</span>:                     allocateResultSet.addAll(allocateResult);</div><div class=\"line\"> <span class=\"number\">61</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">62</span>: </div><div class=\"line\"> <span class=\"number\">63</span>:                 <span class=\"comment\">// 更新消息队列</span></div><div class=\"line\"> <span class=\"number\">64</span>:                 <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</div><div class=\"line\"> <span class=\"number\">65</span>:                 <span class=\"keyword\">if</span> (changed) &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:                     log.info(</div><div class=\"line\"> <span class=\"number\">67</span>:                         <span class=\"string\">\"rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">68</span>:                         strategy.getName(), consumerGroup, topic, <span class=\"keyword\">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</div><div class=\"line\"> <span class=\"number\">69</span>:                         allocateResultSet.size(), allocateResultSet);</div><div class=\"line\"> <span class=\"number\">70</span>:                     <span class=\"keyword\">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</div><div class=\"line\"> <span class=\"number\">71</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">72</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">73</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">74</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"> <span class=\"number\">76</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"> <span class=\"number\">77</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">78</span>: &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 81:  * 当负载均衡时，更新 消息处理队列</div><div class=\"line\"> 82:  * - 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列</div><div class=\"line\"> 83:  * - 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列</div><div class=\"line\"> 84:  *</div><div class=\"line\"> 85:  * <span class=\"doctag\">@param</span> topic Topic</div><div class=\"line\"> 86:  * <span class=\"doctag\">@param</span> mqSet 负载均衡结果后的消息队列数组</div><div class=\"line\"> 87:  * <span class=\"doctag\">@param</span> isOrder 是否顺序</div><div class=\"line\"> 88:  * <span class=\"doctag\">@return</span> 是否变更</div><div class=\"line\"> 89:  */</div><div class=\"line\"> <span class=\"number\">90</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">updateProcessQueueTableInRebalance</span><span class=\"params\">(<span class=\"keyword\">final</span> String topic, <span class=\"keyword\">final</span> Set&lt;MessageQueue&gt; mqSet, <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isOrder)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">91</span>:     <span class=\"keyword\">boolean</span> changed = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">92</span>: </div><div class=\"line\"> <span class=\"number\">93</span>:     <span class=\"comment\">// 移除 在processQueueTable &amp;&amp; 不存在于 mqSet 里的消息队列</span></div><div class=\"line\"> <span class=\"number\">94</span>:     Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class=\"keyword\">this</span>.processQueueTable.entrySet().iterator();</div><div class=\"line\"> <span class=\"number\">95</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123; <span class=\"comment\">// TODO 待读：</span></div><div class=\"line\"> <span class=\"number\">96</span>:         Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</div><div class=\"line\"> <span class=\"number\">97</span>:         MessageQueue mq = next.getKey();</div><div class=\"line\"> <span class=\"number\">98</span>:         ProcessQueue pq = next.getValue();</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:         <span class=\"keyword\">if</span> (mq.getTopic().equals(topic)) &#123;</div><div class=\"line\"><span class=\"number\">101</span>:             <span class=\"keyword\">if</span> (!mqSet.contains(mq)) &#123; <span class=\"comment\">// 不包含的队列</span></div><div class=\"line\"><span class=\"number\">102</span>:                 pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">103</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                     it.remove();</div><div class=\"line\"><span class=\"number\">105</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">106</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">107</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">108</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pq.isPullExpired()) &#123; <span class=\"comment\">// 队列拉取超时，进行清理</span></div><div class=\"line\"><span class=\"number\">109</span>:                 <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.consumeType()) &#123;</div><div class=\"line\"><span class=\"number\">110</span>:                     <span class=\"keyword\">case</span> CONSUME_ACTIVELY:</div><div class=\"line\"><span class=\"number\">111</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">112</span>:                     <span class=\"keyword\">case</span> CONSUME_PASSIVELY:</div><div class=\"line\"><span class=\"number\">113</span>:                         pq.setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">114</span>:                         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</div><div class=\"line\"><span class=\"number\">115</span>:                             it.remove();</div><div class=\"line\"><span class=\"number\">116</span>:                             changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">117</span>:                             log.error(<span class=\"string\">\"[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it\"</span>,</div><div class=\"line\"><span class=\"number\">118</span>:                                 consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">119</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">120</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">121</span>:                     <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">122</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">123</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">124</span>:             &#125;</div><div class=\"line\"><span class=\"number\">125</span>:         &#125;</div><div class=\"line\"><span class=\"number\">126</span>:     &#125;</div><div class=\"line\"><span class=\"number\">127</span>: </div><div class=\"line\"><span class=\"number\">128</span>:     <span class=\"comment\">// 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。</span></div><div class=\"line\"><span class=\"number\">129</span>:     List&lt;PullRequest&gt; pullRequestList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(); <span class=\"comment\">// 拉消息请求数组</span></div><div class=\"line\"><span class=\"number\">130</span>:     <span class=\"keyword\">for</span> (MessageQueue mq : mqSet) &#123;</div><div class=\"line\"><span class=\"number\">131</span>:         <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.processQueueTable.containsKey(mq)) &#123;</div><div class=\"line\"><span class=\"number\">132</span>:             <span class=\"keyword\">if</span> (isOrder &amp;&amp; !<span class=\"keyword\">this</span>.lock(mq)) &#123;</div><div class=\"line\"><span class=\"number\">133</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">134</span>:                 <span class=\"keyword\">continue</span>;</div><div class=\"line\"><span class=\"number\">135</span>:             &#125;</div><div class=\"line\"><span class=\"number\">136</span>: </div><div class=\"line\"><span class=\"number\">137</span>:             <span class=\"keyword\">this</span>.removeDirtyOffset(mq);</div><div class=\"line\"><span class=\"number\">138</span>:             ProcessQueue pq = <span class=\"keyword\">new</span> ProcessQueue();</div><div class=\"line\"><span class=\"number\">139</span>:             <span class=\"keyword\">long</span> nextOffset = <span class=\"keyword\">this</span>.computePullFromWhere(mq);</div><div class=\"line\"><span class=\"number\">140</span>:             <span class=\"keyword\">if</span> (nextOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">141</span>:                 ProcessQueue pre = <span class=\"keyword\">this</span>.processQueueTable.putIfAbsent(mq, pq);</div><div class=\"line\"><span class=\"number\">142</span>:                 <span class=\"keyword\">if</span> (pre != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">143</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">144</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">145</span>:                     log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">146</span>:                     PullRequest pullRequest = <span class=\"keyword\">new</span> PullRequest();</div><div class=\"line\"><span class=\"number\">147</span>:                     pullRequest.setConsumerGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">148</span>:                     pullRequest.setNextOffset(nextOffset);</div><div class=\"line\"><span class=\"number\">149</span>:                     pullRequest.setMessageQueue(mq);</div><div class=\"line\"><span class=\"number\">150</span>:                     pullRequest.setProcessQueue(pq);</div><div class=\"line\"><span class=\"number\">151</span>:                     pullRequestList.add(pullRequest);</div><div class=\"line\"><span class=\"number\">152</span>:                     changed = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">153</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">154</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">155</span>:                 log.warn(<span class=\"string\">\"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;\"</span>, consumerGroup, mq);</div><div class=\"line\"><span class=\"number\">156</span>:             &#125;</div><div class=\"line\"><span class=\"number\">157</span>:         &#125;</div><div class=\"line\"><span class=\"number\">158</span>:     &#125;</div><div class=\"line\"><span class=\"number\">159</span>: </div><div class=\"line\"><span class=\"number\">160</span>:     <span class=\"comment\">// 发起消息拉取请求</span></div><div class=\"line\"><span class=\"number\">161</span>:     <span class=\"keyword\">this</span>.dispatchPullRequest(pullRequestList);</div><div class=\"line\"><span class=\"number\">162</span>: </div><div class=\"line\"><span class=\"number\">163</span>:     <span class=\"keyword\">return</span> changed;</div><div class=\"line\"><span class=\"number\">164</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#rebalanceByTopic(...)</code> 说明 ：分配 <code>Topic</code> 的消息队列。<ul>\n<li>第 3 至 19 行 ：广播模式( <code>BROADCASTING</code> ) 下，分配 <code>Topic</code> 对应的<strong>所有</strong>消息队列。   </li>\n<li>第 20 至 74 行 ：集群模式( <code>CLUSTERING</code> ) 下，分配 <code>Topic</code> 对应的<strong>部分</strong>消息队列。<ul>\n<li>第 21 至 40 行 ：获取 <code>Topic</code> 对应的消息队列和消费者们，并对其进行排序。因为各 <code>Consumer</code> 是在本地分配消息队列，排序后才能保证各 <code>Consumer</code> 顺序一致。</li>\n<li>第 42 至 61 行 ：根据 队列分配策略( <code>AllocateMessageQueueStrategy</code> ) 分配消息队列。详细解析见：<a href=\"#allocatemessagequeuestrategy\">AllocateMessageQueueStrategy</a>。</li>\n<li>第 63 至 72 行 ：更新 <code>Topic</code> 对应的消息队列。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>#updateProcessQueueTableInRebalance(...)</code> 说明 ：当分配队列时，更新 <code>Topic</code> 对应的消息队列，并返回是否有变更。<ul>\n<li>第 93 至 126 行 ：移除不存在于分配的消息队列( <code>mqSet</code> ) 的 消息处理队列( <code>processQueueTable</code> )。<ul>\n<li>第 103 行 ：移除不需要的消息队列。详细解析见：<a href=\"#rebalancepushimplremoveunnecessarymessagequeue\">RebalancePushImpl#removeUnnecessaryMessageQueue(…)</a>。</li>\n<li>第 108 至 120 行 ：队列拉取超时，即 <code>当前时间 - 最后一次拉取消息时间 &gt; 120s</code> ( 120s 可配置)，判定发生 <strong>BUG</strong>，过久未进行消息拉取，移除消息队列。移除后，下面<strong>#新增队列逻辑#</strong>可以重新加入新的该消息队列。</li>\n</ul>\n</li>\n<li>第 128 至 158 行 ：增加 分配的消息队列( <code>mqSet</code> ) 新增的消息队列。<ul>\n<li>第 132 至 135 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n<li>第 137 行 ：移除消息队列的消费进度。</li>\n<li>第 139 行 ：获取队列消费进度。详细解析见：<a href=\"#rebalancepushimplcomputepullfromwhere\">RebalancePushImpl#computePullFromWhere(…)</a>。</li>\n<li>第 140 至 156 行 ：<strong>添加新消费处理队列，添加消费拉取消息请求</strong>。</li>\n</ul>\n</li>\n<li>第 161 行 ：<strong>发起新增的消息队列消息拉取请求</strong>。详细解析见：<a href=\"#rebalancepushimpldispatchpullrequest\">RebalancePushImpl#dispatchPullRequest(…)</a>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"RebalanceImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#RebalanceImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"RebalanceImpl#removeUnnecessaryMessageQueue(…)\"></a>RebalanceImpl#removeUnnecessaryMessageQueue(…)</h3><h4 id=\"RebalancePushImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#RebalancePushImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"RebalancePushImpl#removeUnnecessaryMessageQueue(…)\"></a>RebalancePushImpl#removeUnnecessaryMessageQueue(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 同步队列的消费进度，并移除之。</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"comment\">// TODO 顺序消费</span></div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.isConsumeOrderly()</div><div class=\"line\"> <span class=\"number\">7</span>:         &amp;&amp; MessageModel.CLUSTERING.equals(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">if</span> (pq.getLockConsume().tryLock(<span class=\"number\">1000</span>, TimeUnit.MILLISECONDS)) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.unlockDelay(mq, pq);</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                     pq.getLockConsume().unlock();</div><div class=\"line\"><span class=\"number\">14</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">15</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 log.warn(<span class=\"string\">\"[WRONG]mq is consuming, so can not unlock it, &#123;&#125;. maybe hanged for a while, &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">17</span>:                     mq, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">18</span>:                     pq.getTryUnlockTimes());</div><div class=\"line\"><span class=\"number\">19</span>: </div><div class=\"line\"><span class=\"number\">20</span>:                 pq.incTryUnlockTimes();</div><div class=\"line\"><span class=\"number\">21</span>:             &#125;</div><div class=\"line\"><span class=\"number\">22</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:             log.error(<span class=\"string\">\"removeUnnecessaryMessageQueue Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">24</span>:         &#125;</div><div class=\"line\"><span class=\"number\">25</span>: </div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">27</span>:     &#125;</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">29</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除不需要的消息队列相关的信息，并返回是否移除成功。</li>\n<li>第 2 至 4 行 ：<strong>同步</strong>队列的消费进度，并移除之。</li>\n<li>第 5 至 27 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n</ul>\n<h4 id=\"PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…\"><a href=\"#PullConsumer-RebalancePullImpl-removeUnnecessaryMessageQueue-…\" class=\"headerlink\" title=\"[PullConsumer] RebalancePullImpl#removeUnnecessaryMessageQueue(…)\"></a><code>[PullConsumer]</code> RebalancePullImpl#removeUnnecessaryMessageQueue(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeUnnecessaryMessageQueue</span><span class=\"params\">(MessageQueue mq, ProcessQueue pq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.defaultMQPullConsumerImpl.getOffsetStore().persist(mq);</div><div class=\"line\"><span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.defaultMQPullConsumerImpl.getOffsetStore().removeOffset(mq);</div><div class=\"line\"><span class=\"number\">4</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">5</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除不需要的消息队列相关的信息，并返回移除成功。<strong>和<code>RebalancePushImpl#removeUnnecessaryMessageQueue(...)</code>基本一致。</strong></li>\n</ul>\n<h3 id=\"RebalancePushImpl-dispatchPullRequest-…\"><a href=\"#RebalancePushImpl-dispatchPullRequest-…\" class=\"headerlink\" title=\"RebalancePushImpl#dispatchPullRequest(…)\"></a>RebalancePushImpl#dispatchPullRequest(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPullRequest</span><span class=\"params\">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">for</span> (PullRequest pullRequest : pullRequestList) &#123;</div><div class=\"line\"><span class=\"number\">3</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">4</span>:         log.info(<span class=\"string\">\"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;\"</span>, consumerGroup, pullRequest);</div><div class=\"line\"><span class=\"number\">5</span>:     &#125;</div><div class=\"line\"><span class=\"number\">6</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发起消息拉取请求。<strong>该调用是<code>PushConsumer</code>不断不断不断拉取消息的起点</strong>。</li>\n</ul>\n<h4 id=\"DefaultMQPushConsumerImpl-executePullRequestImmediately-…\"><a href=\"#DefaultMQPushConsumerImpl-executePullRequestImmediately-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#executePullRequestImmediately(…)\"></a>DefaultMQPushConsumerImpl#executePullRequestImmediately(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestImmediately</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">3</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交拉取请求。提交后，<code>PullMessageService</code> <strong>异步执行</strong>，<strong>非阻塞</strong>。详细解析见：<a href=\"pullmessageservice\">PullMessageService</a>。</li>\n</ul>\n<h3 id=\"AllocateMessageQueueStrategy\"><a href=\"#AllocateMessageQueueStrategy\" class=\"headerlink\" title=\"AllocateMessageQueueStrategy\"></a>AllocateMessageQueueStrategy</h3><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/01.png\" alt=\"AllocateMessageQueueStrategy类图\"></p>\n<h4 id=\"AllocateMessageQueueAveragely\"><a href=\"#AllocateMessageQueueAveragely\" class=\"headerlink\" title=\"AllocateMessageQueueAveragely\"></a>AllocateMessageQueueAveragely</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueAveragely</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 校验参数是否正确</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (currentCID == <span class=\"keyword\">null</span> || currentCID.length() &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"currentCID is empty\"</span>);</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (mqAll == <span class=\"keyword\">null</span> || mqAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"mqAll is null or mqAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (cidAll == <span class=\"keyword\">null</span> || cidAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"cidAll is null or cidAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         &#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (!cidAll.contains(currentCID)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             log.info(<span class=\"string\">\"[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">21</span>:                 consumerGroup,</div><div class=\"line\"><span class=\"number\">22</span>:                 currentCID,</div><div class=\"line\"><span class=\"number\">23</span>:                 cidAll);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"comment\">// 平均分配</span></div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID); <span class=\"comment\">// 第几个consumer。</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> mod = mqAll.size() % cidAll.size(); <span class=\"comment\">// 余数，即多少消息队列无法平均分配。</span></div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">int</span> averageSize =</div><div class=\"line\"><span class=\"number\">30</span>:             mqAll.size() &lt;= cidAll.size() ? <span class=\"number\">1</span> : (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</div><div class=\"line\"><span class=\"number\">31</span>:                 + <span class=\"number\">1</span> : mqAll.size() / cidAll.size());</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">int</span> startIndex = (mod &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod; <span class=\"comment\">// 有余数的情况下，[0, mod) 平分余数，即每consumer多分配一个节点；第index开始，跳过前mod余数。</span></div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"keyword\">int</span> range = Math.min(averageSize, mqAll.size() - startIndex); <span class=\"comment\">// 分配队列数量。之所以要Math.min()的原因是，mqAll.size() &lt;= cidAll.size()，部分consumer分配不到消息队列。</span></div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; range; i++) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:             result.add(mqAll.get((startIndex + i) % mqAll.size()));</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"AVG\"</span>;</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>平均</strong>分配队列策略。</li>\n<li>第 7 至 25 行 ：参数校验。</li>\n<li>第 26 至 36 行 ：平均分配消息队列。<ul>\n<li>第 27 行 ：<code>index</code> ：当前 <code>Consumer</code> 在消费集群里是第几个。这里就是为什么需要对传入的 <code>cidAll</code> 参数必须进行排序的原因。如果不排序，<code>Consumer</code> 在本地计算出来的 <code>index</code> 无法一致，影响计算结果。</li>\n<li>第 28 行 ：<code>mod</code> ：余数，即多少消息队列无法平均分配。</li>\n<li>第 29 至 31 行 ：<code>averageSize</code> ：代码可以简化成 <code>(mod &gt; 0 &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size() + 1 : mqAll.size() / cidAll.size())</code>。<ul>\n<li><code>[ 0, mod )</code> ：<code>mqAll.size() / cidAll.size() + 1</code>。前面 <code>mod</code> 个 <code>Consumer</code> 平分余数，多获得 1 个消息队列。</li>\n<li><code>[ mod, cidAll.size() )</code> ：<code>mqAll.size() / cidAll.size()</code>。</li>\n</ul>\n</li>\n<li>第 32 行 ：<code>startIndex</code> ：<code>Consumer</code> 分配消息队列开始位置。</li>\n<li>第 33 行 ：<code>range</code> ：分配队列数量。之所以要 <code>Math#min(...)</code> 的原因：当 <code>mqAll.size() &lt;= cidAll.size()</code> 时，最后几个 <code>Consumer</code> 分配不到消息队列。</li>\n<li>第 34 至 36 行 ：生成分配消息队列结果。</li>\n</ul>\n</li>\n<li>举个例子：</li>\n</ul>\n<p>固定消息队列长度为<strong>4</strong>。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Consumer <em> 2 </em>可以整除*</th>\n<th>Consumer <em> 3 </em>不可整除*</th>\n<th>Consumer <em> 5 </em>无法都分配*</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>消息队列[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n</tr>\n<tr>\n<td>消息队列[1]</td>\n<td>Consumer[0]</td>\n<td>Consumer[0]</td>\n<td>Consumer[1]</td>\n</tr>\n<tr>\n<td>消息队列[2]</td>\n<td>Consumer[1]</td>\n<td>Consumer[1]</td>\n<td>Consumer[2]</td>\n</tr>\n<tr>\n<td>消息队列[3]</td>\n<td>Consumer[1]</td>\n<td>Consumer[2]</td>\n<td>Consumer[3]</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"AllocateMessageQueueByMachineRoom\"><a href=\"#AllocateMessageQueueByMachineRoom\" class=\"headerlink\" title=\"AllocateMessageQueueByMachineRoom\"></a>AllocateMessageQueueByMachineRoom</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueByMachineRoom</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 3:      * 消费者消费brokerName集合</div><div class=\"line\"> 4:      */</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">private</span> Set&lt;String&gt; consumeridcs;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">9</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 参数校验</span></div><div class=\"line\"><span class=\"number\">11</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">int</span> currentIndex = cidAll.indexOf(currentCID);</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">if</span> (currentIndex &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"comment\">// 计算符合当前配置的消费者数组('consumeridcs')对应的消息队列</span></div><div class=\"line\"><span class=\"number\">17</span>:         List&lt;MessageQueue&gt; premqAll = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : mqAll) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             String[] temp = mq.getBrokerName().split(<span class=\"string\">\"@\"</span>);</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">if</span> (temp.length == <span class=\"number\">2</span> &amp;&amp; consumeridcs.contains(temp[<span class=\"number\">0</span>])) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 premqAll.add(mq);</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:         &#125;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// 平均分配</span></div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">int</span> mod = premqAll.size() / cidAll.size();</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">int</span> rem = premqAll.size() % cidAll.size();</div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">int</span> startIndex = mod * currentIndex;</div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> endIndex = startIndex + mod;</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             result.add(mqAll.get(i));</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (rem &gt; currentIndex) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:             result.add(premqAll.get(currentIndex + mod * cidAll.size()));</div><div class=\"line\"><span class=\"number\">34</span>:         &#125;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"MACHINE_ROOM\"</span>;</div><div class=\"line\"><span class=\"number\">41</span>:     &#125;</div><div class=\"line\"><span class=\"number\">42</span>: </div><div class=\"line\"><span class=\"number\">43</span>:     <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getConsumeridcs</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">44</span>:         <span class=\"keyword\">return</span> consumeridcs;</div><div class=\"line\"><span class=\"number\">45</span>:     &#125;</div><div class=\"line\"><span class=\"number\">46</span>: </div><div class=\"line\"><span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConsumeridcs</span><span class=\"params\">(Set&lt;String&gt; consumeridcs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">48</span>:         <span class=\"keyword\">this</span>.consumeridcs = consumeridcs;</div><div class=\"line\"><span class=\"number\">49</span>:     &#125;</div><div class=\"line\"><span class=\"number\">50</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：<strong>平均</strong>分配<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>\n<li>第 7 至 15 行 ：参数校验。</li>\n<li>第 16 至 23 行 ：计算<strong>可消费的</strong> <code>Broker</code> 对应的消息队列。</li>\n<li>第 25 至 34 行 ：平均分配消息队列。该<strong>平均分配</strong>方式和 <code>AllocateMessageQueueAveragely</code> 略有不同，其是将多余的结尾部分分配给前 <code>rem</code> 个 <code>Consumer</code>。</li>\n<li>疑问：<em>使用该分配策略时，<code>Consumer</code> 和 <code>Broker</code> 分配需要怎么配置</em>。😈等研究<strong>主从</strong>相关源码时，仔细考虑下。</li>\n</ul>\n<h4 id=\"AllocateMessageQueueAveragelyByCircle\"><a href=\"#AllocateMessageQueueAveragelyByCircle\" class=\"headerlink\" title=\"AllocateMessageQueueAveragelyByCircle\"></a>AllocateMessageQueueAveragelyByCircle</h4> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueAveragelyByCircle</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"comment\">// 校验参数是否正确</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (currentCID == <span class=\"keyword\">null</span> || currentCID.length() &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"currentCID is empty\"</span>);</div><div class=\"line\"><span class=\"number\">10</span>:         &#125;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">if</span> (mqAll == <span class=\"keyword\">null</span> || mqAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"mqAll is null or mqAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">if</span> (cidAll == <span class=\"keyword\">null</span> || cidAll.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"cidAll is null or cidAll empty\"</span>);</div><div class=\"line\"><span class=\"number\">16</span>:         &#125;</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         List&lt;MessageQueue&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;MessageQueue&gt;();</div><div class=\"line\"><span class=\"number\">19</span>:         <span class=\"keyword\">if</span> (!cidAll.contains(currentCID)) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:             log.info(<span class=\"string\">\"[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">21</span>:                 consumerGroup,</div><div class=\"line\"><span class=\"number\">22</span>:                 currentCID,</div><div class=\"line\"><span class=\"number\">23</span>:                 cidAll);</div><div class=\"line\"><span class=\"number\">24</span>:             <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"comment\">// 环状分配</span></div><div class=\"line\"><span class=\"number\">28</span>:         <span class=\"keyword\">int</span> index = cidAll.indexOf(currentCID);</div><div class=\"line\"><span class=\"number\">29</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = index; i &lt; mqAll.size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:             <span class=\"keyword\">if</span> (i % cidAll.size() == index) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                 result.add(mqAll.get(i));</div><div class=\"line\"><span class=\"number\">32</span>:             &#125;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:         <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">35</span>:     &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"AVG_BY_CIRCLE\"</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：环状分配消息队列。</li>\n</ul>\n<h4 id=\"AllocateMessageQueueByConfig\"><a href=\"#AllocateMessageQueueByConfig\" class=\"headerlink\" title=\"AllocateMessageQueueByConfig\"></a>AllocateMessageQueueByConfig</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllocateMessageQueueByConfig</span> <span class=\"keyword\">implements</span> <span class=\"title\">AllocateMessageQueueStrategy</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> List&lt;MessageQueue&gt; messageQueueList;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">allocate</span><span class=\"params\">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></div><div class=\"line\"> <span class=\"number\">6</span>:         List&lt;String&gt; cidAll) &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.messageQueueList;</div><div class=\"line\"> <span class=\"number\">8</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">return</span> <span class=\"string\">\"CONFIG\"</span>;</div><div class=\"line\"><span class=\"number\">13</span>:     &#125;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"function\"><span class=\"keyword\">public</span> List&lt;MessageQueue&gt; <span class=\"title\">getMessageQueueList</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">return</span> messageQueueList;</div><div class=\"line\"><span class=\"number\">17</span>:     &#125;</div><div class=\"line\"><span class=\"number\">18</span>: </div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMessageQueueList</span><span class=\"params\">(List&lt;MessageQueue&gt; messageQueueList)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"keyword\">this</span>.messageQueueList = messageQueueList;</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：分配<strong>配置的</strong>消息队列。</li>\n<li>疑问 ：<em>该分配策略的使用场景。</em></li>\n</ul>\n<h1 id=\"5、PushConsumer-消费进度读取\"><a href=\"#5、PushConsumer-消费进度读取\" class=\"headerlink\" title=\"5、PushConsumer 消费进度读取\"></a>5、PushConsumer 消费进度读取</h1><h2 id=\"RebalancePushImpl-computePullFromWhere-…\"><a href=\"#RebalancePushImpl-computePullFromWhere-…\" class=\"headerlink\" title=\"RebalancePushImpl#computePullFromWhere(…)\"></a>RebalancePushImpl#computePullFromWhere(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">computePullFromWhere</span><span class=\"params\">(MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">long</span> result = -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> ConsumeFromWhere consumeFromWhere = <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> OffsetStore offsetStore = <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">switch</span> (consumeFromWhere) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_MIN_OFFSET: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_MAX_OFFSET: <span class=\"comment\">// 废弃</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">11</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">12</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"comment\">// First start,no offset</span></div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     result = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</div><div class=\"line\"><span class=\"number\">21</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">26</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">29</span>:         &#125;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">34</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:                 result = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">36</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">38</span>:             &#125;</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">40</span>:         &#125;</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">case</span> CONSUME_FROM_TIMESTAMP: &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"keyword\">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">if</span> (lastOffset &gt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">44</span>:                 result = lastOffset;</div><div class=\"line\"><span class=\"number\">45</span>:             &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-<span class=\"number\">1</span> == lastOffset) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">48</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</div><div class=\"line\"><span class=\"number\">49</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">51</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">52</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">53</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">54</span>:                         <span class=\"keyword\">long</span> timestamp = UtilAll.parseDate(<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</div><div class=\"line\"><span class=\"number\">55</span>:                             UtilAll.YYYY_MMDD_HHMMSS).getTime();</div><div class=\"line\"><span class=\"number\">56</span>:                         result = <span class=\"keyword\">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</div><div class=\"line\"><span class=\"number\">57</span>:                     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">58</span>:                         result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">59</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">61</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">62</span>:                 result = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">63</span>:             &#125;</div><div class=\"line\"><span class=\"number\">64</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">65</span>:         &#125;</div><div class=\"line\"><span class=\"number\">66</span>: </div><div class=\"line\"><span class=\"number\">67</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">68</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: </div><div class=\"line\"><span class=\"number\">71</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">72</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：计算消息队列开始消费位置。</li>\n<li><code>PushConsumer</code> 读取消费进度有三种选项：<ul>\n<li><code>CONSUME_FROM_LAST_OFFSET</code> ：第 6 至 29 行 ：一个新的消费集群第一次启动从<strong>队列的最后位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n<li><code>CONSUME_FROM_FIRST_OFFSET</code> ：第 30 至 40 行 ：一个新的消费集群第一次启动从队列的<strong>最前位置</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n<li><code>CONSUME_FROM_TIMESTAMP</code> ：第 41 至 65 行 ：一个新的消费集群第一次启动从<strong>指定时间点</strong>开始消费。<strong>后续再启动接着上次消费的进度开始消费</strong>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PullConsumer-RebalancePullImpl-computePullFromWhere-…\"><a href=\"#PullConsumer-RebalancePullImpl-computePullFromWhere-…\" class=\"headerlink\" title=\"[PullConsumer] RebalancePullImpl#computePullFromWhere(…)\"></a><code>[PullConsumer]</code> RebalancePullImpl#computePullFromWhere(…)</h2><p>暂时跳过。😈</p>\n<h1 id=\"6、PushConsumer-拉取消息\"><a href=\"#6、PushConsumer-拉取消息\" class=\"headerlink\" title=\"6、PushConsumer 拉取消息\"></a>6、PushConsumer 拉取消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/05.png\" alt=\"DefaultMQPushConsumerImpl拉取消息\"></p>\n<h2 id=\"PullMessageService\"><a href=\"#PullMessageService\" class=\"headerlink\" title=\"PullMessageService\"></a>PullMessageService</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PullMessageService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ServiceThread</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger log = ClientLogger.getLog();</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 拉取消息请求队列</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LinkedBlockingQueue&lt;PullRequest&gt; pullRequestQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  8:      * MQClient对象</div><div class=\"line\">  9:      */</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MQClientInstance mQClientFactory;</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 定时器。用于延迟提交拉取请求</div><div class=\"line\"> 13:      */</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ScheduledExecutorService scheduledExecutorService = Executors</div><div class=\"line\"> <span class=\"number\">15</span>:         .newSingleThreadScheduledExecutor(<span class=\"keyword\">new</span> ThreadFactory() &#123;</div><div class=\"line\"> <span class=\"number\">16</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">17</span>:             <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">18</span>:                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Thread(r, <span class=\"string\">\"PullMessageServiceScheduledThread\"</span>);</div><div class=\"line\"> <span class=\"number\">19</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">20</span>:         &#125;);</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PullMessageService</span><span class=\"params\">(MQClientInstance mQClientFactory)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">this</span>.mQClientFactory = mQClientFactory;</div><div class=\"line\"> <span class=\"number\">24</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">25</span>: </div><div class=\"line\"> <span class=\"number\">26</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 27:      * 执行延迟拉取消息请求</div><div class=\"line\"> 28:      *</div><div class=\"line\"> 29:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 30:      * <span class=\"doctag\">@param</span> timeDelay 延迟时长</div><div class=\"line\"> 31:      */</div><div class=\"line\"> <span class=\"number\">32</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestLater</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeDelay)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">33</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">34</span>: </div><div class=\"line\"> <span class=\"number\">35</span>:             <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">36</span>:             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">37</span>:                 PullMessageService.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"> <span class=\"number\">38</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">39</span>:         &#125;, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\"> <span class=\"number\">40</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">41</span>: </div><div class=\"line\"> <span class=\"number\">42</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 43:      * 执行立即拉取消息请求</div><div class=\"line\"> 44:      *</div><div class=\"line\"> 45:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 46:      */</div><div class=\"line\"> <span class=\"number\">47</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executePullRequestImmediately</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">48</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">49</span>:             <span class=\"keyword\">this</span>.pullRequestQueue.put(pullRequest);</div><div class=\"line\"> <span class=\"number\">50</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">51</span>:             log.error(<span class=\"string\">\"executePullRequestImmediately pullRequestQueue.put\"</span>, e);</div><div class=\"line\"> <span class=\"number\">52</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">53</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">54</span>: </div><div class=\"line\"> <span class=\"number\">55</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 56:      * 执行延迟任务</div><div class=\"line\"> 57:      *</div><div class=\"line\"> 58:      * <span class=\"doctag\">@param</span> r 任务</div><div class=\"line\"> 59:      * <span class=\"doctag\">@param</span> timeDelay 延迟时长</div><div class=\"line\"> 60:      */</div><div class=\"line\"> <span class=\"number\">61</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeTaskLater</span><span class=\"params\">(<span class=\"keyword\">final</span> Runnable r, <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeDelay)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">62</span>:         <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(r, timeDelay, TimeUnit.MILLISECONDS);</div><div class=\"line\"> <span class=\"number\">63</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">64</span>: </div><div class=\"line\"> <span class=\"number\">65</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ScheduledExecutorService <span class=\"title\">getScheduledExecutorService</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">66</span>:         <span class=\"keyword\">return</span> scheduledExecutorService;</div><div class=\"line\"> <span class=\"number\">67</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">68</span>: </div><div class=\"line\"> <span class=\"number\">69</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 70:      * 拉取消息</div><div class=\"line\"> 71:      *</div><div class=\"line\"> 72:      * <span class=\"doctag\">@param</span> pullRequest 拉取消息请求</div><div class=\"line\"> 73:      */</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">pullMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">final</span> MQConsumerInner consumer = <span class=\"keyword\">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">76</span>:         <span class=\"keyword\">if</span> (consumer != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:             DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</div><div class=\"line\"> <span class=\"number\">78</span>:             impl.pullMessage(pullRequest);</div><div class=\"line\"> <span class=\"number\">79</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             log.warn(<span class=\"string\">\"No matched consumer for the PullRequest &#123;&#125;, drop it\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">82</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">83</span>: </div><div class=\"line\"> <span class=\"number\">84</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">85</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">86</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service started\"</span>);</div><div class=\"line\"> <span class=\"number\">87</span>: </div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>.isStopped()) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:                 PullRequest pullRequest = <span class=\"keyword\">this</span>.pullRequestQueue.take();</div><div class=\"line\"> <span class=\"number\">91</span>:                 <span class=\"keyword\">if</span> (pullRequest != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">92</span>:                     <span class=\"keyword\">this</span>.pullMessage(pullRequest);</div><div class=\"line\"> <span class=\"number\">93</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">94</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"> <span class=\"number\">95</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"> <span class=\"number\">96</span>:                 log.error(<span class=\"string\">\"Pull Message Service Run Method exception\"</span>, e);</div><div class=\"line\"> <span class=\"number\">97</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">98</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:         log.info(<span class=\"keyword\">this</span>.getServiceName() + <span class=\"string\">\" service end\"</span>);</div><div class=\"line\"><span class=\"number\">101</span>:     &#125;</div><div class=\"line\"><span class=\"number\">102</span>: </div><div class=\"line\"><span class=\"number\">103</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">104</span>:     <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getServiceName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">105</span>:         <span class=\"keyword\">return</span> PullMessageService.class.getSimpleName();</div><div class=\"line\"><span class=\"number\">106</span>:     &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：拉取消息服务，不断不断不断从 <code>Broker</code> 拉取消息，并提交消费任务到 <code>ConsumeMessageService</code>。</li>\n<li><code>#executePullRequestLater(...)</code> ：第 26 至 40 行 ： 提交<strong>延迟</strong>拉取消息请求。</li>\n<li><code>#executePullRequestImmediately(...)</code> ：第 42 至 53 行 ：提交<strong>立即</strong>拉取消息请求。</li>\n<li><code>#executeTaskLater(...)</code> ：第 55 至 63 行 ：提交<strong>延迟任务</strong>。</li>\n<li><code>#pullMessage(...)</code> ：第 69 至 82 行 ：执行拉取消息逻辑。详细解析见：<a href=\"#defaultmqpushconsumerimplpullmessage\">DefaultMQPushConsumerImpl#pullMessage(…)</a>。</li>\n<li><code>#run(...)</code> ：第 84 至 101 行 ：循环拉取消息请求队列( <code>pullRequestQueue</code> )，进行消息拉取。</li>\n</ul>\n<h2 id=\"DefaultMQPushConsumerImpl-pullMessage-…\"><a href=\"#DefaultMQPushConsumerImpl-pullMessage-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#pullMessage(…)\"></a>DefaultMQPushConsumerImpl#pullMessage(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pullMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (processQueue.isDropped()) &#123;</div><div class=\"line\">  <span class=\"number\">4</span>:         log.info(<span class=\"string\">\"the pull request[&#123;&#125;] is dropped.\"</span>, pullRequest.toString());</div><div class=\"line\">  <span class=\"number\">5</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\">  <span class=\"number\">6</span>:     &#125;</div><div class=\"line\">  <span class=\"number\">7</span>: </div><div class=\"line\">  <span class=\"number\">8</span>:     <span class=\"comment\">// 设置队列最后拉取消息时间</span></div><div class=\"line\">  <span class=\"number\">9</span>:     pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</div><div class=\"line\"> <span class=\"number\">10</span>: </div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">// 判断consumer状态是否运行中。如果不是，则延迟拉取消息。</span></div><div class=\"line\"> <span class=\"number\">12</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">13</span>:         <span class=\"keyword\">this</span>.makeSureStateOK();</div><div class=\"line\"> <span class=\"number\">14</span>:     &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"> <span class=\"number\">15</span>:         log.warn(<span class=\"string\">\"pullMessage exception, consumer state not ok\"</span>, e);</div><div class=\"line\"> <span class=\"number\">16</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">18</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">19</span>: </div><div class=\"line\"> <span class=\"number\">20</span>:     <span class=\"comment\">// 判断是否暂停中。</span></div><div class=\"line\"> <span class=\"number\">21</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isPause()) &#123;</div><div class=\"line\"> <span class=\"number\">22</span>:         log.warn(<span class=\"string\">\"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;\"</span>, <span class=\"keyword\">this</span>.defaultMQPushConsumer.getInstanceName(), <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">23</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">25</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">26</span>: </div><div class=\"line\"> <span class=\"number\">27</span>:     <span class=\"comment\">// 判断是否超过最大持有消息数量。默认最大值为1000。</span></div><div class=\"line\"> <span class=\"number\">28</span>:     <span class=\"keyword\">long</span> size = processQueue.getMsgCount().get();</div><div class=\"line\"> <span class=\"number\">29</span>:     <span class=\"keyword\">if</span> (size &gt; <span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</div><div class=\"line\"> <span class=\"number\">30</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); <span class=\"comment\">// 提交延迟消息拉取请求。50ms。</span></div><div class=\"line\"> <span class=\"number\">31</span>:         <span class=\"keyword\">if</span> ((flowControlTimes1++ % <span class=\"number\">1000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">32</span>:             log.warn(</div><div class=\"line\"> <span class=\"number\">33</span>:                 <span class=\"string\">\"the consumer message buffer is full, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, size=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">34</span>:                 processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), size, pullRequest, flowControlTimes1);</div><div class=\"line\"> <span class=\"number\">35</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">37</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">38</span>: </div><div class=\"line\"> <span class=\"number\">39</span>:     <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.consumeOrderly) &#123; <span class=\"comment\">// 判断消息跨度是否过大。</span></div><div class=\"line\"> <span class=\"number\">40</span>:         <span class=\"keyword\">if</span> (processQueue.getMaxSpan() &gt; <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</div><div class=\"line\"> <span class=\"number\">41</span>:             <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); <span class=\"comment\">// 提交延迟消息拉取请求。50ms。</span></div><div class=\"line\"> <span class=\"number\">42</span>:             <span class=\"keyword\">if</span> ((flowControlTimes2++ % <span class=\"number\">1000</span>) == <span class=\"number\">0</span>) &#123;</div><div class=\"line\"> <span class=\"number\">43</span>:                 log.warn(</div><div class=\"line\"> <span class=\"number\">44</span>:                     <span class=\"string\">\"the queue's messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">45</span>:                     processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</div><div class=\"line\"> <span class=\"number\">46</span>:                     pullRequest, flowControlTimes2);</div><div class=\"line\"> <span class=\"number\">47</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">48</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">49</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">50</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// TODO 顺序消费</span></div><div class=\"line\"> <span class=\"number\">51</span>:         <span class=\"keyword\">if</span> (processQueue.isLocked()) &#123;</div><div class=\"line\"> <span class=\"number\">52</span>:             <span class=\"keyword\">if</span> (!pullRequest.isLockedFirst()) &#123;</div><div class=\"line\"> <span class=\"number\">53</span>:                 <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset = <span class=\"keyword\">this</span>.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</div><div class=\"line\"> <span class=\"number\">54</span>:                 <span class=\"keyword\">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</div><div class=\"line\"> <span class=\"number\">55</span>:                 log.info(<span class=\"string\">\"the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">56</span>:                     pullRequest, offset, brokerBusy);</div><div class=\"line\"> <span class=\"number\">57</span>:                 <span class=\"keyword\">if</span> (brokerBusy) &#123;</div><div class=\"line\"> <span class=\"number\">58</span>:                     log.info(<span class=\"string\">\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">59</span>:                         pullRequest, offset);</div><div class=\"line\"> <span class=\"number\">60</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">61</span>: </div><div class=\"line\"> <span class=\"number\">62</span>:                 pullRequest.setLockedFirst(<span class=\"keyword\">true</span>);</div><div class=\"line\"> <span class=\"number\">63</span>:                 pullRequest.setNextOffset(offset);</div><div class=\"line\"> <span class=\"number\">64</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">65</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">66</span>:             <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">67</span>:             log.info(<span class=\"string\">\"pull message later because not locked in broker, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">68</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">70</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">71</span>: </div><div class=\"line\"> <span class=\"number\">72</span>:     <span class=\"comment\">// 获取Topic 对应的订阅信息。若不存在，则延迟拉取消息</span></div><div class=\"line\"> <span class=\"number\">73</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData = <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</div><div class=\"line\"> <span class=\"number\">74</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == subscriptionData) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"> <span class=\"number\">76</span>:         log.warn(<span class=\"string\">\"find the consumer's subscription failed, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"> <span class=\"number\">77</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">78</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">79</span>: </div><div class=\"line\"> <span class=\"number\">80</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">81</span>: </div><div class=\"line\"> <span class=\"number\">82</span>:     PullCallback pullCallback = <span class=\"keyword\">new</span> PullCallback() &#123;</div><div class=\"line\"> <span class=\"number\">83</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">84</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(PullResult pullResult)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">85</span>:             <span class=\"keyword\">if</span> (pullResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">86</span>:                 pullResult = DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</div><div class=\"line\"> <span class=\"number\">87</span>:                     subscriptionData);</div><div class=\"line\"> <span class=\"number\">88</span>: </div><div class=\"line\"> <span class=\"number\">89</span>:                 <span class=\"keyword\">switch</span> (pullResult.getPullStatus()) &#123;</div><div class=\"line\"> <span class=\"number\">90</span>:                     <span class=\"keyword\">case</span> FOUND:</div><div class=\"line\"> <span class=\"number\">91</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"> <span class=\"number\">92</span>:                         <span class=\"keyword\">long</span> prevRequestOffset = pullRequest.getNextOffset();</div><div class=\"line\"> <span class=\"number\">93</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"> <span class=\"number\">94</span>: </div><div class=\"line\"> <span class=\"number\">95</span>:                         <span class=\"comment\">// 统计</span></div><div class=\"line\"> <span class=\"number\">96</span>:                         <span class=\"keyword\">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</div><div class=\"line\"> <span class=\"number\">97</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</div><div class=\"line\"> <span class=\"number\">98</span>:                             pullRequest.getMessageQueue().getTopic(), pullRT);</div><div class=\"line\"> <span class=\"number\">99</span>: </div><div class=\"line\"><span class=\"number\">100</span>:                         <span class=\"keyword\">long</span> firstMsgOffset = Long.MAX_VALUE;</div><div class=\"line\"><span class=\"number\">101</span>:                         <span class=\"keyword\">if</span> (pullResult.getMsgFoundList() == <span class=\"keyword\">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">102</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">103</span>:                         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">104</span>:                             firstMsgOffset = pullResult.getMsgFoundList().get(<span class=\"number\">0</span>).getQueueOffset();</div><div class=\"line\"><span class=\"number\">105</span>: </div><div class=\"line\"><span class=\"number\">106</span>:                             <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">107</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</div><div class=\"line\"><span class=\"number\">108</span>:                                 pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</div><div class=\"line\"><span class=\"number\">109</span>: </div><div class=\"line\"><span class=\"number\">110</span>:                             <span class=\"comment\">// 提交拉取到的消息到消息处理队列</span></div><div class=\"line\"><span class=\"number\">111</span>:                             <span class=\"keyword\">boolean</span> dispathToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</div><div class=\"line\"><span class=\"number\">112</span>: </div><div class=\"line\"><span class=\"number\">113</span>:                             <span class=\"comment\">// 提交消费请求</span></div><div class=\"line\"><span class=\"number\">114</span>:                             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.consumeMessageService.submitConsumeRequest(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">115</span>:                                 pullResult.getMsgFoundList(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">116</span>:                                 processQueue, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">117</span>:                                 pullRequest.getMessageQueue(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">118</span>:                                 dispathToConsume);</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>:                             <span class=\"comment\">// 提交下次拉取消息请求</span></div><div class=\"line\"><span class=\"number\">121</span>:                             <span class=\"keyword\">if</span> (DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">122</span>:                                 DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestLater(pullRequest,</div><div class=\"line\"><span class=\"number\">123</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullInterval());</div><div class=\"line\"><span class=\"number\">124</span>:                             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">125</span>:                                 DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">126</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">127</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">128</span>: </div><div class=\"line\"><span class=\"number\">129</span>:                         <span class=\"comment\">// 下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为BUG，输出log</span></div><div class=\"line\"><span class=\"number\">130</span>:                         <span class=\"keyword\">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">131</span>:                             || firstMsgOffset &lt; prevRequestOffset) &#123;</div><div class=\"line\"><span class=\"number\">132</span>:                             log.warn(</div><div class=\"line\"><span class=\"number\">133</span>:                                 <span class=\"string\">\"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">134</span>:                                 pullResult.getNextBeginOffset(), <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">135</span>:                                 firstMsgOffset, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">136</span>:                                 prevRequestOffset);</div><div class=\"line\"><span class=\"number\">137</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">138</span>: </div><div class=\"line\"><span class=\"number\">139</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">140</span>:                     <span class=\"keyword\">case</span> NO_NEW_MSG:</div><div class=\"line\"><span class=\"number\">141</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">142</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">143</span>: </div><div class=\"line\"><span class=\"number\">144</span>:                         <span class=\"comment\">// 持久化消费进度</span></div><div class=\"line\"><span class=\"number\">145</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.correctTagsOffset(pullRequest);</div><div class=\"line\"><span class=\"number\">146</span>: </div><div class=\"line\"><span class=\"number\">147</span>:                         <span class=\"comment\">// 立即提交拉取消息请求</span></div><div class=\"line\"><span class=\"number\">148</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">149</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">150</span>:                     <span class=\"keyword\">case</span> NO_MATCHED_MSG:</div><div class=\"line\"><span class=\"number\">151</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">152</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">153</span>: </div><div class=\"line\"><span class=\"number\">154</span>:                         <span class=\"comment\">// 持久化消费进度</span></div><div class=\"line\"><span class=\"number\">155</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.correctTagsOffset(pullRequest);</div><div class=\"line\"><span class=\"number\">156</span>: </div><div class=\"line\"><span class=\"number\">157</span>:                         <span class=\"comment\">// 提交立即拉取消息请求</span></div><div class=\"line\"><span class=\"number\">158</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestImmediately(pullRequest);</div><div class=\"line\"><span class=\"number\">159</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">160</span>:                     <span class=\"keyword\">case</span> OFFSET_ILLEGAL:</div><div class=\"line\"><span class=\"number\">161</span>:                         log.warn(<span class=\"string\">\"the pull request offset illegal, &#123;&#125; &#123;&#125;\"</span>, <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">162</span>:                             pullRequest.toString(), pullResult.toString());</div><div class=\"line\"><span class=\"number\">163</span>:                         <span class=\"comment\">// 设置下次拉取消息队列位置</span></div><div class=\"line\"><span class=\"number\">164</span>:                         pullRequest.setNextOffset(pullResult.getNextBeginOffset());</div><div class=\"line\"><span class=\"number\">165</span>: </div><div class=\"line\"><span class=\"number\">166</span>:                         <span class=\"comment\">// 设置消息处理队列为dropped</span></div><div class=\"line\"><span class=\"number\">167</span>:                         pullRequest.getProcessQueue().setDropped(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">168</span>: </div><div class=\"line\"><span class=\"number\">169</span>:                         <span class=\"comment\">// 提交延迟任务，进行消费处理队列移除。不立即移除的原因：可能有地方正在使用，避免受到影响。</span></div><div class=\"line\"><span class=\"number\">170</span>:                         DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executeTaskLater(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">171</span>: </div><div class=\"line\"><span class=\"number\">172</span>:                             <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">173</span>:                             <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">174</span>:                                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">175</span>:                                     <span class=\"comment\">// 更新消费进度，同步消费进度到Broker</span></div><div class=\"line\"><span class=\"number\">176</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</div><div class=\"line\"><span class=\"number\">177</span>:                                         pullRequest.getNextOffset(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">178</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">179</span>: </div><div class=\"line\"><span class=\"number\">180</span>:                                     <span class=\"comment\">// 移除消费处理队列</span></div><div class=\"line\"><span class=\"number\">181</span>:                                     DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">182</span>: </div><div class=\"line\"><span class=\"number\">183</span>:                                     log.warn(<span class=\"string\">\"fix the pull request offset, &#123;&#125;\"</span>, pullRequest);</div><div class=\"line\"><span class=\"number\">184</span>:                                 &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"><span class=\"number\">185</span>:                                     log.error(<span class=\"string\">\"executeTaskLater Exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">186</span>:                                 &#125;</div><div class=\"line\"><span class=\"number\">187</span>:                             &#125;</div><div class=\"line\"><span class=\"number\">188</span>:                         &#125;, <span class=\"number\">10000</span>);</div><div class=\"line\"><span class=\"number\">189</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">190</span>:                     <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">191</span>:                         <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">192</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">193</span>:             &#125;</div><div class=\"line\"><span class=\"number\">194</span>:         &#125;</div><div class=\"line\"><span class=\"number\">195</span>: </div><div class=\"line\"><span class=\"number\">196</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">197</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onException</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">198</span>:             <span class=\"keyword\">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</div><div class=\"line\"><span class=\"number\">199</span>:                 log.warn(<span class=\"string\">\"execute the pull request exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">200</span>:             &#125;</div><div class=\"line\"><span class=\"number\">201</span>: </div><div class=\"line\"><span class=\"number\">202</span>:             <span class=\"comment\">// 提交延迟拉取消息请求</span></div><div class=\"line\"><span class=\"number\">203</span>:             DefaultMQPushConsumerImpl.<span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"><span class=\"number\">204</span>:         &#125;</div><div class=\"line\"><span class=\"number\">205</span>:     &#125;;</div><div class=\"line\"><span class=\"number\">206</span>: </div><div class=\"line\"><span class=\"number\">207</span>:     <span class=\"comment\">// 集群消息模型下，计算提交的消费进度。</span></div><div class=\"line\"><span class=\"number\">208</span>:     <span class=\"keyword\">boolean</span> commitOffsetEnable = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">209</span>:     <span class=\"keyword\">long</span> commitOffsetValue = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">210</span>:     <span class=\"keyword\">if</span> (MessageModel.CLUSTERING == <span class=\"keyword\">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</div><div class=\"line\"><span class=\"number\">211</span>:         commitOffsetValue = <span class=\"keyword\">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</div><div class=\"line\"><span class=\"number\">212</span>:         <span class=\"keyword\">if</span> (commitOffsetValue &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">213</span>:             commitOffsetEnable = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">214</span>:         &#125;</div><div class=\"line\"><span class=\"number\">215</span>:     &#125;</div><div class=\"line\"><span class=\"number\">216</span>: </div><div class=\"line\"><span class=\"number\">217</span>:     <span class=\"comment\">// 计算请求的 订阅表达式 和 是否进行filtersrv过滤消息</span></div><div class=\"line\"><span class=\"number\">218</span>:     String subExpression = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">219</span>:     <span class=\"keyword\">boolean</span> classFilter = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">220</span>:     SubscriptionData sd = <span class=\"keyword\">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</div><div class=\"line\"><span class=\"number\">221</span>:     <span class=\"keyword\">if</span> (sd != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">222</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</div><div class=\"line\"><span class=\"number\">223</span>:             subExpression = sd.getSubString();</div><div class=\"line\"><span class=\"number\">224</span>:         &#125;</div><div class=\"line\"><span class=\"number\">225</span>: </div><div class=\"line\"><span class=\"number\">226</span>:         classFilter = sd.isClassFilterMode();</div><div class=\"line\"><span class=\"number\">227</span>:     &#125;</div><div class=\"line\"><span class=\"number\">228</span>: </div><div class=\"line\"><span class=\"number\">229</span>:     <span class=\"comment\">// 计算拉取消息系统标识</span></div><div class=\"line\"><span class=\"number\">230</span>:     <span class=\"keyword\">int</span> sysFlag = PullSysFlag.buildSysFlag(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">231</span>:         commitOffsetEnable, <span class=\"comment\">// commitOffset</span></div><div class=\"line\"><span class=\"number\">232</span>:         <span class=\"keyword\">true</span>, <span class=\"comment\">// suspend</span></div><div class=\"line\"><span class=\"number\">233</span>:         subExpression != <span class=\"keyword\">null</span>, <span class=\"comment\">// subscription</span></div><div class=\"line\"><span class=\"number\">234</span>:         classFilter <span class=\"comment\">// class filter</span></div><div class=\"line\"><span class=\"number\">235</span>:     );</div><div class=\"line\"><span class=\"number\">236</span>: </div><div class=\"line\"><span class=\"number\">237</span>:     <span class=\"comment\">// 执行拉取。如果拉取请求发生异常时，提交延迟拉取消息请求。</span></div><div class=\"line\"><span class=\"number\">238</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">239</span>:         <span class=\"keyword\">this</span>.pullAPIWrapper.pullKernelImpl(<span class=\"comment\">//</span></div><div class=\"line\"><span class=\"number\">240</span>:             pullRequest.getMessageQueue(), <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"number\">241</span>:             subExpression, <span class=\"comment\">// 2</span></div><div class=\"line\"><span class=\"number\">242</span>:             subscriptionData.getSubVersion(), <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"number\">243</span>:             pullRequest.getNextOffset(), <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"number\">244</span>:             <span class=\"keyword\">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class=\"comment\">// 5</span></div><div class=\"line\"><span class=\"number\">245</span>:             sysFlag, <span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"number\">246</span>:             commitOffsetValue, <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"number\">247</span>:             BROKER_SUSPEND_MAX_TIME_MILLIS, <span class=\"comment\">// 8</span></div><div class=\"line\"><span class=\"number\">248</span>:             CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, <span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"number\">249</span>:             CommunicationMode.ASYNC, <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"number\">250</span>:             pullCallback<span class=\"comment\">// 11</span></div><div class=\"line\"><span class=\"number\">251</span>:         );</div><div class=\"line\"><span class=\"number\">252</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">253</span>:         log.error(<span class=\"string\">\"pullKernelImpl exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">254</span>:         <span class=\"keyword\">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</div><div class=\"line\"><span class=\"number\">255</span>:     &#125;</div><div class=\"line\"><span class=\"number\">256</span>: &#125;</div><div class=\"line\"><span class=\"number\">257</span>: </div><div class=\"line\"><span class=\"number\">258</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">correctTagsOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> PullRequest pullRequest)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">259</span>:     <span class=\"keyword\">if</span> (<span class=\"number\">0L</span> == pullRequest.getProcessQueue().getMsgCount().get()) &#123;</div><div class=\"line\"><span class=\"number\">260</span>:         <span class=\"keyword\">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">261</span>:     &#125;</div><div class=\"line\"><span class=\"number\">262</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><code>#pullMessage(...)</code> 说明 ：拉取消息。<ul>\n<li>第 3 至 6 行 ：消息处理队列已经终止，不进行消息拉取。</li>\n<li>第 9 行 ：设置消息处理队列最后拉取消息时间。</li>\n<li>第 11 至 18 行 ：<code>Consumer</code> 未处于运行中状态，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 20 至 25 行 ： <code>Consumer</code> 处于暂停中，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 27 至 37 行 ：消息处理队列持有消息超过最大允许值（默认：1000条），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 39 至 49 行 ：<code>Consumer</code> 为<strong>并发消费</strong> 并且 消息队列持有消息跨度过大（消息跨度 = 持有消息最后一条和第一条的消息位置差，默认：2000），不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 50 至 70 行 ：<code>顺序消费</code> 相关跳过，详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-send-and-consume-orderly/\">《RocketMQ 源码分析 —— Message 顺序发送与消费》</a>。</li>\n<li>第 72 至 78 行 ：<code>Topic</code> 对应的订阅信息不存在，不进行消息拉取，提交<strong>延迟</strong>拉取消息请求。</li>\n<li>第 222 至 224 行 ：判断请求是否使用 <code>Consumer</code> <strong>本地</strong>的订阅信息( <code>SubscriptionData</code> )，而不使用 <code>Broker</code> 里的订阅信息。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…\">PullMessageProcessor#processRequest(…) 第 64 至 110 行代码</a>。</li>\n<li>第 226 行 ：是否开启过滤类过滤模式。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/filtersrv/\">《RocketMQ 源码分析 —— Filtersrv》</a>。</li>\n<li>第 229 至 235 行 ：计算拉取消息请求系统标识。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageRequestHeader\">PullMessageRequestHeader.sysFlag</a>。</li>\n<li>第 237 至 255 行 ：<ul>\n<li>执行消息拉取<strong>异步</strong>请求。详细解析见：<a href=\"#pullapiwrapperpullkernelimpl\">PullAPIWrapper#pullKernelImpl(…)</a>。</li>\n<li>当发起请求产生异常时，提交<strong>延迟</strong>拉取消息请求。对应 <code>Broker</code> 处理拉取消息逻辑见：<a href=\"http://www.yunai.me/RocketMQ/message-pull-and-consume-first/#PullMessageProcessor-processRequest-…\">PullMessageProcessor#processRequest(…)</a>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>PullCallback</code> ：拉取消息回调：<ul>\n<li>第 86 行 ：处理拉取结果。详细逻辑见：<a href=\"#pullapiwrapperprocesspullresult\">PullAPIWrapper#processPullResult(…)</a>。</li>\n<li>第 89 至 192 行 ：处理拉取状态结果：<ul>\n<li>第 90 至 139 行 ：拉取到消息( <code>FOUND</code> ) ：<ul>\n<li>第 91 至 93 行 ：设置下次拉取消息队列位置。</li>\n<li>第 95 至 97 行 ：统计。</li>\n<li>第 101 至 102 行 ：拉取到消息的消息列表为空，提交<strong>立即</strong>拉取消息请求。为什么会存在拉取到消息，但是消息结果未空呢？原因见：<a href=\"#pullapiwrapperprocesspullresult\">PullAPIWrapper#processPullResult(…)</a>。</li>\n<li>第 106 至 108 行 ：统计。</li>\n<li>第 111 行 ：提交拉取到的消息到消息处理队列。详细解析见：<a href=\"#processqueueputmessage\">ProcessQueue#putMessage(…)</a>。</li>\n<li>第 113 至 118 行 ：提交消费请求到 <code>ConsumeMessageService</code>。详细解析见：<a href=\"#consumemessageconcurrentlyservice\">ConsumeMessageConcurrentlyService</a>。</li>\n<li>第 120 至 126 行 ：根据拉取频率( <code>pullInterval</code> )，提交<strong>立即或者延迟</strong>拉取消息请求。默认拉取频率为 0ms ，提交<strong>立即</strong>拉取消息请求。</li>\n<li>第 129 至 137 行 ：下次拉取消息队列位置小于上次拉取消息队列位置 或者 第一条消息的消息队列位置小于上次拉取消息队列位置，则判定为<strong>BUG</strong>，输出警告日志。<ul>\n<li>第 140 至 149 行 ：没有新消息( <code>NO_NEW_MSG</code> ) ：</li>\n</ul>\n</li>\n<li>第 142 行 ： 设置下次拉取消息队列位置。</li>\n<li>第 145 行 ：更正消费进度。详细解析见：<code>#correctTagsOffset(...)</code>。</li>\n<li>第 148 行 ：提交<strong>立即</strong>拉取消息请求。<ul>\n<li>第 150 至 159 行 ：有新消息但是不匹配( <code>NO_MATCHED_MSG</code> )。逻辑同 <code>NO_NEW_MSG</code> 。</li>\n<li>第 160 至 189 行 ：拉取请求的消息队列位置不合法 (<code>OFFSET_ILLEGAL</code>)。</li>\n</ul>\n</li>\n<li>第 164 行 ：设置下次拉取消息队列位置。</li>\n<li>第 167 行 ：设置消息处理队列为 <code>dropped</code>。</li>\n<li>第 169 至 188 行 ：提交延迟任务，进行队列移除。<ul>\n<li>第 175 至 178 行 ：更新消费进度，同步消费进度到 <code>Broker</code>。</li>\n<li>第 181 行 ：移除消费处理队列。<ul>\n<li>疑问：为什么不立即移除？？？ <ul>\n<li>第 196 至 204 行 ：发生异常，提交<strong>延迟</strong>拉取消息请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>#correctTagsOffset(...)</code> ：更正消费进度。<ul>\n<li>第 258 至 261 行 ： 当消费处理队列持有消息数量为 <strong>0</strong> 时，更新消费进度为拉取请求的拉取消息队列位置。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"PullAPIWrapper-pullKernelImpl-…\"><a href=\"#PullAPIWrapper-pullKernelImpl-…\" class=\"headerlink\" title=\"PullAPIWrapper#pullKernelImpl(…)\"></a>PullAPIWrapper#pullKernelImpl(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 拉取消息核心方法</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> subExpression 订阅表达式</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> subVersion 订阅版本号</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> offset 拉取队列开始位置</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> maxNums 拉取消息数量</div><div class=\"line\"> 9:  * <span class=\"doctag\">@param</span> sysFlag 拉取请求系统标识</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> commitOffset 提交消费进度</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> brokerSuspendMaxTimeMillis broker挂起请求最大时间</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> timeoutMillis 请求broker超时时长</div><div class=\"line\">13:  * <span class=\"doctag\">@param</span> communicationMode 通讯模式</div><div class=\"line\">14:  * <span class=\"doctag\">@param</span> pullCallback 拉取回调</div><div class=\"line\">15:  * <span class=\"doctag\">@return</span> 拉取消息结果。只有通讯模式为同步时，才返回结果，否则返回null。</div><div class=\"line\">16:  * <span class=\"doctag\">@throws</span> MQClientException 当寻找不到 broker 时，或发生其他client异常</div><div class=\"line\">17:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">18:  * <span class=\"doctag\">@throws</span> MQBrokerException 当 broker 发生异常时。只有通讯模式为同步时才会发生该异常。</div><div class=\"line\">19:  * <span class=\"doctag\">@throws</span> InterruptedException 当发生中断异常时</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"function\"><span class=\"keyword\">protected</span> PullResult <span class=\"title\">pullKernelImpl</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">final</span> MessageQueue mq,</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"keyword\">final</span> String subExpression,</div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> subVersion,</div><div class=\"line\"><span class=\"number\">25</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> offset,</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxNums,</div><div class=\"line\"><span class=\"number\">27</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> sysFlag,</div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> commitOffset,</div><div class=\"line\"><span class=\"number\">29</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerSuspendMaxTimeMillis,</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"keyword\">final</span> CommunicationMode communicationMode,</div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">final</span> PullCallback pullCallback</div><div class=\"line\"><span class=\"number\">33</span>: ) <span class=\"keyword\">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 获取Broker信息</span></div><div class=\"line\"><span class=\"number\">35</span>:     FindBrokerResult findBrokerResult =</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">this</span>.recalculatePullFromWhichNode(mq), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == findBrokerResult) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:         <span class=\"keyword\">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</div><div class=\"line\"><span class=\"number\">40</span>:         findBrokerResult =</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(),</div><div class=\"line\"><span class=\"number\">42</span>:                 <span class=\"keyword\">this</span>.recalculatePullFromWhichNode(mq), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 请求拉取消息</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">if</span> (findBrokerResult != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:         <span class=\"keyword\">int</span> sysFlagInner = sysFlag;</div><div class=\"line\"><span class=\"number\">48</span>: </div><div class=\"line\"><span class=\"number\">49</span>:         <span class=\"keyword\">if</span> (findBrokerResult.isSlave()) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:             sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:         PullMessageRequestHeader requestHeader = <span class=\"keyword\">new</span> PullMessageRequestHeader();</div><div class=\"line\"><span class=\"number\">54</span>:         requestHeader.setConsumerGroup(<span class=\"keyword\">this</span>.consumerGroup);</div><div class=\"line\"><span class=\"number\">55</span>:         requestHeader.setTopic(mq.getTopic());</div><div class=\"line\"><span class=\"number\">56</span>:         requestHeader.setQueueId(mq.getQueueId());</div><div class=\"line\"><span class=\"number\">57</span>:         requestHeader.setQueueOffset(offset);</div><div class=\"line\"><span class=\"number\">58</span>:         requestHeader.setMaxMsgNums(maxNums);</div><div class=\"line\"><span class=\"number\">59</span>:         requestHeader.setSysFlag(sysFlagInner);</div><div class=\"line\"><span class=\"number\">60</span>:         requestHeader.setCommitOffset(commitOffset);</div><div class=\"line\"><span class=\"number\">61</span>:         requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</div><div class=\"line\"><span class=\"number\">62</span>:         requestHeader.setSubscription(subExpression);</div><div class=\"line\"><span class=\"number\">63</span>:         requestHeader.setSubVersion(subVersion);</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:         String brokerAddr = findBrokerResult.getBrokerAddr();</div><div class=\"line\"><span class=\"number\">66</span>:         <span class=\"keyword\">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123; <span class=\"comment\">// TODO filtersrv</span></div><div class=\"line\"><span class=\"number\">67</span>:             brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</div><div class=\"line\"><span class=\"number\">68</span>:         &#125;</div><div class=\"line\"><span class=\"number\">69</span>: </div><div class=\"line\"><span class=\"number\">70</span>:         PullResult pullResult = <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(</div><div class=\"line\"><span class=\"number\">71</span>:             brokerAddr,</div><div class=\"line\"><span class=\"number\">72</span>:             requestHeader,</div><div class=\"line\"><span class=\"number\">73</span>:             timeoutMillis,</div><div class=\"line\"><span class=\"number\">74</span>:             communicationMode,</div><div class=\"line\"><span class=\"number\">75</span>:             pullCallback);</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:         <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">78</span>:     &#125;</div><div class=\"line\"><span class=\"number\">79</span>: </div><div class=\"line\"><span class=\"number\">80</span>:     <span class=\"comment\">// Broker信息不存在，则抛出异常</span></div><div class=\"line\"><span class=\"number\">81</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">\"The broker[\"</span> + mq.getBrokerName() + <span class=\"string\">\"] not exist\"</span>, <span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">82</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：拉取消息核心方法。<strong>该方法参数较多，可以看下代码注释上每个参数的说明</strong>😈。</li>\n<li>第 34 至 43 行 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。<ul>\n<li><a href=\"#pullapiwrapperrecalculatepullfromwhichnode\">#recalculatePullFromWhichNode(…)</a></li>\n<li><a href=\"#mqclientinstancefindbrokeraddressinsubscribe\">#MQClientInstance#findBrokerAddressInSubscribe(…)</a></li>\n</ul>\n</li>\n<li>第 45 至 78 行 ：<strong>请求拉取消息</strong>。</li>\n<li>第 81 行 ：当 <code>Broker</code> 信息不存在，则抛出异常。</li>\n</ul>\n<h4 id=\"PullAPIWrapper-recalculatePullFromWhichNode-…\"><a href=\"#PullAPIWrapper-recalculatePullFromWhichNode-…\" class=\"headerlink\" title=\"PullAPIWrapper#recalculatePullFromWhichNode(…)\"></a>PullAPIWrapper#recalculatePullFromWhichNode(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消息队列 与 拉取Broker 的映射</div><div class=\"line\"> 3:  * 当拉取消息时，会通过该映射获取拉取请求对应的Broker</div><div class=\"line\"> 4:  */</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"keyword\">private</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong<span class=\"comment\">/* brokerId */</span>&gt; pullFromWhichNodeTable =</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">new</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;(<span class=\"number\">32</span>);</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 8:  * 是否使用默认Broker</div><div class=\"line\"> 9:  */</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> connectBrokerByUser = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"comment\">/**</span></div><div class=\"line\">12:  * 默认Broker编号</div><div class=\"line\">13:  */</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> defaultBrokerId = MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>: <span class=\"comment\">/**</span></div><div class=\"line\">17:  * 计算消息队列拉取消息对应的Broker编号</div><div class=\"line\">18:  *</div><div class=\"line\">19:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\">20:  * <span class=\"doctag\">@return</span> Broker编号</div><div class=\"line\">21:  */</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">recalculatePullFromWhichNode</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">23</span>:     <span class=\"comment\">// 若开启默认Broker开关，则返回默认Broker编号</span></div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.isConnectBrokerByUser()) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.defaultBrokerId;</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: </div><div class=\"line\"><span class=\"number\">28</span>:     <span class=\"comment\">// 若消息队列映射拉取Broker存在，则返回映射Broker编号</span></div><div class=\"line\"><span class=\"number\">29</span>:     AtomicLong suggest = <span class=\"keyword\">this</span>.pullFromWhichNodeTable.get(mq);</div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">if</span> (suggest != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"keyword\">return</span> suggest.get();</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 返回Broker主节点编号</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">return</span> MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">36</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：计算消息队列拉取消息对应的 <code>Broker</code> 编号。</li>\n</ul>\n<h4 id=\"MQClientInstance-findBrokerAddressInSubscribe-…\"><a href=\"#MQClientInstance-findBrokerAddressInSubscribe-…\" class=\"headerlink\" title=\"MQClientInstance#findBrokerAddressInSubscribe(…)\"></a>MQClientInstance#findBrokerAddressInSubscribe(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * Broker名字 和 Broker地址相关 Map</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;String<span class=\"comment\">/* Broker Name */</span>, HashMap&lt;Long<span class=\"comment\">/* brokerId */</span>, String<span class=\"comment\">/* address */</span>&gt;&gt; brokerAddrTable =</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 8:  * 获得Broker信息</div><div class=\"line\"> 9:  *</div><div class=\"line\">10:  * <span class=\"doctag\">@param</span> brokerName broker名字</div><div class=\"line\">11:  * <span class=\"doctag\">@param</span> brokerId broker编号</div><div class=\"line\">12:  * <span class=\"doctag\">@param</span> onlyThisBroker 是否必须是该broker</div><div class=\"line\">13:  * <span class=\"doctag\">@return</span> Broker信息</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">public</span> FindBrokerResult <span class=\"title\">findBrokerAddressInSubscribe</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">final</span> String brokerName, //</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> brokerId, //</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> onlyThisBroker//</div><div class=\"line\"><span class=\"number\">19</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:     String brokerAddr = <span class=\"keyword\">null</span>; <span class=\"comment\">// broker地址</span></div><div class=\"line\"><span class=\"number\">21</span>:     <span class=\"keyword\">boolean</span> slave = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否为从节点</span></div><div class=\"line\"><span class=\"number\">22</span>:     <span class=\"keyword\">boolean</span> found = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否找到</span></div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:     <span class=\"comment\">// 获得Broker信息</span></div><div class=\"line\"><span class=\"number\">25</span>:     HashMap&lt;Long<span class=\"comment\">/* brokerId */</span>, String<span class=\"comment\">/* address */</span>&gt; map = <span class=\"keyword\">this</span>.brokerAddrTable.get(brokerName);</div><div class=\"line\"><span class=\"number\">26</span>:     <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span> &amp;&amp; !map.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:         brokerAddr = map.get(brokerId);</div><div class=\"line\"><span class=\"number\">28</span>:         slave = brokerId != MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">29</span>:         found = brokerAddr != <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:         <span class=\"comment\">// 如果不强制获得，选择一个Broker</span></div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"keyword\">if</span> (!found &amp;&amp; !onlyThisBroker) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:             Entry&lt;Long, String&gt; entry = map.entrySet().iterator().next();</div><div class=\"line\"><span class=\"number\">34</span>:             brokerAddr = entry.getValue();</div><div class=\"line\"><span class=\"number\">35</span>:             slave = entry.getKey() != MixAll.MASTER_ID;</div><div class=\"line\"><span class=\"number\">36</span>:             found = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>:     &#125;</div><div class=\"line\"><span class=\"number\">39</span>: </div><div class=\"line\"><span class=\"number\">40</span>:     <span class=\"comment\">// 找到broker，则返回信息</span></div><div class=\"line\"><span class=\"number\">41</span>:     <span class=\"keyword\">if</span> (found) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FindBrokerResult(brokerAddr, slave);</div><div class=\"line\"><span class=\"number\">43</span>:     &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:     <span class=\"comment\">// 找不到，则返回空</span></div><div class=\"line\"><span class=\"number\">46</span>:     <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">47</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：获取 <code>Broker</code> 信息(<code>Broker</code> 地址、是否为从节点)。</li>\n</ul>\n<h3 id=\"PullAPIWrapper-processPullResult-…\"><a href=\"#PullAPIWrapper-processPullResult-…\" class=\"headerlink\" title=\"PullAPIWrapper#processPullResult(…)\"></a>PullAPIWrapper#processPullResult(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 处理拉取结果</div><div class=\"line\"> 3:  * 1. 更新消息队列拉取消息Broker编号的映射</div><div class=\"line\"> 4:  * 2. 解析消息，并根据订阅信息消息tagCode匹配合适消息</div><div class=\"line\"> 5:  *</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> mq 消息队列</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> pullResult 拉取结果</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> subscriptionData 订阅信息</div><div class=\"line\"> 9:  * <span class=\"doctag\">@return</span> 拉取结果</div><div class=\"line\">10:  */</div><div class=\"line\"><span class=\"number\">11</span>: <span class=\"function\"><span class=\"keyword\">public</span> PullResult <span class=\"title\">processPullResult</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> PullResult pullResult,</span></span></div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> SubscriptionData subscriptionData) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:     PullResultExt pullResultExt = (PullResultExt) pullResult;</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"comment\">// 更新消息队列拉取消息Broker编号的映射</span></div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">this</span>.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"comment\">// 解析消息，并根据订阅信息消息tagCode匹配合适消息</span></div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">if</span> (PullStatus.FOUND == pullResult.getPullStatus()) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:         <span class=\"comment\">// 解析消息</span></div><div class=\"line\"><span class=\"number\">21</span>:         ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());</div><div class=\"line\"><span class=\"number\">22</span>:         List&lt;MessageExt&gt; msgList = MessageDecoder.decodes(byteBuffer);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"comment\">// 根据订阅信息消息tagCode匹配合适消息</span></div><div class=\"line\"><span class=\"number\">25</span>:         List&lt;MessageExt&gt; msgListFilterAgain = msgList;</div><div class=\"line\"><span class=\"number\">26</span>:         <span class=\"keyword\">if</span> (!subscriptionData.getTagsSet().isEmpty() &amp;&amp; !subscriptionData.isClassFilterMode()) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:             msgListFilterAgain = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(msgList.size());</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgList) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                 <span class=\"keyword\">if</span> (msg.getTags() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">30</span>:                     <span class=\"keyword\">if</span> (subscriptionData.getTagsSet().contains(msg.getTags())) &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                         msgListFilterAgain.add(msg);</div><div class=\"line\"><span class=\"number\">32</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">33</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">34</span>:             &#125;</div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>: </div><div class=\"line\"><span class=\"number\">37</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasHook()) &#123;</div><div class=\"line\"><span class=\"number\">39</span>:             FilterMessageContext filterMessageContext = <span class=\"keyword\">new</span> FilterMessageContext();</div><div class=\"line\"><span class=\"number\">40</span>:             filterMessageContext.setUnitMode(unitMode);</div><div class=\"line\"><span class=\"number\">41</span>:             filterMessageContext.setMsgList(msgListFilterAgain);</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"keyword\">this</span>.executeHook(filterMessageContext);</div><div class=\"line\"><span class=\"number\">43</span>:         &#125;</div><div class=\"line\"><span class=\"number\">44</span>: </div><div class=\"line\"><span class=\"number\">45</span>:         <span class=\"comment\">// 设置消息队列当前最小/最大位置到消息拓展字段</span></div><div class=\"line\"><span class=\"number\">46</span>:         <span class=\"keyword\">for</span> (MessageExt msg : msgListFilterAgain) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MIN_OFFSET,</div><div class=\"line\"><span class=\"number\">48</span>:                 Long.toString(pullResult.getMinOffset()));</div><div class=\"line\"><span class=\"number\">49</span>:             MessageAccessor.putProperty(msg, MessageConst.PROPERTY_MAX_OFFSET,</div><div class=\"line\"><span class=\"number\">50</span>:                 Long.toString(pullResult.getMaxOffset()));</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:         <span class=\"comment\">// 设置消息列表</span></div><div class=\"line\"><span class=\"number\">54</span>:         pullResultExt.setMsgFoundList(msgListFilterAgain);</div><div class=\"line\"><span class=\"number\">55</span>:     &#125;</div><div class=\"line\"><span class=\"number\">56</span>: </div><div class=\"line\"><span class=\"number\">57</span>:     <span class=\"comment\">// 清空消息二进制数组</span></div><div class=\"line\"><span class=\"number\">58</span>:     pullResultExt.setMessageBinary(<span class=\"keyword\">null</span>);</div><div class=\"line\"><span class=\"number\">59</span>: </div><div class=\"line\"><span class=\"number\">60</span>:     <span class=\"keyword\">return</span> pullResult;</div><div class=\"line\"><span class=\"number\">61</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：处理拉取结果。<ul>\n<li>更新消息队列拉取消息 <code>Broker</code> 编号的映射。</li>\n<li>解析消息，并根据订阅信息消息 <code>tagCode</code>匹配合适消息。</li>\n</ul>\n</li>\n<li>第 16 行 ：更新消息队列拉取消息 <code>Broker</code> 编号的映射。下次拉取消息时，如果未设置默认拉取的 <code>Broker</code> 编号，会使用更新后的 <code>Broker</code> 编号。</li>\n<li>第 18 至 55 行 ：解析消息，并根据订阅信息消息 <code>tagCode</code> 匹配合适消息。<ul>\n<li>第 20 至 22 行 ：解析消息。详细解析见：<a href=\"http://www.yunai.me/RocketMQ/message/\">《RocketMQ 源码分析 —— Message基础》</a> 。</li>\n<li>第 24 至 35 行 ：根据订阅信息<code>tagCode</code> 匹配消息。</li>\n<li>第 37 至 43 行 ：<code>Hook</code>。</li>\n<li>第 45 至 51 行 ：设置消息队列当前最小/最大位置到消息拓展字段。</li>\n<li>第 54 行 ：设置消息队列。</li>\n</ul>\n</li>\n<li>第 58 行 ：清空消息二进制数组。</li>\n</ul>\n<h3 id=\"ProcessQueue-putMessage-…\"><a href=\"#ProcessQueue-putMessage-…\" class=\"headerlink\" title=\"ProcessQueue#putMessage(…)\"></a>ProcessQueue#putMessage(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>:  <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消息映射读写锁</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock lockTreeMap = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 6:  * 消息映射</div><div class=\"line\"> 7:  * key：消息队列位置</div><div class=\"line\"> 8:  */</div><div class=\"line\"> <span class=\"number\">9</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"comment\">/**</span></div><div class=\"line\">11:  * 消息数</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicLong msgCount = <span class=\"keyword\">new</span> AtomicLong();</div><div class=\"line\"><span class=\"number\">14</span>: <span class=\"comment\">/**</span></div><div class=\"line\">15:  * 添加消息最大队列位置</div><div class=\"line\">16:  */</div><div class=\"line\"><span class=\"number\">17</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> queueOffsetMax = <span class=\"number\">0L</span>;</div><div class=\"line\"><span class=\"number\">18</span>: <span class=\"comment\">/**</span></div><div class=\"line\">19:  * 是否正在消费</div><div class=\"line\">20:  */</div><div class=\"line\"><span class=\"number\">21</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> consuming = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">22</span>: <span class=\"comment\">/**</span></div><div class=\"line\">23:  * Broker累计消息数量</div><div class=\"line\">24:  * 计算公式 = queueMaxOffset - 新添加消息数组[n - 1].queueOffset</div><div class=\"line\">25:  * Acc = Accumulation</div><div class=\"line\">26:  * cnt = （猜测）对比度</div><div class=\"line\">27:  */</div><div class=\"line\"><span class=\"number\">28</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> msgAccCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>: <span class=\"comment\">/**</span></div><div class=\"line\">31:  * 添加消息，并返回是否提交给消费者</div><div class=\"line\">32:  * 返回true，当有新消息添加成功时，</div><div class=\"line\">33:  *</div><div class=\"line\">34:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\">35:  * <span class=\"doctag\">@return</span> 是否提交给消费者</div><div class=\"line\">36:  */</div><div class=\"line\"><span class=\"number\">37</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">boolean</span> dispatchToConsume = <span class=\"keyword\">false</span>;</div><div class=\"line\"><span class=\"number\">39</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">40</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">41</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">42</span>:             <span class=\"comment\">// 添加消息</span></div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"keyword\">int</span> validMsgCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">44</span>:             <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">45</span>:                 MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);</div><div class=\"line\"><span class=\"number\">46</span>:                 <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == old) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                     validMsgCnt++;</div><div class=\"line\"><span class=\"number\">48</span>:                     <span class=\"keyword\">this</span>.queueOffsetMax = msg.getQueueOffset();</div><div class=\"line\"><span class=\"number\">49</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">50</span>:             &#125;</div><div class=\"line\"><span class=\"number\">51</span>:             msgCount.addAndGet(validMsgCnt);</div><div class=\"line\"><span class=\"number\">52</span>: </div><div class=\"line\"><span class=\"number\">53</span>:             <span class=\"comment\">// 计算是否正在消费</span></div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; !<span class=\"keyword\">this</span>.consuming) &#123;</div><div class=\"line\"><span class=\"number\">55</span>:                 dispatchToConsume = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">56</span>:                 <span class=\"keyword\">this</span>.consuming = <span class=\"keyword\">true</span>;</div><div class=\"line\"><span class=\"number\">57</span>:             &#125;</div><div class=\"line\"><span class=\"number\">58</span>: </div><div class=\"line\"><span class=\"number\">59</span>:             <span class=\"comment\">// Broker累计消息数量</span></div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">if</span> (!msgs.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">61</span>:                 MessageExt messageExt = msgs.get(msgs.size() - <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">62</span>:                 String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);</div><div class=\"line\"><span class=\"number\">63</span>:                 <span class=\"keyword\">if</span> (property != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">64</span>:                     <span class=\"keyword\">long</span> accTotal = Long.parseLong(property) - messageExt.getQueueOffset();</div><div class=\"line\"><span class=\"number\">65</span>:                     <span class=\"keyword\">if</span> (accTotal &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\"><span class=\"number\">66</span>:                         <span class=\"keyword\">this</span>.msgAccCnt = accTotal;</div><div class=\"line\"><span class=\"number\">67</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">68</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">69</span>:             &#125;</div><div class=\"line\"><span class=\"number\">70</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">71</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">72</span>:         &#125;</div><div class=\"line\"><span class=\"number\">73</span>:     &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">74</span>:         log.error(<span class=\"string\">\"putMessage exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">75</span>:     &#125;</div><div class=\"line\"><span class=\"number\">76</span>: </div><div class=\"line\"><span class=\"number\">77</span>:     <span class=\"keyword\">return</span> dispatchToConsume;</div><div class=\"line\"><span class=\"number\">78</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>如果用最简单粗暴的方式描述 <code>PullConsumer</code> 拉取消息的过程，那就是如下的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (不满足拉取消息) &#123;</div><div class=\"line\">        Thread.sleep(间隔);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    主动拉取消息();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"6、PushConsumer-消费消息\"><a href=\"#6、PushConsumer-消费消息\" class=\"headerlink\" title=\"6、PushConsumer 消费消息\"></a>6、PushConsumer 消费消息</h1><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/06.png\" alt=\"DefaultMQPushConsumerImpl消费消息\"></p>\n<h2 id=\"ConsumeMessageConcurrentlyService-提交消费请求\"><a href=\"#ConsumeMessageConcurrentlyService-提交消费请求\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService 提交消费请求\"></a>ConsumeMessageConcurrentlyService 提交消费请求</h2><h3 id=\"ConsumeMessageConcurrentlyService-submitConsumeRequest-…\"><a href=\"#ConsumeMessageConcurrentlyService-submitConsumeRequest-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#submitConsumeRequest(…)\"></a>ConsumeMessageConcurrentlyService#submitConsumeRequest(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 消费线程池队列</div><div class=\"line\"> 3:  */</div><div class=\"line\"> <span class=\"number\">4</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;</div><div class=\"line\"> <span class=\"number\">5</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 6:  * 消费线程池</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadPoolExecutor consumeExecutor;</div><div class=\"line\"> <span class=\"number\">9</span>: </div><div class=\"line\"><span class=\"number\">10</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequest</span><span class=\"params\">(//</span></span></div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue, //</div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">final</span> MessageQueue messageQueue, //</div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> dispatchToConsume) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> consumeBatchSize = <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">if</span> (msgs.size() &lt;= consumeBatchSize) &#123; <span class=\"comment\">// 提交消息小于批量消息数，直接提交消费请求</span></div><div class=\"line\"><span class=\"number\">17</span>:         ConsumeRequest consumeRequest = <span class=\"keyword\">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</div><div class=\"line\"><span class=\"number\">18</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest);</div><div class=\"line\"><span class=\"number\">20</span>:         &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class=\"line\"><span class=\"number\">22</span>:         &#125;</div><div class=\"line\"><span class=\"number\">23</span>:     &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 提交消息大于批量消息数，进行分拆成多个消费请求</span></div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> total = <span class=\"number\">0</span>; total &lt; msgs.size(); ) &#123;</div><div class=\"line\"><span class=\"number\">25</span>:             <span class=\"comment\">// 计算当前拆分请求包含的消息</span></div><div class=\"line\"><span class=\"number\">26</span>:             List&lt;MessageExt&gt; msgThis = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(consumeBatchSize);</div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                 <span class=\"keyword\">if</span> (total &lt; msgs.size()) &#123;</div><div class=\"line\"><span class=\"number\">29</span>:                     msgThis.add(msgs.get(total));</div><div class=\"line\"><span class=\"number\">30</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">31</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">33</span>:             &#125;</div><div class=\"line\"><span class=\"number\">34</span>: </div><div class=\"line\"><span class=\"number\">35</span>:             <span class=\"comment\">// 提交拆分消费请求</span></div><div class=\"line\"><span class=\"number\">36</span>:             ConsumeRequest consumeRequest = <span class=\"keyword\">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 <span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest);</div><div class=\"line\"><span class=\"number\">39</span>:             &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                 <span class=\"comment\">// 如果被拒绝，则将当前拆分消息+剩余消息提交延迟消费请求。</span></div><div class=\"line\"><span class=\"number\">41</span>:                 <span class=\"keyword\">for</span> (; total &lt; msgs.size(); total++) &#123;</div><div class=\"line\"><span class=\"number\">42</span>:                     msgThis.add(msgs.get(total));</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">44</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(consumeRequest);</div><div class=\"line\"><span class=\"number\">45</span>:             &#125;</div><div class=\"line\"><span class=\"number\">46</span>:         &#125;</div><div class=\"line\"><span class=\"number\">47</span>:     &#125;</div><div class=\"line\"><span class=\"number\">48</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交<strong>立即</strong>消费请求。</li>\n<li>第 16 至 22 行 ：提交消息小于等于批量消费数，直接提交消费请求。</li>\n<li>第 23 至 47 行 ：当提交消息大于批量消费数，进行分拆成多个请求。<ul>\n<li>第 25 至 33 行 ：计算当前拆分请求包含的消息。</li>\n<li>第 35 至 38 行 ：提交拆分消费请求。</li>\n<li>第 39 至 44 行 ：提交请求被拒绝，则将当前拆分消息 + 剩余消息提交延迟消费请求，结束拆分循环。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ConsumeMessageConcurrentlyService-submitConsumeRequestLater\"><a href=\"#ConsumeMessageConcurrentlyService-submitConsumeRequestLater\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#submitConsumeRequestLater\"></a>ConsumeMessageConcurrentlyService#submitConsumeRequestLater</h3> <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 提交延迟消费请求</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msgs 消息列表</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> processQueue 消息处理队列</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> messageQueue 消息队列</div><div class=\"line\"> 7:  */</div><div class=\"line\"> <span class=\"number\">8</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequestLater</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs, //</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">final</span> ProcessQueue processQueue, //</div><div class=\"line\"><span class=\"number\">11</span>:     <span class=\"keyword\">final</span> MessageQueue messageQueue//</div><div class=\"line\"><span class=\"number\">12</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">15</span>: </div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">18</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.submitConsumeRequest(msgs, processQueue, messageQueue, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">19</span>:         &#125;</div><div class=\"line\"><span class=\"number\">20</span>:     &#125;, <span class=\"number\">5000</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">21</span>: &#125;</div><div class=\"line\"><span class=\"number\">22</span>: </div><div class=\"line\"><span class=\"number\">23</span>: <span class=\"comment\">/**</span></div><div class=\"line\">24:  * 提交延迟消费请求</div><div class=\"line\">25:  * <span class=\"doctag\">@param</span> consumeRequest 消费请求</div><div class=\"line\">26:  */</div><div class=\"line\"><span class=\"number\">27</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">submitConsumeRequestLater</span><span class=\"params\">(<span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</span></span></div><div class=\"line\"><span class=\"number\">28</span>: ) &#123;</div><div class=\"line\"><span class=\"number\">29</span>: </div><div class=\"line\"><span class=\"number\">30</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">34</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumeExecutor.submit(consumeRequest); <span class=\"comment\">// TODO BUG ?</span></div><div class=\"line\"><span class=\"number\">35</span>:         &#125;</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;, <span class=\"number\">5000</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：提交延迟消费请求。</li>\n<li>第 34 行 ：直接调用 <code>ConsumeMessageConcurrentlyService.this.consumeExecutor.submit(consumeRequest);</code>。如果消息数超过批量消费上限，会不会是<strong>BUG</strong>。</li>\n</ul>\n<h2 id=\"ConsumeRequest\"><a href=\"#ConsumeRequest\" class=\"headerlink\" title=\"ConsumeRequest\"></a>ConsumeRequest</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\">  <span class=\"number\">1</span>: <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsumeRequest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</div><div class=\"line\">  <span class=\"number\">2</span>: </div><div class=\"line\">  <span class=\"number\">3</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  4:      * 消费消息列表</div><div class=\"line\">  5:      */</div><div class=\"line\">  <span class=\"number\">6</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs;</div><div class=\"line\">  <span class=\"number\">7</span>:     <span class=\"comment\">/**</span></div><div class=\"line\">  8:      * 消息处理队列</div><div class=\"line\">  9:      */</div><div class=\"line\"> <span class=\"number\">10</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ProcessQueue processQueue;</div><div class=\"line\"> <span class=\"number\">11</span>:     <span class=\"comment\">/**</span></div><div class=\"line\"> 12:      * 消息队列</div><div class=\"line\"> 13:      */</div><div class=\"line\"> <span class=\"number\">14</span>:     <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MessageQueue messageQueue;</div><div class=\"line\"> <span class=\"number\">15</span>: </div><div class=\"line\"> <span class=\"number\">16</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ConsumeRequest</span><span class=\"params\">(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.msgs = msgs;</div><div class=\"line\"> <span class=\"number\">18</span>:         <span class=\"keyword\">this</span>.processQueue = processQueue;</div><div class=\"line\"> <span class=\"number\">19</span>:         <span class=\"keyword\">this</span>.messageQueue = messageQueue;</div><div class=\"line\"> <span class=\"number\">20</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">21</span>: </div><div class=\"line\"> <span class=\"number\">22</span>:     <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">23</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">24</span>:         <span class=\"comment\">// 废弃队列不进行消费</span></div><div class=\"line\"> <span class=\"number\">25</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.processQueue.isDropped()) &#123;</div><div class=\"line\"> <span class=\"number\">26</span>:             log.info(<span class=\"string\">\"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;\"</span>, ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup, <span class=\"keyword\">this</span>.messageQueue);</div><div class=\"line\"> <span class=\"number\">27</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">28</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">29</span>: </div><div class=\"line\"> <span class=\"number\">30</span>:         MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.messageListener; <span class=\"comment\">// 监听器</span></div><div class=\"line\"> <span class=\"number\">31</span>:         ConsumeConcurrentlyContext context = <span class=\"keyword\">new</span> ConsumeConcurrentlyContext(messageQueue); <span class=\"comment\">// 消费Context</span></div><div class=\"line\"> <span class=\"number\">32</span>:         ConsumeConcurrentlyStatus status = <span class=\"keyword\">null</span>; <span class=\"comment\">// 消费结果状态</span></div><div class=\"line\"> <span class=\"number\">33</span>: </div><div class=\"line\"> <span class=\"number\">34</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"> <span class=\"number\">35</span>:         ConsumeMessageContext consumeMessageContext = <span class=\"keyword\">null</span>;</div><div class=\"line\"> <span class=\"number\">36</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"> <span class=\"number\">37</span>:             consumeMessageContext = <span class=\"keyword\">new</span> ConsumeMessageContext();</div><div class=\"line\"> <span class=\"number\">38</span>:             consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</div><div class=\"line\"> <span class=\"number\">39</span>:             consumeMessageContext.setProps(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;());</div><div class=\"line\"> <span class=\"number\">40</span>:             consumeMessageContext.setMq(messageQueue);</div><div class=\"line\"> <span class=\"number\">41</span>:             consumeMessageContext.setMsgList(msgs);</div><div class=\"line\"> <span class=\"number\">42</span>:             consumeMessageContext.setSuccess(<span class=\"keyword\">false</span>);</div><div class=\"line\"> <span class=\"number\">43</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</div><div class=\"line\"> <span class=\"number\">44</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">45</span>: </div><div class=\"line\"> <span class=\"number\">46</span>:         <span class=\"keyword\">long</span> beginTimestamp = System.currentTimeMillis();</div><div class=\"line\"> <span class=\"number\">47</span>:         <span class=\"keyword\">boolean</span> hasException = <span class=\"keyword\">false</span>;</div><div class=\"line\"> <span class=\"number\">48</span>:         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; <span class=\"comment\">// 消费返回结果类型</span></div><div class=\"line\"> <span class=\"number\">49</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">50</span>:             <span class=\"comment\">// 当消息为重试消息，设置Topic为原始Topic</span></div><div class=\"line\"> <span class=\"number\">51</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.resetRetryTopic(msgs);</div><div class=\"line\"> <span class=\"number\">52</span>: </div><div class=\"line\"> <span class=\"number\">53</span>:             <span class=\"comment\">// 设置开始消费时间</span></div><div class=\"line\"> <span class=\"number\">54</span>:             <span class=\"keyword\">if</span> (msgs != <span class=\"keyword\">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">55</span>:                 <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"> <span class=\"number\">56</span>:                     MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</div><div class=\"line\"> <span class=\"number\">57</span>:                 &#125;</div><div class=\"line\"> <span class=\"number\">58</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">59</span>: </div><div class=\"line\"> <span class=\"number\">60</span>:             <span class=\"comment\">// 进行消费</span></div><div class=\"line\"> <span class=\"number\">61</span>:             status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</div><div class=\"line\"> <span class=\"number\">62</span>:         &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\"> <span class=\"number\">63</span>:             log.warn(<span class=\"string\">\"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">64</span>:                 RemotingHelper.exceptionSimpleDesc(e), <span class=\"comment\">//</span></div><div class=\"line\"> <span class=\"number\">65</span>:                 ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"> <span class=\"number\">66</span>:                 msgs,</div><div class=\"line\"> <span class=\"number\">67</span>:                 messageQueue);</div><div class=\"line\"> <span class=\"number\">68</span>:             hasException = <span class=\"keyword\">true</span>;</div><div class=\"line\"> <span class=\"number\">69</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">70</span>: </div><div class=\"line\"> <span class=\"number\">71</span>:         <span class=\"comment\">// 解析消费返回结果类型</span></div><div class=\"line\"> <span class=\"number\">72</span>:         <span class=\"keyword\">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</div><div class=\"line\"> <span class=\"number\">73</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == status) &#123;</div><div class=\"line\"> <span class=\"number\">74</span>:             <span class=\"keyword\">if</span> (hasException) &#123;</div><div class=\"line\"> <span class=\"number\">75</span>:                 returnType = ConsumeReturnType.EXCEPTION;</div><div class=\"line\"> <span class=\"number\">76</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"> <span class=\"number\">77</span>:                 returnType = ConsumeReturnType.RETURNNULL;</div><div class=\"line\"> <span class=\"number\">78</span>:             &#125;</div><div class=\"line\"> <span class=\"number\">79</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"> <span class=\"number\">80</span>:             returnType = ConsumeReturnType.TIME_OUT;</div><div class=\"line\"> <span class=\"number\">81</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</div><div class=\"line\"> <span class=\"number\">82</span>:             returnType = ConsumeReturnType.FAILED;</div><div class=\"line\"> <span class=\"number\">83</span>:         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</div><div class=\"line\"> <span class=\"number\">84</span>:             returnType = ConsumeReturnType.SUCCESS;</div><div class=\"line\"> <span class=\"number\">85</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">86</span>: </div><div class=\"line\"> <span class=\"number\">87</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"> <span class=\"number\">88</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"> <span class=\"number\">89</span>:             consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</div><div class=\"line\"> <span class=\"number\">90</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">91</span>: </div><div class=\"line\"> <span class=\"number\">92</span>:         <span class=\"comment\">// 消费结果状态为空时，则设置为稍后重新消费</span></div><div class=\"line\"> <span class=\"number\">93</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == status) &#123;</div><div class=\"line\"> <span class=\"number\">94</span>:             log.warn(<span class=\"string\">\"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;\"</span>,</div><div class=\"line\"> <span class=\"number\">95</span>:                 ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup,</div><div class=\"line\"> <span class=\"number\">96</span>:                 msgs,</div><div class=\"line\"> <span class=\"number\">97</span>:                 messageQueue);</div><div class=\"line\"> <span class=\"number\">98</span>:             status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</div><div class=\"line\"> <span class=\"number\">99</span>:         &#125;</div><div class=\"line\"><span class=\"number\">100</span>: </div><div class=\"line\"><span class=\"number\">101</span>:         <span class=\"comment\">// Hook</span></div><div class=\"line\"><span class=\"number\">102</span>:         <span class=\"keyword\">if</span> (ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</div><div class=\"line\"><span class=\"number\">103</span>:             consumeMessageContext.setStatus(status.toString());</div><div class=\"line\"><span class=\"number\">104</span>:             consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</div><div class=\"line\"><span class=\"number\">105</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</div><div class=\"line\"><span class=\"number\">106</span>:         &#125;</div><div class=\"line\"><span class=\"number\">107</span>: </div><div class=\"line\"><span class=\"number\">108</span>:         <span class=\"comment\">// 统计</span></div><div class=\"line\"><span class=\"number\">109</span>:         ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.getConsumerStatsManager()</div><div class=\"line\"><span class=\"number\">110</span>:             .incConsumeRT(ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</div><div class=\"line\"><span class=\"number\">111</span>: </div><div class=\"line\"><span class=\"number\">112</span>:         <span class=\"comment\">// 处理消费结果</span></div><div class=\"line\"><span class=\"number\">113</span>:         <span class=\"keyword\">if</span> (!processQueue.isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">114</span>:             ConsumeMessageConcurrentlyService.<span class=\"keyword\">this</span>.processConsumeResult(status, context, <span class=\"keyword\">this</span>);</div><div class=\"line\"><span class=\"number\">115</span>:         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">116</span>:             log.warn(<span class=\"string\">\"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;\"</span>, messageQueue, msgs);</div><div class=\"line\"><span class=\"number\">117</span>:         &#125;</div><div class=\"line\"><span class=\"number\">118</span>:     &#125;</div><div class=\"line\"><span class=\"number\">119</span>: </div><div class=\"line\"><span class=\"number\">120</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：消费请求。提交请求执行消费。</li>\n<li>第 24 至 28 行 ：废弃处理队列不进行消费。</li>\n<li>第 34 至 44 行 ：Hook。</li>\n<li>第 51 行 ：当消息为重试消息，设置 <code>Topic</code>为原始 <code>Topic</code>。例如：原始 <code>Topic</code> 为 <code>TopicTest</code>，重试时 <code>Topic</code> 为 <code>%RETRY%please_rename_unique_group_name_4</code>，经过该方法，<code>Topic</code> 设置回 <code>TopicTest</code>。</li>\n<li>第 53 至 58 行 ：设置开始消费时间。</li>\n<li>第 61 行 ：<strong>进行消费</strong>。</li>\n<li>第 71 至 85 行 ：解析消费返回结果类型</li>\n<li>第 87 至 90 行 ：<code>Hook</code>。</li>\n<li>第 92 至 99 行 ：消费结果状态未空时，则设置消费结果状态为稍后消费。</li>\n<li>第 101 至 106 行 ：<code>Hook</code>。</li>\n<li>第 108 至 110 行 ：统计。</li>\n<li>第 112 至 117 行 ：处理消费结果。<strong>如果消费处理队列被移除，恰好消息被消费，则可能导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性</strong>。详细解析见：<a href=\"#consumemessageconcurrentlyserviceprocessconsumeresult\">ConsumeMessageConcurrentlyService#processConsumeResult(…)</a>。</li>\n</ul>\n<h2 id=\"ConsumeMessageConcurrentlyService-processConsumeResult-…\"><a href=\"#ConsumeMessageConcurrentlyService-processConsumeResult-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#processConsumeResult(…)\"></a>ConsumeMessageConcurrentlyService#processConsumeResult(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processConsumeResult</span><span class=\"params\">(//</span></span></div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">final</span> ConsumeConcurrentlyStatus status, //</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">final</span> ConsumeConcurrentlyContext context, //</div><div class=\"line\"> <span class=\"number\">4</span>:     <span class=\"keyword\">final</span> ConsumeRequest consumeRequest//</div><div class=\"line\"> <span class=\"number\">5</span>: ) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"keyword\">int</span> ackIndex = context.getAckIndex();</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"comment\">// 消息为空，直接返回</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">if</span> (consumeRequest.getMsgs().isEmpty())</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>:     <span class=\"comment\">// 计算从consumeRequest.msgs[0]到consumeRequest.msgs[ackIndex]的消息消费成功</span></div><div class=\"line\"><span class=\"number\">13</span>:     <span class=\"keyword\">switch</span> (status) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:         <span class=\"keyword\">case</span> CONSUME_SUCCESS:</div><div class=\"line\"><span class=\"number\">15</span>:             <span class=\"keyword\">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                 ackIndex = consumeRequest.getMsgs().size() - <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">17</span>:             &#125;</div><div class=\"line\"><span class=\"number\">18</span>:             <span class=\"comment\">// 统计成功/失败数量</span></div><div class=\"line\"><span class=\"number\">19</span>:             <span class=\"keyword\">int</span> ok = ackIndex + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">20</span>:             <span class=\"keyword\">int</span> failed = consumeRequest.getMsgs().size() - ok;</div><div class=\"line\"><span class=\"number\">21</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</div><div class=\"line\"><span class=\"number\">22</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</div><div class=\"line\"><span class=\"number\">23</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">24</span>:         <span class=\"keyword\">case</span> RECONSUME_LATER:</div><div class=\"line\"><span class=\"number\">25</span>:             ackIndex = -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">26</span>:             <span class=\"comment\">// 统计成功/失败数量</span></div><div class=\"line\"><span class=\"number\">27</span>:             <span class=\"keyword\">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</div><div class=\"line\"><span class=\"number\">28</span>:                 consumeRequest.getMsgs().size());</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">30</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"comment\">// 处理消费失败的消息</span></div><div class=\"line\"><span class=\"number\">35</span>:     <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</div><div class=\"line\"><span class=\"number\">36</span>:         <span class=\"keyword\">case</span> BROADCASTING: <span class=\"comment\">// 广播模式，无论是否消费失败，不发回消息到Broker，只打印Log</span></div><div class=\"line\"><span class=\"number\">37</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = ackIndex + <span class=\"number\">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                 MessageExt msg = consumeRequest.getMsgs().get(i);</div><div class=\"line\"><span class=\"number\">39</span>:                 log.warn(<span class=\"string\">\"BROADCASTING, the message consume failed, drop it, &#123;&#125;\"</span>, msg.toString());</div><div class=\"line\"><span class=\"number\">40</span>:             &#125;</div><div class=\"line\"><span class=\"number\">41</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">42</span>:         <span class=\"keyword\">case</span> CLUSTERING:</div><div class=\"line\"><span class=\"number\">43</span>:             <span class=\"comment\">// 发回消息失败到Broker。</span></div><div class=\"line\"><span class=\"number\">44</span>:             List&lt;MessageExt&gt; msgBackFailed = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(consumeRequest.getMsgs().size());</div><div class=\"line\"><span class=\"number\">45</span>:             <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = ackIndex + <span class=\"number\">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</div><div class=\"line\"><span class=\"number\">46</span>:                 MessageExt msg = consumeRequest.getMsgs().get(i);</div><div class=\"line\"><span class=\"number\">47</span>:                 <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">this</span>.sendMessageBack(msg, context);</div><div class=\"line\"><span class=\"number\">48</span>:                 <span class=\"keyword\">if</span> (!result) &#123;</div><div class=\"line\"><span class=\"number\">49</span>:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"number\">50</span>:                     msgBackFailed.add(msg);</div><div class=\"line\"><span class=\"number\">51</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">52</span>:             &#125;</div><div class=\"line\"><span class=\"number\">53</span>: </div><div class=\"line\"><span class=\"number\">54</span>:             <span class=\"comment\">// 发回Broker失败的消息，直接提交延迟重新消费</span></div><div class=\"line\"><span class=\"number\">55</span>:             <span class=\"keyword\">if</span> (!msgBackFailed.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">56</span>:                 consumeRequest.getMsgs().removeAll(msgBackFailed);</div><div class=\"line\"><span class=\"number\">57</span>: </div><div class=\"line\"><span class=\"number\">58</span>:                 <span class=\"keyword\">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</div><div class=\"line\"><span class=\"number\">59</span>:             &#125;</div><div class=\"line\"><span class=\"number\">60</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">61</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">62</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">63</span>:     &#125;</div><div class=\"line\"><span class=\"number\">64</span>: </div><div class=\"line\"><span class=\"number\">65</span>:     <span class=\"comment\">// 移除消费成功消息，并更新最新消费进度</span></div><div class=\"line\"><span class=\"number\">66</span>:     <span class=\"keyword\">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</div><div class=\"line\"><span class=\"number\">67</span>:     <span class=\"keyword\">if</span> (offset &gt;= <span class=\"number\">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</div><div class=\"line\"><span class=\"number\">68</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">69</span>:     &#125;</div><div class=\"line\"><span class=\"number\">70</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：处理消费结果。</li>\n<li>第 8 至 10 行 ：消费请求消息未空时，直接返回。</li>\n<li>第 12 至 32 行 ：计算 <code>ackIndex</code> 值。<code>consumeRequest.msgs[0 - ackIndex]</code>为消费成功，需要进行 <code>ack</code> 确认。<ul>\n<li>第 14 至 23 行 ：<code>CONSUME_SUCCESS</code> ：<code>ackIndex = context.getAckIndex()</code>。</li>\n<li>第 24 至 29 行 ：<code>RECONSUME_LATER</code> ：<code>ackIndex = -1</code>。</li>\n</ul>\n</li>\n<li>第34 至 63 行 ：处理消费失败的消息。<ul>\n<li>第 36 至 41 行 ：<code>BROADCASTING</code> ：广播模式，无论是否消费失败，不发回消息到 <code>Broker</code>，只打印日志。</li>\n<li>第 42 至 60 行 ：<code>CLUSTERING</code> ：集群模式，消费失败的消息发回到 <code>Broker</code>。<ul>\n<li>第 43 至 52 行 ：发回消费失败的消息到 <code>Broker</code>。详细解析见：<a href=\"#defaultmqpushconsumerimplsendmessageback\">DefaultMQPushConsumerImpl#sendMessageBack(…)</a>。</li>\n<li>第 54 至 59 行 ：发回 <code>Broker</code> 失败的消息，直接提交延迟重新消费。</li>\n<li><strong>如果发回 <code>Broker</code> 成功，结果因为例如网络异常，导致 <code>Consumer</code>以为发回失败，判定消费发回失败，会导致消息重复消费，因此，消息消费要尽最大可能性实现幂等性。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第 65 至 69 行 ：移除<strong>【消费成功】</strong>和<strong>【消费失败但发回<code>Broker</code>成功】</strong>的消息，并更新最新消费进度。<ul>\n<li>为什么会有<strong>【消费失败但发回<code>Broker</code>成功】</strong>的消息？见<strong>第 56 行</strong>。</li>\n<li><a href=\"#processqueueremovemessage\">ProcessQueue#removeMessage(…)</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ProcessQueue-removeMessage-…\"><a href=\"#ProcessQueue-removeMessage-…\" class=\"headerlink\" title=\"ProcessQueue#removeMessage(…)\"></a>ProcessQueue#removeMessage(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * 移除消息，并返回第一条消息队列位置</div><div class=\"line\"> 3:  *</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msgs 消息</div><div class=\"line\"> 5:  * <span class=\"doctag\">@return</span> 消息队列位置</div><div class=\"line\"> 6:  */</div><div class=\"line\"> <span class=\"number\">7</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">removeMessage</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">long</span> result = -<span class=\"number\">1</span>;</div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = System.currentTimeMillis();</div><div class=\"line\"><span class=\"number\">10</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">11</span>:         <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">this</span>.lastConsumeTimestamp = now;</div><div class=\"line\"><span class=\"number\">13</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 result = <span class=\"keyword\">this</span>.queueOffsetMax + <span class=\"number\">1</span>; <span class=\"comment\">// 这里+1的原因是：如果msgTreeMap为空时，下一条获得的消息位置为queueOffsetMax+1</span></div><div class=\"line\"><span class=\"number\">16</span>: </div><div class=\"line\"><span class=\"number\">17</span>:                 <span class=\"comment\">// 移除消息</span></div><div class=\"line\"><span class=\"number\">18</span>:                 <span class=\"keyword\">int</span> removedCnt = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"number\">19</span>:                 <span class=\"keyword\">for</span> (MessageExt msg : msgs) &#123;</div><div class=\"line\"><span class=\"number\">20</span>:                     MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());</div><div class=\"line\"><span class=\"number\">21</span>:                     <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         removedCnt--;</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:                 msgCount.addAndGet(removedCnt);</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:                 <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">28</span>:                     result = msgTreeMap.firstKey();</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:         &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:         log.error(<span class=\"string\">\"removeMessage exception\"</span>, t);</div><div class=\"line\"><span class=\"number\">36</span>:     &#125;</div><div class=\"line\"><span class=\"number\">37</span>: </div><div class=\"line\"><span class=\"number\">38</span>:     <span class=\"keyword\">return</span> result;</div><div class=\"line\"><span class=\"number\">39</span>: &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ConsumeMessageConcurrentlyService-cleanExpireMsg-…\"><a href=\"#ConsumeMessageConcurrentlyService-cleanExpireMsg-…\" class=\"headerlink\" title=\"ConsumeMessageConcurrentlyService#cleanExpireMsg(…)\"></a>ConsumeMessageConcurrentlyService#cleanExpireMsg(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">this</span>.cleanExpireMsgExecutors.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">3</span>: </div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:             cleanExpireMsg();</div><div class=\"line\"> <span class=\"number\">7</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     &#125;, <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeTimeout(), <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumeTimeout(), TimeUnit.MINUTES);</div><div class=\"line\"><span class=\"number\">10</span>: &#125;</div><div class=\"line\"><span class=\"number\">11</span>: </div><div class=\"line\"><span class=\"number\">12</span>: <span class=\"comment\">/**</span></div><div class=\"line\">13:  * 清理过期消息</div><div class=\"line\">14:  */</div><div class=\"line\"><span class=\"number\">15</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanExpireMsg</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">16</span>:     Iterator&lt;Map.Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it =</div><div class=\"line\"><span class=\"number\">17</span>:         <span class=\"keyword\">this</span>.defaultMQPushConsumerImpl.getRebalanceImpl().getProcessQueueTable().entrySet().iterator();</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">while</span> (it.hasNext()) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:         Map.Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</div><div class=\"line\"><span class=\"number\">20</span>:         ProcessQueue pq = next.getValue();</div><div class=\"line\"><span class=\"number\">21</span>:         pq.cleanExpiredMsg(<span class=\"keyword\">this</span>.defaultMQPushConsumer);</div><div class=\"line\"><span class=\"number\">22</span>:     &#125;</div><div class=\"line\"><span class=\"number\">23</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：定时清理过期消息，默认周期：15min。</li>\n</ul>\n<h3 id=\"ProcessQueue-cleanExpiredMsg-…\"><a href=\"#ProcessQueue-cleanExpiredMsg-…\" class=\"headerlink\" title=\"ProcessQueue#cleanExpiredMsg(…)\"></a>ProcessQueue#cleanExpiredMsg(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanExpiredMsg</span><span class=\"params\">(DefaultMQPushConsumer pushConsumer)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 顺序消费时，直接返回</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (pushConsumer.getDefaultMQPushConsumerImpl().isConsumeOrderly()) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">6</span>: </div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"comment\">// 循环移除消息</span></div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">int</span> loop = msgTreeMap.size() &lt; <span class=\"number\">16</span> ? msgTreeMap.size() : <span class=\"number\">16</span>; <span class=\"comment\">// 每次循环最多移除16条</span></div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; loop; i++) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 获取第一条消息。判断是否超时，若不超时，则结束循环</span></div><div class=\"line\"><span class=\"number\">11</span>:         MessageExt msg = <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">12</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:             <span class=\"keyword\">this</span>.lockTreeMap.readLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; System.currentTimeMillis() - Long.parseLong(MessageAccessor.getConsumeStartTimeStamp(msgTreeMap.firstEntry().getValue())) &gt; pushConsumer.getConsumeTimeout() * <span class=\"number\">60</span> * <span class=\"number\">1000</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     msg = msgTreeMap.firstEntry().getValue();</div><div class=\"line\"><span class=\"number\">17</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">18</span>:                     <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">19</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">20</span>:             &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">this</span>.lockTreeMap.readLock().unlock();</div><div class=\"line\"><span class=\"number\">22</span>:             &#125;</div><div class=\"line\"><span class=\"number\">23</span>:         &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:             log.error(<span class=\"string\">\"getExpiredMsg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">25</span>:         &#125;</div><div class=\"line\"><span class=\"number\">26</span>: </div><div class=\"line\"><span class=\"number\">27</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">28</span>:             <span class=\"comment\">// 发回超时消息</span></div><div class=\"line\"><span class=\"number\">29</span>:             pushConsumer.sendMessageBack(msg, <span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"number\">30</span>:             log.info(<span class=\"string\">\"send expire msg back. topic=&#123;&#125;, msgId=&#123;&#125;, storeHost=&#123;&#125;, queueId=&#123;&#125;, queueOffset=&#123;&#125;\"</span>, msg.getTopic(), msg.getMsgId(), msg.getStoreHost(), msg.getQueueId(), msg.getQueueOffset());</div><div class=\"line\"><span class=\"number\">31</span>: </div><div class=\"line\"><span class=\"number\">32</span>:             <span class=\"comment\">// 判断此时消息是否依然是第一条，若是，则进行移除</span></div><div class=\"line\"><span class=\"number\">33</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">34</span>:                 <span class=\"keyword\">this</span>.lockTreeMap.writeLock().lockInterruptibly();</div><div class=\"line\"><span class=\"number\">35</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">36</span>:                     <span class=\"keyword\">if</span> (!msgTreeMap.isEmpty() &amp;&amp; msg.getQueueOffset() == msgTreeMap.firstKey()) &#123;</div><div class=\"line\"><span class=\"number\">37</span>:                         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">38</span>:                             msgTreeMap.remove(msgTreeMap.firstKey());</div><div class=\"line\"><span class=\"number\">39</span>:                         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">40</span>:                             log.error(<span class=\"string\">\"send expired msg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">41</span>:                         &#125;</div><div class=\"line\"><span class=\"number\">42</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">43</span>:                 &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\"><span class=\"number\">44</span>:                     <span class=\"keyword\">this</span>.lockTreeMap.writeLock().unlock();</div><div class=\"line\"><span class=\"number\">45</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">46</span>:             &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\"><span class=\"number\">47</span>:                 log.error(<span class=\"string\">\"getExpiredMsg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">48</span>:             &#125;</div><div class=\"line\"><span class=\"number\">49</span>:         &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">50</span>:             log.error(<span class=\"string\">\"send expired msg exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">51</span>:         &#125;</div><div class=\"line\"><span class=\"number\">52</span>:     &#125;</div><div class=\"line\"><span class=\"number\">53</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：移除过期消息。</li>\n<li>第 2 至 5 行 ：顺序消费时，直接返回。</li>\n<li>第 7 至 9 行 ：循环移除消息。默认最大循环次数：16次。</li>\n<li>第 10 至 25 行 ：获取第一条消息。判断是否超时，若不超时，则结束循环。</li>\n<li>第 29 行 ：<strong>发回超时消息到<code>Broker</code></strong>。</li>\n<li>第 32 至 48 行 ：判断此时消息是否依然是第一条，若是，则进行移除。</li>\n</ul>\n<h1 id=\"7、PushConsumer-发回消费失败消息\"><a href=\"#7、PushConsumer-发回消费失败消息\" class=\"headerlink\" title=\"7、PushConsumer 发回消费失败消息\"></a>7、PushConsumer 发回消费失败消息</h1><h2 id=\"DefaultMQPushConsumerImpl-sendMessageBack-…\"><a href=\"#DefaultMQPushConsumerImpl-sendMessageBack-…\" class=\"headerlink\" title=\"DefaultMQPushConsumerImpl#sendMessageBack(…)\"></a>DefaultMQPushConsumerImpl#sendMessageBack(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessageBack</span><span class=\"params\">(MessageExt msg, <span class=\"keyword\">int</span> delayLevel, <span class=\"keyword\">final</span> String brokerName)</span></span></div><div class=\"line\"> 2:     <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException &#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"comment\">// Consumer发回消息</span></div><div class=\"line\"> <span class=\"number\">5</span>:         String brokerAddr = (<span class=\"keyword\">null</span> != brokerName) ? <span class=\"keyword\">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</div><div class=\"line\"> <span class=\"number\">6</span>:             : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</div><div class=\"line\"> <span class=\"number\">7</span>:         <span class=\"keyword\">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</div><div class=\"line\"> <span class=\"number\">8</span>:             <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class=\"number\">5000</span>, getMaxReconsumeTimes());</div><div class=\"line\"> <span class=\"number\">9</span>:     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; <span class=\"comment\">// TODO 疑问：什么情况下会发生异常</span></div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"comment\">// 异常时，使用Client内置Producer发回消息</span></div><div class=\"line\"><span class=\"number\">11</span>:         log.error(<span class=\"string\">\"sendMessageBack Exception, \"</span> + <span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</div><div class=\"line\"><span class=\"number\">12</span>: </div><div class=\"line\"><span class=\"number\">13</span>:         Message newMsg = <span class=\"keyword\">new</span> Message(MixAll.getRetryTopic(<span class=\"keyword\">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</div><div class=\"line\"><span class=\"number\">14</span>: </div><div class=\"line\"><span class=\"number\">15</span>:         String originMsgId = MessageAccessor.getOriginMessageId(msg);</div><div class=\"line\"><span class=\"number\">16</span>:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</div><div class=\"line\"><span class=\"number\">17</span>: </div><div class=\"line\"><span class=\"number\">18</span>:         newMsg.setFlag(msg.getFlag());</div><div class=\"line\"><span class=\"number\">19</span>:         MessageAccessor.setProperties(newMsg, msg.getProperties());</div><div class=\"line\"><span class=\"number\">20</span>:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</div><div class=\"line\"><span class=\"number\">21</span>:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class=\"number\">1</span>));</div><div class=\"line\"><span class=\"number\">22</span>:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</div><div class=\"line\"><span class=\"number\">23</span>:         newMsg.setDelayTimeLevel(<span class=\"number\">3</span> + msg.getReconsumeTimes());</div><div class=\"line\"><span class=\"number\">24</span>: </div><div class=\"line\"><span class=\"number\">25</span>:         <span class=\"keyword\">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</div><div class=\"line\"><span class=\"number\">26</span>:     &#125;</div><div class=\"line\"><span class=\"number\">27</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：发回消息。</li>\n<li>第 4 至 8 行 ：<code>Consumer</code> 发回消息。详细解析见：<a href=\"#mqclientapiimplconsumersendmessageback\">MQClientAPIImpl#consumerSendMessageBack(…)</a>。</li>\n<li>第 10 至 25 行 ：发生异常时，<code>Consumer</code> 内置默认 <code>Producer</code> 发送消息。<ul>\n<li>😈疑问：什么样的情况下会发生异常呢？</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MQClientAPIImpl-consumerSendMessageBack-…\"><a href=\"#MQClientAPIImpl-consumerSendMessageBack-…\" class=\"headerlink\" title=\"MQClientAPIImpl#consumerSendMessageBack(…)\"></a>MQClientAPIImpl#consumerSendMessageBack(…)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"comment\">/**</span></div><div class=\"line\"> 2:  * Consumer发回消息</div><div class=\"line\"> 3:  * <span class=\"doctag\">@param</span> addr Broker地址</div><div class=\"line\"> 4:  * <span class=\"doctag\">@param</span> msg 消息</div><div class=\"line\"> 5:  * <span class=\"doctag\">@param</span> consumerGroup 消费分组</div><div class=\"line\"> 6:  * <span class=\"doctag\">@param</span> delayLevel 延迟级别</div><div class=\"line\"> 7:  * <span class=\"doctag\">@param</span> timeoutMillis 超时</div><div class=\"line\"> 8:  * <span class=\"doctag\">@param</span> maxConsumeRetryTimes 消费最大重试次数</div><div class=\"line\"> 9:  * <span class=\"doctag\">@throws</span> RemotingException 当远程调用发生异常时</div><div class=\"line\">10:  * <span class=\"doctag\">@throws</span> MQBrokerException 当Broker发生异常时</div><div class=\"line\">11:  * <span class=\"doctag\">@throws</span> InterruptedException 当线程中断时</div><div class=\"line\">12:  */</div><div class=\"line\"><span class=\"number\">13</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">consumerSendMessageBack</span><span class=\"params\">(</span></span></div><div class=\"line\"><span class=\"number\">14</span>:     <span class=\"keyword\">final</span> String addr,</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">final</span> MessageExt msg,</div><div class=\"line\"><span class=\"number\">16</span>:     <span class=\"keyword\">final</span> String consumerGroup,</div><div class=\"line\"><span class=\"number\">17</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> delayLevel,</div><div class=\"line\"><span class=\"number\">18</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> timeoutMillis,</div><div class=\"line\"><span class=\"number\">19</span>:     <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConsumeRetryTimes</div><div class=\"line\"><span class=\"number\">20</span>: ) <span class=\"keyword\">throws</span> RemotingException, MQBrokerException, InterruptedException &#123;</div><div class=\"line\"><span class=\"number\">21</span>:     ConsumerSendMsgBackRequestHeader requestHeader = <span class=\"keyword\">new</span> ConsumerSendMsgBackRequestHeader();</div><div class=\"line\"><span class=\"number\">22</span>:     RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</div><div class=\"line\"><span class=\"number\">23</span>: </div><div class=\"line\"><span class=\"number\">24</span>:     requestHeader.setGroup(consumerGroup);</div><div class=\"line\"><span class=\"number\">25</span>:     requestHeader.setOriginTopic(msg.getTopic());</div><div class=\"line\"><span class=\"number\">26</span>:     requestHeader.setOffset(msg.getCommitLogOffset());</div><div class=\"line\"><span class=\"number\">27</span>:     requestHeader.setDelayLevel(delayLevel);</div><div class=\"line\"><span class=\"number\">28</span>:     requestHeader.setOriginMsgId(msg.getMsgId());</div><div class=\"line\"><span class=\"number\">29</span>:     requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     RemotingCommand response = <span class=\"keyword\">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class=\"keyword\">this</span>.clientConfig.isVipChannelEnabled(), addr),</div><div class=\"line\"><span class=\"number\">32</span>:         request, timeoutMillis);</div><div class=\"line\"><span class=\"number\">33</span>:     <span class=\"keyword\">assert</span> response != <span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"keyword\">switch</span> (response.getCode()) &#123;</div><div class=\"line\"><span class=\"number\">35</span>:         <span class=\"keyword\">case</span> ResponseCode.SUCCESS: &#123;</div><div class=\"line\"><span class=\"number\">36</span>:             <span class=\"keyword\">return</span>;</div><div class=\"line\"><span class=\"number\">37</span>:         &#125;</div><div class=\"line\"><span class=\"number\">38</span>:         <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">39</span>:             <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">40</span>:     &#125;</div><div class=\"line\"><span class=\"number\">41</span>: </div><div class=\"line\"><span class=\"number\">42</span>:     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQBrokerException(response.getCode(), response.getRemark());</div><div class=\"line\"><span class=\"number\">43</span>: &#125;</div></pre></td></tr></table></figure>\n<h1 id=\"8、Consumer-消费进度\"><a href=\"#8、Consumer-消费进度\" class=\"headerlink\" title=\"8、Consumer 消费进度\"></a>8、Consumer 消费进度</h1><h2 id=\"OffsetStore\"><a href=\"#OffsetStore\" class=\"headerlink\" title=\"OffsetStore\"></a>OffsetStore</h2><p><img src=\"http://www.yunai.me/images/RocketMQ/2017_05_04/07.png\" alt=\"OffsetStore类图.png\"></p>\n<ul>\n<li><code>RemoteBrokerOffsetStore</code> ：<code>Consumer</code> <strong>集群模式</strong> 下，使用远程 <code>Broker</code> 消费进度。</li>\n<li><code>LocalFileOffsetStore</code> ：<code>Consumer</code> <strong>广播模式</strong>下，使用本地 <code>文件</code> 消费进度。</li>\n</ul>\n<h3 id=\"OffsetStore-load-…\"><a href=\"#OffsetStore-load-…\" class=\"headerlink\" title=\"OffsetStore#load(…)\"></a>OffsetStore#load(…)</h3><h4 id=\"LocalFileOffsetStore-load-…\"><a href=\"#LocalFileOffsetStore-load-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#load(…)\"></a>LocalFileOffsetStore#load(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"comment\">// 从本地硬盘读取消费进度</span></div><div class=\"line\"> <span class=\"number\">4</span>:     OffsetSerializeWrapper offsetSerializeWrapper = <span class=\"keyword\">this</span>.readLocalOffset();</div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"keyword\">if</span> (offsetSerializeWrapper != <span class=\"keyword\">null</span> &amp;&amp; offsetSerializeWrapper.getOffsetTable() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         offsetTable.putAll(offsetSerializeWrapper.getOffsetTable());</div><div class=\"line\"> <span class=\"number\">7</span>: </div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"comment\">// 打印每个消息队列的消费进度</span></div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : offsetSerializeWrapper.getOffsetTable().keySet()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);</div><div class=\"line\"><span class=\"number\">11</span>:             log.info(<span class=\"string\">\"load consumer's offset, &#123;&#125; &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">12</span>:                 <span class=\"keyword\">this</span>.groupName,</div><div class=\"line\"><span class=\"number\">13</span>:                 mq,</div><div class=\"line\"><span class=\"number\">14</span>:                 offset.get());</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:     &#125;</div><div class=\"line\"><span class=\"number\">17</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：从本地文件加载消费进度到内存。</li>\n</ul>\n<h5 id=\"OffsetSerializeWrapper\"><a href=\"#OffsetSerializeWrapper\" class=\"headerlink\" title=\"OffsetSerializeWrapper\"></a>OffsetSerializeWrapper</h5><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OffsetSerializeWrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">RemotingSerializable</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"keyword\">private</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable =</div><div class=\"line\"> <span class=\"number\">3</span>:             <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:     <span class=\"function\"><span class=\"keyword\">public</span> ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; <span class=\"title\">getOffsetTable</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"keyword\">return</span> offsetTable;</div><div class=\"line\"> <span class=\"number\">7</span>:     &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOffsetTable</span><span class=\"params\">(ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt; offsetTable)</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">10</span>:         <span class=\"keyword\">this</span>.offsetTable = offsetTable;</div><div class=\"line\"><span class=\"number\">11</span>:     &#125;</div><div class=\"line\"><span class=\"number\">12</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：本地 <code>Offset</code> 存储序列化。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">Yunai-MacdeMacBook-Pro-2:config yunai$ cat /Users/yunai/.rocketmq_offsets/192.168.17.0@DEFAULT/please_rename_unique_group_name_1/offsets.json</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"string\">\"offsetTable\"</span>:&#123;&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:3,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:2,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1471,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:1,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470,&#123;</div><div class=\"line\">\t\t\t<span class=\"string\">\"brokerName\"</span>:<span class=\"string\">\"broker-a\"</span>,</div><div class=\"line\">\t\t\t<span class=\"string\">\"queueId\"</span>:0,</div><div class=\"line\">\t\t\t<span class=\"string\">\"topic\"</span>:<span class=\"string\">\"TopicTest\"</span></div><div class=\"line\">\t\t&#125;:1470</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"RemoteBrokerOffsetStore-load-…\"><a href=\"#RemoteBrokerOffsetStore-load-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#load(…)\"></a>RemoteBrokerOffsetStore#load(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">load</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"><span class=\"number\">3</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：不进行加载，实际读取消费进度时，从 <code>Broker</code> 获取。</li>\n</ul>\n<h3 id=\"OffsetStore-readOffset-…\"><a href=\"#OffsetStore-readOffset-…\" class=\"headerlink\" title=\"OffsetStore#readOffset(…)\"></a>OffsetStore#readOffset(…)</h3><p>读取消费进度类型：</p>\n<ul>\n<li><code>READ_FROM_MEMORY</code> ：从内存读取。</li>\n<li><code>READ_FROM_STORE</code> ：从存储( <code>Broker</code> 或 <code>文件</code> )读取。</li>\n<li><code>MEMORY_FIRST_THEN_STORE</code> ：优先从内存读取，读取不到，从存储读取。</li>\n</ul>\n<h4 id=\"LocalFileOffsetStore-readOffset-…\"><a href=\"#LocalFileOffsetStore-readOffset-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#readOffset(…)\"></a>LocalFileOffsetStore#readOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">readOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ReadOffsetType type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">case</span> MEMORY_FIRST_THEN_STORE:</div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"keyword\">case</span> READ_FROM_MEMORY: &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 AtomicLong offset = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">10</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> READ_FROM_STORE: &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 OffsetSerializeWrapper offsetSerializeWrapper;</div><div class=\"line\"><span class=\"number\">16</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:                     offsetSerializeWrapper = <span class=\"keyword\">this</span>.readLocalOffset();</div><div class=\"line\"><span class=\"number\">18</span>:                 &#125; <span class=\"keyword\">catch</span> (MQClientException e) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"keyword\">if</span> (offsetSerializeWrapper != <span class=\"keyword\">null</span> &amp;&amp; offsetSerializeWrapper.getOffsetTable() != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                     AtomicLong offset = offsetSerializeWrapper.getOffsetTable().get(mq);</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">24</span>:                         <span class=\"keyword\">this</span>.updateOffset(mq, offset.get(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">25</span>:                         <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">26</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">27</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">28</span>:             &#125;</div><div class=\"line\"><span class=\"number\">29</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">30</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">31</span>:         &#125;</div><div class=\"line\"><span class=\"number\">32</span>:     &#125;</div><div class=\"line\"><span class=\"number\">33</span>: </div><div class=\"line\"><span class=\"number\">34</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">35</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：从 <code>文件</code> 读取消费进度。</li>\n</ul>\n<h4 id=\"RemoteBrokerOffsetStore-readOffset-…\"><a href=\"#RemoteBrokerOffsetStore-readOffset-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#readOffset(…)\"></a>RemoteBrokerOffsetStore#readOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">readOffset</span><span class=\"params\">(<span class=\"keyword\">final</span> MessageQueue mq, <span class=\"keyword\">final</span> ReadOffsetType type)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">switch</span> (type) &#123;</div><div class=\"line\"> <span class=\"number\">5</span>:             <span class=\"keyword\">case</span> MEMORY_FIRST_THEN_STORE:</div><div class=\"line\"> <span class=\"number\">6</span>:             <span class=\"keyword\">case</span> READ_FROM_MEMORY: &#123;</div><div class=\"line\"> <span class=\"number\">7</span>:                 AtomicLong offset = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">8</span>:                 <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:                     <span class=\"keyword\">return</span> offset.get();</div><div class=\"line\"><span class=\"number\">10</span>:                 &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">12</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">13</span>:             &#125;</div><div class=\"line\"><span class=\"number\">14</span>:             <span class=\"keyword\">case</span> READ_FROM_STORE: &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                 <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">16</span>:                     <span class=\"keyword\">long</span> brokerOffset = <span class=\"keyword\">this</span>.fetchConsumeOffsetFromBroker(mq);</div><div class=\"line\"><span class=\"number\">17</span>:                     AtomicLong offset = <span class=\"keyword\">new</span> AtomicLong(brokerOffset);</div><div class=\"line\"><span class=\"number\">18</span>:                     <span class=\"keyword\">this</span>.updateOffset(mq, offset.get(), <span class=\"keyword\">false</span>);</div><div class=\"line\"><span class=\"number\">19</span>:                     <span class=\"keyword\">return</span> brokerOffset;</div><div class=\"line\"><span class=\"number\">20</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">21</span>:                 <span class=\"comment\">// No offset in broker</span></div><div class=\"line\"><span class=\"number\">22</span>:                 <span class=\"keyword\">catch</span> (MQBrokerException e) &#123;</div><div class=\"line\"><span class=\"number\">23</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">25</span>:                 <span class=\"comment\">//Other exceptions</span></div><div class=\"line\"><span class=\"number\">26</span>:                 <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">27</span>:                     log.warn(<span class=\"string\">\"fetchConsumeOffsetFromBroker exception, \"</span> + mq, e);</div><div class=\"line\"><span class=\"number\">28</span>:                     <span class=\"keyword\">return</span> -<span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"number\">29</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">30</span>:             &#125;</div><div class=\"line\"><span class=\"number\">31</span>:             <span class=\"keyword\">default</span>:</div><div class=\"line\"><span class=\"number\">32</span>:                 <span class=\"keyword\">break</span>;</div><div class=\"line\"><span class=\"number\">33</span>:         &#125;</div><div class=\"line\"><span class=\"number\">34</span>:     &#125;</div><div class=\"line\"><span class=\"number\">35</span>: </div><div class=\"line\"><span class=\"number\">36</span>:     <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"number\">37</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>第 16 行 ：从 <code>Broker</code> 读取消费进度。</li>\n</ul>\n<h3 id=\"OffsetStore-updateOffset-…\"><a href=\"#OffsetStore-updateOffset-…\" class=\"headerlink\" title=\"OffsetStore#updateOffset(…)\"></a>OffsetStore#updateOffset(…)</h3><p>该方法 <code>RemoteBrokerOffsetStore</code> 与 <code>LocalFileOffsetStore</code> 实现相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateOffset</span><span class=\"params\">(MessageQueue mq, <span class=\"keyword\">long</span> offset, <span class=\"keyword\">boolean</span> increaseOnly)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (mq != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"> <span class=\"number\">4</span>:         AtomicLong offsetOld = <span class=\"keyword\">this</span>.offsetTable.get(mq);</div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == offsetOld) &#123;</div><div class=\"line\"> <span class=\"number\">6</span>:             offsetOld = <span class=\"keyword\">this</span>.offsetTable.putIfAbsent(mq, <span class=\"keyword\">new</span> AtomicLong(offset));</div><div class=\"line\"> <span class=\"number\">7</span>:         &#125;</div><div class=\"line\"> <span class=\"number\">8</span>: </div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != offsetOld) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             <span class=\"keyword\">if</span> (increaseOnly) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                 MixAll.compareAndIncreaseOnly(offsetOld, offset);</div><div class=\"line\"><span class=\"number\">12</span>:             &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 offsetOld.set(offset);</div><div class=\"line\"><span class=\"number\">14</span>:             &#125;</div><div class=\"line\"><span class=\"number\">15</span>:         &#125;</div><div class=\"line\"><span class=\"number\">16</span>:     &#125;</div><div class=\"line\"><span class=\"number\">17</span>: &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"OffsetStore-persistAll-…\"><a href=\"#OffsetStore-persistAll-…\" class=\"headerlink\" title=\"OffsetStore#persistAll(…)\"></a>OffsetStore#persistAll(…)</h3><h4 id=\"LocalFileOffsetStore-persistAll-…\"><a href=\"#LocalFileOffsetStore-persistAll-…\" class=\"headerlink\" title=\"LocalFileOffsetStore#persistAll(…)\"></a>LocalFileOffsetStore#persistAll(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">persistAll</span><span class=\"params\">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqs || mqs.isEmpty())</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     OffsetSerializeWrapper offsetSerializeWrapper = <span class=\"keyword\">new</span> OffsetSerializeWrapper();</div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class=\"keyword\">this</span>.offsetTable.entrySet()) &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:         <span class=\"keyword\">if</span> (mqs.contains(entry.getKey())) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:             AtomicLong offset = entry.getValue();</div><div class=\"line\"><span class=\"number\">10</span>:             offsetSerializeWrapper.getOffsetTable().put(entry.getKey(), offset);</div><div class=\"line\"><span class=\"number\">11</span>:         &#125;</div><div class=\"line\"><span class=\"number\">12</span>:     &#125;</div><div class=\"line\"><span class=\"number\">13</span>: </div><div class=\"line\"><span class=\"number\">14</span>:     String jsonString = offsetSerializeWrapper.toJson(<span class=\"keyword\">true</span>);</div><div class=\"line\"><span class=\"number\">15</span>:     <span class=\"keyword\">if</span> (jsonString != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">16</span>:         <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">17</span>:             MixAll.string2File(jsonString, <span class=\"keyword\">this</span>.storePath);</div><div class=\"line\"><span class=\"number\">18</span>:         &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</div><div class=\"line\"><span class=\"number\">19</span>:             log.error(<span class=\"string\">\"persistAll consumer offset Exception, \"</span> + <span class=\"keyword\">this</span>.storePath, e);</div><div class=\"line\"><span class=\"number\">20</span>:         &#125;</div><div class=\"line\"><span class=\"number\">21</span>:     &#125;</div><div class=\"line\"><span class=\"number\">22</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：持久化消费进度。<strong>将消费进度写入文件</strong>。</li>\n</ul>\n<h4 id=\"RemoteBrokerOffsetStore-persistAll-…\"><a href=\"#RemoteBrokerOffsetStore-persistAll-…\" class=\"headerlink\" title=\"RemoteBrokerOffsetStore#persistAll(…)\"></a>RemoteBrokerOffsetStore#persistAll(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">2</span>: <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">persistAll</span><span class=\"params\">(Set&lt;MessageQueue&gt; mqs)</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == mqs || mqs.isEmpty())</div><div class=\"line\"> <span class=\"number\">4</span>:         <span class=\"keyword\">return</span>;</div><div class=\"line\"> <span class=\"number\">5</span>: </div><div class=\"line\"> <span class=\"number\">6</span>:     <span class=\"comment\">// 持久化消息队列</span></div><div class=\"line\"> <span class=\"number\">7</span>:     <span class=\"keyword\">final</span> HashSet&lt;MessageQueue&gt; unusedMQ = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</div><div class=\"line\"> <span class=\"number\">8</span>:     <span class=\"keyword\">if</span> (!mqs.isEmpty()) &#123;</div><div class=\"line\"> <span class=\"number\">9</span>:         <span class=\"keyword\">for</span> (Map.Entry&lt;MessageQueue, AtomicLong&gt; entry : <span class=\"keyword\">this</span>.offsetTable.entrySet()) &#123;</div><div class=\"line\"><span class=\"number\">10</span>:             MessageQueue mq = entry.getKey();</div><div class=\"line\"><span class=\"number\">11</span>:             AtomicLong offset = entry.getValue();</div><div class=\"line\"><span class=\"number\">12</span>:             <span class=\"keyword\">if</span> (offset != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\"><span class=\"number\">13</span>:                 <span class=\"keyword\">if</span> (mqs.contains(mq)) &#123;</div><div class=\"line\"><span class=\"number\">14</span>:                     <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"><span class=\"number\">15</span>:                         <span class=\"keyword\">this</span>.updateConsumeOffsetToBroker(mq, offset.get());</div><div class=\"line\"><span class=\"number\">16</span>:                         log.info(<span class=\"string\">\"[persistAll] Group: &#123;&#125; ClientId: &#123;&#125; updateConsumeOffsetToBroker &#123;&#125; &#123;&#125;\"</span>,</div><div class=\"line\"><span class=\"number\">17</span>:                             <span class=\"keyword\">this</span>.groupName,</div><div class=\"line\"><span class=\"number\">18</span>:                             <span class=\"keyword\">this</span>.mQClientFactory.getClientId(),</div><div class=\"line\"><span class=\"number\">19</span>:                             mq,</div><div class=\"line\"><span class=\"number\">20</span>:                             offset.get());</div><div class=\"line\"><span class=\"number\">21</span>:                     &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">22</span>:                         log.error(<span class=\"string\">\"updateConsumeOffsetToBroker exception, \"</span> + mq.toString(), e);</div><div class=\"line\"><span class=\"number\">23</span>:                     &#125;</div><div class=\"line\"><span class=\"number\">24</span>:                 &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"><span class=\"number\">25</span>:                     unusedMQ.add(mq);</div><div class=\"line\"><span class=\"number\">26</span>:                 &#125;</div><div class=\"line\"><span class=\"number\">27</span>:             &#125;</div><div class=\"line\"><span class=\"number\">28</span>:         &#125;</div><div class=\"line\"><span class=\"number\">29</span>:     &#125;</div><div class=\"line\"><span class=\"number\">30</span>: </div><div class=\"line\"><span class=\"number\">31</span>:     <span class=\"comment\">// 移除不适用的消息队列</span></div><div class=\"line\"><span class=\"number\">32</span>:     <span class=\"keyword\">if</span> (!unusedMQ.isEmpty()) &#123;</div><div class=\"line\"><span class=\"number\">33</span>:         <span class=\"keyword\">for</span> (MessageQueue mq : unusedMQ) &#123;</div><div class=\"line\"><span class=\"number\">34</span>:             <span class=\"keyword\">this</span>.offsetTable.remove(mq);</div><div class=\"line\"><span class=\"number\">35</span>:             log.info(<span class=\"string\">\"remove unused mq, &#123;&#125;, &#123;&#125;\"</span>, mq, <span class=\"keyword\">this</span>.groupName);</div><div class=\"line\"><span class=\"number\">36</span>:         &#125;</div><div class=\"line\"><span class=\"number\">37</span>:     &#125;</div><div class=\"line\"><span class=\"number\">38</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：持久化指定消息队列数组的消费进度到 <code>Broker</code>，并移除非指定消息队列。</li>\n</ul>\n<h4 id=\"MQClientInstance-persistAllConsumerOffset-…\"><a href=\"#MQClientInstance-persistAllConsumerOffset-…\" class=\"headerlink\" title=\"MQClientInstance#persistAllConsumerOffset(…)\"></a>MQClientInstance#persistAllConsumerOffset(…)</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><div class=\"line\"> <span class=\"number\">1</span>: <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startScheduledTask</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">2</span>:     <span class=\"comment\">// 定时同步消费进度</span></div><div class=\"line\"> <span class=\"number\">3</span>:     <span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\"> <span class=\"number\">4</span>: </div><div class=\"line\"> <span class=\"number\">5</span>:         <span class=\"meta\">@Override</span></div><div class=\"line\"> <span class=\"number\">6</span>:         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"> <span class=\"number\">7</span>:             <span class=\"keyword\">try</span> &#123;</div><div class=\"line\"> <span class=\"number\">8</span>:                 MQClientInstance.<span class=\"keyword\">this</span>.cleanOfflineBroker();</div><div class=\"line\"> <span class=\"number\">9</span>:                 MQClientInstance.<span class=\"keyword\">this</span>.sendHeartbeatToAllBrokerWithLock();</div><div class=\"line\"><span class=\"number\">10</span>:             &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</div><div class=\"line\"><span class=\"number\">11</span>:                 log.error(<span class=\"string\">\"ScheduledTask sendHeartbeatToAllBroker exception\"</span>, e);</div><div class=\"line\"><span class=\"number\">12</span>:             &#125;</div><div class=\"line\"><span class=\"number\">13</span>:         &#125;</div><div class=\"line\"><span class=\"number\">14</span>:     &#125;, <span class=\"number\">1000</span>, <span class=\"keyword\">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</div><div class=\"line\"><span class=\"number\">15</span>: &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>说明 ：定时进行持久化，默认周期：5000ms。</li>\n<li><strong>重要说明 ：</strong><ul>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n<li><strong>消费进度持久化不仅仅只有定时持久化，拉取消息、分配消息队列等等操作，都会进行消费进度持久化。</strong> </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"9、结尾\"><a href=\"#9、结尾\" class=\"headerlink\" title=\"9、结尾\"></a>9、结尾</h1><p>😈可能是本系列最长的一篇文章，如有表达错误和不清晰，请多多见谅。<br>感谢对本系列的阅读、收藏、点赞、分享，特别是翻到结尾。😜真的有丢丢长。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj519kz9h0000ag5daz47obvg","category_id":"cj519kz9n0002ag5dotac7hr4","_id":"cj519kz9z0008ag5dds12woh0"},{"post_id":"cj519kz9l0001ag5drp5hfcuo","category_id":"cj519kz9n0002ag5dotac7hr4","_id":"cj519kza3000cag5d92zz0pih"},{"post_id":"cj519kz9p0003ag5duhiuiqhu","category_id":"cj519kza1000aag5d09i3gxhq","_id":"cj519kza7000hag5dhlxb4b2v"},{"post_id":"cj519kz9r0004ag5daq7uhkcu","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzaa000lag5d1aktkukp"},{"post_id":"cj519kz9w0005ag5d7sh61b7t","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzad000pag5dfdw3ot3a"},{"post_id":"cj519kz9y0007ag5dv6sgh5qe","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzaf000tag5d7cf6dmp4"},{"post_id":"cj519kz9z0009ag5dm4tfb0fv","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzah000xag5d9t8anvqo"},{"post_id":"cj519kza2000bag5d3qpnx2u3","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzaj0011ag5dux2mre1z"},{"post_id":"cj519kza3000dag5dnwirg1d1","category_id":"cj519kza4000eag5d29ir0s7d","_id":"cj519kzal0014ag5d2zm6vwky"},{"post_id":"cj519kza4000fag5d3ttocjsy","category_id":"cj519kzak0012ag5dazzo3rnj","_id":"cj519kzan0016ag5d5g6dmcrh"},{"post_id":"cj519kza6000gag5deyrl6gjs","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzan0018ag5dbhd8mvme"},{"post_id":"cj519kza8000jag5dx8ksyc5u","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzao001aag5drm0gz2sl"},{"post_id":"cj519kza9000kag5d4a9hxani","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzao001cag5dkdqhh0vo"},{"post_id":"cj519kzab000nag5d0sfei1b8","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzap001eag5dy0htashk"},{"post_id":"cj519kzac000oag5dpqvzeged","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzaq001gag5deamjfuc1"},{"post_id":"cj519kzae000rag5d303o6ea0","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzar001iag5d4brqxawf"},{"post_id":"cj519kzaf000sag5dg5n0cxuu","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzas001kag5dby3uqcod"},{"post_id":"cj519kzag000vag5d6gdn43nw","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzat001mag5dpl3wtelr"},{"post_id":"cj519kzah000wag5dkb4av5ix","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzat001oag5drs09hn5x"},{"post_id":"cj519kzai000zag5dmhu7mtut","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzau001qag5dvcaieuhh"},{"post_id":"cj519kzaj0010ag5d0kiosnza","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzau001sag5dj0crhqdw"},{"post_id":"cj519kzak0013ag5d98qf1fmo","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzav001tag5dkpqdbom4"},{"post_id":"cj519kzb1001uag5dvvfywp1k","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzb4001wag5d2kmgy95u"},{"post_id":"cj519kzb2001vag5dvm1j77uu","category_id":"cj519kzal0015ag5dej9fbt12","_id":"cj519kzb4001xag5dk5g53x8w"}],"PostTag":[],"Tag":[]}}