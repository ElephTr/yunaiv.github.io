<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋艿V的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yunai.me/"/>
  <updated>2017-08-04T18:07:37.000Z</updated>
  <id>http://www.yunai.me/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 执行</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-execute/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-execute/</id>
    <published>2017-08-13T16:00:00.000Z</published>
    <updated>2017-08-04T18:07:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ExecutorEngine</a><ul>
<li><a href="#">2.1 ListeningExecutorService</a></li>
<li><a href="#">2.2 关闭</a></li>
<li><a href="#">2.3 执行 SQL 任务</a></li>
</ul>
</li>
<li><a href="#">3. Executor</a><ul>
<li><a href="#">3.1 StatementExecutor</a></li>
<li><a href="#">3.2 PreparedStatementExecutor</a></li>
<li><a href="#">3.3 BatchPreparedStatementExecutor</a></li>
</ul>
</li>
<li><a href="#">4. ExecutionEvent</a><ul>
<li><a href="#">4.1 EventBus</a></li>
<li><a href="#">4.2 BestEffortsDeliveryListener</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>越过千山万水（SQL 解析、SQL 路由、SQL 改写），我们终于来到了 <strong>SQL 执行</strong>。开森不开森？！</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/01.png" alt=""></p>
<p>本文主要分享<strong>SQL 执行</strong>的过程，不包括<strong>结果聚合</strong>。<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> <strong>东半球第二良心笔者</strong>会更新，关注微信公众号<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>完稿后<strong>第一时间</strong>通知您哟。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/06.png" alt=""></p>
<p><strong>绿框部分</strong> SQL 执行主流程。</p>
<h1 id="2-ExecutorEngine"><a href="#2-ExecutorEngine" class="headerlink" title="2. ExecutorEngine"></a>2. ExecutorEngine</h1><p>ExecutorEngine，SQL执行引擎。</p>
<p>分表分库，需要执行的 SQL 数量从单条变成了多条，此时有两种方式执行：</p>
<ul>
<li><strong>串行</strong>执行 SQL</li>
<li><strong>并行</strong>执行 SQL</li>
</ul>
<p>前者，编码容易，性能较差，总耗时是多条 SQL 执行时间累加。<br>后者，编码复杂，性能较好，总耗时约等于执行时间最长的 SQL。</p>
<p>👼 ExecutorEngine 当然采用的是<strong>后者</strong>，并行执行 SQL。</p>
<h2 id="2-1-ListeningExecutorService"><a href="#2-1-ListeningExecutorService" class="headerlink" title="2.1 ListeningExecutorService"></a>2.1 ListeningExecutorService</h2><p><a href="http://www.yiibai.com/guava/" rel="external nofollow noopener noreferrer" target="_blank">Guava( Java 工具库 )</a> 提供的继承自  ExecutorService 的<strong>线程服务接口</strong>，提供创建 ListenableFuture 功能。ListenableFuture 接口，继承 Future 接口，有如下好处：</p>
<blockquote>
<p>我们强烈地建议你在代码中多使用ListenableFuture来代替JDK的 Future, 因为：  </p>
<ul>
<li>大多数Futures 方法中需要它。  </li>
<li>转到ListenableFuture 编程比较容易。  </li>
<li>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和ListenableFuture的扩展方法。  </li>
</ul>
<p>传统JDK中的Future通过异步的方式计算返回结果:在多线程运算中可能或者可能在没有结束返回结果，Future是运行中的多线程的一个引用句柄，确保在服务执行返回一个Result。   </p>
<p>ListenableFuture可以允许你注册回调方法(callbacks)，在运算（多线程执行）完成的时候进行调用,  或者在运算（多线程执行）完成后立即执行。这样简单的改进，使得可以明显的支持更多的操作，这样的功能在JDK concurrent中的Future是不支持的。</p>
</blockquote>
<p>如上内容来自<a href="http://ifeve.com/google-guava-listenablefuture/" rel="external nofollow noopener noreferrer" target="_blank">《Google Guava包的ListenableFuture解析<br>》</a>，文章写的很棒。下文你会看到 Sharding-JDBC 是<strong>如何通过 ListenableFuture 简化并发编程的</strong>。</p>
<p>下面看看 ExecutorEngine 如何<strong>初始化</strong> ListeningExecutorService </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingDataSource</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> Properties props)</span> </span>&#123;</div><div class="line">    <span class="comment">// .... 省略部分代码</span></div><div class="line">   shardingProperties = <span class="keyword">new</span> ShardingProperties(props);</div><div class="line">   <span class="keyword">int</span> executorSize = shardingProperties.getValue(ShardingPropertiesConstant.EXECUTOR_SIZE);</div><div class="line">   executorEngine = <span class="keyword">new</span> ExecutorEngine(executorSize);</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorEngine</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> executorSize)</span> </span>&#123;</div><div class="line">   executorService = MoreExecutors.listeningDecorator(<span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           executorSize, executorSize, <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder().setDaemon(<span class="keyword">true</span>).setNameFormat(<span class="string">"ShardingJDBC-%d"</span>).build()));</div><div class="line">   MoreExecutors.addDelayedShutdownHook(executorService, <span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一个分片数据源( ShardingDataSource ) <strong>独占</strong> 一个 SQL执行引擎( ExecutorEngine )。</li>
<li><code>MoreExecutors#listeningDecorator()</code> 创建 ListeningExecutorService，这样 <code>#submit()</code>，<code>#invokeAll()</code> 可以返回 ListenableFuture。</li>
<li>默认情况下，线程池大小为 <strong>8</strong>。可以根据实际业务需要，设置 ShardingProperties 进行调整。</li>
<li><code>#setNameFormat()</code> 并发编程时，一定要对线程名字做下定义，这样排查问题会方便很多。</li>
<li><code>MoreExecutors#addDelayedShutdownHook()</code>，<strong>应用关闭</strong>时，等待<strong>所有任务全部完成</strong>再关闭。默认配置等待时间为 60 秒，<strong>建议</strong>将等待时间做成可配的。</li>
</ul>
<h2 id="2-2-关闭"><a href="#2-2-关闭" class="headerlink" title="2.2 关闭"></a>2.2 关闭</h2><p>数据源关闭时，会调用 ExecutorEngine 也进行关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorEngine.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorService.shutdownNow();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       executorService.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!executorService.isTerminated()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"ExecutorEngine can not been terminated"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#shutdownNow()</code> 尝试使用 <code>Thread.interrupt()</code> 打断正在执行中的任务，未执行的任务不再执行。<strong>建议</strong>打印下哪些任务未执行，因为 SQL 未执行，可能数据未能持久化。</li>
<li><code>#awaitTermination()</code> 因为 <code>#shutdownNow()</code> 打断不是<strong>立即</strong>结束，需要一个过程，因此这里<strong>等待</strong>了 5 秒。</li>
<li><strong>等待</strong> 5 秒后，线程池不一定已经关闭，此时抛出异常给上层。<strong>建议</strong>打印下日志，记录出现这个情况。</li>
</ul>
<h2 id="2-3-执行-SQL-任务"><a href="#2-3-执行-SQL-任务" class="headerlink" title="2.3 执行 SQL 任务"></a>2.3 执行 SQL 任务</h2><p>ExecutorEngine 对外暴露 <code>#executeStatement()</code>，<code>#executePreparedStatement()</code>，<code>#executeBatch()</code> </p>
<p>三个方法分别提供给 StatementExecutor、PreparedStatementExecutor、BatchPreparedStatementExecutor 调用。而这三个方法，内部调用的都是 <code>#execute()</code> 私有方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Statement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> statementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeStatement</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;StatementUnit&gt; statementUnits, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, statementUnits, Collections.&lt;List&lt;Object&gt;&gt;emptyList(), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行PreparedStatement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> preparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameters 参数列表</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executePreparedStatement</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, preparedStatementUnits, Collections.singletonList(parameters), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Batch.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> batchPreparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; executeBatch(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BatchPreparedStatementUnit&gt; batchPreparedStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, batchPreparedStatementUnits, parameterSets, executeCallback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>#execute()</code> 执行过程大体流程如下图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/02.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL 类型</div><div class="line">* <span class="doctag">@param</span> baseStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">execute</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;? extends BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">if</span> (baseStatementUnits.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Iterator&lt;? extends BaseStatementUnit&gt; iterator = baseStatementUnits.iterator();</div><div class="line">   BaseStatementUnit firstInput = iterator.next();</div><div class="line">   <span class="comment">// 第二个任务开始所有 SQL任务 提交线程池【异步】执行任务</span></div><div class="line">   ListenableFuture&lt;List&lt;T&gt;&gt; restFutures = asyncExecute(sqlType, Lists.newArrayList(iterator), parameterSets, executeCallback);</div><div class="line">   T firstOutput;</div><div class="line">   List&lt;T&gt; restOutputs;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 第一个任务【同步】执行任务</span></div><div class="line">       firstOutput = syncExecute(sqlType, firstInput, parameterSets, executeCallback);</div><div class="line">       <span class="comment">// 等待第二个任务开始所有 SQL任务完成</span></div><div class="line">       restOutputs = restFutures.get();</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       ExecutorExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回结果</span></div><div class="line">   List&lt;T&gt; result = Lists.newLinkedList(restOutputs);</div><div class="line">   result.add(<span class="number">0</span>, firstOutput);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一个任务<strong>【同步】</strong>调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">syncExecute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="comment">// 【同步】执行任务</span></div><div class="line">   <span class="keyword">return</span> executeInternal(sqlType, baseStatementUnit, parameterSets, executeCallback, ExecutorExceptionHandler.isExceptionThrown(), ExecutorDataMap.getDataMap());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第二个开始的任务<strong>提交线程池异步</strong>调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; ListenableFuture&lt;List&lt;T&gt;&gt; asyncExecute(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   List&lt;ListenableFuture&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(baseStatementUnits.size());</div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</div><div class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> BaseStatementUnit each : baseStatementUnits) &#123;</div><div class="line">       <span class="comment">// 提交线程池【异步】执行任务</span></div><div class="line">       result.add(executorService.submit(<span class="keyword">new</span> Callable&lt;T&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executeInternal(sqlType, each, parameterSets, executeCallback, isExceptionThrown, dataMap);</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回 ListenableFuture</span></div><div class="line">   <span class="keyword">return</span> Futures.allAsList(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们注意下 <code>Futures.allAsList(result);</code> 和 <code>restOutputs = restFutures.get();</code>。神器 Guava <strong>简化并发编程</strong> 的好处就提现出来了。<code>ListenableFuture#get()</code> 当<strong>所有任务都成功</strong>时，返回所有任务执行结果；当<strong>任何一个任务失败</strong>时，<strong>马上</strong>抛出异常，无需等待其他任务执行完成。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/03.gif" alt=""></p>
<p>_😮 Guava 真她喵神器，公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>会更新 Guava 源码分享的一个系列哟！老司机还不赶紧上车？_</p>
<ul>
<li>为什么会分同步执行和异步执行呢？猜测，当<strong>SQL 执行是单表时</strong>，只要进行第一个任务的同步调用，性能更加优秀。等跟张亮大神请教确认原因后，咱会进行更新。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">executeInternal</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback, </span></span></div><div class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown, <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap) <span class="keyword">throws</span> Exception &#123;</div><div class="line">   <span class="keyword">synchronized</span> (baseStatementUnit.getStatement().getConnection()) &#123;</div><div class="line">       T result;</div><div class="line">       ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);</div><div class="line">       ExecutorDataMap.setDataMap(dataMap);</div><div class="line">       List&lt;AbstractExecutionEvent&gt; events = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="comment">// 生成 Event</span></div><div class="line">       <span class="keyword">if</span> (parameterSets.isEmpty()) &#123;</div><div class="line">           events.add(getExecutionEvent(sqlType, baseStatementUnit, Collections.emptyList()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (List&lt;Object&gt; each : parameterSets) &#123;</div><div class="line">               events.add(getExecutionEvent(sqlType, baseStatementUnit, each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.BEFORE_EXECUTE</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent event : events) &#123;</div><div class="line">           EventBusInstance.getInstance().post(event);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 执行回调函数</span></div><div class="line">           result = executeCallback.execute(baseStatementUnit);</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_FAILURE</span></div><div class="line">           <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">               each.setEventExecutionType(EventExecutionType.EXECUTE_FAILURE);</div><div class="line">               each.setException(Optional.of(ex));</div><div class="line">               EventBusInstance.getInstance().post(each);</div><div class="line">               ExecutorExceptionHandler.handleException(ex);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_SUCCESS</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">           each.setEventExecutionType(EventExecutionType.EXECUTE_SUCCESS);</div><div class="line">           EventBusInstance.getInstance().post(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>result = executeCallback.execute(baseStatementUnit);</code> 执行回调函数。StatementExecutor，PreparedStatementExecutor，BatchPreparedStatementExecutor 通过传递<strong>执行回调函数</strong>( ExecuteCallback )实现给 ExecutorEngine 实现并行执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> baseStatementUnit 语句对象执行单元</div><div class="line">     * <span class="doctag">@return</span> 处理结果</div><div class="line">     * <span class="doctag">@throws</span> Exception 执行期异常</div><div class="line">     */</div><div class="line">    <span class="function">T <span class="title">execute</span><span class="params">(BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>synchronized (baseStatementUnit.getStatement().getConnection())</code> 原以为 Connection 非线程安全，因此需要用<strong>同步</strong>，后翻查资料<a href="http://blog.csdn.net/goldenfish1919/article/details/9089667" rel="external nofollow noopener noreferrer" target="_blank">《数据库连接池为什么要建立多个连接》</a>，Connection 是线程安全的。等跟张亮大神请教确认原因后，咱会进行更新。</li>
<li>ExecutionEvent 这里先不解释，在本文第四节【EventBus】分享。</li>
<li>ExecutorExceptionHandler、ExecutorDataMap 和 柔性事务 ( AbstractSoftTransaction )，放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>分享。</li>
</ul>
<h1 id="3-Executor"><a href="#3-Executor" class="headerlink" title="3. Executor"></a>3. Executor</h1><p>Executor，执行器，目前一共有三个执行器。不同的执行器对应不同的执行单元 (BaseStatementUnit)。</p>
<table>
<thead>
<tr>
<th style="text-align:left">执行器类</th>
<th style="text-align:left">执行器名</th>
<th style="text-align:left">执行单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">StatementExecutor</td>
<td style="text-align:left">静态语句对象执行单元</td>
<td style="text-align:left">StatementUnit</td>
</tr>
<tr>
<td style="text-align:left">PreparedStatementExecutor</td>
<td style="text-align:left">预编译语句对象请求的执行器</td>
<td style="text-align:left">PreparedStatementUnit</td>
</tr>
<tr>
<td style="text-align:left">BatchPreparedStatementExecutor</td>
<td style="text-align:left">批量预编译语句对象请求的执行器</td>
<td style="text-align:left">BatchPreparedStatementUnit</td>
</tr>
</tbody>
</table>
<ul>
<li>执行器提供的方法不同，因此不存在公用接口或者抽象类。</li>
<li>执行单元继承自 BaseStatementUnit</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/04.png" alt=""></p>
<h2 id="3-1-StatementExecutor"><a href="#3-1-StatementExecutor" class="headerlink" title="3.1 StatementExecutor"></a>3.1 StatementExecutor</h2><p>StatementExecutor，<strong>多线程</strong>执行静态语句对象请求的执行器，一共有三类方法：</p>
<ul>
<li><code>#executeQuery()</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL查询.</div><div class="line">* <span class="doctag">@return</span> 结果集列表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ResultSet&gt; <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeQuery"</span>);</div><div class="line">   List&lt;ResultSet&gt; result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;ResultSet&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> ResultSet <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeQuery(baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#executeUpdate()</code> 因为有四个不同情况的<code>#executeUpdate()</code>，所以抽象了 Updater 接口，从而达到逻辑重用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL更新.</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executeUpdate(<span class="keyword">new</span> Updater() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.executeUpdate(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Updater updater)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> updater.executeUpdate(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算总的更新数量</div><div class="line">* <span class="doctag">@param</span> results 更新数量数组</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; results)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Integer each : results) &#123;</div><div class="line">       result += <span class="keyword">null</span> == each ? <span class="number">0</span> : each;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#execute()</code> 因为有四个不同情况的<code>#execute()</code>，所以抽象了 Executor 接口，从而达到逻辑重用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL请求.</div><div class="line">* <span class="doctag">@return</span> true表示执行DQL语句, false表示执行的DML语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(<span class="keyword">new</span> Executor() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.execute(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Executor executor)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-execute"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Boolean&gt; result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Boolean&gt;() &#123; </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executor.execute(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty() || <span class="keyword">null</span> == result.get(<span class="number">0</span>)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result.get(<span class="number">0</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-PreparedStatementExecutor"><a href="#3-2-PreparedStatementExecutor" class="headerlink" title="3.2 PreparedStatementExecutor"></a>3.2 PreparedStatementExecutor</h2><p>PreparedStatementExecutor，<strong>多线程</strong>执行预编译语句对象请求的执行器。比 StatementExecutor 多了 <code>parameters</code> 参数，方法逻辑上基本一致，就不重复分享啦。</p>
<h2 id="3-3-BatchPreparedStatementExecutor"><a href="#3-3-BatchPreparedStatementExecutor" class="headerlink" title="3.3 BatchPreparedStatementExecutor"></a>3.3 BatchPreparedStatementExecutor</h2><p>BatchPreparedStatementExecutor，<strong>多线程</strong>执行批量预编译语句对象请求的执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BatchPreparedStatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行批量SQL.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] executeBatch() &#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeBatch"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> accumulate(executorEngine.executeBatch(sqlType, batchPreparedStatementUnits, parameterSets, <span class="keyword">new</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> <span class="keyword">int</span>[] execute(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeBatch();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算每个语句的更新数量</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> results 每条 SQL 更新数量</div><div class="line">* <span class="doctag">@return</span> 每个语句的更新数量</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] accumulate(<span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; results) &#123;</div><div class="line">   <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[parameterSets.size()];</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 每个语句按照顺序，读取到其对应的每个分片SQL影响的行数进行累加</span></div><div class="line">   <span class="keyword">for</span> (BatchPreparedStatementUnit each : batchPreparedStatementUnits) &#123;</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : each.getJdbcAndActualAddBatchCallTimesMap().entrySet()) &#123;</div><div class="line">           result[entry.getKey()] += <span class="keyword">null</span> == results.get(count) ? <span class="number">0</span> : results.get(count)[entry.getValue()];</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>眼尖</strong>的同学会发现，为什么有 BatchPreparedStatementExecutor，而没有 BatchStatementExecutor 呢？目前 Sharding-JDBC 不支持 Statement 批量操作，只能进行 PreparedStatement 的批操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatement 批量操作，不会报错</span></div><div class="line">PreparedStatement ps = conn.prepareStatement(sql)</div><div class="line">ps.addBatch();</div><div class="line">ps.addBatch();</div><div class="line"></div><div class="line"><span class="comment">// Statement 批量操作，会报错</span></div><div class="line">ps.addBatch(sql); <span class="comment">// 报错：at com.dangdang.ddframe.rdb.sharding.jdbc.unsupported.AbstractUnsupportedOperationStatement.addBatch</span></div></pre></td></tr></table></figure>
<h1 id="4-ExecutionEvent"><a href="#4-ExecutionEvent" class="headerlink" title="4. ExecutionEvent"></a>4. ExecutionEvent</h1><p>AbstractExecutionEvent，SQL 执行事件抽象接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutionEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件编号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> EventExecutionType eventExecutionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异常</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;SQLException&gt; exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AbstractExecutionEvent 有两个实现子类：</p>
<ul>
<li>DMLExecutionEvent：DML类SQL执行时事件</li>
<li>DQLExecutionEvent：DQL类SQL执行时事件</li>
</ul>
<p>EventExecutionType，事件触发类型。</p>
<ul>
<li>BEFORE_EXECUTE：执行前</li>
<li>EXECUTE_SUCCESS：执行成功</li>
<li>EXECUTE_FAILURE：执行失败</li>
</ul>
<h2 id="4-1-EventBus"><a href="#4-1-EventBus" class="headerlink" title="4.1 EventBus"></a>4.1 EventBus</h2><p><strong>那究竟有什么用途呢？</strong> Sharding-JDBC 使用 Guava（<strong>没错，又是它</strong>）的 <strong>EventBus</strong> 实现了<strong>事件的发布和订阅</strong>。从上文 <code>ExecutorEngine#executeInternal()</code> 我们可以看到<strong>每个分片</strong> SQL 执行的过程中会发布相应事件：</p>
<ul>
<li>执行 SQL 前：发布类型类型为 BEFORE_EXECUTE 的事件</li>
<li>执行 SQL 成功：发布类型类型为 EXECUTE_SUCCESS 的事件</li>
<li>执行 SQL 失败：发布类型类型为 EXECUTE_FAILURE 的事件</li>
</ul>
<p><strong>怎么订阅事件呢？</strong>非常简单，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBusInstance.getInstance().register(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123; <span class="comment">// DMLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DMLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(<span class="keyword">final</span> DQLExecutionEvent event)</span> </span>&#123; <span class="comment">//DQLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DQLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><code>#register()</code> 任何类都可以，并非一定需要使用 Runnable 类。此处例子单纯因为方便</li>
<li><code>@Subscribe</code> 注解在方法上，实现对事件的订阅</li>
<li><code>@AllowConcurrentEvents</code> 注解在方法上，表示线程安全，允许并发执行</li>
<li>方法上的<strong>参数对应的类</strong>即是订阅的事件。例如，<code>#listen()</code> 订阅了 DMLExecutionEvent 事件</li>
<li><code>EventBus#post()</code> 发布事件，<strong>同步</strong>调用订阅逻辑</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/05.png" alt=""></p>
<ul>
<li>推荐阅读文章：<a href="http://www.cnblogs.com/peida/p/EventBus.html" rel="external nofollow noopener noreferrer" target="_blank">《Guava学习笔记：EventBus》</a></li>
</ul>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h2 id="4-2-BestEffortsDeliveryListener"><a href="#4-2-BestEffortsDeliveryListener" class="headerlink" title="4.2 BestEffortsDeliveryListener"></a>4.2 BestEffortsDeliveryListener</h2><p>BestEffortsDeliveryListener，最大努力送达型事务监听器。</p>
<p>本文暂时暂时不分析其实现，仅仅作为另外一个<strong>订阅者</strong>的例子。我们会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>进行分享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">        TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">        BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">        <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">            <span class="keyword">case</span> BEFORE_EXECUTE:</div><div class="line">                <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">                transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                        event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_SUCCESS: </div><div class="line">                transactionLogStorage.remove(event.getId());</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_FAILURE: </div><div class="line">                <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">                    Connection conn = <span class="keyword">null</span>;</div><div class="line">                    PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                        <span class="keyword">if</span> (!isValidConnection(conn)) &#123;</div><div class="line">                            bedSoftTransaction.getConnection().release(conn);</div><div class="line">                            conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                            isNewConnection = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                        <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                            preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement.executeUpdate();</div><div class="line">                        deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                        transactionLogStorage.remove(event.getId());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                        log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        close(isNewConnection, conn, preparedStatement);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">default</span>: </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文完，但也未完。</p>
<p><strong>跨分片事务问题</strong>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> t_order <span class="keyword">SET</span> nickname = ? <span class="keyword">WHERE</span> user_id = ?</div></pre></td></tr></table></figure>
<p>A 节点 <code>connection.commit()</code> 时，应用突然挂了！B节点 <code>connection.commit()</code> 还来不及执行。<br>我们一起去<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>寻找答案。</p>
<p><strong>道友，分享一波朋友圈可好？</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式主键</title>
    <link href="http://www.yunai.me/Sharding-JDBC/distributed-id/"/>
    <id>http://www.yunai.me/Sharding-JDBC/distributed-id/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2017-08-04T18:10:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2.KeyGenerator</a><ul>
<li><a href="#">2.1 DefaultKeyGenerator</a></li>
<li><a href="#">2.2 HostNameKeyGenerator</a></li>
<li><a href="#">2.3 IPKeyGenerator</a></li>
<li><a href="#">2.4 IPSectionKeyGenerator</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 Sharding-JDBC <strong>分布式主键</strong>实现。</p>
<p>官方文档<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/key-generator/" rel="external nofollow noopener noreferrer" target="_blank">《分布式主键》</a>对其介绍及使用方式介绍很完整，强烈先阅读。下面先引用下分布式主键的<strong>实现动机</strong>：</p>
<blockquote>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各大数据库对于该需求也提供了相应的支持，比如MySQL的自增键。对于MySQL而言，分库分表之后，不同表生成全局唯一的Id是非常棘手的问题。因为同一个逻辑表内的不同实际表之间的自增键是无法互相感知的，这样会造成重复Id的生成。我们当然可以通过约束表生成键的规则来达到数据的不重复，但是这需要引入额外的运维力量来解决重复性问题，并使框架缺乏扩展性。  </p>
<p>目前有许多第三方解决方案可以完美解决这个问题，比如UUID等依靠特定算法自生成不重复键，或者通过引入Id生成服务等。 但也正因为这种多样性导致了Sharding-JDBC如果强依赖于任何一种方案就会限制其自身的发展。  </p>
<p>基于以上的原因，最终采用了以JDBC接口来实现对于生成Id的访问，而将底层具体的Id生成实现分离出来。  </p>
</blockquote>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-KeyGenerator"><a href="#2-KeyGenerator" class="headerlink" title="2. KeyGenerator"></a>2. KeyGenerator</h1><p>KeyGenerator，主键生成器接口。实现类通过实现 <code>#generateKey()</code> 方法对外提供<strong>生成主键</strong>的功能。</p>
<h2 id="2-1-DefaultKeyGenerator"><a href="#2-1-DefaultKeyGenerator" class="headerlink" title="2.1 DefaultKeyGenerator"></a>2.1 DefaultKeyGenerator</h2><p>DefaultKeyGenerator，默认的主键生成器。该生成器采用 Twitter Snowflake 算法实现，生成 <strong>64 Bits</strong> 的 <strong>Long</strong> 型编号。国内另外一款数据库中间件 MyCAT 分布式主键也是基于该算法实现。国内很多大型互联网公司<strong>发号器</strong>服务基于该算法加部分改造实现。所以 DefaultKeyGenerator 必须是<strong>根正苗红</strong>。如果你对<strong>分布式主键</strong>感兴趣，可以看看逗比笔者整理的<a href="http://www.yunai.me/Architecture/talk-about-global-id/?self">《谈谈 ID》</a>。</p>
<p>咳咳咳，有点跑题了。<strong>编号</strong>由四部分组成，从高位到低位（从左到右）分别是：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_12/01.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">Bits</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">符号位</td>
<td style="text-align:left">等于 0</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left">时间戳</td>
<td style="text-align:left">从 2016/11/01 零点开始的毫秒数，支持 2 ^41 /365/24/60/60/1000=69.7年</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">工作进程编号</td>
<td style="text-align:left">支持 1024 个进程</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">序列号</td>
<td style="text-align:left">每毫秒从 0 开始自增，支持 4096 个编号</td>
</tr>
</tbody>
</table>
<ul>
<li>每个工作进程每秒可以产生 4096000 个编号。是不是灰常牛比 💯</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间偏移量，从2016年11月1日零点开始</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EPOCH;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量占用比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BITS = <span class="number">12L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_BITS = <span class="number">10L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量掩码（最大值）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_MASK = (<span class="number">1</span> &lt;&lt; SEQUENCE_BITS) - <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间戳左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID最大值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_MAX_VALUE = <span class="number">1L</span> &lt;&lt; WORKER_ID_BITS;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeService timeService = <span class="keyword">new</span> TimeService();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> workerId;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.set(<span class="number">2016</span>, Calendar.NOVEMBER, <span class="number">1</span>);</div><div class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MINUTE, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</div><div class="line">        EPOCH = calendar.getTimeInMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后自增量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后生成编号时间戳，单位：毫秒</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置工作进程Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> workerId 工作进程Id</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWorkerId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> workerId)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(workerId &gt;= <span class="number">0L</span> &amp;&amp; workerId &lt; WORKER_ID_MAX_VALUE);</div><div class="line">        DefaultKeyGenerator.workerId = workerId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生成Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 返回@&#123;<span class="doctag">@link</span> Long&#125;类型的Id</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Number <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 保证当前时间大于最后时间。时间回退会导致产生重复id</span></div><div class="line">        <span class="keyword">long</span> currentMillis = timeService.getCurrentMillis();</div><div class="line">        Preconditions.checkState(lastTime &lt;= currentMillis, <span class="string">"Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds"</span>, lastTime, currentMillis);</div><div class="line">        <span class="comment">// 获取序列号</span></div><div class="line">        <span class="keyword">if</span> (lastTime == currentMillis) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0L</span> == (sequence = ++sequence &amp; SEQUENCE_MASK)) &#123; <span class="comment">// 当获得序号超过最大值时，归0，并去获得新的时间</span></div><div class="line">                currentMillis = waitUntilNextTime(currentMillis);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sequence = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置最后时间戳</span></div><div class="line">        lastTime = currentMillis;</div><div class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">            log.debug(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date(lastTime)), workerId, sequence);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 生成编号</span></div><div class="line">        <span class="keyword">return</span> ((currentMillis - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (workerId &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 不停获得时间，直到大于最后时间</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lastTime 最后时间</div><div class="line">     * <span class="doctag">@return</span> 时间</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitUntilNextTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> time = timeService.getCurrentMillis();</div><div class="line">        <span class="keyword">while</span> (time &lt;= lastTime) &#123;</div><div class="line">            time = timeService.getCurrentMillis();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> time;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>EPOCH = calendar.getTimeInMillis();</code> 计算 2016/11/01 零点开始的毫秒数。</li>
<li><code>#generateKey()</code> 实现逻辑<ol>
<li>校验当前时间<strong>小于等于</strong>最后生成编号时间戳，避免服务器时钟同步，可能产生时间回退，导致产生<strong>重复</strong>编号</li>
</ol>
<ul>
<li>获得序列号。当前时间戳可获得自增量到达最大值时，调用 <code>#waitUntilNextTime()</code> 获得下一毫秒</li>
<li>设置最后生成编号时间戳，用于校验时间回退情况</li>
<li>位操作生成<strong>编号</strong></li>
</ul>
</li>
</ul>
<p>总的来说，Twitter Snowflake 算法实现上是相对简单易懂的，较为麻烦的是<strong>怎么解决工作进程编号的分配</strong>？</p>
<ol>
<li>超过 1024 个怎么办？</li>
<li>怎么保证全局唯一？</li>
</ol>
<p>第一个问题，将分布式主键生成独立成一个<strong>发号器</strong>服务，提供生成分布式编号的功能。这个不在本文的范围内，有兴趣的同学可以 Google 下。</p>
<p>第二个问题，通过 Zookeeper、Consul、Etcd 等提供分布式配置功能的中间件。当然 Sharding-JDBC 也提供了不依赖这些服务的方式，我们一个一个往下看。</p>
<h2 id="2-2-HostNameKeyGenerator"><a href="#2-2-HostNameKeyGenerator" class="headerlink" title="2.2 HostNameKeyGenerator"></a>2.2 HostNameKeyGenerator</h2><blockquote>
<p>根据<strong>机器名最后的数字编号</strong>获取工作进程编号。<br>如果线上机器命名有统一规范,建议使用此种方式。<br>例如，机器的 HostName 为: <code>dangdang-db-sharding-dev-01</code>(公司名-部门名-服务名-环境名-编号)，会截取 HostName 最后的编号 01 作为工作进程编号( workId )。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HostNameKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   Long workerId;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   String hostName = address.getHostName();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       workerId = Long.valueOf(hostName.replace(hostName.replaceAll(<span class="string">"\\d+$"</span>, <span class="string">""</span>), <span class="string">""</span>));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Wrong hostname:%s, hostname must be end with number!"</span>, hostName));</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-3-IPKeyGenerator"><a href="#2-3-IPKeyGenerator" class="headerlink" title="2.3 IPKeyGenerator"></a>2.3 IPKeyGenerator</h2><blockquote>
<p>根据<strong>机器IP</strong>获取工作进程编号。<br>如果线上机器的IP二进制表示的最后10位不重复,建议使用此种方式。<br>例如，机器的IP为192.168.1.108，二进制表示:<code>11000000 10101000 00000001 01101100</code>，截取最后 10 位 <code>01 01101100</code>，转为十进制 364，设置工作进程编号为 364。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   DefaultKeyGenerator.setWorkerId((<span class="keyword">long</span>) (((ipAddressByteArray[ipAddressByteArray.length - <span class="number">2</span>] &amp; <span class="number">0B11</span>) &lt;&lt; Byte.SIZE)</div><div class="line">           + (ipAddressByteArray[ipAddressByteArray.length - <span class="number">1</span>] &amp; <span class="number">0xFF</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-4-IPSectionKeyGenerator"><a href="#2-4-IPSectionKeyGenerator" class="headerlink" title="2.4 IPSectionKeyGenerator"></a>2.4 IPSectionKeyGenerator</h2><p>来自 <strong>DogFc</strong> 贡献，对 IPKeyGenerator 进行改造。</p>
<blockquote>
<p>浏览 IPKeyGenerator 工作进程编号生成的规则后，感觉对服务器IP后10位（特别是IPV6）数值比较约束。<br>有以下优化思路：<br>因为工作进程编号最大限制是 2^10，我们生成的工程进程编号只要满足小于 1024 即可。<br>1.针对IPV4:<br>….IP最大 255.255.255.255。而（255+255+255+255) &lt; 1024。<br>….因此采用IP段数值相加即可生成唯一的workerId，不受IP位限制。   </p>
<ol>
<li>针对IPV6:<br>….IP最大 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff<br>….为了保证相加生成出的工程进程编号 &lt; 1024,思路是将每个 Bit 位的后6位相加。这样在一定程度上也可以满足workerId不重复的问题。<br>使用这种 IP 生成工作进程编号的方法,必须保证IP段相加不能重复  </li>
</ol>
</blockquote>
<p>对于 IPV6 ：2^ 6 = 64。64 * 8 = 512 &lt; 1024。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPSectionKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   <span class="keyword">long</span> workerId = <span class="number">0L</span>;</div><div class="line">   <span class="comment">// IPV4</span></div><div class="line">   <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">4</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0xFF</span>;</div><div class="line">       &#125;</div><div class="line">   <span class="comment">// IPV6</span></div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">16</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0B111111</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bad LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>没有彩蛋。HOHOHO</p>
<p>道友，分享一波朋友圈可好。</p>
<p>感谢你，技术如此只好，还关注我的公众号。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由改写</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-rewrite/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-rewrite/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2017-08-03T13:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLToken</a></li>
<li><a href="#">3.SQL 改写</a><ul>
<li><a href="#">3.1 TableToken</a></li>
<li><a href="#">3.2 ItemsToken</a></li>
<li><a href="#">3.3 OffsetToken</a></li>
<li><a href="#">3.4 RowCountToken</a><ul>
<li><a href="#">3.4.1 分页补充</a></li>
</ul>
</li>
<li><a href="#">3.5 OrderByToken</a></li>
<li><a href="#">3.6 GeneratedKeyToken</a></li>
</ul>
</li>
<li><a href="#">4. SQL 生成</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?mp">《SQL 解析（三）之查询SQL》</a></p>
<p>本文分享<strong>SQL 改写</strong>的源码实现。主要涉及两方面：</p>
<ol>
<li>SQL 改写：改写 SQL，解决分库分表后，查询结果需要聚合，需要对 SQL 进行调整，例如分页</li>
<li>SQL 生成：生成分表分库的执行 SQL</li>
</ol>
<p>SQLRewriteEngine，SQL重写引擎，实现 SQL 改写、生成功能。从 Sharding-JDBC 1.5.0 版本，SQL 改写进行了调整和大量优化。</p>
<blockquote>
<p>1.4.x及之前版本，SQL改写是在SQL路由之前完成的，在1.5.x中调整为SQL路由之后，因为SQL改写可以根据路由至单库表还是多库表而进行进一步优化。</p>
</blockquote>
<p>😆 很多同学看完<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a> 可能是一脸懵逼，特别对<strong>“SQL 半理解”</strong>。<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/01.png" alt="">希望本文能给你一些启发。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-SQLToken"><a href="#2-SQLToken" class="headerlink" title="2. SQLToken"></a>2. SQLToken</h1><p>😁 SQLToken 在本文中很重要，所以即使在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a>已经分享过，我们也换个姿势，再来一次。</p>
<p>SQLToken，SQL标记对象<strong>接口</strong>。SQLRewriteEngine 基于 SQLToken 实现 <strong>SQL改写</strong>。SQL解析器在 SQL解析过程中，很重要的一个目的是<strong>标记需要SQL改写的部分</strong>，也就是 SQLToken。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/02.png" alt=""></p>
<p><strong>各 SQLToken 生成条件如下</strong>(<em>悲伤，做成表格形式排版是乱的</em>)：</p>
<ol>
<li>GeneratedKeyToken 自增主键标记对象<ul>
<li>插入SQL自增列不存在：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>TableToken 表标记对象<ul>
<li>查询列的表别名：<code>SELECT o.order_id</code> 的 <code>o</code> </li>
<li>查询的表名：<code>SELECT * FROM t_order</code> 的 <code>t_order</code></li>
</ul>
</li>
<li>ItemsToken 选择项标记对象<ul>
<li>AVG查询列：<code>SELECT AVG(price) FROM t_order</code> 的 <code>AVG(price)</code></li>
<li>ORDER BY 字段不在查询列：<code>SELECT order_id FROM t_order ORDER BY create_time</code> 的 <code>create_time</code></li>
<li>GROUP BY 字段不在查询列：<code>SELECT COUNT(order_id) FROM t_order GROUP BY user_id</code> 的 <code>user_id</code></li>
<li>自增主键未在插入列中：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>OffsetToken 分页偏移量标记对象<ul>
<li>分页有偏移量，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>RowCountToken 分页长度标记对象<ul>
<li>分页有长度，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>OrderByToken 排序标记对象<ul>
<li>有 GROUP BY 条件，无 ORDER BY 条件：<code>SELECT COUNT(*) FROM t_order GROUP BY order_id</code> 的 <code>order_id</code></li>
</ul>
</li>
</ol>
<h1 id="3-SQL-改写"><a href="#3-SQL-改写" class="headerlink" title="3.SQL 改写"></a>3.SQL 改写</h1><p><code>SQLRewriteEngine#rewrite()</code> 实现了 <strong>SQL改写</strong> 功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* SQL改写.</div><div class="line">* <span class="doctag">@param</span> isRewriteLimit 是否重写Limit</div><div class="line">* <span class="doctag">@return</span> SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewriteLimit)</span> </span>&#123;</div><div class="line">   SQLBuilder result = <span class="keyword">new</span> SQLBuilder();</div><div class="line">   <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</div><div class="line">       result.appendLiterals(originalSQL);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 排序SQLToken，按照 beginPosition 递增</span></div><div class="line">   sortByBeginPosition();</div><div class="line">   <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == count) &#123; <span class="comment">// 拼接第一个 SQLToken 前的字符串</span></div><div class="line">           result.appendLiterals(originalSQL.substring(<span class="number">0</span>, each.getBeginPosition()));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 拼接每个SQLToken</span></div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</div><div class="line">           appendTableToken(result, (TableToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</div><div class="line">           appendItemsToken(result, (ItemsToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</div><div class="line">           appendLimitRowCount(result, (RowCountToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</div><div class="line">           appendLimitOffsetToken(result, (OffsetToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</div><div class="line">           appendOrderByToken(result);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>SQL改写以 SQLToken 为<strong>间隔</strong>，<strong>顺序</strong>改写。<ul>
<li>顺序：调用 <code>#sortByBeginPosition()</code> 将 SQLToken 按照 <code>beginPosition</code> <strong>升序</strong>。</li>
<li>间隔：遍历 SQLToken，逐个拼接。</li>
</ul>
</li>
</ul>
<p>例如：<br>    <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/03.png" alt=""></p>
<hr>
<p>SQLBuilder，SQL构建器。下文会大量用到，我们看下实现代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 段集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; segments;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> StringBuilder currentSegment;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        segments = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加字面量.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> literals 字面量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLiterals</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">        currentSegment.append(literals);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加表占位符.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> tableName 表名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTable</span><span class="params">(<span class="keyword">final</span> String tableName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 TableToken</span></div><div class="line">        segments.add(<span class="keyword">new</span> TableToken(tableName));</div><div class="line">        <span class="comment">// 新建当前段</span></div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略代码，【SQL生成】处分享</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@RequiredArgsConstructor</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 表名</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>现在我们来逐个分析每种 SQLToken 的<strong>拼接</strong>实现。</p>
<h2 id="3-1-TableToken"><a href="#3-1-TableToken" class="headerlink" title="3.1 TableToken"></a>3.1 TableToken</h2><p>调用 <code>#appendTableToken()</code> 方法拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> tableToken tableToken</div><div class="line">* <span class="doctag">@param</span> count tableToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTableToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> TableToken tableToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 TableToken</span></div><div class="line">   String tableName = sqlStatement.getTables().getTableNames().contains(tableToken.getTableName()) ? tableToken.getTableName() : tableToken.getOriginalLiterals();</div><div class="line">   sqlBuilder.appendTable(tableName);</div><div class="line">   <span class="comment">// 拼接 SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = tableToken.getBeginPosition() + tableToken.getOriginalLiterals().length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>SQLBuilder#appendTable()</code> 拼接 TableToken。</li>
<li><code>sqlStatement.getTables().getTableNames().contains(tableToken.getTableName())</code> 目的是处理掉<strong>表名前后有的特殊字符</strong>，例如<code>SELECT * FROM &#39;t_order&#39;</code> 中 <code>t_order</code> 前后有 <code>&#39;</code> 符号。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableToken.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLUtil.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExactlyValue</span><span class="params">(<span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == value ? <span class="keyword">null</span> : CharMatcher.anyOf(<span class="string">"[]`'\""</span>).removeFrom(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当 SQL 为 <code>SELECT o.* FROM t_order o</code><ul>
<li>TableToken 为查询列前的表别名 <code>o</code> 时返回结果：<br>  <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/04.png" alt=""></li>
<li>TableToken 为表名 <code>t_order</code> 时返回结果：<br>  <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/05.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="3-2-ItemsToken"><a href="#3-2-ItemsToken" class="headerlink" title="3.2 ItemsToken"></a>3.2 ItemsToken</h2><p>调用 <code>#appendItemsToken()</code> 方法拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> itemsToken itemsToken</div><div class="line">* <span class="doctag">@param</span> count itemsToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendItemsToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 ItemsToken</span></div><div class="line">   <span class="keyword">for</span> (String item : itemsToken.getItems()) &#123;</div><div class="line">       sqlBuilder.appendLiterals(<span class="string">", "</span>);</div><div class="line">       sqlBuilder.appendLiterals(item);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = itemsToken.getBeginPosition();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一种情况，<strong>AVG查询列</strong>，SQL 为 <code>SELECT AVG(order_id) FROM t_order o</code> 时返回结果：<br><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/06.png" alt=""></li>
<li>第二种情况，<strong>ORDER BY 字段不在查询列</strong>，SQL 为 <code>SELECT userId FROM t_order o ORDER BY order_id</code> 时返回结果：<br><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/07.png" alt=""></li>
<li>第三种情况，<strong>GROUP BY 字段不在查询列</strong>，类似第二种情况，就不举例子列。</li>
</ul>
<h2 id="3-3-OffsetToken"><a href="#3-3-OffsetToken" class="headerlink" title="3.3 OffsetToken"></a>3.3 OffsetToken</h2><p>调用 <code>#appendLimitOffsetToken()</code> 方法拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OffsetToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> offsetToken offsetToken</div><div class="line">* <span class="doctag">@param</span> count offsetToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写。当路由结果为单分片时无需重写</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 OffsetToken</span></div><div class="line">   sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当分页<strong>跨分片</strong>时，需要每个分片都查询后在<strong>内存</strong>中进行聚合。此时 <code>isRewrite = true</code>。为什么是 <code>&quot;0&quot;</code> 开始呢？每个分片在 [0, offset) 的记录<strong>可能</strong>属于实际分页结果，因而查询每个分片需要从 0 开始。</li>
<li>当分页<strong>单分片</strong>时，则无需重写，该分片执行的结果即是最终结果。<strong>SQL改写在SQL路由之后就有这个好处</strong>。如果先改写，因为没办法知道最终是单分片还是跨分片，考虑正确性，只能统一使用跨分片。</li>
</ul>
<h2 id="3-4-RowCountToken"><a href="#3-4-RowCountToken" class="headerlink" title="3.4 RowCountToken"></a>3.4 RowCountToken</h2><p>调用 <code>#appendLimitRowCount()</code> 方法拼接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   Limit limit = selectStatement.getLimit();</div><div class="line">   <span class="keyword">if</span> (!isRewrite) &#123; <span class="comment">// 路由结果为单分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || <span class="comment">// [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">           !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123; <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 路由结果为多分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(limit.isRowCountRewriteFlag() ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>[1.1] <code>!selectStatement.getGroupByItems().isEmpty()</code> 跨分片<strong>分组</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.2] <code>!selectStatement.getAggregationSelectItems().isEmpty())</code> 跨分片<strong>聚合列</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.1][1.2]，<strong>可能</strong>变成必须的前提是 GROUP BY 和 ORDER BY 排序不一致。如果一致，各分片已经排序完成，无需内存中排序。</li>
</ul>
<h3 id="3-4-1-分页补充"><a href="#3-4-1-分页补充" class="headerlink" title="3.4.1 分页补充"></a>3.4.1 分页补充</h3><p>OffsetToken、RowCountToken 只有在分页对应位置非占位符 <code>?</code> 才存在。当对应位置是占位符时，会对<strong>分页条件对应的预编译 SQL 占位符参数</strong>进行重写，<strong>整体逻辑和 OffsetToken、RowCountToken 是一致的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 👼 ParsingSQLRouter#route() 调用 #processLimit() </span></div><div class="line"></div><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理分页条件</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> SQLRewriteEngine#appendLimitRowCount(SQLBuilder, RowCountToken, int, List, boolean) </div><div class="line">* <span class="doctag">@param</span> parameters 占位符对应参数列表</div><div class="line">* <span class="doctag">@param</span> selectStatement Select SQL语句对象</div><div class="line">* <span class="doctag">@param</span> isSingleRouting 是否单表路由</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLimit</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() <span class="comment">// // [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">                               || !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">                           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems(); <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">   selectStatement.getLimit().processParameters(parameters, !isSingleRouting, isNeedFetchAll);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 填充改写分页参数.</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否获取所有数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   fill(parameters);</div><div class="line">   <span class="keyword">if</span> (isRewrite) &#123;</div><div class="line">       rewrite(parameters, isFetchAll);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 将占位符参数里是分页的参数赋值给 offset 、rowCount</div><div class="line">* 赋值的前提条件是 offset、rowCount 是 占位符</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> offset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.offset) &#123;</div><div class="line">       offset = -<span class="number">1</span> == <span class="keyword">this</span>.offset.getIndex() ? getOffsetValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.offset.getIndex()));</div><div class="line">       <span class="keyword">this</span>.offset.setValue(offset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> rowCount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.rowCount) &#123;</div><div class="line">       rowCount = -<span class="number">1</span> == <span class="keyword">this</span>.rowCount.getIndex() ? getRowCountValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.rowCount.getIndex()));</div><div class="line">       <span class="keyword">this</span>.rowCount.setValue(rowCount);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || rowCount &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingException(<span class="string">"LIMIT offset and row count can not be a negative value."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写分页条件对应的参数</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否拉取所有</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> rewriteOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> rewriteRowCount;</div><div class="line">   <span class="comment">// 重写</span></div><div class="line">   <span class="keyword">if</span> (isFetchAll) &#123;</div><div class="line">       rewriteRowCount = Integer.MAX_VALUE;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowCountRewriteFlag) &#123;</div><div class="line">       rewriteRowCount = <span class="keyword">null</span> == rowCount ? -<span class="number">1</span> : getOffsetValue() + rowCount.getValue();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       rewriteRowCount = rowCount.getValue();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 参数设置</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != offset &amp;&amp; offset.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(offset.getIndex(), rewriteOffset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != rowCount &amp;&amp; rowCount.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(rowCount.getIndex(), rewriteRowCount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-5-OrderByToken"><a href="#3-5-OrderByToken" class="headerlink" title="3.5 OrderByToken"></a>3.5 OrderByToken</h2><p>调用 <code>#appendOrderByToken()</code> 方法拼接。数据库里，当无 ORDER BY条件 而有 GROUP BY 条件时候，会使用 GROUP BY条件将结果升序排序：</p>
<ul>
<li><code>SELECT order_id FROM t_order GROUP BY order_id</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id ASC</code></li>
<li><code>SELECT order_id FROM t_order GROUP BY order_id DESC</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id DESC</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OrderByToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   <span class="comment">// 拼接 OrderByToken</span></div><div class="line">   StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder(<span class="string">" ORDER BY "</span>);</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">           orderByLiterals.append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           orderByLiterals.append(<span class="string">","</span>).append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   orderByLiterals.append(<span class="string">" "</span>);</div><div class="line">   sqlBuilder.appendLiterals(orderByLiterals.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当 SQL 为 <code>SELECT order_id FROM t_order o GROUP BY order_id</code> 返回结果：<br>  <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/08.png" alt=""></li>
</ul>
<h2 id="3-6-GeneratedKeyToken"><a href="#3-6-GeneratedKeyToken" class="headerlink" title="3.6 GeneratedKeyToken"></a>3.6 GeneratedKeyToken</h2><p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-4/?mp">《SQL 解析（四）之插入SQL》</a></p>
<p>GeneratedKeyToken，和其它 SQLToken 不同，在 <strong>SQL解析</strong> 完进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123; <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 追加自增主键标记对象.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingRule 分片规则</div><div class="line">* <span class="doctag">@param</span> parametersSize 参数个数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// SQL 里有主键列</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != generatedKey) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TableRule 存在</span></div><div class="line">   Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(getTables().getSingleTableName());</div><div class="line">   <span class="keyword">if</span> (!tableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// GeneratedKeyToken 存在</span></div><div class="line">   Optional&lt;GeneratedKeyToken&gt; generatedKeysToken = findGeneratedKeyToken();</div><div class="line">   <span class="keyword">if</span> (!generatedKeysToken.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">   ItemsToken valuesToken = <span class="keyword">new</span> ItemsToken(generatedKeysToken.get().getBeginPosition());</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == parametersSize) &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken, parametersSize);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 generatedKeysToken</span></div><div class="line">   getSqlTokens().remove(generatedKeysToken.get());</div><div class="line">   <span class="comment">// 新增 ItemsToken</span></div><div class="line">   getSqlTokens().add(valuesToken);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>根据<strong>占位符参数</strong>数量不同，调用的 <code>#appendGenerateKeyToken()</code> 是<strong>不同</strong>的：</li>
<li><strong>占位符参数数量 = 0</strong> 时，直接生成<strong>分布式主键</strong>，保持无占位符的做法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成分布式主键</span></div><div class="line">   Number generatedKey = shardingRule.generateKey(tableRule.getLogicTable());</div><div class="line">   <span class="comment">// 添加到 ItemsToken</span></div><div class="line">   valuesToken.getItems().add(generatedKey.toString());</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLNumberExpression(generatedKey)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   <span class="keyword">this</span>.generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getLogicTable(), -<span class="number">1</span>, generatedKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>占位符参数数量 &gt; 0</strong> 时，生成自增列的占位符，保持有占位符的做法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成占位符</span></div><div class="line">   valuesToken.getItems().add(<span class="string">"?"</span>);</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLPlaceholderExpression(parametersSize)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getGenerateKeyColumn(), parametersSize, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因为 GenerateKeyToken 已经处理完，所以移除，避免 <code>SQLRewriteEngine#rewrite()</code> 二次改写。另外，通过 ItemsToken 补充自增列。</li>
<li>生成 GeneratedKey 会在 ParsingSQLRouter 进一步处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理 插入SQL 主键字段</div><div class="line">* 当 主键编号 未生成时，&#123;<span class="doctag">@link</span> ShardingRule#generateKey(String)&#125; 进行生成</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">* <span class="doctag">@param</span> insertStatement Insert SQL语句对象</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKey</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> InsertStatement insertStatement, <span class="keyword">final</span> SQLRouteResult sqlRouteResult)</span> </span>&#123;</div><div class="line">   GeneratedKey generatedKey = insertStatement.getGeneratedKey();</div><div class="line">   <span class="keyword">if</span> (parameters.isEmpty()) &#123; <span class="comment">// 已有主键，无占位符，INSERT INTO t_order(order_id, user_id) VALUES (1, 100);</span></div><div class="line">       sqlRouteResult.getGeneratedKeys().add(generatedKey.getValue());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.size() == generatedKey.getIndex()) &#123; <span class="comment">// 主键字段不存在存在，INSERT INTO t_order(user_id) VALUES(?);</span></div><div class="line">       Number key = shardingRule.generateKey(insertStatement.getTables().getSingleTableName()); <span class="comment">// 生成主键编号</span></div><div class="line">       parameters.add(key);</div><div class="line">       setGeneratedKeys(sqlRouteResult, key);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> != generatedKey.getIndex()) &#123; <span class="comment">// 主键字段存在，INSERT INTO t_order(order_id, user_id) VALUES(?, ?);</span></div><div class="line">       setGeneratedKeys(sqlRouteResult, (Number) parameters.get(generatedKey.getIndex()));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置 主键编号 到 SQL路由结果</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">* <span class="doctag">@param</span> generatedKey 主键编号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGeneratedKeys</span><span class="params">(<span class="keyword">final</span> SQLRouteResult sqlRouteResult, <span class="keyword">final</span> Number generatedKey)</span> </span>&#123;</div><div class="line">   generatedKeys.add(generatedKey);</div><div class="line">   sqlRouteResult.getGeneratedKeys().clear();</div><div class="line">   sqlRouteResult.getGeneratedKeys().addAll(generatedKeys);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>parameters.size() == generatedKey.getIndex()</code> 处对应 <code>#appendGenerateKeyToken()</code> 的 <strong>占位符参数数量 &gt; 0</strong> 情况，此时会生成<strong>分布式主键</strong>。😈 该处是不是可以考虑把生成<strong>分布式主键</strong>挪到 <code>#appendGenerateKeyToken()</code>，这样更加统一一些。</li>
</ul>
<h1 id="4-SQL-生成"><a href="#4-SQL-生成" class="headerlink" title="4. SQL 生成"></a>4. SQL 生成</h1><p><strong>SQL路由</strong>完后，会生成各数据分片的<strong>执行SQL</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 省略部分代码... 处理 插入SQL 主键字段</span></div><div class="line">   </div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   </div><div class="line">   <span class="comment">// 省略部分代码... SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 省略部分代码... 处理分页</span></div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               <span class="comment">// 👼 生成 SQL</span></div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           <span class="comment">// 👼 生成 SQL</span></div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>RewriteEngine#generateSQL()</code> 生成<strong>执行SQL</strong>。对于笛卡尔积路由结果和简单路由结果传递的参数略有不同：前者使用 CartesianDataSource ( CartesianTableReference )，后者使用路由表单元 ( TableUnit )。对路由结果不是很了解的同学，建议看下 <a href="http://www.yunai.me/Sharding-JDBC/sql-route-2/?mp">《SQL 路由（二）之分库分表路由》</a>。</li>
</ul>
<p><code>RewriteEngine#generateSQL()</code> 对于笛卡尔积路由结果和简单路由结果两种情况，处理上大体是一致的：1. 获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射，2. 根据映射改写 SQL 相关<strong>逻辑表</strong>为<strong>真实表</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(tableUnit));</div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(cartesianTableReference));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">// SQLBuilder.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableTokens 占位符集合（逻辑表与真实表映射）</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">for</span> (Object each : segments) &#123;</div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken &amp;&amp; tableTokens.containsKey(((TableToken) each).tableName)) &#123;</div><div class="line">           result.append(tableTokens.get(((TableToken) each).tableName));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.append(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#toSQL()</code> 结果如图： <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/09.png" alt=""><br>😜 对 <strong>SQL改写</strong> 是不是清晰很多了。</li>
</ul>
<hr>
<p>下面我们以<strong>笛卡尔积路由结果</strong>获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射为例子(<em>简单路由结果基本类似而且简单</em>)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得（笛卡尔积表路由组里的路由表单元逻辑表 和 与其互为BindingTable关系的逻辑表）对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积表路由组</div><div class="line">* <span class="doctag">@return</span> 集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getTableTokens</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; tableTokens = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (TableUnit each : cartesianTableReference.getTableUnits()) &#123;</div><div class="line">       tableTokens.put(each.getLogicTableName(), each.getActualTableName());</div><div class="line">       <span class="comment">// 查找 BindingTableRule</span></div><div class="line">       Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each.getLogicTableName());</div><div class="line">       <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">           tableTokens.putAll(getBindingTableTokens(each, bindingTableRule.get()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> tableTokens;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 BindingTable 关系的逻辑表对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由单元</div><div class="line">* <span class="doctag">@param</span> bindingTableRule Binding表规则配置对象</div><div class="line">* <span class="doctag">@return</span> 映射</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getBindingTableTokens</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> BindingTableRule bindingTableRule)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (String eachTable : sqlStatement.getTables().getTableNames()) &#123;</div><div class="line">       <span class="keyword">if</span> (!eachTable.equalsIgnoreCase(tableUnit.getLogicTableName()) &amp;&amp; bindingTableRule.hasLogicTable(eachTable)) &#123;</div><div class="line">           result.put(eachTable, bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>笛卡尔积表路由组( CartesianTableReference )包含<strong>多个</strong>路由表单元( TableUnit )。每个路由表单元需要遍历。</li>
<li>路由表单元本身包含逻辑表和真实表，直接添加到映射即可。</li>
<li>互为 BindingTable 关系的表只计算一次路由分片，因此<strong>未计算</strong>的真实表需要以其对应的<strong>已计算</strong>的真实表去查找，即 <code>bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName())</code> 处逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BindingTableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据其他Binding表真实表名称获取相应的真实Binding表名称.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> dataSource 数据源名称</div><div class="line">* <span class="doctag">@param</span> logicTable 逻辑表名称</div><div class="line">* <span class="doctag">@param</span> otherActualTable 其他真实Binding表名称</div><div class="line">* <span class="doctag">@return</span> 真实Binding表名称</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBindingActualTable</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String logicTable, <span class="keyword">final</span> String otherActualTable)</span> </span>&#123;</div><div class="line">   <span class="comment">// 计算 otherActualTable 在其 TableRule 的 actualTable 是第几个</span></div><div class="line">   <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.isDynamic()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Dynamic table cannot support Binding table."</span>);</div><div class="line">       &#125;</div><div class="line">       index = each.findActualTableIndex(dataSource, otherActualTable);</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(-<span class="number">1</span> != index, String.format(<span class="string">"Actual table [%s].[%s] is not in table config"</span>, dataSource, otherActualTable));</div><div class="line">   <span class="comment">// 计算 logicTable 在其 TableRule 的 第index 的 真实表</span></div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getLogicTable().equalsIgnoreCase(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> each.getActualTables().get(index).getTableName();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot find binding actual table, data source: %s, logic table: %s, other actual table: %s"</span>, dataSource, logicTable, otherActualTable));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能看起来有些绕，我们看张图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/10.png" alt=""></p>
<p><strong>友情提示</strong>：这里不嫌啰嗦在提一句，互为 BindingTable 的表，配置 TableRule 时，<code>actualTables</code> 数量一定要一致，否则多出来的表，可能会无法被路由到。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈，看完<strong>SQL改写</strong>后，<strong>SQL解析</strong>是不是清晰多了！嘿嘿嘿，反正我现在有点嗨。恩，蛮嗨的。</p>
<p>当然，如果<strong>SQL解析</strong>理解上有点疑惑的你，<strong>欢迎</strong>加我的微信，咱 <strong>1对1</strong> 搞基。关注我的微信公众号：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a> 即可获得。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<p>道友，转发一波朋友圈可好？</p>
<p>Let’s Go! <a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分布式主键》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> 继续。</p>
<p><em>感谢技术牛逼如你耐心的阅读本文。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-3/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-3/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2017-08-02T08:27:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>抱歉，站坑文。近期看情况更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-2/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-2/</id>
    <published>2017-08-05T16:00:00.000Z</published>
    <updated>2017-08-02T09:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLRouteResult</a></li>
<li><a href="#">3. 路由策略 x 算法</a></li>
<li><a href="#">4. SQL 路由</a></li>
<li><a href="#">5. DatabaseHintSQLRouter</a></li>
<li><a href="#">6. ParsingSQLRouter</a><ul>
<li><a href="#">6.1 SimpleRoutingEngine</a></li>
<li><a href="#">6.2 ComplexRoutingEngine</a></li>
<li><a href="#">6.3 CartesianRoutingEngine</a></li>
<li><a href="#">6.3 ParsingSQLRouter 主#route()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享分表分库<strong>路由</strong>相关的实现。涉及内容如下：</p>
<ol>
<li>SQL 路由结果</li>
<li>路由策略 x 算法</li>
<li>SQL 路由器</li>
</ol>
<p>内容顺序如编号。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<p>SQL 路由大体流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<h1 id="2-SQLRouteResult"><a href="#2-SQLRouteResult" class="headerlink" title="2. SQLRouteResult"></a>2. SQLRouteResult</h1><p>经过 <strong>SQL解析</strong>、<strong>SQL路由</strong>后，产生<strong>SQL路由结果</strong>，即 SQLRouteResult。根据路由结果，<strong>生成SQL</strong>，<strong>执行SQL</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/01.png" alt=""></p>
<ul>
<li><code>sqlStatement</code> ：SQL语句对象，经过<strong>SQL解析</strong>的结果对象。</li>
<li><code>executionUnits</code> ：SQL最小执行单元集合。<strong>SQL执行</strong>时，执行每个单元。</li>
<li><code>generatedKeys</code> ：<strong>插入</strong>SQL语句生成的主键编号集合。目前不支持批量插入而使用集合的原因，猜测是为了未来支持批量插入做准备。</li>
</ul>
<h1 id="3-路由策略-x-算法"><a href="#3-路由策略-x-算法" class="headerlink" title="3. 路由策略 x 算法"></a>3. 路由策略 x 算法</h1><p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<p>ShardingStrategy，分片策略。目前支持两种分片：  </p>
<p><em>分片资源：在分库策略里指的是库，在分表策略里指的是表。</em>  </p>
<p>【1】 计算<strong>静态</strong>分片（常用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算静态分片.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL语句的类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的数据源名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doStaticSharding</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">if</span> (shardingValues.isEmpty()) &#123;</div><div class="line">       Preconditions.checkState(!isInsertMultiple(sqlType, availableTargetNames), <span class="string">"INSERT statement should contain sharding value."</span>); <span class="comment">// 插入不能有多资源对象</span></div><div class="line">       result.addAll(availableTargetNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 插入SQL 是否插入多个分片</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInsertMultiple</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.INSERT == sqlType &amp;&amp; availableTargetNames.size() &gt; <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>插入SQL 需要有片键值，否则无法判断单个分片资源。<em>（Sharding-JDBC 目前仅支持单条记录插入）</em></li>
</ul>
<p>【2】计算<strong>动态</strong>分片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算动态分片.</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doDynamicSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Preconditions.checkState(!shardingValues.isEmpty(), <span class="string">"Dynamic table should contain sharding value."</span>); <span class="comment">// 动态分片必须有分片值</span></div><div class="line">   Collection&lt;String&gt; availableTargetNames = Collections.emptyList();</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>动态分片对应 <code>TableRule.dynamic=true</code></li>
<li>动态分片必须有分片值</li>
</ul>
<p>😈 闷了，看起来两者没啥区别？答案在<strong>分片算法</strong>上。我们先看 <code>#doSharding()</code> 方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算分片</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> NoneKeyShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.singletonList(((NoneKeyShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues.iterator().next()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 单片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> SingleKeyShardingAlgorithm) &#123;</div><div class="line">       SingleKeyShardingAlgorithm&lt;?&gt; singleKeyShardingAlgorithm = (SingleKeyShardingAlgorithm&lt;?&gt;) shardingAlgorithm;</div><div class="line">       ShardingValue shardingValue = shardingValues.iterator().next();</div><div class="line">       <span class="keyword">switch</span> (shardingValue.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> SINGLE:</div><div class="line">               <span class="keyword">return</span> Collections.singletonList(singleKeyShardingAlgorithm.doEqualSharding(availableTargetNames, shardingValue));</div><div class="line">           <span class="keyword">case</span> LIST:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doInSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">case</span> RANGE:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doBetweenSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingValue.getType().getClass().getName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> MultipleKeysShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> ((MultipleKeysShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingAlgorithm.getClass().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>无分片键算法：对应 NoneKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NoneKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>单片键算法：对应 SingleKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingleKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doEqualSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">ShardingValueType</th>
<th style="text-align:left">SQL 操作符</th>
<th style="text-align:left">接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SINGLE</td>
<td style="text-align:left">=</td>
<td style="text-align:left"><code>#doEqualSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">LIST</td>
<td style="text-align:left">IN</td>
<td style="text-align:left"><code>#doInSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">RANGE</td>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left"><code>#doBetweenSharding()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>多片键算法：对应 MultipleKeysShardingAlgorithm 分片算法接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipleKeysShardingAlgorithm</span> <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分片算法类结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/02.png" alt=""></p>
<p>来看看 Sharding-JDBC 实现的无需分库的分片算法 NoneDatabaseShardingAlgorithm (NoneTableShardingAlgorithm 基本一模一样)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneDatabaseShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyDatabaseShardingAlgorithm</span>&lt;<span class="title">String</span>&gt;, <span class="title">MultipleKeysDatabaseShardingAlgorithm</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames.isEmpty() ? <span class="keyword">null</span> : availableTargetNames.iterator().next();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>一定要注意，NoneXXXXShardingAlgorithm 只适用于无分库/表的需求，否则会是错误的路由结果。</strong>例如，<code>#doEqualSharding()</code> 返回的是第一个分片资源。</li>
</ul>
<hr>
<p>再来看测试目录下实现的<strong>余数基偶分表算法</strong> ModuloTableShardingAlgorithm 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.ModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">            <span class="keyword">if</span> (each.endsWith(shardingValue.getValue() % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> each;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            <span class="keyword">for</span> (String tableName : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (tableName.endsWith(value % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(tableName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (each.endsWith(i % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(each);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>我们可以参考这个例子编写自己的分片算哟 👼。</li>
<li>多片键分库算法接口实现例子：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/test/java/com/dangdang/ddframe/rdb/integrate/fixture/MultipleKeysModuloDatabaseShardingAlgorithm.java" rel="external nofollow noopener noreferrer" target="_blank">MultipleKeysModuloDatabaseShardingAlgorithm.java</a></li>
</ul>
<hr>
<p>😈 来看看<strong>动态计算分片</strong>需要怎么实现分片算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.SingleKeyDynamicModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleKeyDynamicModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 表前缀</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tablePrefix;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tablePrefix + shardingValue.getValue() % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(shardingValue.getValues().size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            result.add(tablePrefix + value % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            result.add(tablePrefix + i % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>骚年，是不是明白了一些？<strong>动态表</strong>无需把真实表配置到 TableRule，而是通过<strong>分片算法</strong>计算出<strong>真实表</strong>。</li>
</ul>
<h1 id="4-SQL-路由"><a href="#4-SQL-路由" class="headerlink" title="4. SQL 路由"></a>4. SQL 路由</h1><p>SQLRouter，SQL 路由器接口，共有两种实现：</p>
<ul>
<li>DatabaseHintSQLRouter：通过提示且仅路由至数据库的SQL路由器</li>
<li>ParsingSQLRouter：需要解析的SQL路由器</li>
</ul>
<p>它们实现 <code>#parse()</code>进行<strong>SQL解析</strong>，<code>#route()</code>进行<strong>SQL路由</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/03.png" alt=""></p>
<hr>
<p>RoutingEngine，路由引擎接口，共有四种实现：</p>
<ul>
<li>DatabaseHintRoutingEngine：基于数据库提示的路由引擎</li>
<li>SimpleRoutingEngine：简单路由引擎</li>
<li>CartesianRoutingEngine：笛卡尔积的库表路由</li>
<li>ComplexRoutingEngine：混合多库表路由引擎</li>
</ul>
<p><strong>ComplexRoutingEngine 根据路由结果会转化成 SimpleRoutingEngine 或 ComplexRoutingEngine</strong>。下文会看相应源码。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/04.png" alt=""></p>
<hr>
<p>路由结果有两种：</p>
<ul>
<li>RoutingResult：简单路由结果</li>
<li>CartesianRoutingResult：笛卡尔积路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/05.png" alt=""></p>
<p>从图中，我们已经能大概看到两者有什么区别，更具体的下文随源码一起分享。</p>
<p>😈 SQLRouteResult 和 RoutingResult 有什么区别？</p>
<ul>
<li>SQLRouteResult：<strong>整个SQL路由</strong>返回的路由结果</li>
<li>RoutingResult：<strong>RoutingEngine</strong>返回路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<hr>
<p>一下子看到这么多<strong>“对象”</strong>，可能有点<strong>紧张</strong>。不要紧张，我们一起在整理下。</p>
<table>
<thead>
<tr>
<th style="text-align:left">路由器</th>
<th style="text-align:left">路由引擎</th>
<th style="text-align:left">路由结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DatabaseHintSQLRouter</td>
<td style="text-align:left">DatabaseHintRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">SimpleRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">CartesianRoutingEngine</td>
<td style="text-align:left">CartesianRoutingResult</td>
</tr>
</tbody>
</table>
<p>😈 逗比博主给大家解决了<strong>“对象”</strong>，是不是应该<strong>分享朋友圈</strong>。</p>
<h1 id="5-DatabaseHintSQLRouter"><a href="#5-DatabaseHintSQLRouter" class="headerlink" title="5. DatabaseHintSQLRouter"></a>5. DatabaseHintSQLRouter</h1><p>DatabaseHintSQLRouter，基于数据库提示的路由引擎。路由器工厂 SQLRouterFactory 创建路由器时，判断到使用数据库提示( Hint ) 时，创建 DatabaseHintSQLRouter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLRouter <span class="title">createSQLRouter</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> HintManagerHolder.isDatabaseShardingOnly() ? <span class="keyword">new</span> DatabaseHintSQLRouter(shardingContext) : <span class="keyword">new</span> ParsingSQLRouter(shardingContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看下 HintManagerHolder、HintManager <strong>部分相关</strong>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HintManagerHolder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManagerHolder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * HintManager 线程变量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HintManager&gt; HINT_MANAGER_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否当前只分库.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 是否当前只分库.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDatabaseShardingOnly</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != HINT_MANAGER_HOLDER.get() &amp;&amp; HINT_MANAGER_HOLDER.get().isDatabaseShardingOnly();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清理线索分片管理器的本地线程持有者.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        HINT_MANAGER_HOLDER.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HintManager.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 库分片值集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ShardingKey, ShardingValue&lt;?&gt;&gt; databaseShardingValues = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 只做库分片</div><div class="line">     * &#123;<span class="doctag">@link</span> DatabaseHintRoutingEngine&#125;</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseShardingOnly;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线索分片管理器实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线索分片管理器实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HintManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        HintManager result = <span class="keyword">new</span> HintManager();</div><div class="line">        HintManagerHolder.setHintManager(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置分库分片值.</div><div class="line">     * </div><div class="line">     * &lt;p&gt;分片操作符为等号.该方法适用于只分库的场景&lt;/p&gt;</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 分片值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseShardingValue</span><span class="params">(<span class="keyword">final</span> Comparable&lt;?&gt; value)</span> </span>&#123;</div><div class="line">        databaseShardingOnly = <span class="keyword">true</span>;</div><div class="line">        addDatabaseShardingValue(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么如果要使用 DatabaseHintSQLRouter，我们只需要 <code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 即可。这里有两点要注意下：</p>
<ul>
<li><code>HintManager#getInstance()</code>，每次获取到的都是<strong>新</strong>的 HintManager，多次赋值需要小心。</li>
<li><code>HintManager#close()</code>，使用完需要去清理，避免下个请求读到遗漏的线程变量。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLJudgeEngine(logicSQL).judge(); <span class="comment">// 只解析 SQL 类型</span></div><div class="line">&#125;  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// TODO insert的SQL仍然需要解析自增主键</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = <span class="keyword">new</span> DatabaseHintRoutingEngine(shardingRule.getDataSourceRule(), shardingRule.getDatabaseShardingStrategy(), sqlStatement.getType())</div><div class="line">           .route();</div><div class="line">   <span class="comment">// SQL最小执行单元</span></div><div class="line">   <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">       result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), logicSQL));</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#parse()</code> 只解析了 SQL 类型，即 SELECT / UPDATE / DELETE / INSERT 。</li>
<li><strong>使用的分库策略来自 ShardingRule，不是 TableRule，这个一定要留心。</strong>❓因为 SQL 未解析<strong>表名</strong>。因此，即使在 TableRule 设置了 <code>actualTables</code> 属性也是没有效果的。</li>
<li>目前不支持 Sharding-JDBC 的主键自增。❓因为 SQL 未解析<strong>自增主键</strong>。从代码上的<code>TODO</code>应该会支持。</li>
<li><code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 设置的库分片值使用的是  EQUALS，因而分库策略计算出来的只有<strong>一个库分片</strong>，即 TableUnit 只有一个，SQLExecutionUnit 只有一个。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Hint 获得 分片键值</span></div><div class="line">   Optional&lt;ShardingValue&lt;?&gt;&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(<span class="keyword">new</span> ShardingKey(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME));</div><div class="line">   Preconditions.checkState(shardingValue.isPresent());</div><div class="line">   log.debug(<span class="string">"Before database sharding only db:&#123;&#125; sharding values: &#123;&#125;"</span>, dataSourceRule.getDataSourceNames(), shardingValue.get());</div><div class="line">   <span class="comment">// 路由。表分片规则使用的是 ShardingRule 里的。因为没 SQL 解析。</span></div><div class="line">   Collection&lt;String&gt; routingDataSources = databaseShardingStrategy.doStaticSharding(sqlType, dataSourceRule.getDataSourceNames(), Collections.&lt;ShardingValue&lt;?&gt;&gt;singleton(shardingValue.get()));</div><div class="line">   Preconditions.checkState(!routingDataSources.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   log.debug(<span class="string">"After database sharding only result: &#123;&#125;"</span>, routingDataSources);</div><div class="line">   <span class="comment">// 路由结果</span></div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (String each : routingDataSources) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each, <span class="string">""</span>, <span class="string">""</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>只</strong>调用 <code>databaseShardingStrategy.doStaticSharding()</code> 方法计算<strong>库</strong>分片。</li>
<li><code>new TableUnit(each, &quot;&quot;, &quot;&quot;)</code> 的 <code>logicTableName</code>，<code>actualTableName</code> 都是空串，相信原因你已经知道。</li>
</ul>
<h1 id="6-ParsingSQLRouter"><a href="#6-ParsingSQLRouter" class="headerlink" title="6. ParsingSQLRouter"></a>6. ParsingSQLRouter</h1><p>ParsingSQLRouter，需要解析的SQL路由器。</p>
<p>ParsingSQLRouter 使用 SQLParsingEngine <strong>解析SQL</strong>。对<strong>SQL解析</strong>有兴趣的同学可以看看拙作<a href="http://www.yunai.me/categories/Sharding-JDBC/?mp">《Sharding-JDBC 源码分析 —— SQL 解析》</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123;</div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#appendGenerateKeyToken()</code> 会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>分享</li>
</ul>
<hr>
<p>ParsingSQLRouter 在路由时，会根据<strong>表情况</strong>使用 SimpleRoutingEngine 或 CartesianRoutingEngine 进行路由。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; tableNames = sqlStatement.getTables().getTableNames();</div><div class="line">   RoutingEngine routingEngine;</div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == tableNames.size() || shardingRule.isAllBindingTables(tableNames)) &#123;</div><div class="line">       routingEngine = <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableNames.iterator().next(), sqlStatement);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// TODO 可配置是否执行笛卡尔积</span></div><div class="line">       routingEngine = <span class="keyword">new</span> ComplexRoutingEngine(shardingRule, parameters, tableNames, sqlStatement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> routingEngine.route();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当只进行<strong>一张表</strong>或者<strong>多表互为BindingTable关系</strong>时，使用 SimpleRoutingEngine 简单路由引擎。<strong>多表互为BindingTable关系</strong>时，每张表的路由结果是相同的，所以只要计算第一张表的分片即可。</li>
<li><code>tableNames.iterator().next()</code> 注意下，<code>tableNames</code> 变量是 <code>new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER)</code>。所以 <code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code> 即使 <code>t_order_item</code> 排在 <code>t_order</code> 前面，<code>tableNames.iterator().next()</code> 返回的是 <code>t_order</code>。当 <code>t_order</code> 和 <code>t_order_item</code> 为 <strong>BindingTable关系</strong> 时，计算的是 <code>t_order</code> 路由分片。</li>
<li>BindingTable关系在 ShardingRule 的 <code>tableRules</code> 配置。配置该关系 TableRule 有如下需要遵守的规则：<ul>
<li>分片策略与算法相同</li>
<li>数据源配置对象相同</li>
<li>真实表<strong>数量</strong>相同  </li>
</ul>
</li>
</ul>
<p><strong>举个例子</strong>：  </p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code>  </li>
<li>分库分表情况：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div></pre></td></tr></table></figure>
<p>最终执行的SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div></pre></td></tr></table></figure>
<ul>
<li><code>t_order_item_03</code>、<code>t_order_item_04</code> 无法被查询到。</li>
</ul>
<p>下面我们看看 <code>#isAllBindingTables()</code> 如何实现<strong>多表互为BindingTable关系</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="comment">// 调用顺序 #isAllBindingTables()=&gt;#filterAllBindingTables()=&gt;#findBindingTableRule()=&gt;#findBindingTableRule()</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断逻辑表名称集合是否全部属于Binding表.</div><div class="line">* <span class="doctag">@param</span> logicTables 逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; bindingTables = filterAllBindingTables(logicTables);</div><div class="line">   <span class="keyword">return</span> !bindingTables.isEmpty() &amp;&amp; bindingTables.containsAll(logicTables);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 过滤出所有的Binding表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">filterAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logicTables.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Optional&lt;BindingTableRule&gt; bindingTableRule = findBindingTableRule(logicTables);</div><div class="line">   <span class="keyword">if</span> (!bindingTableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交集</span></div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(bindingTableRule.get().getAllLogicTables());</div><div class="line">   result.retainAll(logicTables);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得包含&lt;strong&gt;任一&lt;/strong&gt;在逻辑表名称集合的binding表配置的逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;BindingTableRule&gt; result = findBindingTableRule(each);</div><div class="line">       <span class="keyword">if</span> (result.isPresent()) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据逻辑表名称获取binding表配置的逻辑表名称集合.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> String logicTable)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (BindingTableRule each : bindingTableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.hasLogicTable(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>逻辑看起来比较长，目的是找到一条 BindingTableRule 包含<strong>所有</strong>逻辑表集合</li>
<li>不支持<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB" rel="external nofollow noopener noreferrer" target="_blank">《传递关系》</a>：配置 BindingTableRule 时，<strong>相同绑定关系一定要配置在一条</strong>，必须是 <code>[a, b, c]</code>，而不能是 <code>[a, b], [b, c]</code>。</li>
</ul>
<h2 id="6-1-SimpleRoutingEngine"><a href="#6-1-SimpleRoutingEngine" class="headerlink" title="6.1 SimpleRoutingEngine"></a>6.1 SimpleRoutingEngine</h2><p>SimpleRoutingEngine，简单路由引擎。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/07.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</div><div class="line">   DatabaseShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getDatabaseShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualDatasourceNames(), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;ShardingValue&lt;?&gt;&gt; getShardingValues(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns) &#123;</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</div><div class="line">   <span class="keyword">for</span> (String each : shardingColumns) &#123;</div><div class="line">       Optional&lt;Condition&gt; condition = sqlStatement.getConditions().find(<span class="keyword">new</span> Column(each, logicTableName));</div><div class="line">       <span class="keyword">if</span> (condition.isPresent()) &#123;</div><div class="line">           result.add(condition.get().getShardingValue(parameters));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以使用 HintManager 设置<strong>库</strong>分片值进行<strong>强制路由</strong>。</li>
<li><code>#getShardingValues()</code> 我们看到了<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/">《SQL 解析（二）之SQL解析》</a>分享的 Condition 对象。之前我们提到过<strong>Parser 半理解SQL的目的之一是：提炼分片上下文</strong>，此处即是该目的的体现。Condition 里只放<strong>明确</strong>影响路由的条件，例如：<code>order_id = 1</code>, <code>order_id IN (1, 2)</code>, <code>order_id BETWEEN (1, 3)</code>，不放<strong>无法计算</strong>的条件，例如：<code>o.order_id = i.order_id</code>。该方法里，使用<strong>分片键</strong>从 Condition 查找 <strong>分片值</strong>。🙂 是不是对 Condition 的认识更加清晰一丢丢落。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources)</span> </span>&#123;</div><div class="line">   TableShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getTableShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = tableRule.isDynamic() ? strategy.doDynamicSharding(shardingValues)</div><div class="line">           : strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualTableNames(routedDataSources), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no table route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以使用 HintManager 设置<strong>表</strong>分片值进行<strong>强制路由</strong>。</li>
<li>根据 <code>dynamic</code> 属性来判断调用 <code>#doDynamicSharding()</code> 还是 <code>#doStaticSharding()</code> 计算分片。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources, <span class="keyword">final</span> Collection&lt;String&gt; routedTables)</span> </span>&#123;</div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (DataNode each : tableRule.getActualDataNodes(routedDataSources, routedTables)) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each.getDataSourceName(), logicTableName, each.getTableName()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据数据源名称过滤获取真实数据单元.</div><div class="line">* <span class="doctag">@param</span> targetDataSources 数据源名称集合</div><div class="line">* <span class="doctag">@param</span> targetTables 真实表名称集合</div><div class="line">* <span class="doctag">@return</span> 真实数据单元</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;DataNode&gt; <span class="title">getActualDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dynamic ? getDynamicDataNodes(targetDataSources, targetTables) : getStaticDataNodes(targetDataSources, targetTables);</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDynamicDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(targetDataSources.size() * targetTables.size());</div><div class="line">   <span class="keyword">for</span> (String targetDataSource : targetDataSources) &#123;</div><div class="line">       <span class="keyword">for</span> (String targetTable : targetTables) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> DataNode(targetDataSource, targetTable));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getStaticDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(actualTables.size());</div><div class="line">   <span class="keyword">for</span> (DataNode each : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (targetDataSources.contains(each.getDataSourceName()) &amp;&amp; targetTables.contains(each.getTableName())) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在 SimpleRoutingEngine 只生成了当前表的 TableUnits。如果存在<strong>与其互为BindingTable关系</strong>的表的 TableUnits 怎么获得？你可以想想噢，当然在后文<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>也会给出答案，看看和你想的是否一样。</li>
</ul>
<h2 id="6-2-ComplexRoutingEngine"><a href="#6-2-ComplexRoutingEngine" class="headerlink" title="6.2 ComplexRoutingEngine"></a>6.2 ComplexRoutingEngine</h2><p>ComplexRoutingEngine，混合多库表路由引擎。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ComplexRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;RoutingResult&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   Collection&lt;String&gt; bindingTableNames = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="comment">// 计算每个逻辑表的简单路由分片</span></div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(each);</div><div class="line">       <span class="keyword">if</span> (tableRule.isPresent()) &#123;</div><div class="line">           <span class="keyword">if</span> (!bindingTableNames.contains(each)) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableRule.get().getLogicTable(), sqlStatement).route());</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 互为 BindingTable 关系的表加到 bindingTableNames 里，不重复计算分片</span></div><div class="line">           Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each);</div><div class="line">           <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">               bindingTableNames.addAll(Lists.transform(bindingTableRule.get().getTableRules(), <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</div><div class="line">                   </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> input.getLogicTable();</div><div class="line">                   &#125;</div><div class="line">               &#125;));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"mixed tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Cannot find table rule and default data source with logic tables: '%s'"</span>, logicTables);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 防御性编程。shardingRule#isAllBindingTables() 已经过滤了这个情况。</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == result.size()) &#123;</div><div class="line">       <span class="keyword">return</span> result.iterator().next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交给 CartesianRoutingEngine 形成笛卡尔积结果</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CartesianRoutingEngine(result).route();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ComplexRoutingEngine 计算每个逻辑表的简单路由分片，路由结果交给 CartesianRoutingEngine <strong>继续</strong>路由形成笛卡尔积结果。</li>
</ul>
<p><img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/08.png" alt=""></p>
<ul>
<li>由于目前 ComplexRoutingEngine 路由前已经判断<strong>全部表互为 BindingTable 关系</strong>，因而不会出现 <code>result.size == 1</code>，属于防御性编程。</li>
<li><strong>部分表互为 BindingTable 关系</strong>时，ComplexRoutingEngine 不重复计算分片。</li>
</ul>
<h2 id="6-3-CartesianRoutingEngine"><a href="#6-3-CartesianRoutingEngine" class="headerlink" title="6.3 CartesianRoutingEngine"></a>6.3 CartesianRoutingEngine</h2><p>CartesianRoutingEngine，笛卡尔积的库表路由。</p>
<p>实现逻辑上<strong>相对</strong>复杂，请保持耐心哟，😈 其实目的就是实现<strong>连连看</strong>的效果：</p>
<ul>
<li>RoutingResult[0] <code>x</code> RoutingResult[1] …… <code>x</code> RoutingResult[n- 1] <code>x</code> RoutingResult[n]</li>
<li><strong>同库</strong> 才可以进行笛卡尔积</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CartesianRoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   CartesianRoutingResult result = <span class="keyword">new</span> CartesianRoutingResult();</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : getDataSourceLogicTablesMap().entrySet()) &#123; <span class="comment">// Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</span></div><div class="line">       <span class="comment">// 获得当前数据源（库）的 路由表单元分组</span></div><div class="line">       List&lt;Set&lt;String&gt;&gt; actualTableGroups = getActualTableGroups(entry.getKey(), entry.getValue()); <span class="comment">// List&lt;Set&lt;真实表&gt;&gt;</span></div><div class="line">       List&lt;Set&lt;TableUnit&gt;&gt; tableUnitGroups = toTableUnitGroups(entry.getKey(), actualTableGroups);</div><div class="line">       <span class="comment">// 笛卡尔积，并合并结果</span></div><div class="line">       result.merge(entry.getKey(), getCartesianTableReferences(Sets.cartesianProduct(tableUnitGroups)));</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"cartesian tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一步，获得<strong>同库</strong>对应的<strong>逻辑表</strong>集合，即 <strong>Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</strong>。</li>
<li>第二步，遍历<strong>数据源（库）</strong>，获得当前<strong>数据源（库）</strong>的<strong>路由表单元分组</strong>。</li>
<li>第三步，对<strong>路由表单元分组</strong>进行<strong>笛卡尔积</strong>，并合并到路由结果。</li>
</ul>
<p>下面，我们一起逐步看看代码实现。</p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li>
<li>分库分表情况：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得同库对应的逻辑表集合</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; getDataSourceLogicTablesMap() &#123;</div><div class="line">   Collection&lt;String&gt; intersectionDataSources = getIntersectionDataSources();</div><div class="line">   Map&lt;String, Set&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(routingResults.size());</div><div class="line">   <span class="comment">// 获得同库对应的逻辑表集合</span></div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : each.getTableUnits().getDataSourceLogicTablesMap(intersectionDataSources).entrySet()) &#123; <span class="comment">// 过滤掉不在数据源（库）交集的逻辑表</span></div><div class="line">           <span class="keyword">if</span> (result.containsKey(entry.getKey())) &#123;</div><div class="line">               result.get(entry.getKey()).addAll(entry.getValue());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(entry.getKey(), entry.getValue());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得所有路由结果里的数据源（库）交集</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getIntersectionDataSources</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">           result.addAll(each.getTableUnits().getDataSourceNames());</div><div class="line">       &#125;</div><div class="line">       result.retainAll(each.getTableUnits().getDataSourceNames()); <span class="comment">// 交集</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#getDataSourceLogicTablesMap()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/09.png" alt=""></li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第二步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;String&gt;&gt; getActualTableGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Set&lt;String&gt; logicTables) &#123;</div><div class="line">   List&lt;Set&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       result.addAll(each.getTableUnits().getActualTableNameGroups(dataSource, logicTables));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;TableUnit&gt;&gt; toTableUnitGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> List&lt;Set&lt;String&gt;&gt; actualTableGroups) &#123;</div><div class="line">   List&lt;Set&lt;TableUnit&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTableGroups.size());</div><div class="line">   <span class="keyword">for</span> (Set&lt;String&gt; each : actualTableGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> HashSet&lt;&gt;(Lists.transform(<span class="keyword">new</span> ArrayList&lt;&gt;(each), <span class="keyword">new</span> Function&lt;String, TableUnit&gt;() &#123;</div><div class="line">    </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> TableUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> findTableUnit(dataSource, input);</div><div class="line">           &#125;</div><div class="line">       &#125;)));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#getActualTableGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/10.png" alt=""></li>
<li><code>#toTableUnitGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/11.png" alt=""></li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;CartesianTableReference&gt; <span class="title">getCartesianTableReferences</span><span class="params">(<span class="keyword">final</span> Set&lt;List&lt;TableUnit&gt;&gt; cartesianTableUnitGroups)</span> </span>&#123;</div><div class="line">   List&lt;CartesianTableReference&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(cartesianTableUnitGroups.size());</div><div class="line">   <span class="keyword">for</span> (List&lt;TableUnit&gt; each : cartesianTableUnitGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> CartesianTableReference(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CartesianRoutingResult.java</span></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CartesianDataSource&gt; routingDataSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Collection&lt;CartesianTableReference&gt; routingTableReferences)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianTableReference each : routingTableReferences) &#123;</div><div class="line">       merge(dataSource, each);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> CartesianTableReference routingTableReference)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianDataSource each : routingDataSources) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getDataSource().equalsIgnoreCase(dataSource)) &#123;</div><div class="line">           each.getRoutingTableReferences().add(routingTableReference);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   routingDataSources.add(<span class="keyword">new</span> CartesianDataSource(dataSource, routingTableReference));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>Sets.cartesianProduct(tableUnitGroups)</code> 返回如图（Guava 工具库真强大）：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/12.png" alt=""></li>
<li><p><code>#getCartesianTableReferences()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/13.png" alt=""></p>
<p>  CartesianTableReference，笛卡尔积表<strong>路由组</strong>，包含<strong>多条</strong> TableUnit，即 TableUnit[0] <code>x</code> TableUnit[1] …… <code>x</code> TableUnit[n]。例如图中：<code>t_order_01 x t_order_item_02</code>，最终转换成 SQL 为 <code>SELECT * FROM t_order_01 o join t_order_item_02 i ON o.order_id = i.order_id</code>。</p>
</li>
<li><code>#merge()</code> 合并笛卡尔积路由结果。CartesianRoutingResult 包含多个 CartesianDataSource，因此需要将 CartesianTableReference 合并（添加）到对应的 CartesianDataSource。当然，目前在实现时已经是按照<strong>数据源（库）</strong>生成对应的 CartesianTableReference。</li>
</ul>
<h2 id="6-4-ParsingSQLRouter-主-route"><a href="#6-4-ParsingSQLRouter-主-route" class="headerlink" title="6.4 ParsingSQLRouter 主#route()"></a>6.4 ParsingSQLRouter 主#route()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 🐒🐒🐒 路由 🐒🐒🐒</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   <span class="comment">// SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 处理分页</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</div><div class="line">       processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="comment">// 打印 SQL</span></div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>RoutingResult routingResult = route(parameters, sqlStatement);</code> <strong>调用</strong>的就是上文分析的 SimpleRoutingEngine、ComplexRoutingEngine、CartesianRoutingEngine 的 <code>#route()</code> 方法。</li>
<li><code>#processGeneratedKey()</code>、<code>#processLimit()</code>、<code>#rewrite()</code>、<code>#generateSQL()</code> 等会放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 分享。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>篇幅有些长，希望能让大家对<strong>路由</strong>有比较完整的认识。<br>如果内容有错误，烦请您指正，我会<strong>认真</strong>修改。<br>如果表述不清晰，不太理解的，欢迎加我微信（wangwenbin-server）一起探讨。</p>
<p>谢谢你技术这么好，还<strong>耐心</strong>看完了本文。</p>
<p>强制路由 HintManager 讲的相对略过，可以看如下内容进一步了解：</p>
<ol>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/hint-sharding-value/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档-强制路由》</a></li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/api/HintManager.java#L41" rel="external nofollow noopener noreferrer" target="_blank">HintManager.java 源码</a></li>
</ol>
<p>厚着脸皮，道友，辛苦<strong>分享朋友圈</strong>可好？！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（一）之分库分表配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-1/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-1/</id>
    <published>2017-08-03T16:00:00.000Z</published>
    <updated>2017-08-02T14:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. TableRule</a><ul>
<li><a href="#">2.1 logicTable</a></li>
<li><a href="#">2.2 数据单元</a><ul>
<li><a href="#">2.2.1 DataNode</a></li>
<li><a href="#">2.2.2 DynamicDataNode</a></li>
</ul>
</li>
<li><a href="#">2.3 分库/分表策略</a></li>
<li><a href="#">2.4 主键生成</a></li>
</ul>
</li>
<li><a href="#">3. ShardingRule</a><ul>
<li><a href="#">3.1 dataSourceRule</a></li>
<li><a href="#">3.2 tableRules</a></li>
<li><a href="#">3.3 bindingTableRules</a></li>
</ul>
</li>
<li><a href="#">4. ShardingStrategy</a></li>
<li><a href="#">5. ShardingAlgorithm</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>😆<a href="http://www.yunai.me/categories/Sharding-JDBC/?self">《SQL 解析》</a> 已经告于段落，我们要开始新的旅程：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 路由》</a>。相比<strong>SQL解析</strong>，路由会容易理解很多，骗人是小🐷。整个系列预计会拆分成<strong>三小篇</strong>文章：</p>
<ol>
<li>《分库分表配置》</li>
<li>《分表分库路由》</li>
<li>《Spring与YAML配置》</li>
</ol>
<p>第一、二篇会在<strong>近期</strong>更新。第三篇会在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>完成后进行更新。😈改写和执行相对有趣。</p>
<p>👼道友，您看，逗比博主<strong>“很有规划”</strong>，是关注公众号一波<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>还是分享朋友圈。</p>
<hr>
<p>阅读本文之前，建议已经读过<strong>官方</strong>相关文章：</p>
<ul>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/concepts/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 核心概念》</a></li>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/sharding/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 分表分库》</a></li>
</ul>
<p>分表分库配置会涉及如下类：</p>
<ul>
<li>TableRule 表规则配置对象</li>
<li>ShardingRule 分库分表规则配置对象</li>
<li>ShardingStrategy 分片策略</li>
<li>ShardingAlgorithm 分片算法</li>
</ul>
<p>我们来一起逐个类往下看。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-TableRule"><a href="#2-TableRule" class="headerlink" title="2. TableRule"></a>2. TableRule</h1><p>TableRule，表规则配置对象，内嵌 TableRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/01.png" alt=""></p>
<h2 id="2-1-logicTable"><a href="#2-1-logicTable" class="headerlink" title="2.1 logicTable"></a>2.1 logicTable</h2><blockquote>
<p>数据分片的<strong>逻辑表</strong>，对于水平拆分的数据库(表)，同一类表的总称。<br>例：订单数据根据主键尾数拆分为10张表,分别是t_order_0到t_order_9，他们的逻辑表名为t_order。</p>
</blockquote>
<h2 id="2-2-数据单元"><a href="#2-2-数据单元" class="headerlink" title="2.2 数据单元"></a>2.2 数据单元</h2><p>Sharding-JDBC 有两种类型<strong>数据单元</strong>：</p>
<ul>
<li>DataNode ：<strong>静态</strong>分库分表数据单元</li>
</ul>
<blockquote>
<p>数据分片的最小单元，由数据源名称和数据表组成。<br>例：ds_1.t_order_0。配置时默认各个分片数据库的表结构均相同，直接配置逻辑表和真实表对应关系即可。<br>如果各数据库的表结果不同，可使用ds.actual_table配置。</p>
</blockquote>
<ul>
<li>DynamicDataNode ：<strong>动态</strong>表的分库分表数据单元</li>
</ul>
<blockquote>
<p>逻辑表和真实表不一定需要在配置规则中静态配置。<br>比如按照日期分片的场景，真实表的名称随着时间的推移会产生变化。<br>此类需求Sharding-JDBC是支持的，不过目前配置并不友好，会在新版本中提升。</p>
</blockquote>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/02.png" alt=""></p>
<p>TableRuleBuilder 调用 <code>#build()</code> 方法创建 TableRule。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRuleBuilder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TableRuleBuilder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> TableRule <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">       KeyGenerator keyGenerator = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != generateKeyColumn &amp;&amp; <span class="keyword">null</span> != keyGeneratorClass) &#123;</div><div class="line">           keyGenerator = KeyGeneratorFactory.createKeyGenerator(keyGeneratorClass);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TableRule(logicTable, dynamic, actualTables, dataSourceRule, dataSourceNames, databaseShardingStrategy, tableShardingStrategy, generateKeyColumn, keyGenerator);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableRule</span><span class="params">(<span class="keyword">final</span> String logicTable, <span class="keyword">final</span> <span class="keyword">boolean</span> dynamic, <span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; dataSourceNames,</span></span></div><div class="line">                <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy,</div><div class="line">                <span class="keyword">final</span> String generateKeyColumn, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   Preconditions.checkNotNull(logicTable);</div><div class="line">   <span class="keyword">this</span>.logicTable = logicTable;</div><div class="line">   <span class="keyword">this</span>.dynamic = dynamic;</div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = tableShardingStrategy;</div><div class="line">   <span class="keyword">if</span> (dynamic) &#123; <span class="comment">// 动态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(dataSourceRule);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == actualTables || actualTables.isEmpty()) &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(Collections.singletonList(logicTable), dataSourceRule, dataSourceNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(actualTables, dataSourceRule, dataSourceNames);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.generateKeyColumn = generateKeyColumn;</div><div class="line">   <span class="keyword">this</span>.keyGenerator = keyGenerator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-1-DataNode"><a href="#2-2-1-DataNode" class="headerlink" title="2.2.1 DataNode"></a>2.2.1 DataNode</h3><p>大多数业务场景下，我们使用<strong>静态</strong>分库分表数据单元，即 DataNode。如上文注释处 <code>静态表的分库分表数据单元</code> 处所见，分成<strong>两</strong>种判断，实质上第一种是将 <code>logicTable</code> 作为 <code>actualTable</code>，即在<strong>库</strong>里不进行分表，是第二种的一种特例。</p>
<p>我们来看看 <code>#generateDataNodes()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成静态数据分片节点</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> actualTables 真实表</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 静态数据分片节点</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = getDataSourceNames(dataSourceRule, actualDataSourceNames);</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTables.size() * (dataSourceNames.isEmpty() ? <span class="number">1</span> : dataSourceNames.size()));</div><div class="line">   <span class="keyword">for</span> (String actualTable : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (DataNode.isValidDataNode(actualTable)) &#123; <span class="comment">// 当 actualTable 为 $&#123;dataSourceName&#125;.$&#123;tableName&#125; 时</span></div><div class="line">           result.add(<span class="keyword">new</span> DataNode(actualTable));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (String dataSourceName : dataSourceNames) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> DataNode(dataSourceName, actualTable));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据 数据源配置对象 和 数据源名集合 获得 最终的数据源名集合</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 最终的数据源名集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getDataSourceNames</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == dataSourceRule) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == actualDataSourceNames || actualDataSourceNames.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> dataSourceRule.getDataSourceNames();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> actualDataSourceNames;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>第一种情况，<strong>自定义分布</strong>。<code>actualTable</code> 为 <code>${dataSourceName}.${tableName}</code> 时，即已经明确真实表所在数据源。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"db0.t_order_0"</span>, <span class="string">"db1.t_order_1"</span>, <span class="string">"db1.t_order_2"</span>))</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  └── t_order_0 </div><div class="line">db1</div><div class="line">  ├── t_order_1</div><div class="line">  └── t_order_2</div></pre></td></tr></table></figure>
<ul>
<li>第二种情况，<strong>均匀分布</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"t_order_0"</span>, <span class="string">"t_order_1"</span>))</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1 </div><div class="line">db1</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1</div></pre></td></tr></table></figure>
<p><code>#getDataSourceNames()</code> 使用 <code>dataSourceRule</code> 和 <code>actualDataSourceNames</code> 获取数据源的逻辑看起来有种“诡异”。<strong>实际 TableRuleBuilder 创建 TableRule 时，使用 <code>dataSourceRule</code> 而不要使用 <code>actualDataSourceNames</code></strong>。</p>
<h3 id="2-2-2-DynamicDataNode"><a href="#2-2-2-DynamicDataNode" class="headerlink" title="2.2.2 DynamicDataNode"></a>2.2.2 DynamicDataNode</h3><p>少数业务场景下，我们使用<strong>动态</strong>分库分表数据单元，即 DynamicDataNode。<br><strong>通过 <code>dynamic=true</code> 属性配置</strong>。生成代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = dataSourceRule.getDataSourceNames();</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(dataSourceNames.size());</div><div class="line">   <span class="keyword">for</span> (String each : dataSourceNames) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> DynamicDataNode(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>😂 从代码上看，貌似和<strong>动态</strong>分库分表数据单元没一毛钱关系？！别捉鸡，答案在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 上。</p>
<h2 id="2-3-分库-分表策略"><a href="#2-3-分库-分表策略" class="headerlink" title="2.3 分库/分表策略"></a>2.3 分库/分表策略</h2><ul>
<li><code>databaseShardingStrategy</code> ：分库策略</li>
<li><code>tableShardingStrategy</code> ：分表策略</li>
</ul>
<p>当分库/分表策略不配置时，使用 ShardingRule 配置的分库/分表策略。</p>
<h2 id="2-4-主键生成"><a href="#2-4-主键生成" class="headerlink" title="2.4 主键生成"></a>2.4 主键生成</h2><ul>
<li><code>generateKeyColumn</code> ：主键字段</li>
<li><code>keyGenerator</code> ：主键生成器</li>
</ul>
<p>当主键生成器不配置时，使用 ShardingRule 配置的主键生成器。</p>
<h1 id="3-ShardingRule"><a href="#3-ShardingRule" class="headerlink" title="3. ShardingRule"></a>3. ShardingRule</h1><p>ShardingRule，分库分表规则配置对象，内嵌 ShardingRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/03.png" alt=""></p>
<p>其中 databaseShardingStrategy、tableShardingStrategy、keyGenerator、defaultGenerator 和 TableRule 属性重复，用于当 TableRule 未配置对应属性，使用 ShardingRule 提供的该属性。</p>
<h2 id="3-1-dataSourceRule"><a href="#3-1-dataSourceRule" class="headerlink" title="3.1 dataSourceRule"></a>3.1 dataSourceRule</h2><p><code>dataSourceRule</code>，数据源配置对象。ShardingRule 需要数据源配置正确。这点和 TableRule 是不同的。TableRule 对 <code>dataSourceRule</code> <strong>只使用数据源名字，最终执行SQL 使用数据源名字从 ShardingRule 获取数据源连接</strong>。大家可以回到本文【2.2.1 DataNode】细看下 DataNode 的生成过程。</p>
<h2 id="3-2-tableRules"><a href="#3-2-tableRules" class="headerlink" title="3.2 tableRules"></a>3.2 tableRules</h2><p><code>tableRules</code>，表规则配置对象<strong>集合</strong>。</p>
<h2 id="3-3-bindingTableRules"><a href="#3-3-bindingTableRules" class="headerlink" title="3.3 bindingTableRules"></a>3.3 bindingTableRules</h2><blockquote>
<p>指在任何场景下分片规则均一致的主表和子表。<br>例：订单表和订单项表，均按照订单ID分片，则此两张表互为BindingTable关系。<br>BindingTable关系的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。</p>
</blockquote>
<p>😈 这么说，可能不太容易理解。<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>，我们在源码的基础上，好好理解下。<strong>非常重要，特别是性能优化上面</strong>。</p>
<h1 id="4-ShardingStrategy"><a href="#4-ShardingStrategy" class="headerlink" title="4. ShardingStrategy"></a>4. ShardingStrategy</h1><p>ShardingStrategy，分片策略。</p>
<ul>
<li>针对分库、分表有两个子类。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<ul>
<li>DatabaseShardingStrategy，使用<strong>分库</strong>算法进行分片</li>
<li>TableShardingStrategy，使用<strong>分表</strong>算法进行分片</li>
</ul>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1 id="5-ShardingAlgorithm"><a href="#5-ShardingAlgorithm" class="headerlink" title="5. ShardingAlgorithm"></a>5. ShardingAlgorithm</h1><p>ShardingAlgorithm，分片算法。</p>
<ul>
<li>针对分库、分表有两个子<strong>接口</strong>。</li>
<li>针对<strong>分片键</strong>数量分成：无分片键算法、单片键算法、多片键算法。</li>
</ul>
<p><strong>其中 NoneKeyDatabaseShardingAlgorithm、NoneTableShardingAlgorithm 为 ShardingRule 在未设置分库、分表算法的默认值</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingRule</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;TableRule&gt; tableRules, <span class="keyword">final</span> Collection&lt;BindingTableRule&gt; bindingTableRules,</div><div class="line">       <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = <span class="keyword">null</span> == databaseShardingStrategy ? <span class="keyword">new</span> DatabaseShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneDatabaseShardingAlgorithm()) : databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = <span class="keyword">null</span> == tableShardingStrategy ? <span class="keyword">new</span> TableShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneTableShardingAlgorithm()) : tableShardingStrategy;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文看似在水更，实是为<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>做铺垫（一阵脸红😳）。</p>
<p>But，无论怎么说，道友，我做了新的关注二维码（感谢猫🐱先生），是不是可以推荐一波公众号给基佬。</p>
<p>恩，继续更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（六）之删除SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-6/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-6/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. DeleteStatement</a></li>
<li><a href="#">3. #parse()</a><ul>
<li><a href="#">3.1 #skipBetweenDeleteAndTable()</a></li>
<li><a href="#">3.2 #parseSingleTable()</a></li>
<li><a href="#">3.3 #parseWhere()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>删除SQL解析</strong>的源码实现。</p>
<p>🙂 如果你已经理解<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之查询SQL》</a>，那本文会是一篇水文，当成一种放松吧。还是跟前文一样，以 MySQL 举例子。我们来一起看看 MySQLDeleteParser。</p>
<p>MySQL DELETE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>] <span class="keyword">FROM</span> tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</div><div class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</div></pre></td></tr></table></figure>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    tbl_name[.*] [, tbl_name[.*]] ...</div><div class="line">    <span class="keyword">FROM</span> table_references</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    </div><div class="line">【<span class="keyword">OR</span>】</div><div class="line"></div><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    <span class="keyword">FROM</span> tbl_name[.*] [, tbl_name[.*]] ...</div><div class="line">    <span class="keyword">USING</span> table_references</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div></pre></td></tr></table></figure>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<p>Sharding-JDBC 更新SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_02/01.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> DeleteStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 DELETE</span></div><div class="line">   skipBetweenDeleteAndTable(); <span class="comment">// // 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE 和 FROM</span></div><div class="line">   sqlParser.parseSingleTable(deleteStatement); <span class="comment">// 解析表</span></div><div class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE); <span class="comment">// 跳到 WHERE</span></div><div class="line">   sqlParser.parseWhere(deleteStatement); <span class="comment">// 解析 WHERE</span></div><div class="line">   <span class="keyword">return</span> deleteStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-DeleteStatement"><a href="#2-DeleteStatement" class="headerlink" title="2. DeleteStatement"></a>2. DeleteStatement</h1><p>删除SQL 解析结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>😈 对，没有其他属性。</p>
<p>我们来看下 <code>DELETE IGNORE FROM t_user WHERE user_id = ?</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_02/02.png" alt=""></p>
<h1 id="3-parse"><a href="#3-parse" class="headerlink" title="3. #parse()"></a>3. #parse()</h1><h2 id="3-1-skipBetweenDeleteAndTable"><a href="#3-1-skipBetweenDeleteAndTable" class="headerlink" title="3.1 #skipBetweenDeleteAndTable()"></a>3.1 #skipBetweenDeleteAndTable()</h2><p>在 <code>DELETE</code> 和 表名 之间有些词法，对 SQL 路由和改写无影响，进行跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenDeleteAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipAll(MySQLKeyword.LOW_PRIORITY, MySQLKeyword.QUICK, MySQLKeyword.IGNORE);</div><div class="line">   getSqlParser().skipIfEqual(DefaultKeyword.FROM);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OracleDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenDeleteAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipIfEqual(DefaultKeyword.FROM);</div><div class="line">   getSqlParser().skipIfEqual(OracleKeyword.ONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-parseSingleTable"><a href="#3-2-parseSingleTable" class="headerlink" title="3.2 #parseSingleTable()"></a>3.2 #parseSingleTable()</h2><p>解析<strong>表</strong>，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2 id="3-3-parseWhere"><a href="#3-3-parseWhere" class="headerlink" title="3.3 #parseWhere()"></a>3.3 #parseWhere()</h2><p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>道友，帮我分享一波怎么样？</p>
<p><strong>后面 SQL 路由和改写会更加有趣哟！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（五）之更新SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-5/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-5/</id>
    <published>2017-07-30T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. UpdateStatement</a></li>
<li><a href="#">3. #parse()</a><ul>
<li><a href="#">3.1 #skipBetweenUpdateAndTable()</a></li>
<li><a href="#">3.2 #parseSingleTable()</a></li>
<li><a href="#">3.3 #parseSetItems()</a></li>
<li><a href="#">3.4 #parseWhere()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>更新SQL解析</strong>的源码实现。</p>
<p>更新SQL解析比查询SQL解析复杂度低的多的多。不同数据库在插入SQL语法上也统一的多。<strong>本文分享 MySQL 更新SQL解析器 MySQLUpdateParser</strong>。</p>
<p>MySQL UPDATE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_reference</div><div class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</div><div class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</div></pre></td></tr></table></figure>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_references</div><div class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div></pre></td></tr></table></figure>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<p>Sharding-JDBC 更新SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_31/01.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> UpdateStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 UPDATE</span></div><div class="line">   skipBetweenUpdateAndTable(); <span class="comment">// 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE</span></div><div class="line">   sqlParser.parseSingleTable(updateStatement); <span class="comment">// 解析表</span></div><div class="line">   parseSetItems(); <span class="comment">// 解析 SET</span></div><div class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE);</div><div class="line">   sqlParser.setParametersIndex(parametersIndex);</div><div class="line">   sqlParser.parseWhere(updateStatement);</div><div class="line">   <span class="keyword">return</span> updateStatement; <span class="comment">// 解析 WHERE</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-UpdateStatement"><a href="#2-UpdateStatement" class="headerlink" title="2. UpdateStatement"></a>2. UpdateStatement</h1><p>更新SQL 解析结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>😈 对，没有其他属性。</p>
<p>我们来看下 <code>UPDATE t_user SET nickname = ?, age = ? WHERE user_id = ?</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_31/02.png" alt=""></p>
<h1 id="3-parse"><a href="#3-parse" class="headerlink" title="3. #parse()"></a>3. #parse()</h1><h2 id="3-1-skipBetweenUpdateAndTable"><a href="#3-1-skipBetweenUpdateAndTable" class="headerlink" title="3.1 #skipBetweenUpdateAndTable()"></a>3.1 #skipBetweenUpdateAndTable()</h2><p>在 <code>UPDATE</code> 和 表名 之间有些词法，对 SQL 路由和改写无影响，进行跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenUpdateAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipAll(MySQLKeyword.LOW_PRIORITY, MySQLKeyword.IGNORE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OracleUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenUpdateAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipIfEqual(OracleKeyword.ONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-parseSingleTable"><a href="#3-2-parseSingleTable" class="headerlink" title="3.2 #parseSingleTable()"></a>3.2 #parseSingleTable()</h2><p>解析<strong>表</strong>，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2 id="3-3-parseSetItems"><a href="#3-3-parseSetItems" class="headerlink" title="3.3 #parseSetItems()"></a>3.3 #parseSetItems()</h2><p>解析<code>SET</code>后语句。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractUpdateParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析多个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.accept(DefaultKeyword.SET);</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       parseSetItem();</div><div class="line">   &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA)); <span class="comment">// 以 "," 分隔</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetItem</span><span class="params">()</span> </span>&#123;</div><div class="line">   parseSetColumn();</div><div class="line">   sqlParser.skipIfEqual(Symbol.EQ, Symbol.COLON_EQ);</div><div class="line">   parseSetValue();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetColumn</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       sqlParser.skipParentheses();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> beginPosition = sqlParser.getLexer().getCurrentToken().getEndPosition();</div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// 字段有别名</span></div><div class="line">       <span class="comment">// TableToken</span></div><div class="line">       <span class="keyword">if</span> (updateStatement.getTables().getSingleTableName().equalsIgnoreCase(SQLUtil.getExactlyValue(literals))) &#123;</div><div class="line">           updateStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition - literals.length(), literals));</div><div class="line">       &#125;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 值</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetValue</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.parseExpression(updateStatement);</div><div class="line">   parametersIndex = sqlParser.getParametersIndex();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-parseWhere"><a href="#3-4-parseWhere" class="headerlink" title="3.4 #parseWhere()"></a>3.4 #parseWhere()</h2><p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😝 比更新SQL解析是不是简单，更不用对比查询SQL解析。😳有一种在水更的感觉。嘿嘿，下一篇（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a>）会更加容易。</p>
<p>道友，帮我分享一波怎么样？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（四）之插入SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-4/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-4/</id>
    <published>2017-07-28T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. InsertStatement</a></li>
<li><a href="#">3. #parse()</a><ul>
<li><a href="#">3.1 #parseInfo()</a></li>
<li><a href="#">3.2 #parseColumns()</a></li>
<li><a href="#">3.3 #parseValues()</a></li>
<li><a href="#">3.4 #parseCustomizedInsert()</a></li>
<li><a href="#">3.5 #appendGenerateKey()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>插入SQL解析</strong>的源码实现。</p>
<p>不考虑 INSERT SELECT 情况下，插入SQL解析比查询SQL解析复杂度低的多的多。不同数据库在插入SQL语法上也统一的多。<strong>本文分享 MySQL 插入SQL解析器 MySQLInsertParser</strong>。</p>
<p>MySQL INSERT 语法一共有 3 种 ：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [(col_name,...)]</div><div class="line">    &#123;<span class="keyword">VALUES</span> | <span class="keyword">VALUE</span>&#125; (&#123;expr | <span class="keyword">DEFAULT</span>&#125;,...),(...),...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure>
<ul>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    <span class="keyword">SET</span> col_name=&#123;expr | <span class="keyword">DEFAULT</span>&#125;, ...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure>
<ul>
<li>第三种：<code>INSERT SELECT</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [(col_name,...)]</div><div class="line">    <span class="keyword">SELECT</span> ...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure>
<p>Sharding-JDBC 目前支持：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code> <strong>单条记录</strong></li>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<p>Sharding-JDBC 插入SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_29/01.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InsertStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 INSERT 关键字</span></div><div class="line">   parseInto(); <span class="comment">// 解析INTO</span></div><div class="line">   parseColumns(); <span class="comment">// 解析表</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT, Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (getValuesKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第一种插入SQL情况</span></div><div class="line">       parseValues();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getCustomizedInsertKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第二种插入SQL情况</span></div><div class="line">       parseCustomizedInsert();</div><div class="line">   &#125;</div><div class="line">   appendGenerateKey(); <span class="comment">// 自增主键</span></div><div class="line">   <span class="keyword">return</span> insertStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-InsertStatement"><a href="#2-InsertStatement" class="headerlink" title="2. InsertStatement"></a>2. InsertStatement</h1><p>插入SQL 解析结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 插入字段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Column&gt; columns = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> GeneratedKey generatedKey;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 插入字段 下一个Token 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> columnsListLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值字段 下一个Token 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> valuesListLastPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们来看下 <code>INSERT INTO t_order (uid, nickname) VALUES (?, ?)</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_29/02.png" alt=""></p>
<h1 id="3-parse"><a href="#3-parse" class="headerlink" title="3. #parse()"></a>3. #parse()</h1><h2 id="3-1-parseInto"><a href="#3-1-parseInto" class="headerlink" title="3.1 #parseInto()"></a>3.1 #parseInto()</h2><p>解析<strong>表</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInto</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 例如，Oracle，INSERT FIRST/ALL 目前不支持</span></div><div class="line">   <span class="keyword">if</span> (getUnsupportedKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">   sqlParser.skipUntil(DefaultKeyword.INTO);</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="comment">// 解析表</span></div><div class="line">   sqlParser.parseSingleTable(insertStatement);</div><div class="line">   skipBetweenTableAndValues();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过 表 和 插入字段 中间的 Token</div><div class="line">* 例如 MySQL ：[PARTITION (partition_name,...)]</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipBetweenTableAndValues</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (getSkippedKeywordsBetweenTableAndValues().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>#parseSingleTable()</code> 请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2 id="3-2-parseColumns"><a href="#3-2-parseColumns" class="headerlink" title="3.2 #parseColumns()"></a>3.2 #parseColumns()</h2><p>解析<strong>插入字段</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseColumns</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;Column&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       String tableName = insertStatement.getTables().getSingleTableName();</div><div class="line">       Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName); <span class="comment">// 自动生成键信息</span></div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">do</span> &#123;</div><div class="line">           <span class="comment">// Column 插入字段</span></div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           String columnName = SQLUtil.getExactlyValue(sqlParser.getLexer().getCurrentToken().getLiterals());</div><div class="line">           result.add(<span class="keyword">new</span> Column(columnName, tableName));</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           <span class="comment">// 自动生成键</span></div><div class="line">           <span class="keyword">if</span> (generateKeyColumn.isPresent() &amp;&amp; generateKeyColumn.get().equalsIgnoreCase(columnName)) &#123;</div><div class="line">               generateKeyColumnIndex = count;</div><div class="line">           &#125;</div><div class="line">           count++;</div><div class="line">       &#125; <span class="keyword">while</span> (!sqlParser.equalAny(Symbol.RIGHT_PAREN) &amp;&amp; !sqlParser.equalAny(Assist.END));</div><div class="line">       <span class="comment">//</span></div><div class="line">       insertStatement.setColumnsListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">       <span class="comment">//</span></div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">   insertStatement.getColumns().addAll(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-parseValues"><a href="#3-3-parseValues" class="headerlink" title="3.3 #parseValues()"></a>3.3 #parseValues()</h2><p>解析<strong>值字段</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析值字段</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseValues</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> parsed = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       <span class="keyword">if</span> (parsed) &#123; <span class="comment">// 只允许INSERT INTO 一条</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support multiple insert"</span>);</div><div class="line">       &#125;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       sqlParser.accept(Symbol.LEFT_PAREN);</div><div class="line">       <span class="comment">// 解析表达式</span></div><div class="line">       List&lt;SQLExpression&gt; sqlExpressions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="keyword">do</span> &#123;</div><div class="line">           sqlExpressions.add(sqlParser.parseExpression());</div><div class="line">       &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA));</div><div class="line">       <span class="comment">//</span></div><div class="line">       insertStatement.setValuesListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">       <span class="comment">// 解析值字段</span></div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Column each : insertStatement.getColumns()) &#123;</div><div class="line">           SQLExpression sqlExpression = sqlExpressions.get(count);</div><div class="line">           insertStatement.getConditions().add(<span class="keyword">new</span> Condition(each, sqlExpression), shardingRule);</div><div class="line">           <span class="keyword">if</span> (generateKeyColumnIndex == count) &#123; <span class="comment">// 自动生成键</span></div><div class="line">               insertStatement.setGeneratedKey(createGeneratedKey(each, sqlExpression));</div><div class="line">           &#125;</div><div class="line">           count++;</div><div class="line">       &#125;</div><div class="line">       sqlParser.accept(Symbol.RIGHT_PAREN);</div><div class="line">       parsed = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (sqlParser.equalAny(Symbol.COMMA)); <span class="comment">// 字段以 "," 分隔</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建 自动生成键</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> column 字段</div><div class="line">* <span class="doctag">@param</span> sqlExpression 表达式</div><div class="line">* <span class="doctag">@return</span> 自动生成键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> GeneratedKey <span class="title">createGeneratedKey</span><span class="params">(<span class="keyword">final</span> Column column, <span class="keyword">final</span> SQLExpression sqlExpression)</span> </span>&#123;</div><div class="line">   GeneratedKey result;</div><div class="line">   <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLPlaceholderExpression) &#123; <span class="comment">// 占位符</span></div><div class="line">       result = <span class="keyword">new</span> GeneratedKey(column.getName(), ((SQLPlaceholderExpression) sqlExpression).getIndex(), <span class="keyword">null</span>);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLNumberExpression) &#123; <span class="comment">// 数字</span></div><div class="line">       result = <span class="keyword">new</span> GeneratedKey(column.getName(), -<span class="number">1</span>, ((SQLNumberExpression) sqlExpression).getNumber());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Generated key only support number."</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-1-GeneratedKey"><a href="#3-4-1-GeneratedKey" class="headerlink" title="3.4.1 GeneratedKey"></a>3.4.1 GeneratedKey</h3><p>自动生成键，<strong>属于分片上下文信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedKey</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String column;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第几个占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Number value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-4-2-Condition"><a href="#3-4-2-Condition" class="headerlink" title="3.4.2 Condition"></a>3.4.2 Condition</h3><p>条件对象，<strong>属于分片上下文信息</strong>。在<strong>插入SQL解析</strong>里存储<strong>影响分片的值字段</strong>。后续<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 路由》</a> 会专门分享这块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Column column;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它属性</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 列名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-parseCustomizedInsert"><a href="#3-4-parseCustomizedInsert" class="headerlink" title="3.4 #parseCustomizedInsert()"></a>3.4 #parseCustomizedInsert()</h2><p>解析<strong>第二种插入SQL</strong>：<code>INSERT SET</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">id</span> = <span class="number">4</span>  <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span> = <span class="string">'doubi'</span>, <span class="keyword">name</span> = <span class="string">'hehe'</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">id</span> = <span class="number">4</span>, <span class="keyword">name</span> = <span class="string">'hehe'</span>;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInsertSet</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// 插入字段</span></div><div class="line">       Column column = <span class="keyword">new</span> Column(SQLUtil.getExactlyValue(getSqlParser().getLexer().getCurrentToken().getLiterals()), getInsertStatement().getTables().getSingleTableName());</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// 等号</span></div><div class="line">       getSqlParser().accept(Symbol.EQ);</div><div class="line">       <span class="comment">// 【值】表达式</span></div><div class="line">       SQLExpression sqlExpression;</div><div class="line">       <span class="keyword">if</span> (getSqlParser().equalAny(Literals.INT)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(getSqlParser().getLexer().getCurrentToken().getLiterals()));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Literals.FLOAT)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLNumberExpression(Double.parseDouble(getSqlParser().getLexer().getCurrentToken().getLiterals()));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Literals.CHARS)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLTextExpression(getSqlParser().getLexer().getCurrentToken().getLiterals());</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.NULL)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Symbol.QUESTION)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLPlaceholderExpression(getSqlParser().getParametersIndex());</div><div class="line">           getSqlParser().increaseParametersIndex();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">""</span>);</div><div class="line">       &#125;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// Condition</span></div><div class="line">       <span class="keyword">if</span> (getSqlParser().equalAny(Symbol.COMMA, DefaultKeyword.ON, Assist.END)) &#123;</div><div class="line">           getInsertStatement().getConditions().add(<span class="keyword">new</span> Condition(column, sqlExpression), getShardingRule());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           getSqlParser().skipUntil(Symbol.COMMA, DefaultKeyword.ON);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">while</span> (getSqlParser().equalAny(Symbol.COMMA)); <span class="comment">// 字段以 "," 分隔</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-5-appendGenerateKey"><a href="#3-5-appendGenerateKey" class="headerlink" title="3.5 #appendGenerateKey()"></a>3.5 #appendGenerateKey()</h2><p>当表设置<strong>自动生成键</strong>，并且插入SQL<strong>没</strong>写自增字段，增加该字段。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// 主键为user_id</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(nickname, age) <span class="keyword">VALUES</span> (?, ?)</div></pre></td></tr></table></figure>
<p>后续 SQL 改写会生成该自增编号，并改写该 SQL。后续<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 会专门分享这块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKey</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 当表设置自动生成键，并且插入SQL没写自增字段</span></div><div class="line">   String tableName = insertStatement.getTables().getSingleTableName();</div><div class="line">   Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName);</div><div class="line">   <span class="keyword">if</span> (!generateKeyColumn.isPresent() || <span class="keyword">null</span> != insertStatement.getGeneratedKey()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ItemsToken</span></div><div class="line">   ItemsToken columnsToken = <span class="keyword">new</span> ItemsToken(insertStatement.getColumnsListLastPosition());</div><div class="line">   columnsToken.getItems().add(generateKeyColumn.get());</div><div class="line">   insertStatement.getSqlTokens().add(columnsToken);</div><div class="line">   <span class="comment">// GeneratedKeyToken</span></div><div class="line">   insertStatement.getSqlTokens().add(<span class="keyword">new</span> GeneratedKeyToken(insertStatement.getValuesListLastPosition()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-5-1-GeneratedKeyToken"><a href="#3-5-1-GeneratedKeyToken" class="headerlink" title="3.5.1 GeneratedKeyToken"></a>3.5.1 GeneratedKeyToken</h3><p>自增主键标记对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedKeyToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 是不是比<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之插入SQL》</a>简单很多。</p>
<p><strong>道友，可否分享一波【本文】到朋友圈</strong>。</p>
<p><strong>继续加油更新！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-3/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SelectStatement</a><ul>
<li><a href="#">2.1 AbstractSQLStatement</a></li>
<li><a href="#">2.2 SQLToken</a></li>
</ul>
</li>
<li><a href="#">3. #query()</a><ul>
<li><a href="#">3.1 #parseDistinct()</a></li>
<li><a href="#">3.2 #parseSelectList()</a></li>
<li><a href="#">3.3 #skipToFrom()</a></li>
<li><a href="#">3.4 #parseFrom()</a></li>
<li><a href="#">3.5 #parseWhere()</a></li>
<li><a href="#">3.6 #parseGroupBy()</a></li>
<li><a href="#">3.7 #parseOrderBy()</a></li>
<li><a href="#">3.8 #parseLimit()</a></li>
<li><a href="#">3.9 #queryRest()</a></li>
</ul>
</li>
<li><a href="#">4. appendDerived等方法</a><ul>
<li><a href="#">4.1 appendAvgDerivedColumns</a></li>
<li><a href="#">4.2 appendDerivedOrderColumns</a></li>
<li><a href="#">4.3 ItemsToken</a></li>
<li><a href="#">4.4 appendDerivedOrderBy()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>插入SQL解析</strong>的源码实现。</p>
<p>由于每个数据库在遵守 SQL 语法规范的同时，又有各自独特的语法。因此，在 Sharding-JDBC 里每个数据库都有自己的 SELECT 语句的解析器实现方式，当然绝大部分逻辑是相同的。<strong>本文主要分享笔者最常用的 MySQL 查询</strong>。</p>
<p>查询 SQL 解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/03.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   query();</div><div class="line">   parseOrderBy();</div><div class="line">   customizedSelect();</div><div class="line">   appendDerivedColumns();</div><div class="line">   appendDerivedOrderBy();</div><div class="line">   <span class="keyword">return</span> selectStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#parseOrderBy()</code> ：对于 MySQL 查询语句解析器无效果，因为已经在 <code>#query()</code> 方法里面已经调用 <code>#parseOrderBy()</code>，因此图中省略该方法。</li>
<li><code>#customizedSelect()</code> ：Oracle、SQLServer 查询语句解析器重写了该方法，对于 MySQL 查询解析器是个空方法，进行省略。有兴趣的同学可以单独去研究研究。</li>
</ul>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<p>👼 查询语句解析是增删改查里面<strong>最灵活也是最复杂的</strong>，希望大家有耐心看完本文。理解查询语句解析，另外三种语句理解起来简直是 SO EASY。骗人是小狗🐶。<br>🙂如果对本文有不理解的地方，可以给我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>留言，我会<strong>逐条认真耐心</strong>回复。骗人是小猪🐷。</p>
<p>OK，不废话啦，开始我们这段痛并快乐的旅途。</p>
<h1 id="2-SelectStatement"><a href="#2-SelectStatement" class="headerlink" title="2. SelectStatement"></a>2. SelectStatement</h1><p>🙂 <strong>本节只介绍这些类，方便本文下节分析源码实现大家能知道认识它们</strong> 🙂  </p>
<p>SelectStatement，查询语句解析结果对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SelectStatement.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否行 DISTINCT / DISTINCTROW / UNION</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> distinct;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否查询所有字段，即 SELECT *</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> containStar;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后一个查询项下一个 Token 的开始位置</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #items</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectListLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后一个分组项下一个 Token 的开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groupByLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectItem&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Limit limit;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们对属性按照类型进行归类：</p>
<ul>
<li>特殊<ul>
<li>distinct </li>
</ul>
</li>
<li>查询字段<ul>
<li>containStar</li>
<li>items</li>
<li>selectListLastPosition</li>
</ul>
</li>
<li>分组条件<ul>
<li>groupByItems</li>
<li>groupByLastPosition</li>
</ul>
</li>
<li>排序条件<ul>
<li>orderByItems</li>
</ul>
</li>
<li>分页条件<ul>
<li>limit</li>
</ul>
</li>
</ul>
<h2 id="2-1-AbstractSQLStatement"><a href="#2-1-AbstractSQLStatement" class="headerlink" title="2.1 AbstractSQLStatement"></a>2.1 AbstractSQLStatement</h2><p>增删改查解析结果对象的<strong>抽象父类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSQLStatement</span> <span class="keyword">implements</span> <span class="title">SQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tables tables = <span class="keyword">new</span> Tables();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 过滤条件。</div><div class="line">     * 只有对路由结果有影响的条件，才添加进数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Conditions conditions = <span class="keyword">new</span> Conditions();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL标记对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-SQLToken"><a href="#2-2-SQLToken" class="headerlink" title="2.2 SQLToken"></a>2.2 SQLToken</h2><p>SQLToken，SQL标记对象接口，SQL 改写时使用到。下面都是它的实现类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GeneratedKeyToken</td>
<td style="text-align:left">自增主键标记对象</td>
</tr>
<tr>
<td style="text-align:left">TableToken</td>
<td style="text-align:left">表标记对象</td>
</tr>
<tr>
<td style="text-align:left">ItemsToken</td>
<td style="text-align:left">选择项标记对象</td>
</tr>
<tr>
<td style="text-align:left">OffsetToken</td>
<td style="text-align:left">分页偏移量标记对象</td>
</tr>
<tr>
<td style="text-align:left">OrderByToken</td>
<td style="text-align:left">排序标记对象</td>
</tr>
<tr>
<td style="text-align:left">RowCountToken</td>
<td style="text-align:left">分页长度标记对象</td>
</tr>
</tbody>
</table>
<h1 id="3-query"><a href="#3-query" class="headerlink" title="3. #query()"></a>3. #query()</h1><p><code>#query()</code>，查询 SQL 解析。</p>
<p><strong>MySQL SELECT Syntax</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/select.html</div><div class="line"><span class="keyword">SELECT</span></div><div class="line">    [ALL | <span class="keyword">DISTINCT</span> | <span class="keyword">DISTINCTROW</span> ]</div><div class="line">      [<span class="keyword">HIGH_PRIORITY</span>]</div><div class="line">      [<span class="keyword">STRAIGHT_JOIN</span>]</div><div class="line">      [<span class="keyword">SQL_SMALL_RESULT</span>] [<span class="keyword">SQL_BIG_RESULT</span>] [<span class="keyword">SQL_BUFFER_RESULT</span>]</div><div class="line">      [<span class="keyword">SQL_CACHE</span> | SQL_NO_CACHE] [<span class="keyword">SQL_CALC_FOUND_ROWS</span>]</div><div class="line">    select_expr [, select_expr ...]</div><div class="line">    [<span class="keyword">FROM</span> table_references</div><div class="line">      [<span class="keyword">PARTITION</span> partition_list]</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</div><div class="line">    [<span class="keyword">HAVING</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</div><div class="line">    [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</div><div class="line">    [<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</div><div class="line">    [<span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'file_name'</span></div><div class="line">        [<span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</div><div class="line">        export_options</div><div class="line">      | <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> <span class="string">'file_name'</span></div><div class="line">      | <span class="keyword">INTO</span> var_name [, var_name]]</div><div class="line">    [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> | <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>]]</div></pre></td></tr></table></figure>
<p>大体流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/04.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       parseDistinct();</div><div class="line">       getSqlParser().skipAll(MySQLKeyword.HIGH_PRIORITY, DefaultKeyword.STRAIGHT_JOIN, MySQLKeyword.SQL_SMALL_RESULT, MySQLKeyword.SQL_BIG_RESULT, MySQLKeyword.SQL_BUFFER_RESULT,</div><div class="line">               MySQLKeyword.SQL_CACHE, MySQLKeyword.SQL_NO_CACHE, MySQLKeyword.SQL_CALC_FOUND_ROWS);</div><div class="line">       parseSelectList(); <span class="comment">// 解析 查询字段</span></div><div class="line">       skipToFrom(); <span class="comment">// 跳到 FROM 处</span></div><div class="line">   &#125;</div><div class="line">   parseFrom();<span class="comment">// 解析 表（JOIN ON / FROM 单&amp;多表）</span></div><div class="line">   parseWhere(); <span class="comment">// 解析 WHERE 条件</span></div><div class="line">   parseGroupBy(); <span class="comment">// 解析 Group By 和 Having（目前不支持）条件</span></div><div class="line">   parseOrderBy(); <span class="comment">// 解析 Order By 条件</span></div><div class="line">   parseLimit(); <span class="comment">// 解析 分页 Limit 条件</span></div><div class="line">   <span class="comment">// [PROCEDURE] 暂不支持</span></div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.PROCEDURE)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getSqlParser().getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">   queryRest();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-1-parseDistinct"><a href="#3-1-parseDistinct" class="headerlink" title="3.1 #parseDistinct()"></a>3.1 #parseDistinct()</h2><p>解析 DISTINCT、DISTINCTROW、UNION 谓语。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseDistinct</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DISTINCT, DefaultKeyword.DISTINCTROW, DefaultKeyword.UNION)) &#123;</div><div class="line">       selectStatement.setDistinct(<span class="keyword">true</span>);</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (hasDistinctOn() &amp;&amp; sqlParser.equalAny(DefaultKeyword.ON)) &#123; <span class="comment">// PostgreSQL 独有语法： DISTINCT ON</span></div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ALL)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处 DISTINCT 和 DISTINCT(字段) 不同，它是针对查询结果做去重，即整行重复。举个例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT item_id, order_id FROM t_order_item;</div><div class="line">+---------+----------+</div><div class="line">| item_id | order_id |</div><div class="line">+---------+----------+</div><div class="line">| 1       | 1        |</div><div class="line">| 1       | 1        |</div><div class="line">+---------+----------+</div><div class="line">2 rows in set (0.03 sec)</div><div class="line"></div><div class="line">mysql&gt; SELECT DISTINCT item_id, order_id FROM t_order_item;</div><div class="line">+---------+----------+</div><div class="line">| item_id | order_id |</div><div class="line">+---------+----------+</div><div class="line">| 1       | 1        |</div><div class="line">+---------+----------+</div><div class="line">1 rows in set (0.02 sec)</div></pre></td></tr></table></figure>
<h2 id="3-2-parseSelectList"><a href="#3-2-parseSelectList" class="headerlink" title="3.2 #parseSelectList()"></a>3.2 #parseSelectList()</h2><table>
<thead>
<tr>
<th>SELECT</th>
<th>o.user_id</th>
<th>COUNT(DISTINCT i.item_id) AS item_count</th>
<th>MAX(i.item_id)</th>
<th>FROM</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>SelectItem</td>
<td>SelectItem</td>
<td>SelectItem</td>
</tr>
</tbody>
</table>
<p>将 SQL <strong>查询字段</strong> 按照<strong>逗号( , )</strong>切割成<strong>多个</strong>选择项( SelectItem)。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSelectList</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       <span class="comment">// 解析单个选择项</span></div><div class="line">       parseSelectItem();</div><div class="line">   &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA));</div><div class="line">   <span class="comment">// 设置 最后一个查询项下一个 Token 的开始位置</span></div><div class="line">   selectStatement.setSelectListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-1-SelectItem-选择项"><a href="#3-2-1-SelectItem-选择项" class="headerlink" title="3.2.1 SelectItem 选择项"></a>3.2.1 SelectItem 选择项</h3><p>SelectItem 接口，<strong>属于分片上下文信息</strong>，有 2 个实现类：</p>
<ul>
<li>CommonSelectItem ：通用选择项</li>
<li>AggregationSelectItem ：聚合选择项</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/01.png" alt=""></p>
<p>解析单个 SelectItem 核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectItem</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 第四种情况，SQL Server 独有</span></div><div class="line">   <span class="keyword">if</span> (isRowNumberSelectItem()) &#123;</div><div class="line">       selectStatement.getItems().add(parseRowNumberSelectItem());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   sqlParser.skipIfEqual(DefaultKeyword.CONNECT_BY_ROOT); <span class="comment">// Oracle 独有：https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators004.htm</span></div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   <span class="comment">// 第一种情况，* 通用选择项，SELECT *</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.STAR) || Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(Symbol.STAR.getLiterals(), sqlParser.parseAlias()));</div><div class="line">       selectStatement.setContainStar(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第二种情况，聚合选择项</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.MAX, DefaultKeyword.MIN, DefaultKeyword.SUM, DefaultKeyword.AVG, DefaultKeyword.COUNT)) &#123;</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> AggregationSelectItem(AggregationType.valueOf(literals.toUpperCase()), sqlParser.skipParentheses(), sqlParser.parseAlias()));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第三种情况，非 * 通用选择项</span></div><div class="line">   StringBuilder expression = <span class="keyword">new</span> StringBuilder();</div><div class="line">   Token lastToken = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">while</span> (!sqlParser.equalAny(DefaultKeyword.AS) &amp;&amp; !sqlParser.equalAny(Symbol.COMMA) &amp;&amp; !sqlParser.equalAny(DefaultKeyword.FROM) &amp;&amp; !sqlParser.equalAny(Assist.END)) &#123;</div><div class="line">       String value = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">       <span class="keyword">int</span> position = sqlParser.getLexer().getCurrentToken().getEndPosition() - value.length();</div><div class="line">       expression.append(value);</div><div class="line">       lastToken = sqlParser.getLexer().getCurrentToken();</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (sqlParser.equalAny(Symbol.DOT)) &#123;</div><div class="line">           selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(position, value));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 不带 AS，并且有别名，并且别名不等于自己（tips：这里重点看。判断这么复杂的原因：防止substring操作截取结果错误）</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != lastToken &amp;&amp; Literals.IDENTIFIER == lastToken.getType()</div><div class="line">           &amp;&amp; !isSQLPropertyExpression(expression, lastToken) <span class="comment">// 过滤掉，别名是自己的情况【1】（例如，SELECT u.user_id u.user_id FROM t_user）</span></div><div class="line">           &amp;&amp; !expression.toString().equals(lastToken.getLiterals())) &#123; <span class="comment">// 过滤掉，无别名的情况【2】（例如，SELECT user_id FROM t_user）</span></div><div class="line">       selectStatement.getItems().add(</div><div class="line">               <span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.substring(<span class="number">0</span>, expression.lastIndexOf(lastToken.getLiterals()))), Optional.of(lastToken.getLiterals())));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 带 AS（例如，SELECT user_id AS userId） 或者 无别名（例如，SELECT user_id）</span></div><div class="line">   selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.toString()), sqlParser.parseAlias()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一共分成 4 种大的情况，我们来逐条梳理：</p>
<ul>
<li>第一种：<strong><code>*</code> 通用选择项</strong>：<br>例如，<code>SELECT * FROM t_user</code> 的 <code>*</code>。<br>为什么要加   <code>Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))</code> 判断呢？  </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">`*`</span> <span class="keyword">FROM</span> t_user; // 也能达到查询所有字段的效果</div></pre></td></tr></table></figure>
<ul>
<li>第二种：<strong>聚合选择项</strong>：<br>例如，<code>SELECT COUNT(user_id) FROM t_user</code> 的 <code>COUNT(user_id)</code>。</li>
</ul>
<p>解析结果 AggregationSelectItem：<br><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/05.png" alt=""></p>
<p><code>sqlParser.skipParentheses()</code> 解析见<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的AbstractParser小节</a>。</p>
<ul>
<li>第三种：<strong>非 <code>*</code> 通用选择项</strong>：</li>
</ul>
<p>例如，<code>SELECT user_id FROM t_user</code>。</p>
<p>从实现上，逻辑会复杂很多。相比第一种，可以根据 <code>*</code> 做字段判断；相比第二种，可以使用 <code>(</code> 和 <code>)</code> 做字段判断。能够判断一个<strong>包含别名的</strong> SelectItem 结束有 4 种 Token，根据结束方式我们分成 2 种：</p>
<ul>
<li>DefaultKeyword.AS ：能够接触出 SelectItem 字段，<strong>即不包含别名</strong>。例如，<code>SELECT user_id AS uid FROM t_user</code>，能够直接解析出 <code>user_id</code>。</li>
<li>Symbol.COMMA / DefaultKeyword.FROM / Assist.END ：<strong>包含别名</strong>。例如，<code>SELECT user_id uid FROM t_user</code>，解析结果为 <code>user_id uid</code>。</li>
</ul>
<p>基于这个在配合上面的代码注释，大家再重新理解下第三种情况的实现。</p>
<ul>
<li>第四种：SQLServer ROW_NUMBER：</li>
</ul>
<p>ROW_NUMBER 是 SQLServer 独有的。由于本文大部分的读者使用的 MySQL / Oracle，就跳过了。有兴趣的同学可以看 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/dialect/sqlserver/SQLServerSelectParser.java" rel="external nofollow noopener noreferrer" target="_blank">SQLServerSelectParser#parseRowNumberSelectItem()</a> 方法。</p>
<h3 id="3-2-2-parseAlias-解析别名"><a href="#3-2-2-parseAlias-解析别名" class="headerlink" title="3.2.2 #parseAlias() 解析别名"></a>3.2.2 #parseAlias() 解析别名</h3><p>解析别名，分成是否带 <code>AS</code> 两种情况。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseAlias()小节</a>。</p>
<h3 id="3-2-3-TableToken-表标记对象"><a href="#3-2-3-TableToken-表标记对象" class="headerlink" title="3.2.3 TableToken 表标记对象"></a>3.2.3 TableToken 表标记对象</h3><p>TableToken，记录表名在 SQL 里出现的<strong>位置</strong>和<strong>名字</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表达式</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String originalLiterals;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取表名称.</div><div class="line">     * <span class="doctag">@return</span> 表名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例如上文第三种情况。<br><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/06.png" alt=""></p>
<h2 id="3-3-skipToFrom"><a href="#3-3-skipToFrom" class="headerlink" title="3.3 #skipToFrom()"></a>3.3 #skipToFrom()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 跳到 FROM 处</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipToFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (!getSqlParser().equalAny(DefaultKeyword.FROM) &amp;&amp; !getSqlParser().equalAny(Assist.END)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-parseFrom"><a href="#3-4-parseFrom" class="headerlink" title="3.4 #parseFrom()"></a>3.4 #parseFrom()</h2><p>解析表以及表连接关系。<strong>这块相对比较复杂，请大家耐心+耐心+耐心。</strong></p>
<p><strong>MySQL JOIN Syntax</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/join.html</div><div class="line">table_references:</div><div class="line">    escaped_table_reference [, escaped_table_reference] ...</div><div class="line"></div><div class="line">escaped_table_reference:</div><div class="line">    table_reference</div><div class="line">  | &#123; OJ table_reference &#125;</div><div class="line"></div><div class="line">table_reference:</div><div class="line">    table_factor</div><div class="line">  | join_table</div><div class="line"></div><div class="line">table_factor:</div><div class="line">    tbl_name [PARTITION (partition_names)]</div><div class="line">        [[AS] alias] [index_hint_list]</div><div class="line">  | table_subquery [AS] alias</div><div class="line">  | ( table_references )</div><div class="line"></div><div class="line">join_table:</div><div class="line">    table_reference [INNER | CROSS] JOIN table_factor [join_condition]</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor ON conditional_expr</div><div class="line">  | table_reference &#123;LEFT|RIGHT&#125; [OUTER] JOIN table_reference join_condition</div><div class="line">  | table_reference NATURAL [&#123;LEFT|RIGHT&#125; [OUTER]] JOIN table_factor</div><div class="line"></div><div class="line">join_condition:</div><div class="line">    ON conditional_expr</div><div class="line">  | USING (column_list)</div><div class="line"></div><div class="line">index_hint_list:</div><div class="line">    index_hint [, index_hint] ...</div><div class="line"></div><div class="line">index_hint:</div><div class="line">    USE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list])</div><div class="line">  | IGNORE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</div><div class="line">  | FORCE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</div><div class="line"></div><div class="line">index_list:</div><div class="line">    index_name [, index_name] ...</div></pre></td></tr></table></figure>
<h3 id="3-4-1-JOIN-ON-FROM-TABLE"><a href="#3-4-1-JOIN-ON-FROM-TABLE" class="headerlink" title="3.4.1 JOIN ON / FROM TABLE"></a>3.4.1 JOIN ON / FROM TABLE</h3><p>先抛开<strong>子查询</strong>的情况，只考虑如下两种 SQL 情况。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// JOIN ON ： 实际可以继续 JOIN ON 更多表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id = i.order_id; </div><div class="line">// FROM 多表 ：实际可以继续 FROM 多更表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o, t_order_item i</div></pre></td></tr></table></figure>
<p>在看实现代码之前，先一起看下调用顺序图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/02.png" alt=""></p>
<p>看懂上图后，来继续看下实现代码（🙂<strong>代码有点多，不要方！</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.FROM)) &#123;</div><div class="line">       parseTable();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析子查询</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery for nested tables."</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setContainStar(<span class="keyword">false</span>);</div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询左括号</span></div><div class="line">       parse(); <span class="comment">// 解析子查询 SQL</span></div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询右括号</span></div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   parseTableFactor(); <span class="comment">// 解析当前表</span></div><div class="line">   parseJoinTable(); <span class="comment">// 解析下一个表</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseTableFactor</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> beginPosition = sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length();</div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="comment">// TODO 包含Schema解析</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// https://dev.mysql.com/doc/refman/5.7/en/information-schema.html ：SELECT table_name, table_type, engine FROM information_schema.tables</span></div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       sqlParser.parseAlias();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// FIXME 根据shardingRule过滤table</span></div><div class="line">   selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</div><div class="line">   <span class="comment">// 表 以及 表别名</span></div><div class="line">   selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Join Table 或者 FROM 下一张 Table</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseJoinTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipJoin()) &#123;</div><div class="line">       <span class="comment">// 这里调用 parseJoinTable() 而不是 parseTableFactor() ：下一个 Table 可能是子查询</span></div><div class="line">       <span class="comment">// 例如：SELECT * FROM t_order JOIN (SELECT * FROM t_order_item JOIN t_order_other ON ) .....</span></div><div class="line">       parseTable();</div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.ON)) &#123; <span class="comment">// JOIN 表时 ON 条件</span></div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">               sqlParser.accept(Symbol.EQ);</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">           &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(DefaultKeyword.AND));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.USING)) &#123; <span class="comment">// JOIN 表时 USING 为使用两表相同字段相同时对 ON 的简化。例如以下两条 SQL 等价：</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i USING (order_id);</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id</span></div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">       parseJoinTable(); <span class="comment">// 继续递归</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 ON 条件里的 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> startPosition 开始位置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseTableCondition</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> startPosition)</span> </span>&#123;</div><div class="line">   SQLExpression sqlExpression = sqlParser.parseExpression();</div><div class="line">   <span class="keyword">if</span> (!(sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression)) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">   <span class="keyword">if</span> (selectStatement.getTables().getTableNames().contains(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()))) &#123;</div><div class="line">       selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(startPosition, sqlPropertyExpression.getOwner().getName()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，递归因为平时日常中写的比较少，可能理解起来可能会困难一些，努力看懂！🙂<strong>如果真的看不懂，可以加微信公众号（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>），我来帮你一起理解。</strong></p>
<h3 id="3-4-2-子查询"><a href="#3-4-2-子查询" class="headerlink" title="3.4.2 子查询"></a>3.4.2 子查询</h3><p>Sharding-JDBC 目前支持<strong>第一个</strong>包含多层级的数据子查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3;</div><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o3.order_id = i.order_id;</div></pre></td></tr></table></figure>
<p>不支持<strong>第二个开始</strong>包含多层级的数据子查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> t_order_item i <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">ON</span> o3.order_id = i.order_id; // 此条 SQL 是上面第二条 SQL 左右量表颠倒</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">WHERE</span> o.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">status</span> = ?)) // <span class="keyword">FROM</span> 官方不支持 <span class="keyword">SQL</span> 举例</div></pre></td></tr></table></figure>
<p>使用<strong>第二个开始</strong>的子查询会抛出异常，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// AbstractSelectParser.java#parseTable()片段</div><div class="line">if (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">    throw new UnsupportedOperationException(&quot;Cannot support subquery for nested tables.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用子查询，建议认真阅读官方<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/subquery/" rel="external nofollow noopener noreferrer" target="_blank">《分页及子查询》</a>文档。</p>
<h3 id="3-4-3-parseJoinTable"><a href="#3-4-3-parseJoinTable" class="headerlink" title="3.4.3 #parseJoinTable()"></a>3.4.3 #parseJoinTable()</h3><p>MySQLSelectParser 重写了 <code>#parseJoinTable()</code> 方法用于解析 USE / IGNORE / FORCE index_hint。具体语法见上文 <strong>JOIN Syntax</strong>。这里就跳过，有兴趣的同学可以去看看。</p>
<h3 id="3-4-4-Tables-表集合对象"><a href="#3-4-4-Tables-表集合对象" class="headerlink" title="3.4.4 Tables 表集合对象"></a>3.4.4 Tables 表集合对象</h3><p><strong>属于分片上下文信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Tables.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tables</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Table&gt; tables = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Table.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 别名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractSelectParser.java#parseTableFactor()片段</span></div><div class="line">selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div></pre></td></tr></table></figure>
<h2 id="3-5-parseWhere"><a href="#3-5-parseWhere" class="headerlink" title="3.5 #parseWhere()"></a>3.5 #parseWhere()</h2><p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h2 id="3-6-parseGroupBy"><a href="#3-6-parseGroupBy" class="headerlink" title="3.6 #parseGroupBy()"></a>3.6 #parseGroupBy()</h2><p>解析分组条件，实现上比较类似 <code>#parseSelectList</code>，会更加简单一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Group By 和 Having（暂时不支持）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseGroupBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.GROUP)) &#123;</div><div class="line">       sqlParser.accept(DefaultKeyword.BY);</div><div class="line">       <span class="comment">// 解析 Group By 每个字段</span></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           addGroupByItem(sqlParser.parseExpression(selectStatement));</div><div class="line">           <span class="keyword">if</span> (!sqlParser.equalAny(Symbol.COMMA)) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (sqlParser.equalAny(DefaultKeyword.WITH) || sqlParser.getLexer().getCurrentToken().getLiterals().equalsIgnoreCase(<span class="string">"ROLLUP"</span>)) &#123;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Having（暂时不支持）</span></div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setGroupByLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Group By 单个字段</div><div class="line">* Group By 条件是带有排序功能，默认ASC</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlExpression 表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGroupByItem</span><span class="params">(<span class="keyword">final</span> SQLExpression sqlExpression)</span> </span>&#123;</div><div class="line">   <span class="comment">// Group By 字段 DESC / ASC / ;默认是 ASC。</span></div><div class="line">   OrderType orderByType = OrderType.ASC;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ASC)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.DESC)) &#123;</div><div class="line">       orderByType = OrderType.DESC;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析 OrderItem</span></div><div class="line">   OrderItem orderItem;</div><div class="line">   <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression) &#123;</div><div class="line">       SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()), SQLUtil.getExactlyValue(sqlPropertyExpression.getName()), orderByType,</div><div class="line">               getAlias(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner() + <span class="string">"."</span> + SQLUtil.getExactlyValue(sqlPropertyExpression.getName()))));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLIdentifierExpression) &#123;</div><div class="line">       SQLIdentifierExpression sqlIdentifierExpression = (SQLIdentifierExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName()), orderByType, getAlias(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName())));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   selectStatement.getGroupByItems().add(orderItem);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 字段在查询项里的别名</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> name 字段</div><div class="line">* <span class="doctag">@return</span> 别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;String&gt; <span class="title">getAlias</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123;</div><div class="line">       <span class="keyword">return</span> Optional.absent();</div><div class="line">   &#125;</div><div class="line">   String rawName = SQLUtil.getExactlyValue(name);</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(SQLUtil.getExactlyValue(each.getExpression()))) &#123;</div><div class="line">           <span class="keyword">return</span> each.getAlias();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(each.getAlias().orNull())) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(rawName);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-6-1-OrderItem-排序项"><a href="#3-6-1-OrderItem-排序项" class="headerlink" title="3.6.1 OrderItem 排序项"></a>3.6.1 OrderItem 排序项</h3><p><strong>属于分片上下文信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 所属表别名</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; owner;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 排序字段</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 排序类型</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 按照第几个查询字段排序</div><div class="line">    * ORDER BY 数字 的 数字代表的是第几个字段</div><div class="line">    */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 字段在查询项(&#123;<span class="doctag">@link</span> com.dangdang.ddframe.rdb.sharding.parsing.parser.context.selectitem.SelectItem&#125; 的别名</div><div class="line">    */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-7-parseOrderBy"><a href="#3-7-parseOrderBy" class="headerlink" title="3.7 #parseOrderBy()"></a>3.7 #parseOrderBy()</h2><p>解析排序条件。实现逻辑类似 <code>#parseGroupBy()</code>，这里就跳过，有兴趣的同学可以去看看。</p>
<h2 id="3-8-parseLimit"><a href="#3-8-parseLimit" class="headerlink" title="3.8 #parseLimit()"></a>3.8 #parseLimit()</h2><p>解析分页 Limit 条件。相对简单，这里就跳过，有兴趣的同学可以去看看。注意下，分成 3 种情况：</p>
<ul>
<li>LIMIT row_count</li>
<li>LIMIT offset, row_count</li>
<li>LIMIT row_count OFFSET offset</li>
</ul>
<h3 id="3-8-1-Limit"><a href="#3-8-1-Limit" class="headerlink" title="3.8.1 Limit"></a>3.8.1 Limit</h3><p>分页对象。<strong>属于分片上下文信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Limit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否重写rowCount</div><div class="line">     * TODO 待补充：预计和内存分页合并有关</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> rowCountRewriteFlag;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * offset</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LimitValue offset;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * row</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LimitValue rowCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LimitValue.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitValue</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值</div><div class="line">     * 当 value == -1 时，为占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第几个占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-8-2-OffsetToken-RowCountToken"><a href="#3-8-2-OffsetToken-RowCountToken" class="headerlink" title="3.8.2 OffsetToken RowCountToken"></a>3.8.2 OffsetToken RowCountToken</h3><ul>
<li>OffsetToken：分页偏移量标记对象</li>
<li>RowCountToken：分页长度标记对象</li>
</ul>
<p><strong>只有在对应位置非占位符才有该 SQLToken</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OffsetToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 偏移值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RowCountToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RowCountToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 行数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-9-queryRest"><a href="#3-9-queryRest" class="headerlink" title="3.9 #queryRest()"></a>3.9 #queryRest()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">queryRest</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UNION, DefaultKeyword.EXCEPT, DefaultKeyword.INTERSECT, DefaultKeyword.MINUS)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不支持 UNION / EXCEPT / INTERSECT / MINUS ，调用会抛出异常。</p>
<h1 id="4-appendDerived等方法"><a href="#4-appendDerived等方法" class="headerlink" title="4. appendDerived等方法"></a>4. appendDerived等方法</h1><p>因为 Sharding-JDBC 对表做了分片，在 AVG , GROUP BY , ORDER BY 需要对 SQL 进行一些改写，<strong>以达到能在内存里对结果做进一步处理</strong>，例如求平均值、分组、排序等。</p>
<p>😈：打起精神，此块是非常有趣的。</p>
<h2 id="4-1-appendAvgDerivedColumns"><a href="#4-1-appendAvgDerivedColumns" class="headerlink" title="4.1 appendAvgDerivedColumns"></a>4.1 appendAvgDerivedColumns</h2><p>解决 AVG 查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 针对 AVG 聚合字段，增加推导字段</div><div class="line">* AVG 改写成 SUM + COUNT 查询，内存计算出 AVG 结果。</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> itemsToken 选择项标记对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAvgDerivedColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (!(each <span class="keyword">instanceof</span> AggregationSelectItem) || AggregationType.AVG != ((AggregationSelectItem) each).getType()) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       AggregationSelectItem avgItem = (AggregationSelectItem) each;</div><div class="line">       <span class="comment">// COUNT 字段</span></div><div class="line">       String countAlias = String.format(DERIVED_COUNT_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem countItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.COUNT, avgItem.getInnerExpression(), Optional.of(countAlias));</div><div class="line">       <span class="comment">// SUM 字段</span></div><div class="line">       String sumAlias = String.format(DERIVED_SUM_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem sumItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.SUM, avgItem.getInnerExpression(), Optional.of(sumAlias));</div><div class="line">       <span class="comment">// AggregationSelectItem 设置</span></div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(countItem);</div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(sumItem);</div><div class="line">       <span class="comment">// TODO 将AVG列替换成常数，避免数据库再计算无用的AVG函数</span></div><div class="line">       <span class="comment">// ItemsToken</span></div><div class="line">       itemsToken.getItems().add(countItem.getExpression() + <span class="string">" AS "</span> + countAlias + <span class="string">" "</span>);</div><div class="line">       itemsToken.getItems().add(sumItem.getExpression() + <span class="string">" AS "</span> + sumAlias + <span class="string">" "</span>);</div><div class="line">       <span class="comment">//</span></div><div class="line">       derivedColumnOffset++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-2-appendDerivedOrderColumns"><a href="#4-2-appendDerivedOrderColumns" class="headerlink" title="4.2 appendDerivedOrderColumns"></a>4.2 appendDerivedOrderColumns</h2><p>解决 GROUP BY , ORDER BY。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 针对 GROUP BY 或 ORDER BY 字段，增加推导字段</div><div class="line">* 如果该字段不在查询字段里，需要额外查询该字段，这样才能在内存里 GROUP BY 或 ORDER BY</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> itemsToken 选择项标记对象</div><div class="line">* <span class="doctag">@param</span> orderItems 排序字段</div><div class="line">* <span class="doctag">@param</span> aliasPattern 别名模式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems, <span class="keyword">final</span> String aliasPattern)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">       <span class="keyword">if</span> (!isContainsItem(each)) &#123;</div><div class="line">           String alias = String.format(aliasPattern, derivedColumnOffset++);</div><div class="line">           each.setAlias(Optional.of(alias));</div><div class="line">           itemsToken.getItems().add(each.getQualifiedName().get() + <span class="string">" AS "</span> + alias + <span class="string">" "</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 查询字段是否包含排序字段</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> orderItem 排序字段</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContainsItem</span><span class="params">(<span class="keyword">final</span> OrderItem orderItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123; <span class="comment">// SELECT *</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != orderItem.getIndex()) &#123; <span class="comment">// ORDER BY 使用数字</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (each.getAlias().isPresent() &amp;&amp; orderItem.getAlias().isPresent() &amp;&amp; each.getAlias().get().equalsIgnoreCase(orderItem.getAlias().get())) &#123; <span class="comment">// 字段别名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!each.getAlias().isPresent() &amp;&amp; orderItem.getQualifiedName().isPresent() &amp;&amp; each.getExpression().equalsIgnoreCase(orderItem.getQualifiedName().get())) &#123; <span class="comment">// 字段原名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3-ItemsToken"><a href="#4-3-ItemsToken" class="headerlink" title="4.3 ItemsToken"></a>4.3 ItemsToken</h2><p>选择项标记对象，<strong>属于分片上下文信息</strong>，目前有 3 个情况会创建：</p>
<ol>
<li><code>AVG</code> 查询额外 COUNT 和 SUM：<code>#appendAvgDerivedColumns()</code></li>
<li><code>GROUP BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li>
<li><code>ORDER BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段名数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-4-appendDerivedOrderBy"><a href="#4-4-appendDerivedOrderBy" class="headerlink" title="4.4 appendDerivedOrderBy()"></a>4.4 appendDerivedOrderBy()</h2><p>当 SQL 有聚合条件而无排序条件，根据聚合条件进行排序。这是数据库自己的执行规则。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT order_id FROM t_order GROUP BY order_id;</div><div class="line">+----------+</div><div class="line">| order_id |</div><div class="line">+----------+</div><div class="line">| 1        |</div><div class="line">| 2        |</div><div class="line">| 3        |</div><div class="line">+----------+</div><div class="line">3 rows in set (0.05 sec)</div><div class="line"></div><div class="line">mysql&gt; SELECT order_id FROM t_order GROUP BY order_id DESC;</div><div class="line">+----------+</div><div class="line">| order_id |</div><div class="line">+----------+</div><div class="line">| 3        |</div><div class="line">| 2        |</div><div class="line">| 1        |</div><div class="line">+----------+</div><div class="line">3 rows in set (0.02 sec)</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!getSelectStatement().getGroupByItems().isEmpty() &amp;&amp; getSelectStatement().getOrderByItems().isEmpty()) &#123;</div><div class="line">       getSelectStatement().getOrderByItems().addAll(getSelectStatement().getGroupByItems());</div><div class="line">       getSelectStatement().getSqlTokens().add(<span class="keyword">new</span> OrderByToken(getSelectStatement().getGroupByLastPosition()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-1-OrderByToken"><a href="#4-3-1-OrderByToken" class="headerlink" title="4.3.1 OrderByToken"></a>4.3.1 OrderByToken</h3><p>排序标记对象。当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OrderByToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>咳咳咳，确实有一些略长。但请相信，INSERT / UPDATE / DELETE 会简单很多很多。考试考的 SQL 最多的是什么？SELECT 语句呀！为啥，难呗。恩，我相信看到此处的你，一定是能看懂的，加油！</p>
<p>🙂如果对本文有不理解的地方，可以关注我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>获得<strong>微信号</strong>，我们来一场，1 对 1 的搞基吧，不不不，是交流交流。</p>
<p>道友，帮我分享一波怎么样？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（二）之SQL解析</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-2/</id>
    <published>2017-07-25T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a></strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLParsingEngine</a></li>
<li><a href="#">3. SQLParser SQL解析器</a><ul>
<li><a href="#">3.1 AbstractParser</a></li>
<li><a href="#">3.2 SQLParser</a><ul>
<li><a href="#">3.2.1 #parseExpression() 和 SQLExpression</a></li>
<li><a href="#">3.2.2 #parseAlias()</a></li>
<li><a href="#">3.2.3 #parseSingleTable()</a></li>
<li><a href="#">3.2.4 #skipJoin()</a></li>
<li><a href="#">3.2.5 #parseWhere()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">4. StatementParser SQL语句解析器</a><ul>
<li><a href="#">4.1 StatementParser</a></li>
<li><a href="#">4.2 Statement</a></li>
</ul>
</li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>上篇文章<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/">《词法解析》</a>分享了<strong>词法解析器Lexer</strong>是如何解析 SQL 里的词法。本文分享<strong>SQL解析引擎</strong>是如何解析与理解 SQL的。因为本文建立在<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/">《词法解析》</a>之上，你需要阅读它后在开始这段旅程。🙂如果对词法解析不完全理解，请给我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>留言，我会<strong>逐条认真耐心</strong>回复。</p>
<p>区别于 Lexer，Parser <strong>理解SQL</strong>：</p>
<ul>
<li><strong>提炼分片上下文</strong></li>
<li><strong>标记需要SQL改写的部分</strong></li>
</ul>
<p>Parser 有三个组件：</p>
<ul>
<li>SQLParsingEngine ：SQL 解析引擎</li>
<li>SQLParser ：SQL 解析器</li>
<li>StatementParser ：SQL语句解析器</li>
</ul>
<p>SQLParsingEngine 调用 StatementParser 解析 SQL。<br>StatementParser 调用 SQLParser 解析 SQL 表达式。<br>SQLParser 调用 Lexer 解析 SQL 词法。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/01.png" alt=""></p>
<p>😜 是不是觉得 SQLParser 和 StatementParser 看起来很接近？下文为你揭开这个答案。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-SQLParsingEngine"><a href="#2-SQLParsingEngine" class="headerlink" title="2. SQLParsingEngine"></a>2. SQLParsingEngine</h1><p>SQLParsingEngine，SQL 解析引擎。其 <code>#parse()</code> 方法作为 SQL 解析入口，本身不带复杂逻辑，通过调用 SQL 对应的 StatementParser 进行 SQL 解析。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParsingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 SQL解析器</span></div><div class="line">   SQLParser sqlParser = getSQLParser();</div><div class="line">   <span class="comment">//</span></div><div class="line">   sqlParser.skipIfEqual(Symbol.SEMI); <span class="comment">// 跳过 ";"</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.WITH)) &#123; <span class="comment">// WITH Syntax</span></div><div class="line">       skipWith(sqlParser);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取对应 SQL语句解析器 解析SQL</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">       <span class="keyword">return</span> SelectParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.INSERT)) &#123;</div><div class="line">       <span class="keyword">return</span> InsertParserFactory.newInstance(shardingRule, sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UPDATE)) &#123;</div><div class="line">       <span class="keyword">return</span> UpdateParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DELETE)) &#123;</div><div class="line">       <span class="keyword">return</span> DeleteParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-SQLParser-SQL解析器"><a href="#3-SQLParser-SQL解析器" class="headerlink" title="3. SQLParser SQL解析器"></a>3. SQLParser SQL解析器</h1><p>SQLParser，SQL 解析器。和词法解析器 Lexer 一样，不同数据库有不同的实现。</p>
<p>类图如下（<strong>包含所有属性和方法</strong>）（<strong><a href="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/02.png">放大图片</a></strong>）：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/02.png" alt=""></p>
<h2 id="3-1-AbstractParser"><a href="#3-1-AbstractParser" class="headerlink" title="3.1 AbstractParser"></a>3.1 AbstractParser</h2><p>AbstractParser，SQLParser 的抽象父类，对 Lexer 简单封装。例如：</p>
<ul>
<li><code>#skipIfEqual()</code>：判断当前词法标记类型是否与其中一个传入值相等</li>
<li><code>#equalAny()</code>：判断当前词法标记类型是否与其中一个传入值相等</li>
</ul>
<p><em><strong>这里有一点我们需要注意，SQLParser 并不是等 Lexer 解析完词法( Token )，再根据词法去理解 SQL。而是，在理解 SQL 的过程中，调用 Lexer 进行分词。</strong></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParsingEngine.java#parse()片段</span></div><div class="line"><span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">    <span class="keyword">return</span> SelectParserFactory.newInstance(sqlParser).parse();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equalAny</span><span class="params">(<span class="keyword">final</span> TokenType... tokenTypes)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (TokenType each : tokenTypes) &#123;</div><div class="line">       <span class="keyword">if</span> (each == lexer.getCurrentToken().getType()) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>↑↑↑ 判断当前<strong>词法</strong>是否为 SELECT。实际 AbstractParser 只知道当前词法，并<strong>不知道</strong>后面还有哪些词法，也<strong>不知道</strong>之前有哪些词法。</li>
</ul>
<p>我们来看 AbstractParser 里比较复杂的方法 <code>#skipParentheses()</code> 帮助大家再理解下。请认真看代码注释噢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过小括号内所有的词法标记.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 小括号内所有的词法标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">skipParentheses</span><span class="params">()</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (Symbol.LEFT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> beginPosition = getLexer().getCurrentToken().getEndPosition();</div><div class="line">       result.append(Symbol.LEFT_PAREN.getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">               increaseParametersIndex();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 到达结尾 或者 匹配合适数的)右括号</span></div><div class="line">           <span class="keyword">if</span> (Assist.END == getLexer().getCurrentToken().getType() || (Symbol.RIGHT_PAREN == getLexer().getCurrentToken().getType() &amp;&amp; <span class="number">0</span> == count)) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 处理里面有多个括号的情况，例如：SELECT COUNT(DISTINCT(order_id) FROM t_order</span></div><div class="line">           <span class="keyword">if</span> (Symbol.LEFT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">               count++;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Symbol.RIGHT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">               count--;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 下一个词法</span></div><div class="line">           getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得括号内的内容</span></div><div class="line">       result.append(getLexer().getInput().substring(beginPosition, getLexer().getCurrentToken().getEndPosition()));</div><div class="line">       <span class="comment">// 下一个词法</span></div><div class="line">       getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类其它方法很重要，逻辑相对简单，我们就不占用篇幅了。大家一定要看哟，后面调用非常非常多。<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/master/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/AbstractParser.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractParser.java 传送门</a>。👼也可以关注我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>发送关键字【sjdbc】获取<strong>增加方法内注释的项目地址</strong>。</p>
<h2 id="3-2-SQLParser"><a href="#3-2-SQLParser" class="headerlink" title="3.2 SQLParser"></a>3.2 SQLParser</h2><p>SQLParser，SQL 解析器，<strong>主要提供只考虑 SQL 块的解析方法，<em>不考虑 SQL 上下文</em></strong>。下文即将提到的 StatementParser 将 SQL 拆成对应的<strong>块</strong>，调用 SQLParser 进行解析。🤓 这么说，可能会有些抽象，我们下面来一起看。</p>
<p>SQLParser 看起来方法特别多，合并下一共 5 种：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">#parseExpression()</td>
<td style="text-align:left">解析表达式</td>
</tr>
<tr>
<td style="text-align:left">#parseAlias()</td>
<td style="text-align:left">解析别名</td>
</tr>
<tr>
<td style="text-align:left">#parseSingleTable()</td>
<td style="text-align:left">解析单表</td>
</tr>
<tr>
<td style="text-align:left">#skipJoin()</td>
<td style="text-align:left">跳过表关联词法</td>
</tr>
<tr>
<td style="text-align:left">#parseWhere()</td>
<td style="text-align:left">解析查询条件</td>
</tr>
</tbody>
</table>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/03.png" alt=""></p>
<p>看了这 5 个方法是否有点理解了？SQLParser 不考虑 SQL 是 SELECT / INSERT / UPDATE / DELETE ，它考虑的是，<strong>给我的是 WHERE 处解析查询条件，或是 INSERT INTO 解析单表 等</strong>，提供 SELECT / INSERT / UPDATE / DELETE 需要的 SQL 块公用解析。</p>
<h3 id="3-2-1-parseExpression-和-SQLExpression"><a href="#3-2-1-parseExpression-和-SQLExpression" class="headerlink" title="3.2.1 #parseExpression() 和 SQLExpression"></a>3.2.1 #parseExpression() 和 SQLExpression</h3><p>SQLExpression，SQL表达式接口。目前 6 种实现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">对应Token</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SQLIdentifierExpression</td>
<td style="text-align:left">标识表达式</td>
<td style="text-align:left">Literals.IDENTIFIER</td>
</tr>
<tr>
<td style="text-align:left">SQLPropertyExpression</td>
<td style="text-align:left">属性表达式</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">SQLNumberExpression</td>
<td style="text-align:left">数字表达式</td>
<td style="text-align:left">Literals.INT, Literals.HEX</td>
</tr>
<tr>
<td style="text-align:left">SQLPlaceholderExpression</td>
<td style="text-align:left">占位符表达式</td>
<td style="text-align:left">Symbol.QUESTION</td>
</tr>
<tr>
<td style="text-align:left">SQLTextExpression</td>
<td style="text-align:left">字符表达式</td>
<td style="text-align:left">Literals.CHARS</td>
</tr>
<tr>
<td style="text-align:left">SQLIgnoreExpression</td>
<td style="text-align:left">分片中无需关注的SQL表达式</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/04.png" alt=""></p>
<ul>
<li>SQLPropertyExpression 例如：<code>SELECT * FROM t_order o ORDER BY o.order_id</code> 中的 <code>o.order_id</code>。<strong>SQLPropertyExpression 从 SQLIdentifierExpression 进一步判断解析而来。</strong><br> <img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/05.png" alt=""> </li>
<li>SQLIgnoreExpression 例如：<code>SELECT * FROM t_order o ORDER BY o.order_id % 2</code> 中的<code>o.order_id % 2</code>。<strong>复合表达式都会解析成 SQLIgnoreExpression。</strong></li>
</ul>
<p>解析 SQLExpression 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析表达式.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 表达式</div><div class="line">*/</div><div class="line"><span class="comment">// TODO 完善Expression解析的各种场景</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SQLExpression <span class="title">parseExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析表达式</span></div><div class="line">   String literals = getLexer().getCurrentToken().getLiterals();</div><div class="line">   <span class="keyword">final</span> SQLExpression expression = getExpression(literals);</div><div class="line">   <span class="comment">// SQLIdentifierExpression 需要特殊处理。考虑自定义函数，表名.属性情况。</span></div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Literals.IDENTIFIER)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// 例如，ORDER BY o.uid 中的 "o.uid"</span></div><div class="line">           String property = getLexer().getCurrentToken().getLiterals();</div><div class="line">           getLexer().nextToken();</div><div class="line">           <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : <span class="keyword">new</span> SQLPropertyExpression(<span class="keyword">new</span> SQLIdentifierExpression(literals), property);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.LEFT_PAREN)) &#123; <span class="comment">// 例如，GROUP BY DATE(create_time) 中的 "DATE(create_time)"</span></div><div class="line">           skipParentheses();</div><div class="line">           skipRestCompositeExpression();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</div><div class="line">   &#125;</div><div class="line">   getLexer().nextToken();</div><div class="line">   <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 词法Token 对应的 SQLExpression</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> literals 词法字面量标记</div><div class="line">* <span class="doctag">@return</span> SQLExpression</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> SQLExpression <span class="title">getExpression</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">       increaseParametersIndex();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLPlaceholderExpression(getParametersIndex() - <span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.CHARS)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLTextExpression(literals);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 考虑long的情况</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.INT)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.FLOAT)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Double.parseDouble(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 考虑long的情况</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.HEX)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals, <span class="number">16</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLIdentifierExpression(SQLUtil.getExactlyValue(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 如果是 复合表达式，跳过。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否跳过</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipIfCompositeExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT, Symbol.LEFT_PAREN)) &#123;</div><div class="line">       skipParentheses();</div><div class="line">       skipRestCompositeExpression();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过剩余复合表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipRestCompositeExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (skipIfEqual(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">           increaseParametersIndex();</div><div class="line">       &#125;</div><div class="line">       getLexer().nextToken();</div><div class="line">       skipParentheses();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析了 SQLExpression 有什么用呢？我们会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《插入SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《更新SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a>。留个悬念😈，关注我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>，<strong>实时收到新文更新通知</strong>。</p>
<h3 id="3-2-2-parseAlias"><a href="#3-2-2-parseAlias" class="headerlink" title="3.2.2 #parseAlias()"></a>3.2.2 #parseAlias()</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析别名.不仅仅是字段的别名，也可以是表的别名。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">parseAlias</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析带 AS 情况</span></div><div class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.AS)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.values())) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.absent();</div><div class="line">       &#125;</div><div class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">return</span> Optional.of(result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析别名</span></div><div class="line">   <span class="comment">// TODO 增加哪些数据库识别哪些关键字作为别名的配置</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER, Literals.CHARS, DefaultKeyword.USER, DefaultKeyword.END, DefaultKeyword.CASE, DefaultKeyword.KEY, DefaultKeyword.INTERVAL, DefaultKeyword.CONSTRAINT)) &#123;</div><div class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">return</span> Optional.of(result);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-3-parseSingleTable"><a href="#3-2-3-parseSingleTable" class="headerlink" title="3.2.3 #parseSingleTable()"></a>3.2.3 #parseSingleTable()</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单表.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL语句对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSingleTable</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> hasParentheses = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(DefaultKeyword.SELECT)) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</div><div class="line">       &#125;</div><div class="line">       hasParentheses = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   Table table;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> beginPosition = getLexer().getCurrentToken().getEndPosition() - getLexer().getCurrentToken().getLiterals().length();</div><div class="line">   String literals = getLexer().getCurrentToken().getLiterals();</div><div class="line">   getLexer().nextToken();</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123;</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</div><div class="line">           accept(Symbol.RIGHT_PAREN);</div><div class="line">       &#125;</div><div class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</div><div class="line">           accept(Symbol.RIGHT_PAREN);</div><div class="line">       &#125;</div><div class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (skipJoin()) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Multiple-Table."</span>);</div><div class="line">   &#125;</div><div class="line">   sqlStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</div><div class="line">   sqlStatement.getTables().add(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-4-skipJoin"><a href="#3-2-4-skipJoin" class="headerlink" title="3.2.4 #skipJoin()"></a>3.2.4 #skipJoin()</h3><p>跳过表关联词法，支持 <code>SELECT * FROM t_user, t_order WHERE ...</code>, <code>SELECT * FROM t_user JOIN t_order ON ...</code>。下篇<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a><strong>解析表</strong>会用到这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过表关联词法.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否表关联.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">skipJoin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.LEFT, DefaultKeyword.RIGHT, DefaultKeyword.FULL)) &#123;</div><div class="line">       skipIfEqual(DefaultKeyword.OUTER);</div><div class="line">       accept(DefaultKeyword.JOIN);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.INNER)) &#123;</div><div class="line">       accept(DefaultKeyword.JOIN);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, Symbol.COMMA, DefaultKeyword.STRAIGHT_JOIN)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.CROSS)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, DefaultKeyword.APPLY)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.OUTER)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.APPLY)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-5-parseWhere"><a href="#3-2-5-parseWhere" class="headerlink" title="3.2.5 #parseWhere()"></a>3.2.5 #parseWhere()</h3><p>解析 WHERE 查询条件。目前支持 AND 条件，不支持 OR 条件。近期 OR 条件支持的可能性比较低。另外条件这块对括号解析需要继续优化，实际使用请勿写冗余的括号。例如：<code>SELECT * FROM tbl_name1 WHERE ((val1=?) AND (val2=?)) AND val3 =?</code>。</p>
<p>根据不同的运算操作符，分成如下情况：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>附加条件</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td></td>
<td>#parseEqualCondition()</td>
</tr>
<tr>
<td>IN</td>
<td></td>
<td>#parseInCondition()</td>
</tr>
<tr>
<td>BETWEEN</td>
<td></td>
<td>#parseBetweenCondition()</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>Oracle 或 SQLServer 分页</td>
<td>#parseRowNumberCondition()</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td></td>
<td>#parseOtherCondition()</td>
</tr>
<tr>
<td>LIKE</td>
<td></td>
<td>parseOtherCondition</td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有查询条件。</div><div class="line">* 目前不支持 OR 条件。</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConditions</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="comment">// AND 查询</span></div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       parseComparisonCondition(sqlStatement);</div><div class="line">   &#125; <span class="keyword">while</span> (skipIfEqual(DefaultKeyword.AND));</div><div class="line">   <span class="comment">// 目前不支持 OR 条件</span></div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.OR)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">&#125; </div><div class="line"><span class="comment">// TODO 解析组合expr</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个查询条件</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseComparisonCondition</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   skipIfEqual(Symbol.LEFT_PAREN);</div><div class="line">   SQLExpression left = parseExpression(sqlStatement);</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.EQ)) &#123;</div><div class="line">       parseEqualCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.IN)) &#123;</div><div class="line">       parseInCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.BETWEEN)) &#123;</div><div class="line">       parseBetweenCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.LT, Symbol.GT, Symbol.LT_EQ, Symbol.GT_EQ)) &#123;</div><div class="line">       <span class="keyword">if</span> (left <span class="keyword">instanceof</span> SQLIdentifierExpression &amp;&amp; sqlStatement <span class="keyword">instanceof</span> SelectStatement</div><div class="line">               &amp;&amp; isRowNumberCondition((SelectStatement) sqlStatement, ((SQLIdentifierExpression) left).getName())) &#123;</div><div class="line">           parseRowNumberCondition((SelectStatement) sqlStatement);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left <span class="keyword">instanceof</span> SQLPropertyExpression &amp;&amp; sqlStatement <span class="keyword">instanceof</span> SelectStatement</div><div class="line">               &amp;&amp; isRowNumberCondition((SelectStatement) sqlStatement, ((SQLPropertyExpression) left).getName())) &#123;</div><div class="line">           parseRowNumberCondition((SelectStatement) sqlStatement);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           parseOtherCondition(sqlStatement);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (equalAny(DefaultKeyword.LIKE)) &#123;</div><div class="line">       parseOtherCondition(sqlStatement);</div><div class="line">   &#125;</div><div class="line">   skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>#parseComparisonCondition()</code> 解析到 <code>左SQL表达式(left)</code> 和 运算符，调用相应方法进一步处理。我们选择 <code>#parseEqualCondition()</code> 看下，其他方法有兴趣跳转 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/master/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/SQLParser.java" rel="external nofollow noopener noreferrer" target="_blank">SQLParser</a> 查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 = 条件</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">* <span class="doctag">@param</span> left 左SQLExpression</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseEqualCondition</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement, <span class="keyword">final</span> SQLExpression left)</span> </span>&#123;</div><div class="line">   getLexer().nextToken();</div><div class="line">   SQLExpression right = parseExpression(sqlStatement);</div><div class="line">   <span class="comment">// 添加列</span></div><div class="line">   <span class="comment">// TODO 如果有多表,且找不到column是哪个表的,则不加入condition,以后需要解析binding table</span></div><div class="line">   <span class="keyword">if</span> ((sqlStatement.getTables().isSingleTable() || left <span class="keyword">instanceof</span> SQLPropertyExpression)</div><div class="line">           <span class="comment">// 只有对路由结果有影响的才会添加到 conditions。SQLPropertyExpression 和 SQLIdentifierExpression 无法判断，所以未加入 conditions</span></div><div class="line">           &amp;&amp; (right <span class="keyword">instanceof</span> SQLNumberExpression || right <span class="keyword">instanceof</span> SQLTextExpression || right <span class="keyword">instanceof</span> SQLPlaceholderExpression)) &#123;</div><div class="line">       Optional&lt;Column&gt; column = find(sqlStatement.getTables(), left);</div><div class="line">       <span class="keyword">if</span> (column.isPresent()) &#123;</div><div class="line">           sqlStatement.getConditions().add(<span class="keyword">new</span> Condition(column.get(), right), shardingRule);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>#parseEqualCondition()</code> 解析到 <code>右SQL表达式(right)</code>，并判断 <code>左右SQL表达式</code> 与路由逻辑是否有影响，如果有，则加入到 Condition。<strong>这个就是 <code>#parseWhere()</code> 的目的：解析 WHERE 查询条件对路由有影响的条件。</strong><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《路由》</a>相关的逻辑，会单独开文章介绍。这里，我们先留有映像。</p>
<h1 id="4-StatementParser-SQL语句解析器"><a href="#4-StatementParser-SQL语句解析器" class="headerlink" title="4. StatementParser SQL语句解析器"></a>4. StatementParser SQL语句解析器</h1><h2 id="4-1-StatementParser"><a href="#4-1-StatementParser" class="headerlink" title="4.1 StatementParser"></a>4.1 StatementParser</h2><p>StatementParser，SQL语句解析器。每种 SQL，都有相应的 SQL语句解析器实现。不同数据库，继承这些 SQL语句解析器，实现各自 SQL 上的差异。大体结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/06.png" alt=""></p>
<p>SQLParsingEngine 根据不同 SQL 调用对应工厂创建 StatementParser。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectParserFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建Select语句解析器.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> sqlParser SQL解析器</div><div class="line">     * <span class="doctag">@return</span> Select语句解析器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractSelectParser <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> SQLParser sqlParser)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> MySQLParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MySQLSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> OracleParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OracleSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> SQLServerParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SQLServerSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> PostgreSQLParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PostgreSQLSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(String.format(<span class="string">"Cannot support sqlParser class [%s]."</span>, sqlParser.getClass()));</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 <code>StatementParser#parse()</code> 实现方法，对 SQL 进行解析。具体解析过程，另开文章分享。</p>
<h2 id="4-2-Statement"><a href="#4-2-Statement" class="headerlink" title="4.2 Statement"></a>4.2 Statement</h2><p>不同 SQL 解析后，返回对应的 SQL 结果,即 Statement。大体结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/07.png" alt=""></p>
<p>Statement 包含两部分信息：</p>
<ul>
<li><p>分片上下文：用于 SQL 路由。</p>
<p>  <img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/08.png" alt=""></p>
</li>
<li><p>SQL 标记对象：用于 SQL 改写。</p>
<p> <img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/09.png" alt=""></p>
</li>
</ul>
<p>我们会在后文增删改查SQL解析的过程中分享到它们。</p>
<h2 id="4-3-预告"><a href="#4-3-预告" class="headerlink" title="4.3 预告"></a>4.3 预告</h2><table>
<thead>
<tr>
<th>Parser</th>
<th>Statement</th>
<th>分享文章</th>
</tr>
</thead>
<tbody>
<tr>
<td>SelectStatementParser</td>
<td>SelectStatement + AbstractSQLStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a></td>
</tr>
<tr>
<td>InsertStatementParser</td>
<td>InsertStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《插入SQL解析》</a></td>
</tr>
<tr>
<td>UpdateStatementParser</td>
<td>UpdateStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《更新SQL解析》</a></td>
</tr>
<tr>
<td>DeleteStatementParser</td>
<td>DeleteStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a></td>
</tr>
</tbody>
</table>
<h1 id="5-彩蛋"><a href="#5-彩蛋" class="headerlink" title="5. 彩蛋"></a>5. 彩蛋</h1><p>老铁，是不是有丢丢长？<br>如果有地方错误，烦请指出🙂。<br>如果有地方不是很理解，可以加我的公众号<strong>（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）</strong>留言，我会<strong>逐条认真耐心</strong>回复。<br>如果觉得还凑合，劳驾分享朋友圈或者基佬。</p>
<p><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a>已经写了一半，预计很快…</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：&lt;a href=&quot;http://
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（一）之词法解析</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-1/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. Lexer 词法解析器</a></li>
<li><a href="#">3. Token 词法标记</a><ul>
<li><a href="#">3.1 DefaultKeyword 词法关键词</a></li>
<li><a href="#">3.2 Literals 词法字面量标记</a><ul>
<li><a href="#">3.2.1 Literals.IDENTIFIER 词法关键词</a></li>
<li><a href="#">3.2.2 Literals.VARIABLE 变量</a></li>
<li><a href="#">3.2.3 Literals.CHARS 字符串</a></li>
<li><a href="#">3.2.4 Literals.HEX 十六进制</a></li>
<li><a href="#">3.2.5 Literals.INT 整数</a></li>
<li><a href="#">3.2.6 Literals.FLOAT 浮点数</a></li>
</ul>
</li>
<li><a href="#">3.3 Symbol 词法符号标记</a></li>
<li><a href="#">3.4 Assist 词法辅助标记</a></li>
</ul>
</li>
<li><a href="#">4. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>SQL 解析引擎</strong>，数据库中间件必备的功能和流程。Sharding-JDBC 在 <code>1.5.0.M1</code> 正式发布时，将 SQL 解析引擎从 Druid 替换成了自研的。<strong>新引擎仅解析分片上下文，对于 SQL 采用”半理解”理念，进一步提升性能和兼容性，同时降低了代码复杂度</strong>（不理解没关系，我们后续会更新文章解释该优点）。 国内另一款数据库中间件 MyCAT SQL 解析引擎也是 Druid，目前也在开发属于自己的 SQL 解析引擎。</p>
<p>可能有同学看到<strong>SQL 解析</strong>会被吓到，请淡定，耐心往下看。《SQL 解析》内容我们会分成 5 篇相对简短的文章，让大家能够相对轻松愉快的去理解：</p>
<ol>
<li>词法解析</li>
<li>插入 SQL 解析</li>
<li>查询 SQL 解析</li>
<li>更新 SQL 解析</li>
<li>删除 SQL 解析</li>
</ol>
<hr>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/01.png" alt=""></p>
<p><strong>SQL 解析引擎</strong>在 <code>parsing</code> 包下，如上图所见包含两大组件：</p>
<ol>
<li>Lexer：<strong>词法</strong>解析器。</li>
<li>Parser：<strong>SQL</strong>解析器。</li>
</ol>
<p>两者都是解析器，区别在于 Lexer 只做词法的解析，不关注上下文，将字符串拆解成 N 个词法。而 Parser 在 Lexer 的基础上，还需要理解 SQL 。打个比方：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">SQL ：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user  </div><div class="line">Lexer ：[<span class="keyword">SELECT</span>] [ * ] [<span class="keyword">FROM</span>] [t_user]  </div><div class="line">Parser ：这是一条 [<span class="keyword">SELECT</span>] 查询表为 [t_user] ，并且返回 [ * ] 所有字段的 <span class="keyword">SQL</span>。</div></pre></td></tr></table></figure>
<p>🙂不完全懂？没关系，本文的主角是 Lexer，我们通过源码一点一点理解。一共 1400 行左右代码左右，还包含注释等等，实际更少噢。</p>
<h1 id="2-Lexer-词法解析器"><a href="#2-Lexer-词法解析器" class="headerlink" title="2. Lexer 词法解析器"></a>2. Lexer 词法解析器</h1><p><strong>Lexer 原理</strong>：<strong>顺序顺序顺序</strong> 解析 SQL，将字符串拆解成 N 个词法。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出字符串</div><div class="line">     * 比如：SQL</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String input;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 词法标记字典</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解析到 SQL 的 offset</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前 词法标记</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> Token currentToken;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分析下一个词法标记.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #currentToken</div><div class="line">     * <span class="doctag">@see</span> #offset</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        skipIgnoredToken();</div><div class="line">        <span class="keyword">if</span> (isVariableBegin()) &#123; <span class="comment">// 变量</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanVariable();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNCharBegin()) &#123; <span class="comment">// N\</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, ++offset).scanChars();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierBegin()) &#123; <span class="comment">// Keyword + Literals.IDENTIFIER</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanIdentifier();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHexDecimalBegin()) &#123; <span class="comment">// 十六进制</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanHexDecimal();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNumberBegin()) &#123; <span class="comment">// 数字（整数+浮点数）</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanNumber();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSymbolBegin()) &#123; <span class="comment">// 符号</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanSymbol();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCharsBegin()) &#123; <span class="comment">// 字符串，例如："abc"</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanChars();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isEnd()) &#123; <span class="comment">// 结束</span></div><div class="line">            currentToken = <span class="keyword">new</span> Token(Assist.END, <span class="string">""</span>, offset);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 分析错误，无符合条件的词法标记</span></div><div class="line">            currentToken = <span class="keyword">new</span> Token(Assist.ERROR, <span class="string">""</span>, offset);</div><div class="line">        &#125;</div><div class="line">        offset = currentToken.getEndPosition();</div><div class="line">        <span class="comment">// System.out.println("| " + currentToken.getLiterals() + " | " + currentToken.getType() + " | " + currentToken.getEndPosition() + " |");</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 跳过忽略的词法标记</div><div class="line">     * 1. 空格</div><div class="line">     * 2. SQL Hint</div><div class="line">     * 3. SQL 注释</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipIgnoredToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 空格</span></div><div class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        <span class="comment">// SQL Hint</span></div><div class="line">        <span class="keyword">while</span> (isHintBegin()) &#123;</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipHint();</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SQL 注释</span></div><div class="line">        <span class="keyword">while</span> (isCommentBegin()) &#123;</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipComment();</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 <code>#nextToken()</code> 方法，不断解析出 Token(<em>词法标记</em>)。我们来执行一次，看看 SQL 会被拆解成哪些 Token。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">SQL ：<span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.user_id=? <span class="keyword">AND</span> o.order_id=?</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>literals</th>
<th>TokenType类</th>
<th>TokenType值</th>
<th>endPosition</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>DefaultKeyword</td>
<td>SELECT</td>
<td>6</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>8</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>9</td>
</tr>
<tr>
<td>*</td>
<td>Symbol</td>
<td>STAR</td>
<td>10</td>
</tr>
<tr>
<td>FROM</td>
<td>DefaultKeyword</td>
<td>FROM</td>
<td>15</td>
</tr>
<tr>
<td>t_order</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>23</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>25</td>
</tr>
<tr>
<td>JOIN</td>
<td>DefaultKeyword</td>
<td>JOIN</td>
<td>30</td>
</tr>
<tr>
<td>t_order_item</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>43</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>45</td>
</tr>
<tr>
<td>ON</td>
<td>DefaultKeyword</td>
<td>ON</td>
<td>48</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>50</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>51</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>59</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>60</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>61</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>62</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>70</td>
</tr>
<tr>
<td>WHERE</td>
<td>DefaultKeyword</td>
<td>WHERE</td>
<td>76</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>78</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>79</td>
</tr>
<tr>
<td>user_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>86</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>87</td>
</tr>
<tr>
<td>?</td>
<td>Symbol</td>
<td>QUESTION</td>
<td>88</td>
</tr>
<tr>
<td>AND</td>
<td>DefaultKeyword</td>
<td>AND</td>
<td>92</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>94</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>95</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>103</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>104</td>
</tr>
<tr>
<td>?</td>
<td>Symbol</td>
<td>QUESTION</td>
<td>105</td>
</tr>
<tr>
<td></td>
<td>Assist</td>
<td>END</td>
<td>105</td>
</tr>
</tbody>
</table>
<p>眼尖的同学可能看到了 Tokenizer。对的，它是 Lexer 的好基佬，负责<strong>分词</strong>。</p>
<p><em>我们来总结下，<code>Lexer#nextToken()</code> 方法里，使用 <code>#skipIgnoredToken()</code> 方法跳过忽略的 Token，通过 <code>#isXXXX()</code> 方法判断好下一个 Token 的类型后，<strong>交给 Tokenizer 进行分词返回 Token</strong>。‼️此处可以考虑做个优化，不需要每次都 <code>new Tokenizer(...)</code> 出来，一个 Lexer 搭配一个 Tokenizer。</em></p>
<hr>
<p>由于不同数据库遵守 SQL 规范略有不同，所以不同的数据库对应不同的 Lexer。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/02.png" alt=""></p>
<p>子 Lexer 通过重写方法实现自己独有的 SQL 语法。</p>
<h1 id="3-Token-词法标记"><a href="#3-Token-词法标记" class="headerlink" title="3. Token 词法标记"></a>3. Token 词法标记</h1><p>上文我们已经看过 Token 的例子，一共有 3 个属性：</p>
<ul>
<li>TokenType type ：词法标记类型</li>
<li>String literals ：词法字面量标记</li>
<li>int endPosition ：<code>literals</code> 在 SQL 里的结束位置</li>
</ul>
<p>TokenType 词法标记类型，一共分成 4 个大类：</p>
<ul>
<li>DefaultKeyword ：词法关键词</li>
<li>Literals ：词法字面量标记</li>
<li>Symbol ：词法符号标记</li>
<li>Assist ：词法辅助标记</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/03.png" alt=""></p>
<h2 id="3-1-DefaultKeyword-词法关键词"><a href="#3-1-DefaultKeyword-词法关键词" class="headerlink" title="3.1 DefaultKeyword 词法关键词"></a>3.1 DefaultKeyword 词法关键词</h2><p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/04.png" alt=""></p>
<p><strong>不同数据库有自己独有的<em>词法关键词</em>，例如 MySQL 熟知的分页 Limit。</strong></p>
<p>我们以 MySQL 举个例子，当创建 MySQLLexer 时，会加载 DefaultKeyword 和 MySQLKeyword（ <em>OracleLexer、PostgreSQLLexer、SQLServerLexer 同 MySQLLexer</em> ）。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLLexer.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLLexer</span> <span class="keyword">extends</span> <span class="title">Lexer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字典</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(MySQLKeyword.values());</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySQLLexer</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(input, dictionary);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Dictionary.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 词法关键词Map</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Keyword&gt; tokens = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span><span class="params">(<span class="keyword">final</span> Keyword... dialectKeywords)</span> </span>&#123;</div><div class="line">        fill(dialectKeywords);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 装上默认词法关键词 + 方言词法关键词</div><div class="line">     * 不同的数据库有相同的默认词法关键词，有有不同的方言关键词</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> dialectKeywords 方言词法关键词</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> Keyword... dialectKeywords)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (DefaultKeyword each : DefaultKeyword.values()) &#123;</div><div class="line">            tokens.put(each.name(), each);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Keyword each : dialectKeywords) &#123;</div><div class="line">            tokens.put(each.toString(), each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Keyword 与 Literals.IDENTIFIER 是一起解析的，我们放在 Literals.IDENTIFIER 处一起分析。</p>
<h2 id="3-2-Literals-词法字面量标记"><a href="#3-2-Literals-词法字面量标记" class="headerlink" title="3.2 Literals 词法字面量标记"></a>3.2 Literals 词法字面量标记</h2><p>Literals 词法字面量标记，一共分成 6 种：</p>
<ul>
<li>IDENTIFIER ：词法关键词</li>
<li>VARIABLE ：变量</li>
<li>CHARS ：字符串</li>
<li>HEX ：十六进制</li>
<li>INT ：整数</li>
<li>FLOAT ：浮点数</li>
</ul>
<h3 id="3-2-1-Literals-IDENTIFIER-词法关键词"><a href="#3-2-1-Literals-IDENTIFIER-词法关键词" class="headerlink" title="3.2.1 Literals.IDENTIFIER 词法关键词"></a>3.2.1 Literals.IDENTIFIER 词法关键词</h3><p>词法关键词。例如：表名，查询字段 等等。</p>
<p>解析 Literals.IDENTIFIER 与 Keyword 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isIdentifierBegin(getCurrentChar(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierBegin</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isAlphabet(ch) || <span class="string">'`'</span> == ch || <span class="string">'_'</span> == ch || <span class="string">'$'</span> == ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描标识符.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 标识符标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanIdentifier</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// `字段`，例如：SELECT `id` FROM t_user 中的 `id`</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'`'</span> == charAt(offset)) &#123;</div><div class="line">       <span class="keyword">int</span> length = getLengthUntilTerminatedChar(<span class="string">'`'</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.IDENTIFIER, input.substring(offset, offset + length), offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (isIdentifierChar(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   String literals = input.substring(offset, offset + length);</div><div class="line">   <span class="comment">// 处理 order / group 作为表名</span></div><div class="line">   <span class="keyword">if</span> (isAmbiguousIdentifier(literals)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Token(processAmbiguousIdentifier(offset + length, literals), literals, offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 从 词法关键词 查找是否是 Keyword，如果是，则返回 Keyword，否则返回 Literals.IDENTIFIER</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(dictionary.findTokenType(literals, Literals.IDENTIFIER), literals, offset + length);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算到结束字符的长度</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> #hasEscapeChar(char, int) 处理类似 SELECT a AS `b``c` FROM table。此处连续的 "``" 不是结尾，如果传递的是 "`" 会产生误判，所以加了这个判断</div><div class="line">* <span class="doctag">@param</span> terminatedChar 结束字符</div><div class="line">* <span class="doctag">@return</span> 长度</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLengthUntilTerminatedChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> terminatedChar)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">   <span class="keyword">while</span> (terminatedChar != charAt(offset + length) || hasEscapeChar(terminatedChar, offset + length)) &#123;</div><div class="line">       <span class="keyword">if</span> (offset + length &gt;= input.length()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnterminatedCharException(terminatedChar);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (hasEscapeChar(terminatedChar, offset + length)) &#123;</div><div class="line">           length++;</div><div class="line">       &#125;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> length + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 Escape 字符</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> charIdentifier 字符</div><div class="line">* <span class="doctag">@param</span> offset 位置</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEscapeChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> charIdentifier, <span class="keyword">final</span> <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> charIdentifier == charAt(offset) &amp;&amp; charIdentifier == charAt(offset + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isAlphabet(ch) || CharType.isDigital(ch) || <span class="string">'_'</span> == ch || <span class="string">'$'</span> == ch || <span class="string">'#'</span> == ch;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是引起歧义的标识符</div><div class="line">* 例如 "SELECT * FROM group"，此时 "group" 代表的是表名，而非词法关键词</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> literals 标识符</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAmbiguousIdentifier</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> DefaultKeyword.ORDER.name().equalsIgnoreCase(literals) || DefaultKeyword.GROUP.name().equalsIgnoreCase(literals);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取引起歧义的标识符对应的词法标记类型</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> offset 位置</div><div class="line">* <span class="doctag">@param</span> literals 标识符</div><div class="line">* <span class="doctag">@return</span> 词法标记类型</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> TokenType <span class="title">processAmbiguousIdentifier</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (CharType.isWhitespace(charAt(offset + i))) &#123;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (DefaultKeyword.BY.name().equalsIgnoreCase(String.valueOf(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;charAt(offset + i), charAt(offset + i + <span class="number">1</span>)&#125;))) &#123;</div><div class="line">       <span class="keyword">return</span> dictionary.findTokenType(literals);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Literals.IDENTIFIER;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-2-Literals-VARIABLE-变量"><a href="#3-2-2-Literals-VARIABLE-变量" class="headerlink" title="3.2.2 Literals.VARIABLE 变量"></a>3.2.2 Literals.VARIABLE 变量</h3><p>变量。例如：<code>SELECT @@VERSION</code> 。</p>
<p>解析核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 变量</div><div class="line">* MySQL 与 SQL Server 支持</div><div class="line">* </div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanVariable()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isVariableBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描变量.</div><div class="line">* 在 MySQL 里，@代表用户变量；@@代表系统变量。</div><div class="line">* 在 SQLServer 里，有 @@。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 变量标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanVariable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="string">'@'</span> == charAt(offset + <span class="number">1</span>)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (isVariableChar(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.VARIABLE, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-3-Literals-CHARS-字符串"><a href="#3-2-3-Literals-CHARS-字符串" class="headerlink" title="3.2.3 Literals.CHARS 字符串"></a>3.2.3 Literals.CHARS 字符串</h3><p>字符串。例如：<code>SELECT &quot;123&quot;</code> 。</p>
<p>解析核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否 N\</div><div class="line">* 目前 SQLServer 独有：在 SQL Server 中處理 Unicode 字串常數時，必需為所有的 Unicode 字串加上前置詞 N</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanChars()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNCharBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isSupportNChars() &amp;&amp; <span class="string">'N'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; <span class="string">'\''</span> == getCurrentChar(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCharsBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'\''</span> == getCurrentChar(<span class="number">0</span>) || <span class="string">'\"'</span> == getCurrentChar(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描字符串.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 字符串标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanChars</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> scanChars(charAt(offset));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> Token <span class="title">scanChars</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> terminatedChar)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = getLengthUntilTerminatedChar(terminatedChar);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.CHARS, input.substring(offset + <span class="number">1</span>, offset + length - <span class="number">1</span>), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-4-Literals-HEX-十六进制"><a href="#3-2-4-Literals-HEX-十六进制" class="headerlink" title="3.2.4 Literals.HEX 十六进制"></a>3.2.4 Literals.HEX 十六进制</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 十六进制</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanHexDecimal()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHexDecimalBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'0'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; <span class="string">'x'</span> == getCurrentChar(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描十六进制数.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 十六进制数标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanHexDecimal</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = HEX_BEGIN_SYMBOL_LENGTH;</div><div class="line">   <span class="comment">// 负数</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (isHex(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.HEX, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-5-Literals-INT-整数"><a href="#3-2-5-Literals-INT-整数" class="headerlink" title="3.2.5 Literals.INT 整数"></a>3.2.5 Literals.INT 整数</h3><p>整数。例如：<code>SELECT * FROM t_user WHERE id = 1</code>。</p>
<p>Literals.INT 与 Literals.FLOAT 是一起解析的，我们放在 Literals.FLOAT 处一起分析。</p>
<h3 id="3-2-6-Literals-FLOAT-浮点数"><a href="#3-2-6-Literals-FLOAT-浮点数" class="headerlink" title="3.2.6 Literals.FLOAT 浮点数"></a>3.2.6 Literals.FLOAT 浮点数</h3><p>浮点数。例如：<code>SELECT * FROM t_user WHERE id = 1.0</code>。<br>浮点数包含几种：”1.0”，”1.0F”，”7.823E5”（科学计数法）。</p>
<p>解析核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 数字</div><div class="line">* '-' 需要特殊处理。".2" 被处理成省略0的小数，"-.2" 不能被处理成省略的小数，否则会出问题。</div><div class="line">* 例如说，"SELECT a-.2" 处理的结果是 "SELECT" / "a" / "-" / ".2"</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumberBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isDigital(getCurrentChar(<span class="number">0</span>)) <span class="comment">// 数字</span></div><div class="line">           || (<span class="string">'.'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; CharType.isDigital(getCurrentChar(<span class="number">1</span>)) &amp;&amp; !isIdentifierBegin(getCurrentChar(-<span class="number">1</span>)) <span class="comment">// 浮点数</span></div><div class="line">           || (<span class="string">'-'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; (<span class="string">'.'</span> == getCurrentChar(<span class="number">0</span>) || CharType.isDigital(getCurrentChar(<span class="number">1</span>))))); <span class="comment">// 负数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描数字.</div><div class="line">* 解析数字的结果会有两种：整数 和 浮点数.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 数字标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanNumber</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 负数</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 浮点数</span></div><div class="line">   length += getDigitalLength(offset + length);</div><div class="line">   <span class="keyword">boolean</span> isFloat = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="string">'.'</span> == charAt(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">       length += getDigitalLength(offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 科学计数表示，例如：SELECT 7.823E5</span></div><div class="line">   <span class="keyword">if</span> (isScientificNotation(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">       <span class="keyword">if</span> (<span class="string">'+'</span> == charAt(offset + length) || <span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">           length++;</div><div class="line">       &#125;</div><div class="line">       length += getDigitalLength(offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 浮点数，例如：SELECT 1.333F</span></div><div class="line">   <span class="keyword">if</span> (isBinaryNumber(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(isFloat ? Literals.FLOAT : Literals.INT, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要特别注意下：<strong>“-“</strong>。在数字表达实例，可以判定为 负号 和 减号（不考虑科学计数法）。</p>
<ul>
<li>“.2”  解析结果是 “.2”</li>
<li>“-.2” 解析结果不能是 “-.2”，而是 “-“ 和 “.2”。</li>
</ul>
<h2 id="3-3-Symbol-词法符号标记"><a href="#3-3-Symbol-词法符号标记" class="headerlink" title="3.3 Symbol 词法符号标记"></a>3.3 Symbol 词法符号标记</h2><p>词法符号标记。例如：”{“, “}”, “&gt;=” 等等。</p>
<p>解析核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 符号</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanSymbol()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbolBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isSymbol(getCurrentChar(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CharType.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断是否为符号.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> ch 待判断的字符</div><div class="line">* <span class="doctag">@return</span> 是否为符号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'('</span> == ch || <span class="string">')'</span> == ch || <span class="string">'['</span> == ch || <span class="string">']'</span> == ch || <span class="string">'&#123;'</span> == ch || <span class="string">'&#125;'</span> == ch || <span class="string">'+'</span> == ch || <span class="string">'-'</span> == ch || <span class="string">'*'</span> == ch || <span class="string">'/'</span> == ch || <span class="string">'%'</span> == ch || <span class="string">'^'</span> == ch || <span class="string">'='</span> == ch</div><div class="line">           || <span class="string">'&gt;'</span> == ch || <span class="string">'&lt;'</span> == ch || <span class="string">'~'</span> == ch || <span class="string">'!'</span> == ch || <span class="string">'?'</span> == ch || <span class="string">'&amp;'</span> == ch || <span class="string">'|'</span> == ch || <span class="string">'.'</span> == ch || <span class="string">':'</span> == ch || <span class="string">'#'</span> == ch || <span class="string">','</span> == ch || <span class="string">';'</span> == ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描符号.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 符号标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanSymbol</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (CharType.isSymbol(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   String literals = input.substring(offset, offset + length);</div><div class="line">   <span class="comment">// 倒序遍历，查询符合条件的 符号。例如 literals = ";;"，会是拆分成两个 ";"。如果基于正序，literals = "&lt;="，会被解析成 "&lt;" + "="。</span></div><div class="line">   Symbol symbol;</div><div class="line">   <span class="keyword">while</span> (<span class="keyword">null</span> == (symbol = Symbol.literalsOf(literals))) &#123;</div><div class="line">       literals = input.substring(offset, offset + --length);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(symbol, literals, offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-Assist-词法辅助标记"><a href="#3-4-Assist-词法辅助标记" class="headerlink" title="3.4 Assist 词法辅助标记"></a>3.4 Assist 词法辅助标记</h2><p>Assist 词法辅助标记，一共分成 2 种：</p>
<ul>
<li>END ：分析结束</li>
<li>ERROR ：分析错误。</li>
</ul>
<h1 id="4-彩蛋"><a href="#4-彩蛋" class="headerlink" title="4. 彩蛋"></a>4. 彩蛋</h1><p>老铁，是不是比想象中简单一些？！继续加油写 Parser 相关的文章！来一波微信公众号关注吧。</p>
<hr>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。Sharding-JDBC 也会因此，能够覆盖更广的场景。登记吧，少年！</strong></p>
<hr>
<p><strong>我创建了一个微信群【源码圈】，希望和大家分享交流读源码的经验。<br>读源码先难后易，掌握方法后，可以做更有深度的学习。<br>而且掌握方法并不难噢。<br>加群方式：微信公众号发送关键字【qun】。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— SQL ON MongoDB</title>
    <link href="http://www.yunai.me/MyCAT/connect-mongodb/"/>
    <id>http://www.yunai.me/MyCAT/connect-mongodb/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 主流程</a></li>
<li><a href="#">3. 查询操作</a></li>
<li><a href="#">4. 插入操作</a></li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>可能你在看到这个标题会小小的吃惊，MyCAT 能使用 MongoDB 做数据节点。是的，没错，确实可以。<br>吼吼吼，让我们开启这段神奇的“旅途”。</p>
<p>本文主要分成四部分：</p>
<ol>
<li>总体流程，让你有个整体的认识</li>
<li>查询操作</li>
<li>插入操作</li>
<li>彩蛋，😈彩蛋，🙂彩蛋</li>
</ol>
<p>建议你看过这两篇文章（<em>非必须</em>）：</p>
<ol>
<li><a href="http://www.yunai.me/MyCAT/single-db-single-table-insert/?self">《MyCAT 源码分析 —— 【单库单表】插入》</a></li>
<li><a href="http://www.yunai.me/MyCAT/single-db-single-table-select/?self">《MyCAT 源码分析 —— 【单库单表】查询》</a></li>
</ol>
<h1 id="2-主流程"><a href="#2-主流程" class="headerlink" title="2. 主流程"></a>2. 主流程</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/01.png" alt="">   </p>
<ol>
<li><code>MyCAT Server</code> 接收 <code>MySQL Client</code> 基于 <strong>MySQL协议</strong> 的请求，翻译 <strong>SQL</strong> 成 <strong>MongoDB操作</strong> 发送给 <code>MongoDB Server</code>。</li>
<li><code>MyCAT Server</code> 接收 <code>MongoDB Server</code> 返回的 <strong>MongoDB数据</strong>，翻译成 <code>MySQL数据结果</code> 返回给 <code>MySQL Client</code>。</li>
</ol>
<p>这样一看，MyCAT 连接 MongoDB 是不是少神奇一点列。</p>
<hr>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/02.png" alt=""></p>
<blockquote>
<p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。JDBC是面向关系型数据库的。</p>
</blockquote>
<p>MyCAT 使用 JDBC 规范，抽象了对 MongoDB 的访问。通过这样的方式，MyCAT 也抽象了 SequoiaDB 的访问。可能这样说法有些抽象，看个类图压压惊。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/03.png" alt=""></p>
<p>是不是熟悉的味道。<strong>不得不说 JDBC 规范的精妙。</strong></p>
<h1 id="3-查询操作"><a href="#3-查询操作" class="headerlink" title="3. 查询操作"></a>3. 查询操作</h1><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">''</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> _id <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/04.png" alt=""></p>
<p>看顺序图已经很方便的理解整体逻辑，我就不多废话啦。我们来看几个核心的代码逻辑。</p>
<p><strong>1、查询 MongoDB</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> MongoData <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> MongoSQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!(statement <span class="keyword">instanceof</span> SQLSelectStatement)) &#123;</div><div class="line">       <span class="comment">//return null;</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not a query sql statement"</span>);</div><div class="line">   &#125;</div><div class="line">   MongoData mongo = <span class="keyword">new</span> MongoData();</div><div class="line">   DBCursor c = <span class="keyword">null</span>;</div><div class="line">   SQLSelectStatement selectStmt = (SQLSelectStatement) statement;</div><div class="line">   SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();</div><div class="line">   <span class="keyword">int</span> icount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (sqlSelectQuery <span class="keyword">instanceof</span> MySqlSelectQueryBlock) &#123;</div><div class="line">       MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock) selectStmt.getSelect().getQuery();</div><div class="line"></div><div class="line">       BasicDBObject fields = <span class="keyword">new</span> BasicDBObject();</div><div class="line"></div><div class="line">       <span class="comment">// 显示（返回）的字段</span></div><div class="line">       <span class="keyword">for</span> (SQLSelectItem item : mysqlSelectQuery.getSelectList()) &#123;</div><div class="line">           <span class="comment">//System.out.println(item.toString());</span></div><div class="line">           <span class="keyword">if</span> (!(item.getExpr() <span class="keyword">instanceof</span> SQLAllColumnExpr)) &#123;</div><div class="line">               <span class="keyword">if</span> (item.getExpr() <span class="keyword">instanceof</span> SQLAggregateExpr) &#123;</div><div class="line">                   SQLAggregateExpr expr = (SQLAggregateExpr) item.getExpr();</div><div class="line">                   <span class="keyword">if</span> (expr.getMethodName().equals(<span class="string">"COUNT"</span>)) &#123; <span class="comment">// TODO 待读：count（*）</span></div><div class="line">                       icount = <span class="number">1</span>;</div><div class="line">                       mongo.setField(getExprFieldName(expr), Types.BIGINT);</div><div class="line">                   &#125;</div><div class="line">                   fields.put(getExprFieldName(expr), <span class="number">1</span>);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   fields.put(getFieldName(item), <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 表名</span></div><div class="line">       SQLTableSource table = mysqlSelectQuery.getFrom();</div><div class="line">       DBCollection coll = <span class="keyword">this</span>._db.getCollection(table.toString());</div><div class="line">       mongo.setTable(table.toString());</div><div class="line"></div><div class="line">       <span class="comment">// WHERE</span></div><div class="line">       SQLExpr expr = mysqlSelectQuery.getWhere();</div><div class="line">       DBObject query = parserWhere(expr);</div><div class="line"></div><div class="line">       <span class="comment">// GROUP BY</span></div><div class="line">       SQLSelectGroupByClause groupby = mysqlSelectQuery.getGroupBy();</div><div class="line">       BasicDBObject gbkey = <span class="keyword">new</span> BasicDBObject();</div><div class="line">       <span class="keyword">if</span> (groupby != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">for</span> (SQLExpr gbexpr : groupby.getItems()) &#123;</div><div class="line">               <span class="keyword">if</span> (gbexpr <span class="keyword">instanceof</span> SQLIdentifierExpr) &#123;</div><div class="line">                   String name = ((SQLIdentifierExpr) gbexpr).getName();</div><div class="line">                   gbkey.put(name, Integer.valueOf(<span class="number">1</span>));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           icount = <span class="number">2</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// SKIP / LIMIT</span></div><div class="line">       <span class="keyword">int</span> limitoff = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> limitnum = <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (mysqlSelectQuery.getLimit() != <span class="keyword">null</span>) &#123;</div><div class="line">           limitoff = getSQLExprToInt(mysqlSelectQuery.getLimit().getOffset());</div><div class="line">           limitnum = getSQLExprToInt(mysqlSelectQuery.getLimit().getRowCount());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (icount == <span class="number">1</span>) &#123; <span class="comment">// COUNT（*）</span></div><div class="line">           mongo.setCount(coll.count(query));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (icount == <span class="number">2</span>) &#123; <span class="comment">// MapReduce</span></div><div class="line">           BasicDBObject initial = <span class="keyword">new</span> BasicDBObject();</div><div class="line">           initial.put(<span class="string">"num"</span>, <span class="number">0</span>);</div><div class="line">           String reduce = <span class="string">"function (obj, prev) &#123; "</span> + <span class="string">"  prev.num++&#125;"</span>;</div><div class="line">           mongo.setGrouyBy(coll.group(gbkey, query, initial, reduce));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> ((limitoff &gt; <span class="number">0</span>) || (limitnum &gt; <span class="number">0</span>)) &#123;</div><div class="line">               c = coll.find(query, fields).skip(limitoff).limit(limitnum);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               c = coll.find(query, fields);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// order by</span></div><div class="line">           SQLOrderBy orderby = mysqlSelectQuery.getOrderBy();</div><div class="line">           <span class="keyword">if</span> (orderby != <span class="keyword">null</span>) &#123;</div><div class="line">               BasicDBObject order = <span class="keyword">new</span> BasicDBObject();</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderby.getItems().size(); i++) &#123;</div><div class="line">                   SQLSelectOrderByItem orderitem = orderby.getItems().get(i);</div><div class="line">                   order.put(orderitem.getExpr().toString(), getSQLExprToAsc(orderitem.getType()));</div><div class="line">               &#125;</div><div class="line">               c.sort(order);</div><div class="line">               <span class="comment">// System.out.println(order);</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       mongo.setCursor(c);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> mongo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2、查询条件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parserWhere</span><span class="params">(SQLExpr aexpr, BasicDBObject o)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (aexpr <span class="keyword">instanceof</span> SQLBinaryOpExpr) &#123;</div><div class="line">       SQLBinaryOpExpr expr = (SQLBinaryOpExpr) aexpr;</div><div class="line">       SQLExpr exprL = expr.getLeft();</div><div class="line">       <span class="keyword">if</span> (!(exprL <span class="keyword">instanceof</span> SQLBinaryOpExpr)) &#123;</div><div class="line">           <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"="</span>)) &#123;</div><div class="line">               o.put(exprL.toString(), getExpValue(expr.getRight()));</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               String op = <span class="string">""</span>;</div><div class="line">               <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$lt"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$lte"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&gt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$gt"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&gt;="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$gte"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"!="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$ne"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;&gt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$ne"</span>;</div><div class="line">               &#125;</div><div class="line">               parserDBObject(o, exprL.toString(), op, getExpValue(expr.getRight()));</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"AND"</span>)) &#123;</div><div class="line">               parserWhere(exprL, o);</div><div class="line">               parserWhere(expr.getRight(), o);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"OR"</span>)) &#123;</div><div class="line">               orWhere(exprL, expr.getRight(), o);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't identify the operation of  of where"</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orWhere</span><span class="params">(SQLExpr exprL, SQLExpr exprR, BasicDBObject ob)</span> </span>&#123;</div><div class="line">   BasicDBObject xo = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   BasicDBObject yo = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   parserWhere(exprL, xo);</div><div class="line">   parserWhere(exprR, yo);</div><div class="line">   ob.put(<span class="string">"$or"</span>, <span class="keyword">new</span> Object[]&#123;xo, yo&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、解析 MongoDB 数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoResultSet.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MongoResultSet</span><span class="params">(MongoData mongo, String schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>._cursor = mongo.getCursor();</div><div class="line">   <span class="keyword">this</span>._schema = schema;</div><div class="line">   <span class="keyword">this</span>._table = mongo.getTable();</div><div class="line">   <span class="keyword">this</span>.isSum = mongo.getCount() &gt; <span class="number">0</span>;</div><div class="line">   <span class="keyword">this</span>._sum = mongo.getCount();</div><div class="line">   <span class="keyword">this</span>.isGroupBy = mongo.getType();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.isGroupBy) &#123;</div><div class="line">       dblist = mongo.getGrouyBys();</div><div class="line">       <span class="keyword">this</span>.isSum = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>._cursor != <span class="keyword">null</span>) &#123;</div><div class="line">       select = _cursor.getKeysWanted().keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</div><div class="line">       <span class="comment">// 解析 fields</span></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>._cursor.hasNext()) &#123;</div><div class="line">           _cur = _cursor.next();</div><div class="line">           <span class="keyword">if</span> (_cur != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (select.length == <span class="number">0</span>) &#123;</div><div class="line">                   SetFields(_cur.keySet());</div><div class="line">               &#125;</div><div class="line">               _row = <span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 设置 fields 类型</span></div><div class="line">       <span class="keyword">if</span> (select.length == <span class="number">0</span>) &#123;</div><div class="line">           select = <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>&#125;;</div><div class="line">           SetFieldType(<span class="keyword">true</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           SetFieldType(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       SetFields(mongo.getFields().keySet());<span class="comment">//new String[]&#123;"COUNT(*)"&#125;;</span></div><div class="line">       SetFieldType(mongo.getFields());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当使用 <code>SELECT *</code> 查询字段时，fields 使用第一条数据返回的 fields。即使，后面的数据有其他 fields，也不返回。</li>
</ul>
<p><strong>4、返回数据给 MySQL Client</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JDBCConnection.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ouputResultSet</span><span class="params">(ServerConnection sc, String sql)</span></span></div><div class="line">       <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   ResultSet rs = <span class="keyword">null</span>;</div><div class="line">   Statement stmt = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       stmt = con.createStatement();</div><div class="line">       rs = stmt.executeQuery(sql);</div><div class="line"></div><div class="line">       <span class="comment">// header</span></div><div class="line">       List&lt;FieldPacket&gt; fieldPks = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       ResultSetUtil.resultSetToFieldPacket(sc.getCharset(), fieldPks, rs, <span class="keyword">this</span>.isSpark);</div><div class="line">       <span class="keyword">int</span> colunmCount = fieldPks.size();</div><div class="line">       ByteBuffer byteBuf = sc.allocate();</div><div class="line">       ResultSetHeaderPacket headerPkg = <span class="keyword">new</span> ResultSetHeaderPacket();</div><div class="line">       headerPkg.fieldCount = fieldPks.size();</div><div class="line">       headerPkg.packetId = ++packetId;</div><div class="line">       byteBuf = headerPkg.write(byteBuf, sc, <span class="keyword">true</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(header);</div><div class="line">       byteBuf.clear();</div><div class="line">       List&lt;<span class="keyword">byte</span>[]&gt; fields = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(fieldPks.size());</div><div class="line">       <span class="keyword">for</span> (FieldPacket curField : fieldPks) &#123;</div><div class="line">           curField.packetId = ++packetId;</div><div class="line">           byteBuf = curField.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">           byteBuf.flip();</div><div class="line">           <span class="keyword">byte</span>[] field = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">           byteBuf.get(field);</div><div class="line">           byteBuf.clear();</div><div class="line">           fields.add(field);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// header eof</span></div><div class="line">       EOFPacket eofPckg = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eofPckg.packetId = ++packetId;</div><div class="line">       byteBuf = eofPckg.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       <span class="keyword">byte</span>[] eof = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(eof);</div><div class="line">       byteBuf.clear();</div><div class="line">       <span class="keyword">this</span>.respHandler.fieldEofResponse(header, fields, eof, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">       <span class="comment">// row</span></div><div class="line">       <span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">           RowDataPacket curRow = <span class="keyword">new</span> RowDataPacket(colunmCount);</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colunmCount; i++) &#123;</div><div class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">               <span class="keyword">if</span> (MysqlDefs.isBianry((<span class="keyword">byte</span>) fieldPks.get(i).type)) &#123;</div><div class="line">                   curRow.add(rs.getBytes(j));</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldPks.get(i).type == MysqlDefs.FIELD_TYPE_DECIMAL ||</div><div class="line">                       fieldPks.get(i).type == (MysqlDefs.FIELD_TYPE_NEW_DECIMAL - <span class="number">256</span>)) &#123; <span class="comment">// field type is unsigned byte</span></div><div class="line">                   <span class="comment">// ensure that do not use scientific notation format</span></div><div class="line">                   BigDecimal val = rs.getBigDecimal(j);</div><div class="line">                   curRow.add(StringUtil.encode(val != <span class="keyword">null</span> ? val.toPlainString() : <span class="keyword">null</span>, sc.getCharset()));</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   curRow.add(StringUtil.encode(rs.getString(j), sc.getCharset()));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           curRow.packetId = ++packetId;</div><div class="line">           byteBuf = curRow.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">           byteBuf.flip();</div><div class="line">           <span class="keyword">byte</span>[] row = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">           byteBuf.get(row);</div><div class="line">           byteBuf.clear();</div><div class="line">           <span class="keyword">this</span>.respHandler.rowResponse(row, <span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line">       fieldPks.clear();</div><div class="line">       <span class="comment">// row eof</span></div><div class="line">       eofPckg = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eofPckg.packetId = ++packetId;</div><div class="line">       byteBuf = eofPckg.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       eof = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(eof);</div><div class="line">       sc.recycle(byteBuf);</div><div class="line">       <span class="keyword">this</span>.respHandler.rowEofResponse(eof, <span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               rs.close();</div><div class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               stmt.close();</div><div class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MongoResultSet.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Object x = getObject(columnLabel);</div><div class="line">   <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> x.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当返回字段值是 Object 时，返回该对象.toString()。例如：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; select * from user order by _id asc;</div><div class="line">+--------------------------+------+-------------------------------+</div><div class="line">| _id                      | name | profile                       |</div><div class="line">+--------------------------+------+-------------------------------+</div><div class="line">| 1                        | 123  | &#123; "age" : 1 , "height" : 100&#125; |</div></pre></td></tr></table></figure>
<h1 id="4-插入操作"><a href="#4-插入操作" class="headerlink" title="4. 插入操作"></a>4. 插入操作</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/05.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> <span class="keyword">throws</span> MongoSQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLInsertStatement) &#123;</div><div class="line">       <span class="keyword">return</span> InsertData((SQLInsertStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLUpdateStatement) &#123;</div><div class="line">       <span class="keyword">return</span> UpData((SQLUpdateStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLDropTableStatement) &#123;</div><div class="line">       <span class="keyword">return</span> dropTable((SQLDropTableStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLDeleteStatement) &#123;</div><div class="line">       <span class="keyword">return</span> DeleteDate((SQLDeleteStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLCreateTableStatement) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">InsertData</span><span class="params">(SQLInsertStatement state)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (state.getValues().getValues().size() == <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"number of  columns error"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (state.getValues().getValues().size() != state.getColumns().size()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"number of values and columns have to match"</span>);</div><div class="line">   &#125;</div><div class="line">   SQLTableSource table = state.getTableSource();</div><div class="line">   BasicDBObject o = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (SQLExpr col : state.getColumns()) &#123;</div><div class="line">       o.put(getFieldName2(col), getExpValue(state.getValues().getValues().get(i)));</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   DBCollection coll = <span class="keyword">this</span>._db.getCollection(table.toString());</div><div class="line">   coll.insert(o);</div><div class="line">   <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-彩蛋"><a href="#5-彩蛋" class="headerlink" title="5. 彩蛋"></a>5. 彩蛋</h1><p>老铁，看到这里，来一波微信公众号关注吧？！</p>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p>
<p><strong>1、支持多 MongoDB ，并使用 MyCAT 进行分片。</strong></p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/multi_mongodb" rel="external nofollow noopener noreferrer" target="_blank">multi_mongodb</a></p>
<p><strong>2、支持 MongoDB + MySQL 作为同一个 MyCAT Table 的数据节点。查询时，可以合并数据结果。</strong></p>
<p>查询时，返回 MySQL 数据记录字段要比 MongoDB 数据记录字段全，否则，合并结果时会报错。</p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/single_mongodb_mysql" rel="external nofollow noopener noreferrer" target="_blank">single_mongodb_mysql</a></p>
<p><strong>3、MongoDB 作为数据节点时，可以使用 MyCAT 提供的数据库主键字段功能。</strong></p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/single_mongodb" rel="external nofollow noopener noreferrer" target="_blank">single_mongodb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— PreparedStatement 重新入门</title>
    <link href="http://www.yunai.me/MyCAT/what-is-PreparedStatement/"/>
    <id>http://www.yunai.me/MyCAT/what-is-PreparedStatement/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. JDBC Client 实现</a></li>
<li><a href="#">3. MyCAT Server 实现</a><ul>
<li><a href="#">3.1 创建 PreparedStatement</a></li>
<li><a href="#">3.2 执行 SQL</a></li>
</ul>
</li>
<li><a href="#">4. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>相信很多同学在学习 JDBC 时，都碰到 <code>PreparedStatement</code> 和 <code>Statement</code>。究竟该使用哪个呢？最终很可能是<strong>懵里懵懂</strong>的看了各种总结，使用 <code>PreparedStatement</code>。那么本文，通过 MyCAT 对 <code>PreparedStatement</code> 的实现对大家能够重新理解下。</p>
<p>本文主要分成两部分：</p>
<ol>
<li>JDBC Client 如何实现 <code>PreparedStatement</code>。</li>
<li>MyCAT Server 如何处理 <code>PreparedStatement</code>。</li>
</ol>
<p>😈 Let’s Go。</p>
<h1 id="2-JDBC-Client-实现"><a href="#2-JDBC-Client-实现" class="headerlink" title="2. JDBC Client 实现"></a>2. JDBC Client 实现</h1><p>首先，我们来看一段大家最喜欢复制粘贴之一的代码，JDBC PreparedStatement 查询 MySQL 数据库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</div><div class="line">        <span class="comment">// 1. 获得数据库连接</span></div><div class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:8066/dbtest?useServerPrepStmts=true"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// PreparedStatement</span></div><div class="line">        PreparedStatement ps = conn.prepareStatement(<span class="string">"SELECT id, username, password FROM t_user WHERE id = ?"</span>);</div><div class="line">        ps.setLong(<span class="number">1</span>, Math.abs(<span class="keyword">new</span> Random().nextLong()));</div><div class="line"></div><div class="line">        <span class="comment">// execute</span></div><div class="line">        ps.executeQuery();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取 MySQL 连接时，<code>useServerPrepStmts=true</code>  是<strong>非常非常非常重要</strong>的参数。如果不配置，<code>PreparedStatement</code> 实际是个<strong>假</strong>的 <code>PreparedStatement</code>（新版本默认为 FALSE，据说部分老版本默认为 TRUE），未开启服务端级别的 SQL 预编译。</p>
<p>WHY ？来看下 JDBC 里面是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.mysql.jdbc.ConnectionImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (getConnectionMutex()) &#123;</div><div class="line">       checkClosed();</div><div class="line">       </div><div class="line">       PreparedStatement pStmt = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">boolean</span> canServerPrepare = <span class="keyword">true</span>;</div><div class="line">       String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; getEmulateUnsupportedPstmts()) &#123;</div><div class="line">           canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; canServerPrepare) &#123;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getCachePreparedStatements()) &#123; <span class="comment">// 从缓存中获取 pStmt</span></div><div class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>.serverSideStatementCache) &#123;</div><div class="line">                   pStmt = (com.mysql.jdbc.ServerPreparedStatement) <span class="keyword">this</span>.serverSideStatementCache</div><div class="line">                           .remove(makePreparedStatementCacheKey(<span class="keyword">this</span>.database, sql));</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (pStmt != <span class="keyword">null</span>) &#123;</div><div class="line">                       ((com.mysql.jdbc.ServerPreparedStatement) pStmt).setClosed(<span class="keyword">false</span>);</div><div class="line">                       pStmt.clearParameters(); <span class="comment">// 清理上次留下的参数</span></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (pStmt == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// .... 省略代码 ：向 Server 提交 SQL 预编译。</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 向 Server 提交 SQL 预编译。</span></div><div class="line">                   pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, <span class="keyword">this</span>.database, resultSetType, resultSetConcurrency);</div><div class="line"></div><div class="line">                   pStmt.setResultSetType(resultSetType);</div><div class="line">                   pStmt.setResultSetConcurrency(resultSetConcurrency);</div><div class="line">               &#125; <span class="keyword">catch</span> (SQLException sqlEx) &#123;</div><div class="line">                   <span class="comment">// Punt, if necessary</span></div><div class="line">                   <span class="keyword">if</span> (getEmulateUnsupportedPstmts()) &#123;</div><div class="line">                       pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="keyword">throw</span> sqlEx;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> pStmt;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>【前者】当 Client 开启 <code>useServerPreparedStmts</code> 并且 Server 支持 <code>ServerPrepare</code>，<strong>Client 会向 Server 提交 SQL 预编译请求</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; canServerPrepare) &#123;</div><div class="line">    pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, <span class="keyword">this</span>.database, resultSetType, resultSetConcurrency);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>【后者】当 Client 未开启 <code>useServerPreparedStmts</code> 或者 Server 不支持 <code>ServerPrepare</code>，Client 创建 <code>PreparedStatement</code>，<strong><em>不会</em>向 Server 提交 SQL 预编译请求</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p><strong>即使这样，究竟为什么性能会更好呢？</strong></p>
<ul>
<li>【前者】返回的 <code>PreparedStatement</code> 对象类是 <code>JDBC42ServerPreparedStatement.java</code>，后续每次执行 SQL 只需将对应占位符?对应的值提交给 Server即可，减少网络传输和 SQL 解析开销。  </li>
<li>【后者】返回的 <code>PreparedStatement</code> 对象类是 <code>JDBC42PreparedStatement.java</code>，后续每次执行 SQL 需要将<strong>完整</strong>的 SQL 提交给 Server，增加了网络传输和 SQL 解析开销。</li>
</ul>
<p><em>🌚：【前者】性能一定比【后者】好吗？相信你已经有了正确的答案。</em></p>
<h1 id="3-MyCAT-Server-实现"><a href="#3-MyCAT-Server-实现" class="headerlink" title="3. MyCAT Server 实现"></a>3. MyCAT Server 实现</h1><h2 id="3-1-创建-PreparedStatement"><a href="#3-1-创建-PreparedStatement" class="headerlink" title="3.1 创建 PreparedStatement"></a>3.1 创建 PreparedStatement</h2><p>该操作对应 Client <code>conn.prepareStatement(....)</code>。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_17/01.png" alt=""></p>
<p>MyCAT 接收到请求后，创建 <code>PreparedStatement</code>，并返回 <code>statementId</code> 等信息。Client 发起 SQL 执行时，需要将 <code>statementId</code> 带给 MyCAT。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPrepareHandler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(String sql)</span> </span>&#123;</div><div class="line">LOGGER.debug(<span class="string">"use server prepare, sql: "</span> + sql);</div><div class="line"></div><div class="line">   PreparedStatement pstmt = pstmtForSql.get(sql);</div><div class="line">   <span class="keyword">if</span> (pstmt == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存中获取</span></div><div class="line">   	<span class="comment">// 解析获取字段个数和参数个数</span></div><div class="line">   	<span class="keyword">int</span> columnCount = getColumnCount(sql);</div><div class="line">   	<span class="keyword">int</span> paramCount = getParamCount(sql);</div><div class="line">       pstmt = <span class="keyword">new</span> PreparedStatement(++pstmtId, sql, columnCount, paramCount);</div><div class="line">       pstmtForSql.put(pstmt.getStatement(), pstmt);</div><div class="line">       pstmtForId.put(pstmt.getId(), pstmt);</div><div class="line">   &#125;</div><div class="line">   PreparedStmtResponse.response(pstmt, source);</div><div class="line">&#125;</div><div class="line"><span class="comment">// PreparedStmtResponse.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(PreparedStatement pstmt, FrontendConnection c)</span> </span>&#123;</div><div class="line">   <span class="keyword">byte</span> packetId = <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="comment">// write preparedOk packet</span></div><div class="line">   PreparedOkPacket preparedOk = <span class="keyword">new</span> PreparedOkPacket();</div><div class="line">   preparedOk.packetId = ++packetId;</div><div class="line">   preparedOk.statementId = pstmt.getId();</div><div class="line">   preparedOk.columnsNumber = pstmt.getColumnsNumber();</div><div class="line">   preparedOk.parametersNumber = pstmt.getParametersNumber();</div><div class="line">   ByteBuffer buffer = preparedOk.write(c.allocate(), c,<span class="keyword">true</span>);</div><div class="line"></div><div class="line">   <span class="comment">// write parameter field packet</span></div><div class="line">   <span class="keyword">int</span> parametersNumber = preparedOk.parametersNumber;</div><div class="line">   <span class="keyword">if</span> (parametersNumber &gt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parametersNumber; i++) &#123;</div><div class="line">           FieldPacket field = <span class="keyword">new</span> FieldPacket();</div><div class="line">           field.packetId = ++packetId;</div><div class="line">           buffer = field.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       EOFPacket eof = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eof.packetId = ++packetId;</div><div class="line">       buffer = eof.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// write column field packet</span></div><div class="line">   <span class="keyword">int</span> columnsNumber = preparedOk.columnsNumber;</div><div class="line">   <span class="keyword">if</span> (columnsNumber &gt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnsNumber; i++) &#123;</div><div class="line">           FieldPacket field = <span class="keyword">new</span> FieldPacket();</div><div class="line">           field.packetId = ++packetId;</div><div class="line">           buffer = field.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       EOFPacket eof = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eof.packetId = ++packetId;</div><div class="line">       buffer = eof.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// send buffer</span></div><div class="line">   c.write(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>每个连接之间，PreparedStatement 不共享，即不同连接，即使 SQL相同，对应的 PreparedStatement 不同。</strong></p>
<h2 id="3-2-执行-SQL"><a href="#3-2-执行-SQL" class="headerlink" title="3.2 执行 SQL"></a>3.2 执行 SQL</h2><p>该操作对应 Client <code>conn.execute(....)</code>。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_17/02.png" alt=""></p>
<p>MyCAT 接收到请求后，将 PreparedStatement 使用请求的参数格式化成可执行的 SQL 进行执行。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String sql = pstmt.sql.format(request.params);</div><div class="line">execute(sql);</div></pre></td></tr></table></figure>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPrepareHandler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> pstmtId = ByteUtil.readUB4(data, <span class="number">5</span>);</div><div class="line">   PreparedStatement pstmt = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">if</span> ((pstmt = pstmtForId.get(pstmtId)) == <span class="keyword">null</span>) &#123;</div><div class="line">       source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, <span class="string">"Unknown pstmtId when executing."</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 参数读取</span></div><div class="line">       ExecutePacket packet = <span class="keyword">new</span> ExecutePacket(pstmt);</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           packet.read(data, source.getCharset());</div><div class="line">       &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">           source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, e.getMessage());</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       BindValue[] bindValues = packet.values;</div><div class="line">       <span class="comment">// 还原sql中的动态参数为实际参数值</span></div><div class="line">       String sql = prepareStmtBindValue(pstmt, bindValues);</div><div class="line">       <span class="comment">// 执行sql</span></div><div class="line">       source.getSession2().setPrepared(<span class="keyword">true</span>);</div><div class="line">       source.query(sql);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">prepareStmtBindValue</span><span class="params">(PreparedStatement pstmt, BindValue[] bindValues)</span> </span>&#123;</div><div class="line">   String sql = pstmt.getStatement();</div><div class="line">   <span class="keyword">int</span>[] paramTypes = pstmt.getParametersType();</div><div class="line"></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = sql.length(); i &lt; len; i++) &#123;</div><div class="line">       <span class="keyword">char</span> c = sql.charAt(i);</div><div class="line">       <span class="keyword">if</span> (c != <span class="string">'?'</span>) &#123;</div><div class="line">           sb.append(c);</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 处理占位符?</span></div><div class="line">       <span class="keyword">int</span> paramType = paramTypes[idx];</div><div class="line">       BindValue bindValue = bindValues[idx];</div><div class="line">       idx++;</div><div class="line">       <span class="comment">// 处理字段为空的情况</span></div><div class="line">       <span class="keyword">if</span> (bindValue.isNull) &#123;</div><div class="line">           sb.append(<span class="string">"NULL"</span>);</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 非空情况, 根据字段类型获取值</span></div><div class="line">       <span class="keyword">switch</span> (paramType &amp; <span class="number">0xff</span>) &#123;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_TINY:</div><div class="line">               sb.append(String.valueOf(bindValue.byteBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_SHORT:</div><div class="line">               sb.append(String.valueOf(bindValue.shortBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_LONG:</div><div class="line">               sb.append(String.valueOf(bindValue.intBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="comment">// .... 省略非核心代码</span></div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-彩蛋"><a href="#4-彩蛋" class="headerlink" title="4. 彩蛋"></a>4. 彩蛋</h1><p>💯 看到此处是不是真爱？！反正我信了。<br>给老铁们额外加个🍗。</p>
<p>细心的同学们可能已经注意到 JDBC Client 是支持缓存 <code>PreparedStatement</code>，无需每次都让 Server 进行创建。</p>
<p>当配置 MySQL 数据连接 <code>cachePrepStmts=true</code> 时开启 Client 级别的缓存。But，<strong>此处的缓存又和一般的缓存不一样</strong>，是使用 <code>remove</code> 的方式获得的，并且创建好 <code>PreparedStatement</code> 时也不添加到缓存。那什么时候添加缓存呢？在 <code>pstmt.close()</code> 时，并且<strong><code>pstmt</code> 是通过缓存获取时</strong>，添加到缓存。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   MySQLConnection locallyScopedConn = <span class="keyword">this</span>.connection;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (locallyScopedConn == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>; <span class="comment">// already closed</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">synchronized</span> (locallyScopedConn.getConnectionMutex()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.isCached &amp;&amp; isPoolable() &amp;&amp; !<span class="keyword">this</span>.isClosed) &#123;</div><div class="line">           clearParameters();</div><div class="line">           <span class="keyword">this</span>.isClosed = <span class="keyword">true</span>;</div><div class="line">           <span class="keyword">this</span>.connection.recachePreparedStatement(<span class="keyword">this</span>);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       realClose(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ConnectionImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recachePreparedStatement</span><span class="params">(ServerPreparedStatement pstmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (getConnectionMutex()) &#123;</div><div class="line">       <span class="keyword">if</span> (getCachePreparedStatements() &amp;&amp; pstmt.isPoolable()) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.serverSideStatementCache) &#123;</div><div class="line">               <span class="keyword">this</span>.serverSideStatementCache.put(makePreparedStatementCacheKey(pstmt.currentCatalog, pstmt.originalSql), pstmt);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么要这么实现？<code>PreparedStatement</code> 是有状态的变量，我们会去 <code>setXXX(pos, value)</code>，一旦多线程共享，会导致错乱。</p>
<p>🗿 这个“彩蛋”还满意么？<strong>请关注我的公众号：芋艿的后端小屋</strong>。下一篇更新：《MyCAT源码解析 —— MongoDB》，极大可能就在本周噢。</p>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p>
<p>另外推荐一篇文章：<a href="https://www.zybuluo.com/stefanlu/note/254899" rel="external nofollow noopener noreferrer" target="_blank">《JDBC PreparedStatement》</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么阅读 Sharding-JDBC 源码？</title>
    <link href="http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/"/>
    <id>http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-08-04T09:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h2 id="为什么阅读-Sharding-JDBC-源码？"><a href="#为什么阅读-Sharding-JDBC-源码？" class="headerlink" title="为什么阅读 Sharding-JDBC 源码？"></a>为什么阅读 Sharding-JDBC 源码？</h2><ol>
<li>看完大部分的 MyCAT 源码，有惊喜的地方，也有失望的地方，因而想看看 Sharding-JDBC 进行下对比。尽管，Sharding-JDBC 是 Client 端级别，MyCAT 是 Server 级别。</li>
<li>Sharding-JDBC 经历过当当本身业务的考验，从可靠性上来说会更让人有信赖感。</li>
<li>文档更加完善，开发体系更加健全。</li>
<li>Sharding-JDBC 1.5.0.M3 发布。</li>
<li><strong>最大努力送达型</strong>事务支持，想要进一步了解分布式事务的解决方案。Last But Very Importment。</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><p>FROM MyCAT</p>
<p>  <strong>从 MyCAT 阅读计划复制，用于对比。</strong></p>
</li>
<li><p>[x] <del>NIO</del></p>
</li>
<li>[x] <del>分布式事务</del></li>
<li>[x] <del>MyCAT 主从</del></li>
<li>[x] <del>支持prepare预编译指令</del></li>
<li>[x] 自增序列</li>
<li>[x] 单库任意 Join</li>
<li>[x] <del>跨库2表 Join</del></li>
<li>[x] <del>跨库多表 Join</del></li>
<li>[x] SQL 解析</li>
<li>[ ] 读写分离</li>
<li>[x] <del>MySQL 主从</del></li>
<li>[x] <del>自动故障切换</del></li>
<li>[x] <del>Galera Cluster 集群</del></li>
<li>[x] <del>MHA 集群</del></li>
<li>[x] <del>Percona 集群</del></li>
<li>[x] <del>服务降级</del></li>
<li>[x] <del>多租户</del></li>
<li>[x] 路由</li>
<li>[x] <del>MyCAT 集群</del></li>
<li>[x] <del>注解</del></li>
<li>[x] <del>缓存</del></li>
<li>[x] <del>监控</del></li>
<li>[x] <del>Mongodb</del></li>
<li>[ ] 内存管理</li>
<li>[ ] 数据聚合</li>
<li>[ ] 数据排序</li>
<li>[x] 分表</li>
<li>[x] 分库</li>
<li>[x] <del>全局表</del></li>
<li>[x] <del>E/R关系</del></li>
<li>[x] <del>服务降级</del></li>
<li>[x] <del>SQL 注入攻击拦截</del></li>
<li>[x] <del>MySQL 协议</del></li>
<li>[x] <del>PostgreSQL 协议</del></li>
<li><p>[ ] 存储过程</p>
</li>
<li><p>FROM Sharding-JDBC</p>
<p>  <strong>从 官网 介绍获取。</strong></p>
</li>
<li><p>[ ] 分布式事务 ：最大努力送达型事务</p>
</li>
<li>[ ] 分布式事务 ：TCC型事务(TBD)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— XA分布式事务</title>
    <link href="http://www.yunai.me/MyCAT/xa-distributed-transaction/"/>
    <id>http://www.yunai.me/MyCAT/xa-distributed-transaction/</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. XA 概念</a></li>
<li><a href="#">3. MyCAT 代码实现</a><ul>
<li><a href="#">3.1 JDBC Demo 代码</a></li>
<li><a href="#">3.2 MyCAT 开启 XA 事务</a></li>
<li><a href="#">3.3 MyCAT 接收 SQL</a></li>
<li><a href="#">3.4 MySQL 接收 COMMIT</a><ul>
<li><a href="#">3.4.1 单节点事务 or 多节点事务</a></li>
<li><a href="#">3.4.2 协调日志</a></li>
<li><a href="#">3.4.3 MultiNodeCoordinator</a></li>
</ul>
</li>
<li><a href="#">3.5 MyCAT 启动回滚 XA事务</a></li>
</ul>
</li>
<li><a href="#">4. MyCAT 实现缺陷</a><ul>
<li><a href="#">4.1 协调日志写入性能</a></li>
<li><a href="#">4.2 数据节点未全部 PREPARE 就进行 COMMIT</a></li>
<li><a href="#">4.3 MyCAT 启动回滚 PREPARE 的 XA事务</a></li>
<li><a href="#">4.4 单节点事务未记录协调日志</a></li>
<li><a href="#">4.5 XA COMMIT 部分节点挂了重新恢复后，未进一步处理</a></li>
</ul>
</li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>数据库拆分后，业务上会碰到需要分布式事务的场景。MyCAT 基于 XA 实现分布式事务。国内目前另外一款很火的数据库中间件 Sharding-JDBC 准备基于 TCC 实现分布式事务。</p>
<p>本文内容分成三部分：</p>
<ol>
<li>XA 概念简述</li>
<li>MyCAT 代码如何实现 XA</li>
<li>MyCAT 在实现 XA 存在的一些缺陷</li>
</ol>
<h1 id="2-XA-概念"><a href="#2-XA-概念" class="headerlink" title="2. XA 概念"></a>2. XA 概念</h1><p>&gt;<br>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括：  </p>
<ol>
<li>应用程序（ <strong>AP</strong> ）  </li>
<li>事务管理器（ <strong>TM</strong> ）  </li>
<li>资源管理器（ <strong>RM</strong> ）  </li>
<li>通信资源管理器（ <strong>CRM</strong> ）<br>一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ <strong>RM</strong> ）是数据库，常见的通信资源管理器（ <strong>CRM</strong> ）是消息中间件，下图是X/Open DTP模型：</li>
</ol>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/01.png" alt=""></p>
<blockquote>
<p>一般的编程方式是这样的：  </p>
<ol>
<li>配置 <strong>TM</strong> ，通过 <strong>TM</strong> 或者 <strong>RM</strong> 提供的方式，把 <strong>RM</strong> 注册到 <strong>TM</strong>。可以理解为给 <strong>TM</strong> 注册 <strong>RM</strong> 作为数据源。一个 <strong>TM</strong> 可以注册多个 <strong>RM</strong>。  </li>
<li><strong>AP</strong> 从 <strong>TM</strong> 获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）<br><strong>AP</strong> 向 <strong>TM</strong> 发起一个全局事务。这时，<strong>TM</strong> 会通知各个 <strong>RM</strong>。<strong>XID</strong>（全局事务ID）会通知到各个RM。  </li>
<li><strong>AP</strong> 通过 <strong>TM</strong> 中获取的连接，<strong>间接</strong>操作 <strong>RM</strong> 进行业务操作。这时，<strong>TM</strong> 在每次 <strong>AP</strong> 操作时把 <strong>XID</strong>(包括所属分支的信息)传递给 <strong>RM</strong>，<strong>RM</strong> 正是通过这个 <strong>XID</strong> 关联来操作和事务的关系的。  </li>
<li><strong>AP</strong> 结束全局事务时，<strong>TM</strong> 会通知 <strong>RM</strong> 全局事务结束。开始二段提交，也就是prepare - commit的过程。</li>
</ol>
</blockquote>
<hr>
<blockquote>
<p>XA协议指的是TM（事务管理器）和RM（资源管理器）之间的接口。目前主流的关系型数据库产品都是实现了XA接口的。JTA(Java Transaction API)是符合X/Open DTP模型的，事务管理器和资源管理器之间也使用了XA协议。 本质上也是借助两阶段提交协议来实现分布式事务的，下面分别来看看XA事务成功和失败的模型图：</p>
</blockquote>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/02.png" alt="成功"></p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/03.png" alt="失败"></p>
<hr>
<p>😈 看到这里是不是有种黑人问号的感觉？淡定！我们接下来看 MyCAT 代码层面是如何实现 XA 的。另外，有兴趣对概念了解更多的，可以参看如下文章：</p>
<ol>
<li><a href="http://www.infoq.com/cn/articles/xa-transactions-handle" rel="external nofollow noopener noreferrer" target="_blank">《XA事务处理》</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/xa-statements.html" rel="external nofollow noopener noreferrer" target="_blank">《XA Transaction SQL Syntax》</a></li>
<li><a href="http://www.voidcn.com/blog/gao1738/article/p-4554083.html" rel="external nofollow noopener noreferrer" target="_blank">《MySQL XA 事务支持调研》</a></li>
</ol>
<h1 id="3-MyCAT-代码实现"><a href="#3-MyCAT-代码实现" class="headerlink" title="3. MyCAT 代码实现"></a>3. MyCAT 代码实现</h1><ul>
<li>MyCAT ：TM，协调者。</li>
<li>数据节点 ：RM，参与者。</li>
</ul>
<h2 id="3-1-JDBC-Demo-代码"><a href="#3-1-JDBC-Demo-代码" class="headerlink" title="3.1 JDBC Demo 代码"></a>3.1 JDBC Demo 代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCATXAClientDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</div><div class="line">        <span class="comment">// 1. 获得数据库连接</span></div><div class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:8066/dbtest"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</div><div class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 2. 开启 MyCAT XA 事务</span></div><div class="line">        conn.prepareStatement(<span class="string">"set xa=on"</span>).execute();</div><div class="line"></div><div class="line">        <span class="comment">// 3. 插入 SQL</span></div><div class="line">        <span class="comment">// 3.1 SQL1 A库</span></div><div class="line">        <span class="keyword">long</span> uid = Math.abs(<span class="keyword">new</span> Random().nextLong());</div><div class="line">        String username = UUID.randomUUID().toString();</div><div class="line">        String password = UUID.randomUUID().toString();</div><div class="line">        String sql1 = String.format(<span class="string">"insert into t_user(id, username, password) VALUES (%d, '%s', '%s')"</span>,</div><div class="line">                uid, username, password);</div><div class="line">        conn.prepareStatement(sql1).execute();</div><div class="line">        <span class="comment">// 3.2 SQL2 B库</span></div><div class="line">        <span class="keyword">long</span> orderId = Math.abs(<span class="keyword">new</span> Random().nextLong());</div><div class="line">        String nickname = UUID.randomUUID().toString();</div><div class="line">        String sql2 = String.format(<span class="string">"insert into t_order(id, uid, nickname) VALUES(%d, %s, '%s')"</span>, orderId, uid, nickname);</div><div class="line">        conn.prepareStatement(sql2).execute();</div><div class="line"></div><div class="line">        <span class="comment">// 4. 提交 XA 事务</span></div><div class="line">        conn.commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>set xa=on</code> MyCAT 开启 XA 事务。</li>
<li><code>conn.commit</code> 提交 XA 事务。 </li>
</ul>
<h2 id="3-2-MyCAT-开启-XA-事务"><a href="#3-2-MyCAT-开启-XA-事务" class="headerlink" title="3.2 MyCAT 开启 XA 事务"></a>3.2 MyCAT 开启 XA 事务</h2><p>当 MyCAT 接收到 <code>set xa = on</code> 命令时，开启 XA 事务，并生成 XA 事务编号。XA 事务编号生成算法为 UUID。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SetHandler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String stmt, ServerConnection c, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> rs = ServerParseSet.parse(stmt, offset);</div><div class="line">		<span class="keyword">switch</span> (rs &amp; <span class="number">0xff</span>) &#123;</div><div class="line">		<span class="comment">// ... 省略代码</span></div><div class="line">		<span class="keyword">case</span> XA_FLAG_ON: &#123;</div><div class="line">			<span class="keyword">if</span> (c.isAutocommit()) &#123;</div><div class="line">				c.writeErrMessage(ErrorCode.ERR_WRONG_USED, <span class="string">"set xa cmd on can't used in autocommit connection "</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			c.getSession2().setXATXEnabled(<span class="keyword">true</span>);</div><div class="line">			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">case</span> XA_FLAG_OFF: &#123;</div><div class="line">			c.writeErrMessage(ErrorCode.ERR_WRONG_USED,</div><div class="line">					<span class="string">"set xa cmd off not for external use "</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// ... 省略代码</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// NonBlockingSession.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXATXEnabled</span><span class="params">(<span class="keyword">boolean</span> xaTXEnabled)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (xaTXEnabled) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.xaTXID == <span class="keyword">null</span>) &#123;</div><div class="line">           xaTXID = genXATXID(); <span class="comment">// 😈😈😈获得 XA 事务编号</span></div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">this</span>.xaTXID = <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">genXATXID</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> MycatServer.getInstance().getXATXIDGLOBAL();</div><div class="line">&#125;</div><div class="line"><span class="comment">// MycatServer.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getXATXIDGLOBAL</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"'"</span> + getUUID() + <span class="string">"'"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUUID</span><span class="params">()</span> </span>&#123; <span class="comment">// 😈😈😈</span></div><div class="line">   String s = UUID.randomUUID().toString();</div><div class="line">   <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">8</span>) + s.substring(<span class="number">9</span>, <span class="number">13</span>) + s.substring(<span class="number">14</span>, <span class="number">18</span>) + s.substring(<span class="number">19</span>, <span class="number">23</span>) + s.substring(<span class="number">24</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-MyCAT-接收-SQL"><a href="#3-3-MyCAT-接收-SQL" class="headerlink" title="3.3 MyCAT 接收 SQL"></a>3.3 MyCAT 接收 SQL</h2><p>此处 SQL 指的是 <code>insert</code>、<code>update</code>、<code>delete</code> 操作。</p>
<p>当向某个数据节点<strong>第一次</strong>发起 SQL 时，会在 SQL 前面附加 <code>XA START &#39;xaTranId&#39;</code>，并设置该数据节点<strong>连接</strong>事务状态为 <code>TxState.TX_STARTED_STATE</code>（<em>分布式事务状态，下文会专门整理</em>）。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLConnection.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">synAndDoExecute</span><span class="params">(String xaTxID, RouteResultsetNode rrn,</span></span></div><div class="line">                                 <span class="keyword">int</span> clientCharSetIndex, <span class="keyword">int</span> clientTxIsoLation,</div><div class="line">                                 <span class="keyword">boolean</span> clientAutoCommit) &#123;</div><div class="line">   String xaCmd = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">boolean</span> conAutoComit = <span class="keyword">this</span>.autocommit;</div><div class="line">   String conSchema = <span class="keyword">this</span>.schema;</div><div class="line">   <span class="comment">// never executed modify sql,so auto commit</span></div><div class="line">   <span class="keyword">boolean</span> expectAutocommit = !modifiedSQLExecuted || isFromSlaveDB() || clientAutoCommit;</div><div class="line">   <span class="keyword">if</span> (expectAutocommit == <span class="keyword">false</span> &amp;&amp; xaTxID != <span class="keyword">null</span> &amp;&amp; xaStatus == TxState.TX_INITIALIZE_STATE) &#123; <span class="comment">// 😈😈😈</span></div><div class="line">       xaCmd = <span class="string">"XA START "</span> + xaTxID + <span class="string">';'</span>;</div><div class="line">       <span class="keyword">this</span>.xaStatus = TxState.TX_STARTED_STATE;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略代码</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="comment">// .... 省略代码</span></div><div class="line">   <span class="keyword">if</span> (xaCmd != <span class="keyword">null</span>) &#123;</div><div class="line">       sb.append(xaCmd);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// and our query sql to multi command at last</span></div><div class="line">   sb.append(rrn.getStatement() + <span class="string">";"</span>);</div><div class="line">   <span class="comment">// syn and execute others</span></div><div class="line">   <span class="keyword">this</span>.sendQueryCmd(sb.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个 变量<code>sb</code> 的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SET</span> <span class="keyword">names</span> utf8;<span class="keyword">SET</span> autocommit=<span class="number">0</span>;XA <span class="keyword">START</span> <span class="string">'1f2da7353e8846e5833b8d8dd041cfb1'</span>,<span class="string">'db2'</span>;<span class="keyword">insert</span> <span class="keyword">into</span> t_user(<span class="keyword">id</span>, username, <span class="keyword">password</span>) <span class="keyword">VALUES</span> (<span class="number">3400</span>, <span class="string">'b7c5ec1f-11cc-4599-851c-06ad617fec42'</span>, <span class="string">'d2694679-f6a2-4623-a339-48d4a868be90'</span>);</div></pre></td></tr></table></figure>
<h2 id="3-4-MySQL-接收-COMMIT"><a href="#3-4-MySQL-接收-COMMIT" class="headerlink" title="3.4 MySQL 接收 COMMIT"></a>3.4 MySQL 接收 COMMIT</h2><h3 id="3-4-1-单节点事务-or-多节点事务"><a href="#3-4-1-单节点事务-or-多节点事务" class="headerlink" title="3.4.1 单节点事务 or 多节点事务"></a>3.4.1 单节点事务 or 多节点事务</h3><p><code>COMMIT</code> 执行时，MyCAT 会判断 XA 事务里，涉及到的数据库节点数量。</p>
<ul>
<li>如果节点数量为 1，单节点事务，使用 <code>CommitNodeHandler</code> 处理。</li>
<li>如果节点数量 &gt; 1，多节点事务，使用 <code>MultiNodeCoordinator</code> 处理。</li>
</ul>
<p><code>CommitNodeHandler</code> 相比 <code>MultiNodeCoordinator</code> 来说，只有一个数据节点，不需要进行多节点协调，逻辑会相对简单，有兴趣的同学可以另外看。我们主要分析 <code>MultiNodeCoordinator</code>。</p>
<h3 id="3-4-2-协调日志"><a href="#3-4-2-协调日志" class="headerlink" title="3.4.2 协调日志"></a>3.4.2 协调日志</h3><p><strong>协调日志</strong>，记录协调过程中各数据节点 XA 事务状态，处理<strong>MyCAT异常奔溃</strong>或者<strong>数据节点部分XA COMMIT，另外部分 XA PREPARE</strong>下的状态恢复。</p>
<p><strong>XA 事务共有种</strong>：</p>
<ol>
<li>TX_INITIALIZE_STATE ：事务初始化</li>
<li>TX_STARTED_STATE ：事务开始完成</li>
<li>TX_PREPARED_STATE ：事务准备完成</li>
<li>TX_COMMITED_STATE ：事务提交完成</li>
<li>TX_ROLLBACKED_STATE ：事务回滚完成</li>
</ol>
<p><strong>状态变更流</strong> ：TX_INITIALIZE_STATE =&gt; TX_STARTED_STATE =&gt; TX_PREPARED_STATE =&gt; TX_COMMITED_STATE / TX_ROLLBACKED_STATE 。</p>
<p><strong>协调日志包含两个部分</strong>：</p>
<ol>
<li>CoordinatorLogEntry ：协调者日志</li>
<li>ParticipantLogEntry ：参与者日志。<strong>此处，数据节点扮演参与者的角色。下文中，可能会出现参与者与数据节点混用的情况，望见谅。</strong></li>
</ol>
<p><em>一次 XA 事务，对应一条 <code>CoordinatorLogEntry</code>。一条<code>CoordinatorLogEntry</code> 包含 N条<code>ParticipantLogEntry</code></em>。 核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CoordinatorLogEntry ：协调者日志</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLogEntry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务编号</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参与者日志数组</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ParticipantLogEntry[] participants;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ParticipantLogEntry ：参与者日志</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipantLogEntry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务编号</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String coordinatorId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据库 uri</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String uri;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 过期描述</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> expires;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务状态</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> txState;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参与者名字</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String resourceName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>MyCAT 记录协调日志以 JSON格式 到文件</strong>。<strong>每行</strong>包含一条<code>CoordinatorLogEntry</code>。举个例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;<span class="attr">"id"</span>:<span class="string">"'e827b3fe666c4d968961350d19adda31'"</span>,<span class="attr">"participants"</span>:[&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db3"</span>&#125;,&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db1"</span>&#125;]&#125;</div><div class="line">&#123;<span class="attr">"id"</span>:<span class="string">"'f00b61fa17cb4ec5b8264a6d82f847d0'"</span>,<span class="attr">"participants"</span>:[&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db2"</span>&#125;,&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db1"</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<p>实现类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// XA 协调者日志 存储接口：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/Repository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Repository</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// XA 协调者日志 文件存储：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/impl/FileSystemRepository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// XA 协调者日志 文件存储：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/impl/InMemoryRepository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>目前日志文件写入的方式性能较差，这里我们不做分析，在【4. MyCAT 实现缺陷】里一起讲。</p>
<h3 id="3-4-3-MultiNodeCoordinator"><a href="#3-4-3-MultiNodeCoordinator" class="headerlink" title="3.4.3 MultiNodeCoordinator"></a>3.4.3 MultiNodeCoordinator</h3><p>敲敲敲，这里是本文的重点之一噢。😈</p>
<p><strong>第一阶段：发起 PREPARE。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeBatchNodeCmd</span><span class="params">(SQLCtrlCommand cmdHandler)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.cmdHandler = cmdHandler;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> initCount = session.getTargetCount();</div><div class="line">   runningCount.set(initCount);</div><div class="line">   nodeCount = initCount;</div><div class="line">   failed.set(<span class="keyword">false</span>);</div><div class="line">   faileCount.set(<span class="number">0</span>);</div><div class="line">   <span class="comment">//recovery nodes log</span></div><div class="line">   ParticipantLogEntry[] participantLogEntry = <span class="keyword">new</span> ParticipantLogEntry[initCount];</div><div class="line">   <span class="comment">// 执行</span></div><div class="line">   <span class="keyword">int</span> started = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (RouteResultsetNode rrn : session.getTargetKeys()) &#123;</div><div class="line">       <span class="keyword">if</span> (rrn == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">final</span> BackendConnection conn = session.getTarget(rrn);</div><div class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</div><div class="line">           conn.setResponseHandler(<span class="keyword">this</span>);</div><div class="line">           <span class="comment">//process the XA_END XA_PREPARE Command</span></div><div class="line">           MySQLConnection mysqlCon = (MySQLConnection) conn;</div><div class="line">           String xaTxId = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">               xaTxId = session.getXaTXID() + <span class="string">",'"</span> + mysqlCon.getSchema() + <span class="string">"'"</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (mysqlCon.getXaStatus() == TxState.TX_STARTED_STATE) &#123; <span class="comment">// XA 事务</span></div><div class="line">               <span class="comment">//recovery Log</span></div><div class="line">               participantLogEntry[started] = <span class="keyword">new</span> ParticipantLogEntry(xaTxId, conn.getHost(), <span class="number">0</span>, conn.getSchema(), ((MySQLConnection) conn).getXaStatus());</div><div class="line">               String[] cmds = <span class="keyword">new</span> String[]&#123;<span class="string">"XA END "</span> + xaTxId, <span class="comment">// XA END 命令</span></div><div class="line">                       <span class="string">"XA PREPARE "</span> + xaTxId&#125;; <span class="comment">// XA PREPARE 命令</span></div><div class="line">               mysqlCon.execBatchCmd(cmds);</div><div class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非 XA 事务</span></div><div class="line">               <span class="comment">// recovery Log</span></div><div class="line">               participantLogEntry[started] = <span class="keyword">new</span> ParticipantLogEntry(xaTxId, conn.getHost(), <span class="number">0</span>, conn.getSchema(), ((MySQLConnection) conn).getXaStatus());</div><div class="line">               cmdHandler.sendCommand(session, conn);</div><div class="line">           &#125;</div><div class="line">           ++started;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// xa recovery log</span></div><div class="line">   <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">       CoordinatorLogEntry coordinatorLogEntry = <span class="keyword">new</span> CoordinatorLogEntry(session.getXaTXID(), <span class="keyword">false</span>, participantLogEntry);</div><div class="line">       inMemoryRepository.put(session.getXaTXID(), coordinatorLogEntry);</div><div class="line">       fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (started &lt; nodeCount) &#123; <span class="comment">// TODO 疑问：如何触发</span></div><div class="line">       runningCount.set(started);</div><div class="line">       LOGGER.warn(<span class="string">"some connection failed to execute "</span> + (nodeCount - started));</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * assumption: only caused by front-end connection close. &lt;br/&gt;</div><div class="line">        * Otherwise, packet must be returned to front-end</div><div class="line">        */</div><div class="line">       failed.set(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>向各数据节点发送 <code>XA END</code> + <code>XA PREPARE</code> 指令。举个 变量<code>cmds</code> 例子：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">XA <span class="keyword">END</span> <span class="string">'4cbb18214d0b47adbdb0658598666677'</span>,<span class="string">'db3'</span>;XA <span class="keyword">PREPARE</span> <span class="string">'4cbb18214d0b47adbdb0658598666677'</span>,<span class="string">'db3'</span>;</div></pre></td></tr></table></figure>
<ul>
<li>记录协调日志。每条参与者日志状态为 <code>TxState.TX_STARTED_STATE</code>。</li>
</ul>
<hr>
<p><strong>第二阶段：发起 COMMIT。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">okResponse</span><span class="params">(<span class="keyword">byte</span>[] ok, BackendConnection conn)</span> </span>&#123;</div><div class="line">   <span class="comment">// process the XA Transatcion 2pc commit</span></div><div class="line">   <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> MySQLConnection) &#123;</div><div class="line">       MySQLConnection mysqlCon = (MySQLConnection) conn;</div><div class="line">       <span class="keyword">switch</span> (mysqlCon.getXaStatus()) &#123;</div><div class="line">           <span class="keyword">case</span> TxState.TX_STARTED_STATE:</div><div class="line">               <span class="comment">//if there have many SQL execute wait the okResponse,will come to here one by one</span></div><div class="line">               <span class="comment">//should be wait all nodes ready ,then send xa commit to all nodes.</span></div><div class="line">               <span class="keyword">if</span> (mysqlCon.batchCmdFinished()) &#123;</div><div class="line">                   String xaTxId = session.getXaTXID();</div><div class="line">                   String cmd = <span class="string">"XA COMMIT "</span> + xaTxId + <span class="string">",'"</span> + mysqlCon.getSchema() + <span class="string">"'"</span>;</div><div class="line">                   <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class="line">                       LOGGER.debug(<span class="string">"Start execute the cmd :"</span> + cmd + <span class="string">",current host:"</span> + mysqlCon.getHost() + <span class="string">":"</span> + mysqlCon.getPort());</div><div class="line">                   &#125;</div><div class="line">                   <span class="comment">// recovery log</span></div><div class="line">                   CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);</div><div class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntry.participants.length; i++) &#123;</div><div class="line">                       LOGGER.debug(<span class="string">"[In Memory CoordinatorLogEntry]"</span> + coordinatorLogEntry.participants[i]);</div><div class="line">                       <span class="keyword">if</span> (coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())) &#123;</div><div class="line">                           coordinatorLogEntry.participants[i].txState = TxState.TX_PREPARED_STATE;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   inMemoryRepository.put(xaTxId, coordinatorLogEntry);</div><div class="line">                   fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">                   <span class="comment">// send commit</span></div><div class="line">                   mysqlCon.setXaStatus(TxState.TX_PREPARED_STATE);</div><div class="line">                   mysqlCon.execCmd(cmd);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           <span class="keyword">case</span> TxState.TX_PREPARED_STATE: &#123;</div><div class="line">               <span class="comment">// recovery log</span></div><div class="line">               String xaTxId = session.getXaTXID();</div><div class="line">               CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntry.participants.length; i++) &#123;</div><div class="line">                   <span class="keyword">if</span> (coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())) &#123;</div><div class="line">                       coordinatorLogEntry.participants[i].txState = TxState.TX_COMMITED_STATE;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               inMemoryRepository.put(xaTxId, coordinatorLogEntry);</div><div class="line">               fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">               <span class="comment">// XA reset status now</span></div><div class="line">               mysqlCon.setXaStatus(TxState.TX_INITIALIZE_STATE);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 释放连接</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cmdHandler.relaseConOnOK()) &#123;</div><div class="line">       session.releaseConnection(conn);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 是否所有节点都完成commit，如果是，则返回Client 成功</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.finished()) &#123;</div><div class="line">       cmdHandler.okResponse(session, ok);</div><div class="line">       <span class="keyword">if</span> (cmdHandler.isAutoClearSessionCons()) &#123;</div><div class="line">           session.clearResources(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">/* 1.  事务提交后,xa 事务结束   */</span></div><div class="line">       <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">           session.setXATXEnabled(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">/* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */</span></div><div class="line">       <span class="keyword">if</span> (session.getSource().isPreAcStates()) &#123;</div><div class="line">           session.getSource().setAutocommit(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>mysqlCon.batchCmdFinished()</code> 每个数据节点，第一次返回的是 <code>XA END</code> 成功，第二次返回的是 <code>XA PREPARE</code>。在 <code>XA PREPARE</code> 成功后，记录该数据节点的<strong>参与者日志</strong>状态为 <code>TxState.TX_PREPARED_STATE</code>。之后，向该数据节点发起 <code>XA COMMIT</code> 命令。</li>
<li><code>XA COMMIT</code> 返回成功后，记录该数据节点的<strong>事务参与者日志</strong>状态为 <code>TxState.TX_COMMITED_STATE</code>。</li>
<li>当所有数据节点（参与者）都执行完成 <code>XA COMMIT</code> 返回，即 <code>this.finished() == true</code>，返回 MySQL Client XA 事务提交成功。</li>
</ul>
<p>[x] <code>XA PREPARE</code> 和 <code>XA COMMIT</code>，数据节点可能返回失败，目前暂时没模拟出来，对应方法为 <code>#errorResponse(....)</code>。 </p>
<h2 id="3-5-MyCAT-启动回滚-XA事务"><a href="#3-5-MyCAT-启动回滚-XA事务" class="headerlink" title="3.5 MyCAT 启动回滚 XA事务"></a>3.5 MyCAT 启动回滚 XA事务</h2><p>MyCAT 启动时，会<strong>回滚处于TxState.TX_PREPARED_STATE</strong>的 <code>ParticipantLogEntry</code> 对应的数据节点的 XA 事务。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MycatServer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performXARecoveryLog</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// fetch the recovery log</span></div><div class="line">   CoordinatorLogEntry[] coordinatorLogEntries = getCoordinatorLogEntries();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntries.length; i++) &#123;</div><div class="line">       CoordinatorLogEntry coordinatorLogEntry = coordinatorLogEntries[i];</div><div class="line">       <span class="keyword">boolean</span> needRollback = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coordinatorLogEntry.participants.length; j++) &#123;</div><div class="line">           ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];</div><div class="line">           <span class="keyword">if</span> (participantLogEntry.txState == TxState.TX_PREPARED_STATE) &#123;</div><div class="line">               needRollback = <span class="keyword">true</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (needRollback) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coordinatorLogEntry.participants.length; j++) &#123;</div><div class="line">               ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];</div><div class="line">               <span class="comment">//XA rollback</span></div><div class="line">               String xacmd = <span class="string">"XA ROLLBACK "</span> + coordinatorLogEntry.id + <span class="string">';'</span>;</div><div class="line">               OneRawSQLQueryResultHandler resultHandler = <span class="keyword">new</span> OneRawSQLQueryResultHandler(<span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> XARollbackCallback());</div><div class="line">               outloop:</div><div class="line">               <span class="keyword">for</span> (SchemaConfig schema : MycatServer.getInstance().getConfig().getSchemas().values()) &#123;</div><div class="line">                   <span class="keyword">for</span> (TableConfig table : schema.getTables().values()) &#123;</div><div class="line">                       <span class="keyword">for</span> (String dataNode : table.getDataNodes()) &#123;</div><div class="line">                           PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);</div><div class="line">                           <span class="keyword">if</span> (dn.getDbPool().getSource().getConfig().getIp().equals(participantLogEntry.uri)</div><div class="line">                                   &amp;&amp; dn.getDatabase().equals(participantLogEntry.resourceName)) &#123;</div><div class="line">                               <span class="comment">//XA STATE ROLLBACK</span></div><div class="line">                               participantLogEntry.txState = TxState.TX_ROLLBACKED_STATE;</div><div class="line">                               SQLJob sqlJob = <span class="keyword">new</span> SQLJob(xacmd, dn.getDatabase(), resultHandler, dn.getDbPool().getSource());</div><div class="line">                               sqlJob.run();</div><div class="line">                               <span class="keyword">break</span> outloop;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// init into in memory cached</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntries.length; i++) &#123;</div><div class="line">  MultiNodeCoordinator.inMemoryRepository.put(coordinatorLogEntries[i].id, coordinatorLogEntries[i]);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// discard the recovery log</span></div><div class="line">    MultiNodeCoordinator.fileRepository.writeCheckpoint(MultiNodeCoordinator.inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-MyCAT-实现缺陷"><a href="#4-MyCAT-实现缺陷" class="headerlink" title="4. MyCAT 实现缺陷"></a>4. MyCAT 实现缺陷</h1><p>MyCAT 1.6.5 版本实现弱XA事务，相对来说，笔者认为距离实际生产使用存在一些差距。下面罗列可能存在的缺陷，如有错误，麻烦指出。🙂希望 MyCAT 在分布式事务的实现上，能够越来越给力。</p>
<h2 id="4-1-协调日志写入性能"><a href="#4-1-协调日志写入性能" class="headerlink" title="4.1 协调日志写入性能"></a>4.1 协调日志写入性能</h2><p>1、<code>CoordinatorLogEntry</code>、<code>ParticipantLogEntry</code> 在每次写入文件时，是将内存中所有的日志<strong>全部重新</strong>写入，导致写入性能随着 XA 事务次数的增加，性能会越来越糟糕，导致 XA 事务整体性能会非常差。另外，该方法是<strong>同步</strong>的，也加大了写入的延迟。</p>
<p>建议：先获得可写入文件的 OFFSET，写入协调日志到文件，内存维护好 XA事务编号 与 OFFSET 的映射关系，从而实现<strong>顺序写入</strong> + <strong>并行写入</strong>。</p>
<p>2、内存里维护了所有的协调日志，占用内存会越来越大，并且无释放机制。即使重启，协调日志也会重新加载到内存。</p>
<p>建议：已完全回滚或者提交的协调日志不放入内存。另外有文件存储好 XA事务编号 与 OFFSET 的映射关系。</p>
<p>3、协调日志只写入单个文件。</p>
<p>建议：分拆协调日志文件。</p>
<p>PS：有兴趣的同学可以看下 <code>RocketMQ</code> 对 <code>CommitLog</code> 的存储，性能上很赞！</p>
<h2 id="4-2-数据节点未全部-PREPARE-就进行-COMMIT"><a href="#4-2-数据节点未全部-PREPARE-就进行-COMMIT" class="headerlink" title="4.2 数据节点未全部 PREPARE 就进行 COMMIT"></a>4.2 数据节点未全部 PREPARE 就进行 COMMIT</h2><p>XA 事务定义，需要等待所有参与者<strong>全部</strong> <code>XA PREPARE</code> 成功完成后发起 <code>XA COMMIT</code>。目前 MyCAT 是某个数据节点 <code>XA PREPARE</code> 完成后<strong>立即</strong>进行 <code>XA COMMIT</code>。比如说：第一个数据节点提交了 <code>XA END;XA PREPARE</code> 时，第二个数据节在进行 <code>XA END;XA PREAPRE;</code> 前挂了，第一个节点依然会 <code>XA COMMIT</code> 成功。</p>
<p>建议：按照严格的 XA 事务定义。</p>
<h2 id="4-3-MyCAT-启动回滚-PREPARE-的-XA事务"><a href="#4-3-MyCAT-启动回滚-PREPARE-的-XA事务" class="headerlink" title="4.3 MyCAT 启动回滚 PREPARE 的 XA事务"></a>4.3 MyCAT 启动回滚 PREPARE 的 XA事务</h2><p>1、MyCAT 启动时，回滚所有的 <code>PREPARE</code> 的 XA 事务，可能某个 XA 事务，部分 <code>COMMIT</code>，部分 <code>PREPARE</code>。此时直接回滚，会导致数据不一致。</p>
<p>建议：当判断到某个 XA 事务存在 <code>PREPARE</code> 的参与者，<strong>同时判断该 XA 事务里其他参与者的事务状态</strong>以及<strong>数据节点里 XA 事务状态</strong>，比如参与者为 <code>MySQL</code>时，可以使用 <code>XA RECOVER</code> 查询处于 <code>PREPARE</code> 所有的 XA 事务。</p>
<p>2、回滚 <code>PREPARE</code> 是异步进行的，在未进行完成时已经设置文件里回滚成功。如果异步过程中失败，会导致 XA 事务状态不一致。</p>
<p>建议：回调成功后，更新该 XA 事务状态。</p>
<h2 id="4-4-单节点事务未记录协调日志"><a href="#4-4-单节点事务未记录协调日志" class="headerlink" title="4.4 单节点事务未记录协调日志"></a>4.4 单节点事务未记录协调日志</h2><p>该情况较为极端。发起 <code>XA PREPARE</code>完后，MyCAT 挂了。重启后，该 XA 事务在 MyCAT 里就“消失“了，参与者的该 XA 事务一直处于 <code>PREPARE</code> 状态。从理论上来说，需要回滚该 XA 事务。</p>
<p>建议：记录协调日志。</p>
<h2 id="4-5-XA-COMMIT-部分节点挂了重新恢复后，未进一步处理"><a href="#4-5-XA-COMMIT-部分节点挂了重新恢复后，未进一步处理" class="headerlink" title="4.5 XA COMMIT 部分节点挂了重新恢复后，未进一步处理"></a>4.5 XA COMMIT 部分节点挂了重新恢复后，未进一步处理</h2><p>当一部分节点 <code>XA COMMIT</code> 完成，另外一部分此时挂了。在管理员重启挂掉的节点，其对应的 XA 事务未进一步处理，导致数据不一致。</p>
<p>建议：😈木有建议。也很好奇，如果是这样的情况，如何处理较为合适。如有大大知道，烦请告知下。</p>
<h1 id="5-彩蛋"><a href="#5-彩蛋" class="headerlink" title="5. 彩蛋"></a>5. 彩蛋</h1><p>例行“彩蛋”？</p>
<ul>
<li><a href="http://blog.csdn.net/d6619309/article/details/52330334" rel="external nofollow noopener noreferrer" target="_blank">《Mycat源码篇 : MyCat事务管理机制分析》</a> 来自 MyCAT Committer 的文章</li>
<li><a href="http://mysql.taobao.org/monthly/2015/04/05/" rel="external nofollow noopener noreferrer" target="_blank">《MySQL · 捉虫动态 · 连接断开导致XA事务丢失》</a></li>
<li><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" rel="external nofollow noopener noreferrer" target="_blank">《分布式系统事务一致性解决方案》</a></li>
<li><a href="http://blog.csdn.net/fly2749/article/details/44998203" rel="external nofollow noopener noreferrer" target="_blank">《MySQL数据库分布式事务XA优缺点与改进方案》</a></li>
<li><a href="http://www.hollischuang.com/archives/1580" rel="external nofollow noopener noreferrer" target="_blank">《深入理解分布式系统的2PC和3PC》</a></li>
<li><a href="https://github.com/YunaiV/yunaiv.github.io/blob/master/source/_drafts/MyCAT/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.xmind" rel="external nofollow noopener noreferrer" target="_blank">【分布式事务.xmind】</a> 笔者拙作 </li>
<li><a href="http://www.yunai.me/RocketMQ/message-transaction/?self">《RocketMQ 源码分析 —— 事务消息》</a> 笔者拙作</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— 跨库两表Join</title>
    <link href="http://www.yunai.me/MyCAT/two-table-share-join/"/>
    <id>http://www.yunai.me/MyCAT/two-table-share-join/</id>
    <published>2017-07-11T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 主流程</a></li>
<li><a href="#">3. ShareJoin</a><ul>
<li><a href="#">3.1 JoinParser</a></li>
<li><a href="#">3.2 ShareJoin.processSQL(…)</a></li>
<li><a href="#">3.3 BatchSQLJob</a></li>
<li><a href="#">3.4 ShareDBJoinHandler</a></li>
<li><a href="#">3.5 ShareRowOutPutDataHandler</a></li>
</ul>
</li>
<li><a href="#">4. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>MyCAT 支持跨库表 Join，目前版本仅支持跨库<strong>两</strong>表 Join。虽然如此，已经能够满足我们大部分的业务场景。况且，Join 过多的表可能带来的性能问题也是很麻烦的。</p>
<p>本文主要分享：</p>
<ol>
<li>整体流程、调用顺序图</li>
<li>核心代码的分析</li>
</ol>
<p>前置阅读：<a href="http://www.yunai.me/MyCAT/single-db-single-table-select/?yunai">《MyCAT 源码分析 —— 【单库单表】查询》</a>。</p>
<p>OK，Let’s Go。</p>
<h1 id="2-主流程"><a href="#2-主流程" class="headerlink" title="2. 主流程"></a>2. 主流程</h1><p>当执行跨库两表 Join SQL 时，经历的大体流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/01.png" alt=""></p>
<p>SQL 上，需要添加注解 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ ${SQL}</code> 。<code>RouteService#route(...)</code> 解析注解 <code>mycat:catlet</code> 后，路由给 <code>HintCatletHandler</code> 作进一步处理。</p>
<p><code>HintCatletHandler</code> 获取注解对应的 <code>Catlet</code> 实现类，<code>io.mycat.catlets.ShareJoin</code> 就是其中一种实现（目前也只有这一种实现），提供了跨库两表 Join 的功能。从类命名上看，<code>ShareJoin</code> 很大可能性后续会提供<strong>完整</strong>的跨库多表的 Join 功能。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HintCatletHandler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> RouteResultset <span class="title">route</span><span class="params">(SystemConfig sysConfig, SchemaConfig schema,</span></span></div><div class="line">                           <span class="keyword">int</span> sqlType, String realSQL, String charset, ServerConnection sc,</div><div class="line">                           LayerCachePool cachePool, String hintSQLValue, <span class="keyword">int</span> hintSqlType, Map hintMap)</div><div class="line">       <span class="keyword">throws</span> SQLNonTransientException &#123;</div><div class="line">   String cateletClass = hintSQLValue;</div><div class="line">   <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class="line">       LOGGER.debug(<span class="string">"load catelet class:"</span> + hintSQLValue + <span class="string">" to run sql "</span> + realSQL);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Catlet catlet = (Catlet) MycatServer.getInstance().getCatletClassLoader().getInstanceofClass(cateletClass);</div><div class="line">       catlet.route(sysConfig, schema, sqlType, realSQL, charset, sc, cachePool);</div><div class="line">       catlet.processSQL(realSQL, <span class="keyword">new</span> EngineCtx(sc.getSession2()));</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       LOGGER.warn(<span class="string">"catlet error "</span> + e);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLNonTransientException(e);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-ShareJoin"><a href="#3-ShareJoin" class="headerlink" title="3. ShareJoin"></a>3. ShareJoin</h1><p>目前支持跨库<strong>两</strong>表 Join。<code>ShareJoin</code> 将 SQL 拆分成左表 SQL 和 右表 SQL，发送给各数据节点执行，汇总数据结果进行合后返回。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SELECT u.id, o.id FROM t_order o </span></div><div class="line"><span class="comment">// INNER JOIN t_user u ON o.uid = u.id</span></div><div class="line"><span class="comment">// 【顺序】查询左表</span></div><div class="line">String leftSQL = <span class="string">"SELECT o.id, u.id FROM t_order o"</span>;</div><div class="line">List leftList = dn[<span class="number">0</span>].select(leftSQL) + dn[<span class="number">1</span>].select(leftSQL) + ... + dn[n].select(leftsql);</div><div class="line"><span class="comment">// 【并行】查询右表</span></div><div class="line">String rightSQL = <span class="string">"SELECT u.id FROM t_user u WHERE u.id IN ($&#123;leftList.uid&#125;)"</span>;</div><div class="line"><span class="keyword">for</span> (dn : dns) &#123; <span class="comment">// 此处是并行执行，使用回调逻辑</span></div><div class="line">    <span class="keyword">for</span> (rightRecord : dn.select(rightSQL)) &#123; <span class="comment">// 查询右表</span></div><div class="line">        <span class="comment">// 合并结果</span></div><div class="line">        <span class="keyword">for</span> (leftRecord : leftList) &#123;</div><div class="line">            <span class="keyword">if</span> (leftRecord.uid == rightRecord.id) &#123;</div><div class="line">                write(leftRecord + leftRecord.uid 拼接结果);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际情况会更加复杂，我们接下来一点点往下看。</p>
<h2 id="3-1-JoinParser"><a href="#3-1-JoinParser" class="headerlink" title="3.1 JoinParser"></a>3.1 JoinParser</h2><p><code>JoinParser</code> 负责对 SQL 进行解析。整体流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/02.png" alt=""></p>
<p>举个例子，<code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 解析后，<code>TableFilter</code> 结果如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/03.png" alt=""></p>
<ul>
<li>tName ：表名</li>
<li>tAlia ：表自定义命名</li>
<li>where ：过滤条件</li>
<li>order ：排序条件</li>
<li>parenTable ：左连接的 Join 的表名。<code>t_user</code>表 在 <code>join</code>属性 的 <code>parenTable</code> 为 “o”，即 <code>t_order</code>。</li>
<li>joinParentkey ：左连接的 Join 字段</li>
<li>joinKey ：join 字段。<code>t_user</code>表 在 <code>join</code>属性 为 <code>id</code>。</li>
<li>join ：子 tableFilter。即，该表连接的右边的表。</li>
<li>parent ：和 <code>join</code>属性 相对。</li>
</ul>
<p>看到此处，大家可能有疑问，为什么要把 SQL 解析成 <code>TableFilter</code>。<code>JoinParser</code> 根据 <code>TableFilter</code> 生成数据节点执行 SQL。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableFilter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSQL</span><span class="params">()</span> </span>&#123;</div><div class="line">   String sql = <span class="string">""</span>;</div><div class="line">   <span class="comment">// fields</span></div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : fieldAliasMap.entrySet()) &#123;</div><div class="line">       String key = entry.getKey();</div><div class="line">       String val = entry.getValue();</div><div class="line">       <span class="keyword">if</span> (val == <span class="keyword">null</span>) &#123;</div><div class="line">           sql = unionsql(sql, getFieldfrom(key), <span class="string">","</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           sql = unionsql(sql, getFieldfrom(key) + <span class="string">" as "</span> + val, <span class="string">","</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// where</span></div><div class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;    <span class="comment">// on/where 等于号左边的表</span></div><div class="line">       String parentJoinKey = getJoinKey(<span class="keyword">true</span>);</div><div class="line">       <span class="comment">// fix sharejoin bug：</span></div><div class="line">       <span class="comment">// (AbstractConnection.java:458) -close connection,reason:program err:java.lang.IndexOutOfBoundsException:</span></div><div class="line">       <span class="comment">// 原因是左表的select列没有包含 join 列，在获取结果时报上面的错误</span></div><div class="line">       <span class="keyword">if</span> (sql != <span class="keyword">null</span> &amp;&amp; parentJoinKey != <span class="keyword">null</span> &amp;&amp;</div><div class="line">               !sql.toUpperCase().contains(parentJoinKey.trim().toUpperCase())) &#123;</div><div class="line">           sql += <span class="string">", "</span> + parentJoinKey;</div><div class="line">       &#125;</div><div class="line">       sql = <span class="string">"select "</span> + sql + <span class="string">" from "</span> + tName;</div><div class="line">       <span class="keyword">if</span> (!(where.trim().equals(<span class="string">""</span>))) &#123;</div><div class="line">           sql += <span class="string">" where "</span> + where.trim();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;    <span class="comment">// on/where 等于号右边边的表</span></div><div class="line">       <span class="keyword">if</span> (allField) &#123;</div><div class="line">           sql = <span class="string">"select "</span> + sql + <span class="string">" from "</span> + tName;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           sql = unionField(<span class="string">"select "</span> + joinKey, sql, <span class="string">","</span>);</div><div class="line">           sql = sql + <span class="string">" from "</span> + tName;</div><div class="line">           <span class="comment">//sql="select "+joinKey+","+sql+" from "+tName;</span></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!(where.trim().equals(<span class="string">""</span>))) &#123;</div><div class="line">           sql += <span class="string">" where "</span> + where.trim() + <span class="string">" and ("</span> + joinKey + <span class="string">" in %s )"</span>;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           sql += <span class="string">" where "</span> + joinKey + <span class="string">" in %s "</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// order</span></div><div class="line">   <span class="keyword">if</span> (!(order.trim().equals(<span class="string">""</span>))) &#123;</div><div class="line">       sql += <span class="string">" order by "</span> + order.trim();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// limit</span></div><div class="line">   <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">if</span> ((rowCount &gt; <span class="number">0</span>) &amp;&amp; (offset &gt; <span class="number">0</span>)) &#123;</div><div class="line">           sql += <span class="string">" limit"</span> + offset + <span class="string">","</span> + rowCount;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (rowCount &gt; <span class="number">0</span>) &#123;</div><div class="line">               sql += <span class="string">" limit "</span> + rowCount;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> sql;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当 <code>parent</code> 为空时，即<strong>on/where 等于号左边的表</strong>。例如：<code>select id, uid from t_order</code>。</li>
<li>当 <code>parent</code>  不为空时，即<strong>on/where 等于号右边的表</strong>。例如：<code>select id, username from t_user where id in (1, 2, 3)</code>。</li>
</ul>
<h2 id="3-2-ShareJoin-processSQL-…"><a href="#3-2-ShareJoin-processSQL-…" class="headerlink" title="3.2 ShareJoin.processSQL(…)"></a>3.2 ShareJoin.processSQL(…)</h2><p>当 SQL 解析完后，生成<strong>左边的表</strong>执行的 SQL，发送给对应的数据节点查询数据。大体流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/04.png" alt=""></p>
<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getSql()</code> 的返回结果为 <code>select id, uid from t_order</code>。</p>
<p>生成<strong>左边的表</strong>执行的 SQL 后，<strong>顺序顺序顺序</strong>发送给对应的数据节点查询数据。具体顺序查询是怎么实现的，我们来看下章 <strong>BatchSQLJob</strong>。</p>
<h2 id="3-3-BatchSQLJob"><a href="#3-3-BatchSQLJob" class="headerlink" title="3.3 BatchSQLJob"></a>3.3 BatchSQLJob</h2><p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/05.png" alt=""></p>
<p><code>EngineCtx</code> 对 <code>BatchSQLJob</code> 封装，提供上层两个方法：</p>
<ol>
<li>executeNativeSQLSequnceJob ：顺序（非并发）在每个数据节点执行SQL任务</li>
<li>executeNativeSQLParallJob ：并发在每个数据节点执行SQL任务</li>
</ol>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EngineCtx.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeNativeSQLSequnceJob</span><span class="params">(String[] dataNodes, String sql,</span></span></div><div class="line">		SQLJobHandler jobHandler) &#123;</div><div class="line">	<span class="keyword">for</span> (String dataNode : dataNodes) &#123;</div><div class="line">		SQLJob job = <span class="keyword">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class="line">				jobHandler, <span class="keyword">this</span>);</div><div class="line">		bachJob.addJob(job, <span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeNativeSQLParallJob</span><span class="params">(String[] dataNodes, String sql,</span></span></div><div class="line">		SQLJobHandler jobHandler) &#123;</div><div class="line">	<span class="keyword">for</span> (String dataNode : dataNodes) &#123;</div><div class="line">		SQLJob job = <span class="keyword">new</span> SQLJob(jobId.incrementAndGet(), sql, dataNode,</div><div class="line">				jobHandler, <span class="keyword">this</span>);</div><div class="line">		bachJob.addJob(job, <span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><code>BatchSQLJob</code> 通过<strong>执行中任务列表</strong>、<strong>待执行任务列表</strong>来实现<strong>顺序/并发</strong>执行任务。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BatchSQLJob.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行中任务列表</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;Integer, SQLJob&gt; runningJobs = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, SQLJob&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 待执行任务列表</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;SQLJob&gt; waitingJobs = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;SQLJob&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(SQLJob newJob, <span class="keyword">boolean</span> parallExecute)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (parallExecute) &#123;</div><div class="line">       runJob(newJob);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       waitingJobs.offer(newJob);</div><div class="line">       <span class="keyword">if</span> (runningJobs.isEmpty()) &#123; <span class="comment">// 若无正在执行中的任务，则从等待队列里获取任务进行执行。</span></div><div class="line">           SQLJob job = waitingJobs.poll();</div><div class="line">           <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</div><div class="line">               runJob(job);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jobFinished</span><span class="params">(SQLJob sqlJob)</span> </span>&#123;</div><div class="line">	runningJobs.remove(sqlJob.getId());</div><div class="line">	SQLJob job = waitingJobs.poll();</div><div class="line">	<span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</div><div class="line">		runJob(job);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (noMoreJobInput) &#123;</div><div class="line">			<span class="keyword">return</span> runningJobs.isEmpty() &amp;&amp; waitingJobs.isEmpty();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>顺序</strong>执行时，当 <code>runningJobs</code> 存在执行中的任务时，<code>#addJob(...)</code> 时，不立即执行，添加到 <code>waitingJobs</code>。当 <code>SQLJob</code> 完成时，顺序调用下一个任务。</li>
<li><strong>并发</strong>执行时，<code>#addJob(...)</code> 时，立即执行。</li>
</ul>
<hr>
<p><code>SQLJob</code> SQL 异步执行任务。其 <code>jobHandler(SQLJobHandler)</code> 属性，在 SQL 执行有返回结果时，会进行回调，从而实现异步执行。</p>
<p>在 <code>ShareJoin</code> 里，<code>SQLJobHandler</code> 有两个实现：<code>ShareDBJoinHandler</code>、<code>ShareRowOutPutDataHandler</code>。前者，<strong>左边的表</strong>执行的 SQL 回调；后者，<strong>右边的表</strong>执行的 SQL 回调。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/06.png" alt=""></p>
<h2 id="3-4-ShareDBJoinHandler"><a href="#3-4-ShareDBJoinHandler" class="headerlink" title="3.4 ShareDBJoinHandler"></a>3.4 ShareDBJoinHandler</h2><p><code>ShareDBJoinHandler</code>，<strong>左边的表</strong>执行的 SQL 回调。流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/07.png" alt=""></p>
<ul>
<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，放入内存。</li>
<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，放入内存。</li>
<li><code>#rowEofResponse(...)</code> ：接收完一个数据节点返回所有的 row。当所有数据节点都完成 SQL 执行时，提交<strong>右边的表</strong>执行的 SQL 任务，<strong>并行</strong>执行，即图中<strong>#createQryJob(…)</strong>。</li>
</ul>
<p>当 SQL 为 <code>/*!mycat:catlet=io.mycat.catlets.ShareJoin */ SELECT o.id, u.username from t_order o join t_user u on o.uid = u.id;</code> 时，<br><code>sql = getChildSQL()</code> 的返回结果为 <code>select id, username from t_user where id in (1, 2, 3)</code>。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShareJoin.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createQryJob</span><span class="params">(<span class="keyword">int</span> batchSize)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   Map&lt;String, <span class="keyword">byte</span>[]&gt; batchRows = <span class="keyword">new</span> ConcurrentHashMap&lt;String, <span class="keyword">byte</span>[]&gt;();</div><div class="line">   String theId = <span class="keyword">null</span>;</div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder().append(<span class="string">'('</span>);</div><div class="line">   String svalue = <span class="string">""</span>;</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; e : ids.entrySet()) &#123;</div><div class="line">       theId = e.getKey();</div><div class="line">       <span class="keyword">byte</span>[] rowbyte = rows.remove(theId);</div><div class="line">       <span class="keyword">if</span> (rowbyte != <span class="keyword">null</span>) &#123;</div><div class="line">           batchRows.put(theId, rowbyte);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!svalue.equals(e.getValue())) &#123;</div><div class="line">           <span class="keyword">if</span> (joinKeyType == Fields.FIELD_TYPE_VAR_STRING</div><div class="line">                   || joinKeyType == Fields.FIELD_TYPE_STRING) &#123; <span class="comment">// joinkey 为varchar</span></div><div class="line">               sb.append(<span class="string">"'"</span>).append(e.getValue()).append(<span class="string">"'"</span>).append(<span class="string">','</span>); <span class="comment">// ('digdeep','yuanfang')</span></div><div class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// 默认joinkey为int/long</span></div><div class="line">               sb.append(e.getValue()).append(<span class="string">','</span>); <span class="comment">// (1,2,3)</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       svalue = e.getValue();</div><div class="line">       <span class="keyword">if</span> (count++ &gt; batchSize) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   jointTableIsData = <span class="keyword">true</span>;</div><div class="line">   sb.deleteCharAt(sb.length() - <span class="number">1</span>).append(<span class="string">')'</span>);</div><div class="line">   String sql = String.format(joinParser.getChildSQL(), sb);</div><div class="line">   getRoute(sql);</div><div class="line">   ctx.executeNativeSQLParallJob(getDataNodes(), sql, <span class="keyword">new</span> ShareRowOutPutDataHandler(<span class="keyword">this</span>, fields, joinindex, joinParser.getJoinRkey(), batchRows, ctx.getSession()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-5-ShareRowOutPutDataHandler"><a href="#3-5-ShareRowOutPutDataHandler" class="headerlink" title="3.5 ShareRowOutPutDataHandler"></a>3.5 ShareRowOutPutDataHandler</h2><p><code>ShareRowOutPutDataHandler</code>，<strong>右边的表</strong>执行的 SQL 回调。流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/08.png" alt=""></p>
<ul>
<li><code>#fieldEofResponse(...)</code> ：接收数据节点返回的 fields，返回 header 给 MySQL Client。</li>
<li><code>#rowResponse(...)</code> ：接收数据节点返回的 row，匹配左表的记录，返回合并后返回的 row 给 MySQL Client。</li>
<li><code>#rowEofResponse(...)</code> ：当所有 row 都返回完后，返回 eof 给 MySQL Client。</li>
</ul>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShareRowOutPutDataHandler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onRowData</span><span class="params">(String dataNode, <span class="keyword">byte</span>[] rowData)</span> </span>&#123;</div><div class="line">   RowDataPacket rowDataPkgold = ResultSetUtil.parseRowData(rowData, bfields);</div><div class="line">   <span class="comment">//拷贝一份batchRows</span></div><div class="line">   Map&lt;String, <span class="keyword">byte</span>[]&gt; batchRowsCopy = <span class="keyword">new</span> ConcurrentHashMap&lt;String, <span class="keyword">byte</span>[]&gt;();</div><div class="line">   batchRowsCopy.putAll(arows);</div><div class="line">   <span class="comment">// 获取Id字段，</span></div><div class="line">   String id = ByteUtil.getString(rowDataPkgold.fieldValues.get(joinR));</div><div class="line">   <span class="comment">// 查找ID对应的A表的记录</span></div><div class="line">   <span class="keyword">byte</span>[] arow = getRow(batchRowsCopy, id, joinL);</div><div class="line">   <span class="keyword">while</span> (arow != <span class="keyword">null</span>) &#123;</div><div class="line">       RowDataPacket rowDataPkg = ResultSetUtil.parseRowData(arow, afields);<span class="comment">//ctx.getAllFields());</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowDataPkgold.fieldCount; i++) &#123;</div><div class="line">           <span class="comment">// 设置b.name 字段</span></div><div class="line">           <span class="keyword">byte</span>[] bname = rowDataPkgold.fieldValues.get(i);</div><div class="line">           rowDataPkg.add(bname);</div><div class="line">           rowDataPkg.addFieldCount(<span class="number">1</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// huangyiming add</span></div><div class="line">       MiddlerResultHandler middlerResultHandler = session.getMiddlerResultHandler();</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == middlerResultHandler) &#123;</div><div class="line">           ctx.writeRow(rowDataPkg);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (middlerResultHandler <span class="keyword">instanceof</span> MiddlerQueryResultHandler) &#123;</div><div class="line">               <span class="keyword">byte</span>[] columnData = rowDataPkg.fieldValues.get(<span class="number">0</span>);</div><div class="line">               <span class="keyword">if</span> (columnData != <span class="keyword">null</span> &amp;&amp; columnData.length &gt; <span class="number">0</span>) &#123;</div><div class="line">                   String rowValue = <span class="keyword">new</span> String(columnData);</div><div class="line">                   middlerResultHandler.add(rowValue);</div><div class="line">               &#125;</div><div class="line">               <span class="comment">//&#125;</span></div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       arow = getRow(batchRowsCopy, id, joinL);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-彩蛋"><a href="#4-彩蛋" class="headerlink" title="4. 彩蛋"></a>4. 彩蛋</h1><p>如下是本文涉及到的核心类，有兴趣的同学可以翻一翻。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_12/09.png" alt=""></p>
<p><code>ShareJoin</code> 另外不支持的功能：</p>
<ol>
<li>只支持 inner join，不支持 left join、right join 等等连接。</li>
<li>不支持 order by。</li>
<li>不支持 group by 以及 相关聚合函数。</li>
<li>即使 join 左表的字段未声明为返回 fields 也会返回。</li>
</ol>
<p>恩，<strong>MyCAT 弱XA</strong> 源码继续走起！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码解析 —— 分片结果合并（一）</title>
    <link href="http://www.yunai.me/MyCAT/sharding-result-merge-first/"/>
    <id>http://www.yunai.me/MyCAT/sharding-result-merge-first/</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现<strong>分片结果合并</strong>。</p>
<p>跨分片查询大体流程如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/flow.png" alt="flow"></p>
<p>和 <a href="http://www.yunai.me/Mycat/single-db-single-table-select/">《【单库单表】查询》</a> 不同的两个过程：</p>
<ul>
<li>【2】多分片执行 SQL</li>
<li>【4】合并多分片结果</li>
</ul>
<p>下面，我们来逐条讲解这两个过程。</p>
<h1 id="2-多分片执行-SQL"><a href="#2-多分片执行-SQL" class="headerlink" title="2. 多分片执行 SQL"></a>2. 多分片执行 SQL</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/execute_sql.png" alt="execute_sql"></p>
<p>经过 SQL 解析后，计算出需要执行 SQL 的<strong>分片节点</strong>，遍历<strong>分片节点</strong>发送 SQL 进行执行。</p>
<p><strong>核心代码</strong>：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java" rel="external nofollow noopener noreferrer" target="_blank">MultiNodeQueryHandler.java#execute(…)</a></li>
</ul>
<p><em><strong>SQL 解析</strong> 详细过程，我们另开文章，避免内容过多，影响大家对 <strong>分片结果合并</strong> 流程和逻辑的理解。</em></p>
<h1 id="3-合并多分片结果"><a href="#3-合并多分片结果" class="headerlink" title="3. 合并多分片结果"></a>3. 合并多分片结果</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/handle_response.png" alt="handle_response"></p>
<p>和 <a href="http://www.yunai.me/Mycat/single-db-single-table-select/">《【单库单表】查询》</a> 不同，多个<strong>分片节点</strong>都会<strong>分别</strong>响应 <em>记录头(header)</em> 和 <em>记录行(row)</em> 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">FROM       // [1] 选择表</div><div class="line">WHERE      // [2] 过滤表</div><div class="line">GROUP BY   // [3] 分组</div><div class="line"><span class="keyword">SELECT</span>     // [<span class="number">4</span>] 普通字段，<span class="keyword">max</span> / <span class="keyword">min</span> / <span class="keyword">avg</span> / <span class="keyword">sum</span> / <span class="keyword">count</span> 等函数，<span class="keyword">distinct</span></div><div class="line"><span class="keyword">HAVING</span>     // [<span class="number">5</span>] 再过滤表</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>   // [<span class="number">6</span>] 排序</div><div class="line"><span class="keyword">LIMIT</span>      // [<span class="number">7</span>] 分页</div></pre></td></tr></table></figure>
<h2 id="3-1-记录头-header"><a href="#3-1-记录头-header" class="headerlink" title="3.1 记录头(header)"></a>3.1 记录头(header)</h2><p>多个<strong>分片节点</strong>响应时，会响应多次 <em>记录头(header)</em> 。MyCAT 在实际处理时，只处理第一个返回的 <em>记录头(header)</em> 。因此，在使用时要保证表的 Schema 相同。</p>
<p><strong>分片节点</strong>响应的 <em>记录头(header)</em> 可以直接返回 MySQL Client 吗？答案是不可以。<code>AVG</code>函数 是特殊情况，MyCAT 需要将 <code>AVG</code> 拆成 <code>SUM</code> + <code>COUNT</code> 进行计算。举个例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">// [1] MySQL Client =&gt; MyCAT ：</div><div class="line">SELECT AVG(age) FROM student;</div><div class="line"></div><div class="line">// [2] MyCAT =&gt; MySQL Server ：</div><div class="line">SELECT SUM(age) AS AVG0SUM, COUNT(age) AS AVG0COUNT FROM student;</div><div class="line"></div><div class="line">// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)</div></pre></td></tr></table></figure>
<p><strong>核心代码</strong>：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java" rel="external nofollow noopener noreferrer" target="_blank">MultiNodeQueryHandler.java#fieldEofResponse(…)</a>。</li>
</ul>
<h2 id="3-2-记录行-row"><a href="#3-2-记录行-row" class="headerlink" title="3.2 记录行(row)"></a>3.2 记录行(row)</h2><h3 id="3-1-AbstractDataNodeMerge"><a href="#3-1-AbstractDataNodeMerge" class="headerlink" title="3.1 AbstractDataNodeMerge"></a>3.1 AbstractDataNodeMerge</h3><p>MyCAT 对分片结果合并通过 <code>AbstractDataNodeMerge</code> 子类来完成。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/merge_service.png" alt="merge_service"> </p>
<p><code>AbstractDataNodeMerge</code> ：</p>
<ul>
<li>-packs ：待合并记录行(row)队列。队列尾部插入 <code>END_FLAG_PACK</code> 表示队列已结束。</li>
<li>-running ：合并逻辑是否正在执行中的标记。</li>
<li>~onRowMetaData(…) ：根据<strong>记录列信息(ColMeta)</strong>构建对应的排序组件和聚合组件。需要子类进行实现。</li>
<li>~onNewRecord(…) ：插入记录行(row) 到 <code>packs</code>。</li>
<li>~outputMergeResult(…) ：插入 <code>END_FLAG_PACK</code> 到 <code>packs</code>。</li>
<li>~run(…) ：执行<strong>合并</strong>分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。</li>
</ul>
<p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png" alt="AbstractDataNodeMerge_run.png"></p>
<p><strong>通过 <code>running</code> 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行<em>聚合</em>逻辑。当然，<em>排序</em>逻辑需要等到所有分片结果都返回才可以执行。</strong></p>
<p><strong>核心代码</strong>：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractDataNodeMerge.java</a></li>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java" rel="external nofollow noopener noreferrer" target="_blank">DataNodeMergeManager.java#run(…)</a></li>
</ul>
<h3 id="3-2-DataNodeMergeManager"><a href="#3-2-DataNodeMergeManager" class="headerlink" title="3.2 DataNodeMergeManager"></a>3.2 DataNodeMergeManager</h3><p><code>AbstractDataNodeMerge</code> 有两种子类实现：</p>
<ul>
<li><code>DataMergeService</code> ：基于<strong>堆内内存</strong>合并分片结果。</li>
<li><code>DataNodeMergeManager</code> ：基于<strong>堆外内存</strong>合并分片结果。</li>
</ul>
<p>目前官方默认配置使用 <code>DataNodeMergeManager</code>。主要有如下优点：</p>
<ol>
<li>可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。</li>
<li>减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。</li>
<li>更快的内存复制和读取速度，对排序和聚合带来很好的提速。</li>
</ol>
<p>如果对<strong>堆外内存</strong>不太了解，推荐阅读如下文章：</p>
<ol>
<li><a href="http://www.jianshu.com/p/50be08b54bee" rel="external nofollow noopener noreferrer" target="_blank">《从0到1起步-跟我进入堆外内存的奇妙世界》</a></li>
<li><a href="http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory" rel="external nofollow noopener noreferrer" target="_blank">《堆内内存还是堆外内存？》</a></li>
<li><a href="http://www.cnblogs.com/moonandstar08/p/5107648.html" rel="external nofollow noopener noreferrer" target="_blank">《JAVA堆外内存》</a></li>
<li><a href="https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之堆外内存完全解读》</a></li>
</ol>
<p>本文主要分析 <code>DataNodeMergeManager</code> 实现，<code>DataMergeService</code> 可以自己阅读或者等待后续文章（😈<strong>欢迎订阅我的公众号噢</strong>）。</p>
<p><code>DataNodeMergeManager</code> 有三个组件：</p>
<ul>
<li><code>globalSorter</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并并排序</strong>逻辑。</li>
<li><code>globalMergeResult</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并不排序</strong>逻辑。</li>
<li><code>unsafeRowGrouper</code> ： <code>UnsafeRowGrouper</code> =&gt; 实现记录行(row)<strong>聚合</strong>逻辑。</li>
</ul>
<p><code>DataNodeMergeManager#run(...)</code> 逻辑如下：</p>
<ul>
<li>[1] 写入记录行(row)到 <code>UnsafeRow</code>。</li>
<li>[2] 根据情况将 <code>UnsafeRow</code> 插入对应组件。</li>
<li>[3] 当所有 <code>UnsafeRow</code> 插入完后，根据情况使用组件聚合、排序。</li>
</ul>
<table>
<thead>
<tr>
<th>是否排序</th>
<th>是否聚合</th>
<th>依赖组件</th>
<th>[2]</th>
<th>[3]</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td>否</td>
<td><code>globalSorter</code></td>
<td>插入 <code>globalSorter</code></td>
<td>使用 <code>globalSorter</code> 合并并排序</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td><code>globalMergeResult</code></td>
<td>插入 <code>globalMergeResult</code></td>
<td>使用 <code>globalMergeResult</code> 合并不排序</td>
</tr>
<tr>
<td>否</td>
<td>是</td>
<td><code>unsafeRowGrouper</code> + <code>globalSorter</code></td>
<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>
<td>使用 <code>globalSorter</code> 合并并排序</td>
</tr>
<tr>
<td>是</td>
<td>是</td>
<td><code>unsafeRowGrouper</code> + <code>globalMergeResult</code></td>
<td>插入 <code>unsafeRowGrouper</code> 进行聚合</td>
<td>使用 <code>globalMergeResult</code> 合并不排序</td>
</tr>
</tbody>
</table>
<p><strong>核心代码</strong>：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java" rel="external nofollow noopener noreferrer" target="_blank">DataNodeMergeManager.java</a>。</li>
</ul>
<p>🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。</p>
<h3 id="3-3-UnsafeRow"><a href="#3-3-UnsafeRow" class="headerlink" title="3.3 UnsafeRow"></a>3.3 UnsafeRow</h3><p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row.png" alt="unsafe_row"></p>
<p>记录行(row)写到 <code>UnsafeRow</code> 的 <code>baseObject</code> 属性，结构如下：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_object.png" alt="unsafe_row_object"><br><img src="http://www.yunai.me/images/MyCAT/2017_06_13/unsafe_row_2.png" alt="unsafe_row_2.png"></p>
<ul>
<li>拆分成三个区域，<strong>每个区域按照格子记录信息，每个格子 64bits(8 Bytes)</strong>。</li>
<li>记录行(row)按照字段顺序位置记录到 <code>baseObject</code>。</li>
<li>[1] 空标记位区域 ：标记字段对应的值是否为 NULL。<ul>
<li>当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。</li>
<li>因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(<code>bitSetWidthInBytes</code>) = 字段占用的格子数 * 64 bits。</li>
</ul>
</li>
<li>[2] 位置长度区域 ：记录字段对应的值在<code>[3]区域</code>所在的位置和长度。<ul>
<li>每个字段记录<code>[2]区域</code>的位置 = <code>baseOffset</code> + <code>bitSetWidthInBytes</code> + 8 Bytes * 字段顺序。</li>
<li>占用一个格子，前 32 bits 为<code>[3]区域</code>的位置，后 32 bits 为字段对应的值长度。</li>
</ul>
</li>
<li>[3] 值区域 ：记录字段对应的值。<ul>
<li>每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。</li>
<li>因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。</li>
</ul>
</li>
</ul>
<p><strong>写入 <code>UnsafeRow</code>，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。</strong>  </p>
<p>🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 <code>Spark</code>，是不是更加有动力列😈。</p>
<p><strong>核心代码</strong>：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeRow.java</a></li>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java" rel="external nofollow noopener noreferrer" target="_blank">BufferHolder.java</a></li>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeRowWriter.java</a></li>
</ul>
<h3 id="3-4-UnsafeExternalRowSorter"><a href="#3-4-UnsafeExternalRowSorter" class="headerlink" title="3.4 UnsafeExternalRowSorter"></a>3.4 UnsafeExternalRowSorter</h3><p>如果使用 Java 实现 <code>SELECT * FROM student ORDER BY age desc, nickname asc</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Collections.sort(students, <span class="keyword">new</span> Comparator&lt;Comparable&gt;() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</div><div class="line">           <span class="keyword">int</span> cmp = compare(o2.age, o1.age);</div><div class="line">           <span class="keyword">return</span> cmp != <span class="number">0</span> ? cmp : compare(o1.nickname, o2.nickname);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>从功能上，<code>UnsafeExternalRowSorter</code> 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_06_13/sorter_write.jpeg" alt="sorter_write"></p>
<p><code>UnsafeRow</code> 会写入到两个地方：</p>
<ol>
<li><code>List&lt;MemoryBlock&gt;</code> ：内存块数组。当前 <code>MemoryBlock</code> 无法容纳写入的 <code>UnsafeRow</code> 时，生成新的 <code>MemoryBlock</code> 提供写入。每条 <code>UnsafeRow</code> 存储在 <code>MemoryBlock</code> 由 长度 + 字节内容 组成。</li>
<li><code>LongArray</code> ：每条 <code>UnsafeRow</code> 存储在 <code>LongArray</code> 由两部分组成：address + prefix。<ul>
<li><code>address</code> ：<code>UnsafeRow</code> 存储在 <code>List&lt;MemoryBlock&gt;</code> 的位置。前 13 bits 记录所在 <code>MemoryBlock</code> 的 index，后 51 bit 记录在 <code>MemoryBlock</code> 的 offset。</li>
<li><code>prefix</code> ：<code>UnsafeRow</code> 第一个排序字段<strong>值</strong>前 64 bits 计算的值。</li>
</ul>
</li>
</ol>
<p><strong><code>UnsafeExternalRowSorter</code> 排序实现方式</strong> ：提供 <strong><a href="http://blog.csdn.net/yangzhongblog/article/details/8184707" rel="external nofollow noopener noreferrer" target="_blank">TimSort</a></strong> 和 <strong>RadixSort</strong> 两种排序算法，前者为默认实现。<strong>TimSort</strong> 折半查找时，使用 <code>LongArray</code>，先比较 <code>prefix</code>，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 <code>LongArray</code> 操作，<code>List&lt;MemoryBlock&gt;</code> 只作为原始数据。</p>
<p>另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂</p>
<p>核心源码：</p>
<ul>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeExternalRowSorter.java</a></li>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeExternalRowSorter.java</a></li>
<li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java" rel="external nofollow noopener noreferrer" target="_blank">TimSort.java</a></li>
</ul>
<h3 id="3-5-UnsafeRowGrouper"><a href="#3-5-UnsafeRowGrouper" class="headerlink" title="3.5 UnsafeRowGrouper"></a>3.5 UnsafeRowGrouper</h3><p>如果使用 Java 实现 <code>SELECT nickname, COUNT(*) FROM student group by nickname</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;String, List&lt;Object&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="comment">// 聚合</span></div><div class="line"><span class="keyword">for</span> (student : students) &#123;</div><div class="line">    <span class="keyword">if</span> (map.contains(student.nickname)) &#123;</div><div class="line">        map.put(student.nickname, map.get(student.nickname).get(<span class="number">1</span>) + <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        List&lt;Object&gt; value = <span class="keyword">new</span> Array&lt;&gt;();</div><div class="line">        value.add(nickname);</div><div class="line">        value.add(<span class="number">1</span>);</div><div class="line">        map.put(student.nickname, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="keyword">for</span> (value : map.values) &#123;</div><div class="line">    System.out.println(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从功能上，<code>UnsafeRowGrouper</code> 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。</p>
<p>😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。</p>
<h1 id="4-救护中心"><a href="#4-救护中心" class="headerlink" title="4. 救护中心"></a>4. 救护中心</h1><p>看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。</p>
<p>最后的最后，感谢耐心阅读本文的同学。</p>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析 —— 【单库单表】查询</title>
    <link href="http://www.yunai.me/MyCAT/single-db-single-table-select/"/>
    <id>http://www.yunai.me/MyCAT/single-db-single-table-select/</id>
    <published>2017-05-29T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 接收请求，解析 SQL</a></li>
<li><a href="#">3. 获得路由结果</a></li>
<li><a href="#">4. 获得 MySQL 连接，执行 SQL</a></li>
<li><a href="#">5. 响应执行 SQL 结果</a></li>
<li><a href="#">6. 其他 ：更新 / 删除</a></li>
</ul>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote>
<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>
</blockquote>
<p>本文讲解 【单库单表】查询 所涉及到的代码。</p>
<p>😂内容和 <a href="http://www.yunai.me/Mycat/single-db-single-table-insert/">《MyCAT 源码分析 —— 【单库单表】插入》</a> 超级相似，一方面本身流程基本相同，另外一方面文章结构没拆分好。我们使用 🚀 标记差异的逻辑。</p>
<p>交互如下图：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_05_30/01.png" alt="单库单表查询简图"></p>
<p>整个过程，MyCAT Server 流程如下：</p>
<ol>
<li>接收 MySQL Client 请求，解析 SQL。</li>
<li>获得路由结果，进行路由。</li>
<li>获得 MySQL 连接，执行 SQL。</li>
<li>响应执行结果，发送结果给 MySQL Client。</li>
</ol>
<p>我们逐个步骤分析，一起来看看源码。</p>
<h1 id="2-接收请求，解析-SQL"><a href="#2-接收请求，解析-SQL" class="headerlink" title="2. 接收请求，解析 SQL"></a>2. 接收请求，解析 SQL</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_30/02.png" alt="【单库单表】查询（01主流程）"></p>
<h2 id="【1-2】"><a href="#【1-2】" class="headerlink" title="【1 - 2】"></a>【1 - 2】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>
<h2 id="【3】"><a href="#【3】" class="headerlink" title="【3】"></a>【3】</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontendCommandHandler</span> <span class="keyword">implements</span> <span class="title">NIOHandler</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">5</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     </div><div class="line"> <span class="number">7</span>:         <span class="comment">// .... 省略部分代码</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">switch</span> (data[<span class="number">4</span>]) <span class="comment">// </span></div><div class="line"> <span class="number">9</span>:         &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">case</span> MySQLPacket.COM_INIT_DB:</div><div class="line"><span class="number">11</span>:                 commands.doInitDB();</div><div class="line"><span class="number">12</span>:                 source.initDB(data);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             <span class="keyword">case</span> MySQLPacket.COM_QUERY: <span class="comment">// 查询命令</span></div><div class="line"><span class="number">15</span>:                 <span class="comment">// 计数查询命令</span></div><div class="line"><span class="number">16</span>:                 commands.doQuery();</div><div class="line"><span class="number">17</span>:                 <span class="comment">// 执行查询命令</span></div><div class="line"><span class="number">18</span>:                 source.query(data);</div><div class="line"><span class="number">19</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">20</span>:             <span class="keyword">case</span> MySQLPacket.COM_PING:</div><div class="line"><span class="number">21</span>:                 commands.doPing();</div><div class="line"><span class="number">22</span>:                 source.ping();</div><div class="line"><span class="number">23</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>:             <span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: &#125;</div></pre></td></tr></table></figure>
<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-" rel="external nofollow noopener noreferrer" target="_blank">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>
<h2 id="【4】"><a href="#【4】" class="headerlink" title="【4】"></a>【4】</h2><p>将 二进制数组 解析成 SQL。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: 	<span class="comment">// 取得语句</span></div><div class="line"> <span class="number">4</span>: 	String sql = <span class="keyword">null</span>;		</div><div class="line"> <span class="number">5</span>: 	<span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>: 		MySQLMessage mm = <span class="keyword">new</span> MySQLMessage(data);</div><div class="line"> <span class="number">7</span>: 		mm.position(<span class="number">5</span>);</div><div class="line"> <span class="number">8</span>: 		sql = mm.readString(charset);</div><div class="line"> <span class="number">9</span>: 	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line"><span class="number">10</span>: 		writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class="string">"Unknown charset '"</span> + charset + <span class="string">"'"</span>);</div><div class="line"><span class="number">11</span>: 		<span class="keyword">return</span>;</div><div class="line"><span class="number">12</span>: 	&#125;		</div><div class="line"><span class="number">13</span>: 	<span class="comment">// 执行语句</span></div><div class="line"><span class="number">14</span>: 	<span class="keyword">this</span>.query( sql );</div><div class="line"><span class="number">15</span>: &#125;</div></pre></td></tr></table></figure>
<h2 id="【5】"><a href="#【5】" class="headerlink" title="【5】"></a>【5】</h2><p>解析 SQL 类型。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String sql)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>: 	<span class="comment">// 解析 SQL 类型</span></div><div class="line"> <span class="number">5</span>: 	<span class="keyword">int</span> rs = ServerParse.parse(sql);</div><div class="line"> <span class="number">6</span>: 	<span class="keyword">int</span> sqlType = rs &amp; <span class="number">0xff</span>;</div><div class="line"> <span class="number">7</span>: 	</div><div class="line"> <span class="number">8</span>: 	<span class="keyword">switch</span> (sqlType) &#123;</div><div class="line"> <span class="number">9</span>: 	<span class="comment">//explain sql</span></div><div class="line"><span class="number">10</span>: 	<span class="keyword">case</span> ServerParse.EXPLAIN:</div><div class="line"><span class="number">11</span>: 		ExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line"><span class="number">12</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">13</span>: 	<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">14</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">15</span>: 	<span class="keyword">case</span> ServerParse.SELECT:</div><div class="line"><span class="number">16</span>: 		SelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line"><span class="number">17</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">18</span>: 	<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">19</span>: 	<span class="keyword">default</span>:</div><div class="line"><span class="number">20</span>: 		<span class="keyword">if</span>(readOnly)&#123;</div><div class="line"><span class="number">21</span>: 			LOGGER.warn(<span class="keyword">new</span> StringBuilder().append(<span class="string">"User readonly:"</span>).append(sql).toString());</div><div class="line"><span class="number">22</span>: 			c.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class="string">"User readonly"</span>);</div><div class="line"><span class="number">23</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>: 		&#125;</div><div class="line"><span class="number">25</span>: 		c.execute(sql, rs &amp; <span class="number">0xff</span>);</div><div class="line"><span class="number">26</span>: 	&#125;</div><div class="line"><span class="number">27</span>: &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:</div><div class="line"><span class="number">30</span>: <span class="comment">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class="line"><span class="number">31</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String stmt)</span> </span>&#123;</div><div class="line"><span class="number">32</span>: 	<span class="keyword">int</span> length = stmt.length();</div><div class="line"><span class="number">33</span>: 	<span class="comment">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class="line"><span class="number">34</span>: 	<span class="keyword">int</span> rt = -<span class="number">1</span>;</div><div class="line"><span class="number">35</span>: 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</div><div class="line"><span class="number">36</span>: 		<span class="keyword">switch</span> (stmt.charAt(i)) &#123;</div><div class="line"><span class="number">37</span>: 		<span class="comment">// .... 省略部分case			case 'I':</span></div><div class="line"><span class="number">38</span>: 		<span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line"><span class="number">39</span>: 			rt = insertCheck(stmt, i);</div><div class="line"><span class="number">40</span>: 			<span class="keyword">if</span> (rt != OTHER) &#123;</div><div class="line"><span class="number">41</span>: 				<span class="keyword">return</span> rt;</div><div class="line"><span class="number">42</span>: 			&#125;</div><div class="line"><span class="number">43</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">44</span>: 			<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">45</span>: 		<span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line"><span class="number">46</span>: 		<span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line"><span class="number">47</span>: 			rt = sCheck(stmt, i);</div><div class="line"><span class="number">48</span>: 			<span class="keyword">if</span> (rt != OTHER) &#123;</div><div class="line"><span class="number">49</span>: 				<span class="keyword">return</span> rt;</div><div class="line"><span class="number">50</span>: 			&#125;</div><div class="line"><span class="number">51</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">52</span>: 			<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">53</span>: 		<span class="keyword">default</span>:</div><div class="line"><span class="number">54</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">55</span>: 		&#125;</div><div class="line"><span class="number">56</span>: 	&#125;</div><div class="line"><span class="number">57</span>: 	<span class="keyword">return</span> OTHER;</div><div class="line"><span class="number">58</span>: &#125;</div></pre></td></tr></table></figure>
<h2 id="🚀【6】【7】"><a href="#🚀【6】【7】" class="headerlink" title="🚀【6】【7】"></a>🚀【6】【7】</h2><p>解析 Select SQL 类型，分发到对应的逻辑。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String stmt, ServerConnection c, <span class="keyword">int</span> offs)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: 	<span class="keyword">int</span> offset = offs;</div><div class="line"> <span class="number">4</span>: 	<span class="keyword">switch</span> (ServerParseSelect.parse(stmt, offs)) &#123; <span class="comment">// 解析 Select SQL 类型</span></div><div class="line"> <span class="number">5</span>: 	<span class="keyword">case</span> ServerParseSelect.VERSION_COMMENT: <span class="comment">// select @@VERSION_COMMENT;</span></div><div class="line"> <span class="number">6</span>: 		SelectVersionComment.response(c);</div><div class="line"> <span class="number">7</span>: 		<span class="keyword">break</span>;</div><div class="line"> <span class="number">8</span>: 	<span class="keyword">case</span> ServerParseSelect.DATABASE: <span class="comment">// select DATABASE();</span></div><div class="line"> <span class="number">9</span>: 		SelectDatabase.response(c);</div><div class="line"><span class="number">10</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">11</span>: 	<span class="keyword">case</span> ServerParseSelect.USER: <span class="comment">// select CURRENT_USER();</span></div><div class="line"><span class="number">12</span>:         SelectUser.response(c);</div><div class="line"><span class="number">13</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>: 	<span class="keyword">case</span> ServerParseSelect.VERSION: <span class="comment">// select VERSION();</span></div><div class="line"><span class="number">15</span>: 		SelectVersion.response(c);</div><div class="line"><span class="number">16</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">17</span>: 	<span class="keyword">case</span> ServerParseSelect.SESSION_INCREMENT: <span class="comment">// select @@session.auto_increment_increment;</span></div><div class="line"><span class="number">18</span>: 		SessionIncrement.response(c);</div><div class="line"><span class="number">19</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">20</span>: 	<span class="keyword">case</span> ServerParseSelect.SESSION_ISOLATION: <span class="comment">// select @@session.tx_isolation;</span></div><div class="line"><span class="number">21</span>: 		SessionIsolation.response(c);</div><div class="line"><span class="number">22</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">23</span>: 	<span class="keyword">case</span> ServerParseSelect.LAST_INSERT_ID: <span class="comment">// select LAST_INSERT_ID();</span></div><div class="line"><span class="number">24</span>: 		<span class="comment">// ....省略代码</span></div><div class="line"><span class="number">25</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">26</span>: 	<span class="keyword">case</span> ServerParseSelect.IDENTITY: <span class="comment">// select @@identity</span></div><div class="line"><span class="number">27</span>: 		<span class="comment">// ....省略代码</span></div><div class="line"><span class="number">28</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">29</span>:     <span class="keyword">case</span> ServerParseSelect.SELECT_VAR_ALL: <span class="comment">//</span></div><div class="line"><span class="number">30</span>:         SelectVariables.execute(c,stmt);</div><div class="line"><span class="number">31</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">32</span>:     <span class="keyword">case</span> ServerParseSelect.SESSION_TX_READ_ONLY: <span class="comment">//</span></div><div class="line"><span class="number">33</span>:         SelectTxReadOnly.response(c);</div><div class="line"><span class="number">34</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">35</span>: 	<span class="keyword">default</span>: <span class="comment">// 其他，例如 select * from table</span></div><div class="line"><span class="number">36</span>: 		c.execute(stmt, ServerParse.SELECT);</div><div class="line"><span class="number">37</span>: 	&#125;</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: <span class="comment">// ⬇️⬇️⬇️【ServerParseSelect.java】</span></div><div class="line"><span class="number">40</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String stmt, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line"><span class="number">41</span>: 	<span class="keyword">int</span> i = offset;</div><div class="line"><span class="number">42</span>: 	<span class="keyword">for</span> (; i &lt; stmt.length(); ++i) &#123;</div><div class="line"><span class="number">43</span>: 		<span class="keyword">switch</span> (stmt.charAt(i)) &#123;</div><div class="line"><span class="number">44</span>: 		<span class="keyword">case</span> <span class="string">' '</span>:</div><div class="line"><span class="number">45</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">46</span>: 		<span class="keyword">case</span> <span class="string">'/'</span>:</div><div class="line"><span class="number">47</span>: 		<span class="keyword">case</span> <span class="string">'#'</span>:</div><div class="line"><span class="number">48</span>: 			i = ParseUtil.comment(stmt, i);</div><div class="line"><span class="number">49</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">50</span>: 		<span class="keyword">case</span> <span class="string">'@'</span>:</div><div class="line"><span class="number">51</span>: 			<span class="keyword">return</span> select2Check(stmt, i);</div><div class="line"><span class="number">52</span>: 		<span class="keyword">case</span> <span class="string">'D'</span>:</div><div class="line"><span class="number">53</span>: 		<span class="keyword">case</span> <span class="string">'d'</span>:</div><div class="line"><span class="number">54</span>: 			<span class="keyword">return</span> databaseCheck(stmt, i);</div><div class="line"><span class="number">55</span>: 		<span class="keyword">case</span> <span class="string">'L'</span>:</div><div class="line"><span class="number">56</span>: 		<span class="keyword">case</span> <span class="string">'l'</span>:</div><div class="line"><span class="number">57</span>: 			<span class="keyword">return</span> lastInsertCheck(stmt, i);</div><div class="line"><span class="number">58</span>: 		<span class="keyword">case</span> <span class="string">'U'</span>:</div><div class="line"><span class="number">59</span>: 		<span class="keyword">case</span> <span class="string">'u'</span>:</div><div class="line"><span class="number">60</span>: 			<span class="keyword">return</span> userCheck(stmt, i);</div><div class="line"><span class="number">61</span>: 		<span class="keyword">case</span> <span class="string">'C'</span>:</div><div class="line"><span class="number">62</span>: 		<span class="keyword">case</span> <span class="string">'c'</span>:</div><div class="line"><span class="number">63</span>: 			<span class="keyword">return</span> currentUserCheck(stmt, i);</div><div class="line"><span class="number">64</span>: 		<span class="keyword">case</span> <span class="string">'V'</span>:</div><div class="line"><span class="number">65</span>: 		<span class="keyword">case</span> <span class="string">'v'</span>:</div><div class="line"><span class="number">66</span>: 			<span class="keyword">return</span> versionCheck(stmt, i);</div><div class="line"><span class="number">67</span>: 		<span class="keyword">default</span>:</div><div class="line"><span class="number">68</span>: 			<span class="keyword">return</span> OTHER;</div><div class="line"><span class="number">69</span>: 		&#125;</div><div class="line"><span class="number">70</span>: 	&#125;</div><div class="line"><span class="number">71</span>: 	<span class="keyword">return</span> OTHER;</div><div class="line"><span class="number">72</span>: &#125;</div></pre></td></tr></table></figure>
<h2 id="【8】"><a href="#【8】" class="headerlink" title="【8】"></a>【8】</h2><p>执行 SQL，详细解析见下文，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConnection</span> <span class="keyword">extends</span> <span class="title">FrontendConnection</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"> <span class="number">5</span>: 		SchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class="line"> <span class="number">6</span>: 		<span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>: 			writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class="line"> <span class="number">8</span>: 					<span class="string">"Unknown MyCAT Database '"</span> + db + <span class="string">"'"</span>);</div><div class="line"> <span class="number">9</span>: 			<span class="keyword">return</span>;</div><div class="line"><span class="number">10</span>: 		&#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: 		<span class="comment">// 路由到后端数据库，执行 SQL</span></div><div class="line"><span class="number">15</span>: 		routeEndExecuteSQL(sql, type, schema);</div><div class="line"><span class="number">16</span>: 	&#125;</div><div class="line"><span class="number">17</span>: 	</div><div class="line"><span class="number">18</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">routeEndExecuteSQL</span><span class="params">(String sql, <span class="keyword">final</span> <span class="keyword">int</span> type, <span class="keyword">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class="line"><span class="number">19</span>: 		<span class="comment">// 路由计算</span></div><div class="line"><span class="number">20</span>: 		RouteResultset rrs = <span class="keyword">null</span>;</div><div class="line"><span class="number">21</span>: 		<span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>: 			rrs = MycatServer</div><div class="line"><span class="number">23</span>: 					.getInstance()</div><div class="line"><span class="number">24</span>: 					.getRouterservice()</div><div class="line"><span class="number">25</span>: 					.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class="line"><span class="number">26</span>: 							schema, type, sql, <span class="keyword">this</span>.charset, <span class="keyword">this</span>);</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">29</span>: 			StringBuilder s = <span class="keyword">new</span> StringBuilder();</div><div class="line"><span class="number">30</span>: 			LOGGER.warn(s.append(<span class="keyword">this</span>).append(sql).toString() + <span class="string">" err:"</span> + e.toString(),e);</div><div class="line"><span class="number">31</span>: 			String msg = e.getMessage();</div><div class="line"><span class="number">32</span>: 			writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class="keyword">null</span> ? e.getClass().getSimpleName() : msg);</div><div class="line"><span class="number">33</span>: 			<span class="keyword">return</span>;</div><div class="line"><span class="number">34</span>: 		&#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: 		<span class="comment">// 执行 SQL</span></div><div class="line"><span class="number">37</span>: 		<span class="keyword">if</span> (rrs != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">38</span>: 			<span class="comment">// session执行</span></div><div class="line"><span class="number">39</span>: 			session.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class="line"><span class="number">40</span>: 		&#125;</div><div class="line"><span class="number">41</span>: 		</div><div class="line"><span class="number">42</span>:  	&#125;</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>: &#125;</div></pre></td></tr></table></figure>
<h1 id="3-获得路由结果"><a href="#3-获得路由结果" class="headerlink" title="3. 获得路由结果"></a>3. 获得路由结果</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_30/03.png" alt="【单库单表】插入（02获取路由）"></p>
<h2 id="【-1-5-】"><a href="#【-1-5-】" class="headerlink" title="【 1 -  5 】"></a>【 1 -  5 】</h2><p>获得路由主流程。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【SelectHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> RouteResultset <span class="title">route</span><span class="params">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class="line"> <span class="number">3</span>: 		<span class="keyword">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class="line"> 4: 		<span class="keyword">throws</span> SQLNonTransientException &#123;</div><div class="line"> <span class="number">5</span>: 	RouteResultset rrs = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: 	<span class="comment">// SELECT 类型的SQL, 检测缓存是否存在</span></div><div class="line"> <span class="number">8</span>: 	<span class="keyword">if</span> (sqlType == ServerParse.SELECT) &#123;</div><div class="line"> <span class="number">9</span>: 		cacheKey = schema.getName() + stmt;			</div><div class="line"><span class="number">10</span>: 		rrs = (RouteResultset) sqlRouteCache.get(cacheKey);</div><div class="line"><span class="number">11</span>: 		<span class="keyword">if</span> (rrs != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>: 			checkMigrateRule(schema.getName(),rrs,sqlType);</div><div class="line"><span class="number">13</span>: 			<span class="keyword">return</span> rrs;</div><div class="line"><span class="number">14</span>: 			&#125;</div><div class="line"><span class="number">15</span>: 		&#125;</div><div class="line"><span class="number">16</span>: 	&#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">19</span>: 	<span class="keyword">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class="line"><span class="number">20</span>: 	<span class="keyword">if</span>(hintLength != -<span class="number">1</span>)&#123; <span class="comment">// TODO 待读：hint</span></div><div class="line"><span class="number">21</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">22</span>: 		&#125;</div><div class="line"><span class="number">23</span>: 	&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">24</span>: 		stmt = stmt.trim();</div><div class="line"><span class="number">25</span>: 		rrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class="line"><span class="number">26</span>: 				charset, sc, tableId2DataNodeCache);</div><div class="line"><span class="number">27</span>: 	&#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: 	<span class="comment">// 记录查询命令路由结果缓存</span></div><div class="line"><span class="number">30</span>: 	<span class="keyword">if</span> (rrs != <span class="keyword">null</span> &amp;&amp; sqlType == ServerParse.SELECT &amp;&amp; rrs.isCacheAble()) &#123;</div><div class="line"><span class="number">31</span>: 		sqlRouteCache.putIfAbsent(cacheKey, rrs);</div><div class="line"><span class="number">32</span>: 	&#125;</div><div class="line"><span class="number">33</span>: 	<span class="comment">// .... 省略代码		return rrs;</span></div><div class="line"><span class="number">34</span>: &#125;</div><div class="line"><span class="number">35</span>: <span class="comment">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class="line"><span class="number">36</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">37</span>: <span class="function"><span class="keyword">public</span> RouteResultset <span class="title">route</span><span class="params">(SystemConfig sysConfig, SchemaConfig schema, <span class="keyword">int</span> sqlType, String origSQL,</span></span></div><div class="line"><span class="number">38</span>: 		String charset, ServerConnection sc, LayerCachePool cachePool) <span class="keyword">throws</span> SQLNonTransientException &#123;</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">41</span>: </div><div class="line"><span class="number">42</span>: 	<span class="comment">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class="line"><span class="number">43</span>: 	<span class="keyword">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class="line"><span class="number">44</span>: 		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">45</span>: 	&#125;</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>: 	<span class="comment">// 检查是否有分片</span></div><div class="line"><span class="number">50</span>: 	<span class="keyword">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class="line"><span class="number">51</span>: 		rrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class="line"><span class="number">52</span>: 	&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">53</span>: 		RouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class="line"><span class="number">54</span>: 		<span class="keyword">if</span> (returnedSet == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">55</span>: 			rrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class="line"><span class="number">56</span>: 		&#125;</div><div class="line"><span class="number">57</span>: 	&#125;</div><div class="line"><span class="number">58</span>: </div><div class="line"><span class="number">59</span>: 	<span class="keyword">return</span> rrs;</div><div class="line"><span class="number">60</span>: &#125;</div></pre></td></tr></table></figure>
<p>🚀【3】第 7 至 16 行 ：当 Select SQL 存在路由结果缓存时，直接返回缓存。<br>🚀【6】第 29 至 32 行 ：记录 Select SQL 路由结果到缓存。</p>
<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>
<h1 id="4-获得-MySQL-连接，执行-SQL"><a href="#4-获得-MySQL-连接，执行-SQL" class="headerlink" title="4. 获得 MySQL 连接，执行 SQL"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/03.png" alt="【单库单表】查询（03执行 SQL）"></p>
<h2 id="【-1-8-】"><a href="#【-1-8-】" class="headerlink" title="【 1 - 8 】"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>
<ul>
<li>PhysicalDBNode ：物理数据库节点。</li>
<li>PhysicalDatasource ：物理数据库数据源。</li>
</ul>
<h2 id="【-9-13-】"><a href="#【-9-13-】" class="headerlink" title="【 9 - 13 】"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>
<h1 id="🚀-5-响应执行-SQL-结果"><a href="#🚀-5-响应执行-SQL-结果" class="headerlink" title="🚀 5. 响应执行 SQL 结果"></a>🚀 5. 响应执行 SQL 结果</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_30/04.png" alt="【单库单表】查询（04执行响应）"></p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【MySQLConnectionHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>: 	<span class="keyword">switch</span> (resultStatus) &#123;</div><div class="line"> <span class="number">5</span>: 	<span class="keyword">case</span> RESULT_STATUS_INIT:</div><div class="line"> <span class="number">6</span>: 		<span class="keyword">switch</span> (data[<span class="number">4</span>]) &#123;</div><div class="line"> <span class="number">7</span>: 		<span class="keyword">case</span> OkPacket.FIELD_COUNT:</div><div class="line"> <span class="number">8</span>: 			handleOkPacket(data);</div><div class="line"> <span class="number">9</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">10</span>: 		<span class="keyword">case</span> ErrorPacket.FIELD_COUNT:</div><div class="line"><span class="number">11</span>: 			handleErrorPacket(data);</div><div class="line"><span class="number">12</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">13</span>: 		<span class="keyword">case</span> RequestFilePacket.FIELD_COUNT:</div><div class="line"><span class="number">14</span>: 			handleRequestPacket(data);</div><div class="line"><span class="number">15</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">16</span>: 		<span class="keyword">default</span>: <span class="comment">// 初始化 header fields</span></div><div class="line"><span class="number">17</span>: 			resultStatus = RESULT_STATUS_HEADER;</div><div class="line"><span class="number">18</span>: 			header = data;</div><div class="line"><span class="number">19</span>: 			fields = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;((<span class="keyword">int</span>) ByteUtil.readLength(data,</div><div class="line"><span class="number">20</span>: 					<span class="number">4</span>));</div><div class="line"><span class="number">21</span>: 		&#125;</div><div class="line"><span class="number">22</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">23</span>: 	<span class="keyword">case</span> RESULT_STATUS_HEADER:</div><div class="line"><span class="number">24</span>: 		<span class="keyword">switch</span> (data[<span class="number">4</span>]) &#123;</div><div class="line"><span class="number">25</span>: 		<span class="keyword">case</span> ErrorPacket.FIELD_COUNT:</div><div class="line"><span class="number">26</span>: 			resultStatus = RESULT_STATUS_INIT;</div><div class="line"><span class="number">27</span>: 			handleErrorPacket(data);</div><div class="line"><span class="number">28</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">29</span>: 		<span class="keyword">case</span> EOFPacket.FIELD_COUNT: <span class="comment">// 解析 fields 结束</span></div><div class="line"><span class="number">30</span>: 			resultStatus = RESULT_STATUS_FIELD_EOF;</div><div class="line"><span class="number">31</span>: 			handleFieldEofPacket(data);</div><div class="line"><span class="number">32</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">33</span>: 		<span class="keyword">default</span>: <span class="comment">// 解析 fields</span></div><div class="line"><span class="number">34</span>: 			fields.add(data);</div><div class="line"><span class="number">35</span>: 		&#125;</div><div class="line"><span class="number">36</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">37</span>: 	<span class="keyword">case</span> RESULT_STATUS_FIELD_EOF:</div><div class="line"><span class="number">38</span>: 		<span class="keyword">switch</span> (data[<span class="number">4</span>]) &#123;</div><div class="line"><span class="number">39</span>: 		<span class="keyword">case</span> ErrorPacket.FIELD_COUNT:</div><div class="line"><span class="number">40</span>: 			resultStatus = RESULT_STATUS_INIT;</div><div class="line"><span class="number">41</span>: 			handleErrorPacket(data);</div><div class="line"><span class="number">42</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">43</span>: 		<span class="keyword">case</span> EOFPacket.FIELD_COUNT: <span class="comment">// 解析 每行记录 结束</span></div><div class="line"><span class="number">44</span>: 			resultStatus = RESULT_STATUS_INIT;</div><div class="line"><span class="number">45</span>: 			handleRowEofPacket(data);</div><div class="line"><span class="number">46</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">47</span>: 		<span class="keyword">default</span>: <span class="comment">// 每行记录</span></div><div class="line"><span class="number">48</span>: 			handleRowPacket(data);</div><div class="line"><span class="number">49</span>: 		&#125;</div><div class="line"><span class="number">50</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">51</span>: 	<span class="keyword">default</span>:</div><div class="line"><span class="number">52</span>: 		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"unknown status!"</span>);</div><div class="line"><span class="number">53</span>: 	&#125;</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure>
<h1 id="6-其他-：更新-删除"><a href="#6-其他-：更新-删除" class="headerlink" title="6. 其他 ：更新 / 删除"></a>6. 其他 ：更新 / 删除</h1><p>流程基本和 <a href="http://www.yunai.me/Mycat/single-db-single-table-insert/">《MyCAT源码分析：【单库单表】插入》</a> 相同。我们就不另外文章解析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析 —— 【单库单表】插入</title>
    <link href="http://www.yunai.me/MyCAT/single-db-single-table-insert/"/>
    <id>http://www.yunai.me/MyCAT/single-db-single-table-insert/</id>
    <published>2017-05-28T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 接收请求，解析 SQL</a></li>
<li><a href="#">3. 获得路由结果</a></li>
<li><a href="#">4. 获得 MySQL 连接，执行 SQL</a></li>
<li><a href="#">5. 响应执行 SQL 结果</a></li>
</ul>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote>
<p>内容形态以 顺序图 + 核心代码 为主。<br>如果有地方表述不错误或者不清晰，欢迎留言。<br>对于内容形态，非常纠结，如果有建议，特别特别特别欢迎您提出。<br>微信号：wangwenbin-server。</p>
</blockquote>
<p>本文讲解 【单库单表】插入 所涉及到的代码。交互如下图：</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/05.png" alt="单库单表插入简图"></p>
<p>整个过程，MyCAT Server 流程如下：</p>
<ol>
<li>接收 MySQL Client 请求，解析 SQL。</li>
<li>获得路由结果，进行路由。</li>
<li>获得 MySQL 连接，执行 SQL。</li>
<li>响应执行结果，发送结果给 MySQL Client。</li>
</ol>
<p>我们逐个步骤分析，一起来看看源码。</p>
<h1 id="2-接收请求，解析-SQL"><a href="#2-接收请求，解析-SQL" class="headerlink" title="2. 接收请求，解析 SQL"></a>2. 接收请求，解析 SQL</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/01.png" alt="【单库单表】插入（01主流程）"></p>
<h2 id="【-1-2-】"><a href="#【-1-2-】" class="headerlink" title="【 1 - 2 】"></a>【 1 - 2 】</h2><p>接收<strong>一条</strong> MySQL 命令。在【1】之前，还有请求数据读取、拆成单条 MySQL SQL。</p>
<h2 id="【-3-】"><a href="#【-3-】" class="headerlink" title="【 3 】"></a>【 3 】</h2><p>不同 MySQL 命令，分发到不同的方法执行。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【FrontendCommandHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontendCommandHandler</span> <span class="keyword">implements</span> <span class="title">NIOHandler</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">5</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     </div><div class="line"> <span class="number">7</span>:         <span class="comment">// .... 省略部分代码</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">switch</span> (data[<span class="number">4</span>]) <span class="comment">// </span></div><div class="line"> <span class="number">9</span>:         &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">case</span> MySQLPacket.COM_INIT_DB:</div><div class="line"><span class="number">11</span>:                 commands.doInitDB();</div><div class="line"><span class="number">12</span>:                 source.initDB(data);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             <span class="keyword">case</span> MySQLPacket.COM_QUERY: <span class="comment">// 查询命令</span></div><div class="line"><span class="number">15</span>:                 <span class="comment">// 计数查询命令</span></div><div class="line"><span class="number">16</span>:                 commands.doQuery();</div><div class="line"><span class="number">17</span>:                 <span class="comment">// 执行查询命令</span></div><div class="line"><span class="number">18</span>:                 source.query(data);</div><div class="line"><span class="number">19</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">20</span>:             <span class="keyword">case</span> MySQLPacket.COM_PING:</div><div class="line"><span class="number">21</span>:                 commands.doPing();</div><div class="line"><span class="number">22</span>:                 source.ping();</div><div class="line"><span class="number">23</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>:             <span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: &#125;</div></pre></td></tr></table></figure>
<p><code>INSERT</code>/<code>SELECT</code>/<code>UPDATE</code>/<code>DELETE</code> 等 SQL 归属于 <code>MySQLPacket.COM_QUERY</code>，详细可见：<a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/#42-" rel="external nofollow noopener noreferrer" target="_blank">《MySQL协议分析#4.2 客户端命令请求报文（客户端 -&gt; 服务器）》</a>。</p>
<p>##【 4 】</p>
<p>将 二进制数组 解析成 SQL。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【FrontendConnection.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: 	<span class="comment">// 取得语句</span></div><div class="line"> <span class="number">4</span>: 	String sql = <span class="keyword">null</span>;		</div><div class="line"> <span class="number">5</span>: 	<span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>: 		MySQLMessage mm = <span class="keyword">new</span> MySQLMessage(data);</div><div class="line"> <span class="number">7</span>: 		mm.position(<span class="number">5</span>);</div><div class="line"> <span class="number">8</span>: 		sql = mm.readString(charset);</div><div class="line"> <span class="number">9</span>: 	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line"><span class="number">10</span>: 		writeErrMessage(ErrorCode.ER_UNKNOWN_CHARACTER_SET, <span class="string">"Unknown charset '"</span> + charset + <span class="string">"'"</span>);</div><div class="line"><span class="number">11</span>: 		<span class="keyword">return</span>;</div><div class="line"><span class="number">12</span>: 	&#125;		</div><div class="line"><span class="number">13</span>: 	<span class="comment">// 执行语句</span></div><div class="line"><span class="number">14</span>: 	<span class="keyword">this</span>.query( sql );</div><div class="line"><span class="number">15</span>: &#125;</div></pre></td></tr></table></figure>
<p>##【 5 】</p>
<p>解析 SQL 类型。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【ServerQueryHandler.java】</span></div><div class="line"> <span class="number">2</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(String sql)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>: 	<span class="comment">// 解析 SQL 类型</span></div><div class="line"> <span class="number">5</span>: 	<span class="keyword">int</span> rs = ServerParse.parse(sql);</div><div class="line"> <span class="number">6</span>: 	<span class="keyword">int</span> sqlType = rs &amp; <span class="number">0xff</span>;</div><div class="line"> <span class="number">7</span>: 	</div><div class="line"> <span class="number">8</span>: 	<span class="keyword">switch</span> (sqlType) &#123;</div><div class="line"> <span class="number">9</span>: 	<span class="comment">//explain sql</span></div><div class="line"><span class="number">10</span>: 	<span class="keyword">case</span> ServerParse.EXPLAIN:</div><div class="line"><span class="number">11</span>: 		ExplainHandler.handle(sql, c, rs &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line"><span class="number">12</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">13</span>: 	<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">14</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">15</span>: 	<span class="keyword">case</span> ServerParse.SELECT:</div><div class="line"><span class="number">16</span>: 		SelectHandler.handle(sql, c, rs &gt;&gt;&gt; <span class="number">8</span>);</div><div class="line"><span class="number">17</span>: 		<span class="keyword">break</span>;</div><div class="line"><span class="number">18</span>: 	<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">19</span>: 	<span class="keyword">default</span>:</div><div class="line"><span class="number">20</span>: 		<span class="keyword">if</span>(readOnly)&#123;</div><div class="line"><span class="number">21</span>: 			LOGGER.warn(<span class="keyword">new</span> StringBuilder().append(<span class="string">"User readonly:"</span>).append(sql).toString());</div><div class="line"><span class="number">22</span>: 			c.writeErrMessage(ErrorCode.ER_USER_READ_ONLY, <span class="string">"User readonly"</span>);</div><div class="line"><span class="number">23</span>: 			<span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>: 		&#125;</div><div class="line"><span class="number">25</span>: 		c.execute(sql, rs &amp; <span class="number">0xff</span>);</div><div class="line"><span class="number">26</span>: 	&#125;</div><div class="line"><span class="number">27</span>: &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:</div><div class="line"><span class="number">30</span>: <span class="comment">// ⬇️⬇️⬇️【ServerParse.java】</span></div><div class="line"><span class="number">31</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String stmt)</span> </span>&#123;</div><div class="line"><span class="number">32</span>: 	<span class="keyword">int</span> length = stmt.length();</div><div class="line"><span class="number">33</span>: 	<span class="comment">//FIX BUG FOR SQL SUCH AS /XXXX/SQL</span></div><div class="line"><span class="number">34</span>: 	<span class="keyword">int</span> rt = -<span class="number">1</span>;</div><div class="line"><span class="number">35</span>: 	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</div><div class="line"><span class="number">36</span>: 		<span class="keyword">switch</span> (stmt.charAt(i)) &#123;</div><div class="line"><span class="number">37</span>: 		<span class="comment">// .... 省略部分case			case 'I':</span></div><div class="line"><span class="number">38</span>: 		<span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line"><span class="number">39</span>: 			rt = insertCheck(stmt, i);</div><div class="line"><span class="number">40</span>: 			<span class="keyword">if</span> (rt != OTHER) &#123;</div><div class="line"><span class="number">41</span>: 				<span class="keyword">return</span> rt;</div><div class="line"><span class="number">42</span>: 			&#125;</div><div class="line"><span class="number">43</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">44</span>: 			<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">45</span>: 		<span class="keyword">case</span> <span class="string">'S'</span>:</div><div class="line"><span class="number">46</span>: 		<span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line"><span class="number">47</span>: 			rt = sCheck(stmt, i);</div><div class="line"><span class="number">48</span>: 			<span class="keyword">if</span> (rt != OTHER) &#123;</div><div class="line"><span class="number">49</span>: 				<span class="keyword">return</span> rt;</div><div class="line"><span class="number">50</span>: 			&#125;</div><div class="line"><span class="number">51</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">52</span>: 			<span class="comment">// .... 省略部分case</span></div><div class="line"><span class="number">53</span>: 		<span class="keyword">default</span>:</div><div class="line"><span class="number">54</span>: 			<span class="keyword">continue</span>;</div><div class="line"><span class="number">55</span>: 		&#125;</div><div class="line"><span class="number">56</span>: 	&#125;</div><div class="line"><span class="number">57</span>: 	<span class="keyword">return</span> OTHER;</div><div class="line"><span class="number">58</span>: &#125;</div></pre></td></tr></table></figure>
<p>##【 6 】</p>
<p>执行 SQL，详细解析见下文，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【ServerConnection.java】</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConnection</span> <span class="keyword">extends</span> <span class="title">FrontendConnection</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String sql, <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"> <span class="number">5</span>: 		SchemaConfig schema = MycatServer.getInstance().getConfig().getSchemas().get(db);</div><div class="line"> <span class="number">6</span>: 		<span class="keyword">if</span> (schema == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>: 			writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,</div><div class="line"> <span class="number">8</span>: 					<span class="string">"Unknown MyCAT Database '"</span> + db + <span class="string">"'"</span>);</div><div class="line"> <span class="number">9</span>: 			<span class="keyword">return</span>;</div><div class="line"><span class="number">10</span>: 		&#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: 		<span class="comment">// 路由到后端数据库，执行 SQL</span></div><div class="line"><span class="number">15</span>: 		routeEndExecuteSQL(sql, type, schema);</div><div class="line"><span class="number">16</span>: 	&#125;</div><div class="line"><span class="number">17</span>: 	</div><div class="line"><span class="number">18</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">routeEndExecuteSQL</span><span class="params">(String sql, <span class="keyword">final</span> <span class="keyword">int</span> type, <span class="keyword">final</span> SchemaConfig schema)</span> </span>&#123;</div><div class="line"><span class="number">19</span>: 		<span class="comment">// 路由计算</span></div><div class="line"><span class="number">20</span>: 		RouteResultset rrs = <span class="keyword">null</span>;</div><div class="line"><span class="number">21</span>: 		<span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>: 			rrs = MycatServer</div><div class="line"><span class="number">23</span>: 					.getInstance()</div><div class="line"><span class="number">24</span>: 					.getRouterservice()</div><div class="line"><span class="number">25</span>: 					.route(MycatServer.getInstance().getConfig().getSystem(),</div><div class="line"><span class="number">26</span>: 							schema, type, sql, <span class="keyword">this</span>.charset, <span class="keyword">this</span>);</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">29</span>: 			StringBuilder s = <span class="keyword">new</span> StringBuilder();</div><div class="line"><span class="number">30</span>: 			LOGGER.warn(s.append(<span class="keyword">this</span>).append(sql).toString() + <span class="string">" err:"</span> + e.toString(),e);</div><div class="line"><span class="number">31</span>: 			String msg = e.getMessage();</div><div class="line"><span class="number">32</span>: 			writeErrMessage(ErrorCode.ER_PARSE_ERROR, msg == <span class="keyword">null</span> ? e.getClass().getSimpleName() : msg);</div><div class="line"><span class="number">33</span>: 			<span class="keyword">return</span>;</div><div class="line"><span class="number">34</span>: 		&#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: 		<span class="comment">// 执行 SQL</span></div><div class="line"><span class="number">37</span>: 		<span class="keyword">if</span> (rrs != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">38</span>: 			<span class="comment">// session执行</span></div><div class="line"><span class="number">39</span>: 			session.execute(rrs, rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);</div><div class="line"><span class="number">40</span>: 		&#125;</div><div class="line"><span class="number">41</span>: 		</div><div class="line"><span class="number">42</span>:  	&#125;</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>: &#125;</div></pre></td></tr></table></figure>
<h1 id="3-获得路由结果"><a href="#3-获得路由结果" class="headerlink" title="3. 获得路由结果"></a>3. 获得路由结果</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/02.png" alt="【单库单表】插入（02获取路由）"></p>
<h2 id="【-1-2-】【-12-】"><a href="#【-1-2-】【-12-】" class="headerlink" title="【 1 - 2 】【 12 】"></a>【 1 - 2 】【 12 】</h2><p>获得路由主流程。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【RouteService.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> RouteResultset <span class="title">route</span><span class="params">(SystemConfig sysconf, SchemaConfig schema,</span></span></div><div class="line"> <span class="number">3</span>: 		<span class="keyword">int</span> sqlType, String stmt, String charset, ServerConnection sc)</div><div class="line"> 4: 		<span class="keyword">throws</span> SQLNonTransientException &#123;</div><div class="line"> <span class="number">5</span>: 	RouteResultset rrs = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"> <span class="number">7</span>: 	<span class="keyword">int</span> hintLength = RouteService.isHintSql(stmt);</div><div class="line"> <span class="number">8</span>: 	<span class="keyword">if</span>(hintLength != -<span class="number">1</span>)&#123; <span class="comment">// TODO 待读：hint</span></div><div class="line"> <span class="number">9</span>: 		<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">10</span>: 		&#125;</div><div class="line"><span class="number">11</span>: 	&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">12</span>: 		stmt = stmt.trim();</div><div class="line"><span class="number">13</span>: 		rrs = RouteStrategyFactory.getRouteStrategy().route(sysconf, schema, sqlType, stmt,</div><div class="line"><span class="number">14</span>: 				charset, sc, tableId2DataNodeCache);</div><div class="line"><span class="number">15</span>: 	&#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: 	<span class="comment">// .... 省略代码		return rrs;</span></div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: <span class="comment">// ⬇️⬇️⬇️【AbstractRouteStrategy.java】</span></div><div class="line"><span class="number">20</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">21</span>: <span class="function"><span class="keyword">public</span> RouteResultset <span class="title">route</span><span class="params">(SystemConfig sysConfig, SchemaConfig schema, <span class="keyword">int</span> sqlType, String origSQL,</span></span></div><div class="line"><span class="number">22</span>: 		String charset, ServerConnection sc, LayerCachePool cachePool) <span class="keyword">throws</span> SQLNonTransientException &#123;</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>: 	<span class="comment">// 处理一些路由之前的逻辑;全局序列号，父子表插入</span></div><div class="line"><span class="number">27</span>: 	<span class="keyword">if</span> (beforeRouteProcess(schema, sqlType, origSQL, sc) ) &#123;</div><div class="line"><span class="number">28</span>: 		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">29</span>: 	&#125;</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>: 	<span class="comment">// .... 省略代码</span></div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>: 	<span class="comment">// 检查是否有分片</span></div><div class="line"><span class="number">34</span>: 	<span class="keyword">if</span> (schema.isNoSharding() &amp;&amp; ServerParse.SHOW != sqlType) &#123;</div><div class="line"><span class="number">35</span>: 		rrs = RouterUtil.routeToSingleNode(rrs, schema.getDataNode(), stmt);</div><div class="line"><span class="number">36</span>: 	&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">37</span>: 		RouteResultset returnedSet = routeSystemInfo(schema, sqlType, stmt, rrs);</div><div class="line"><span class="number">38</span>: 		<span class="keyword">if</span> (returnedSet == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>: 			rrs = routeNormalSqlWithAST(schema, stmt, rrs, charset, cachePool,sqlType,sc);</div><div class="line"><span class="number">40</span>: 		&#125;</div><div class="line"><span class="number">41</span>: 	&#125;</div><div class="line"><span class="number">42</span>: </div><div class="line"><span class="number">43</span>: 	<span class="keyword">return</span> rrs;</div><div class="line"><span class="number">44</span>: &#125;</div></pre></td></tr></table></figure>
<p><em><strong>路由</strong> 详细解析，我们另开文章，避免内容过多，影响大家对【插入】流程和逻辑的理解。</em></p>
<h2 id="【-3-6-】"><a href="#【-3-6-】" class="headerlink" title="【 3 - 6 】"></a>【 3 - 6 】</h2><p>路由<strong>前置</strong>处理。当符合如下三种情况下，进行处理：  </p>
<p>{ 1 } 使用<strong>全局序列号</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="keyword">NEXT</span> <span class="keyword">VALUE</span> <span class="keyword">FOR</span> MYCATSEQ_ID, <span class="string">'name'</span>)</div></pre></td></tr></table></figure>
<p>{ 2 } ER 子表插入<br>{ 3 } 主键使用自增 ID 插入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">insert into table (name) values ('name')</div><div class="line">===&gt;</div><div class="line">insert into table (id, name) values (NEXT VALUE FOR MYCATSEQ_ID, 'name')</div><div class="line">```  </div><div class="line"></div><div class="line">情况 &#123; 1 &#125; &#123; 3 &#125; 情况类似，使用全局序列号。</div><div class="line"></div><div class="line">核心代码如下：</div><div class="line"></div><div class="line">```Java</div><div class="line">  1: // ⬇️⬇️⬇️【AbstractRouteStrategy.java】</div><div class="line">  2: private boolean beforeRouteProcess(SchemaConfig schema, int sqlType, String origSQL, ServerConnection sc)</div><div class="line">  3: 		throws SQLNonTransientException &#123;</div><div class="line">  4: 	return  // 处理 id 使用 全局序列号</div><div class="line">  5:             RouterUtil.processWithMycatSeq(schema, sqlType, origSQL, sc)</div><div class="line">  6:             // 处理 ER 子表</div><div class="line">  7: 			|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processERChildTable(schema, origSQL, sc))</div><div class="line">  8:             // 处理 id 自增长</div><div class="line">  9: 			|| (sqlType == ServerParse.INSERT &amp;&amp; RouterUtil.processInsert(schema, sqlType, origSQL, sc));</div><div class="line"> 10: &#125;</div></pre></td></tr></table></figure>
<p><code>RouterUtil.java</code> 处理 SQL 考虑性能，实现会比较 C-style，代码咱就不贴了，传送门：<a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/route/util/RouterUtil.java。</a> （😈该仓库从官方 Fork，逐步完善中文注释，欢迎 Star）</p>
<h2 id="【-7-11-】"><a href="#【-7-11-】" class="headerlink" title="【 7 - 11 】"></a>【 7 - 11 】</h2><p>当<strong>前置</strong>路由处理<strong>全局序列号</strong>时，添加到全局序列处理器（<code>MyCATSequnceProcessor</code>）。该处理器会异步生成 ID，替换 SQL 内的 <code>NEXT VALUE FOR MYCATSEQ_</code> 正则。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="keyword">NEXT</span> <span class="keyword">VALUE</span> <span class="keyword">FOR</span> MYCATSEQ_ID, <span class="string">'name'</span>)</div><div class="line">===&gt;</div><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">868348974560579584</span>, <span class="string">'name'</span>)</div></pre></td></tr></table></figure>
<p>异步处理完后，调用 <code>ServerConnection#routeEndExecuteSQL(sql, type, schema)</code> 方法重新执行 SQL。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// ⬇️⬇️⬇️【RouterUtil.java】</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSQL</span><span class="params">(ServerConnection sc,SchemaConfig schema,String sql,<span class="keyword">int</span> sqlType)</span></span>&#123;</div><div class="line"> <span class="number">3</span>: 	SessionSQLPair sessionSQLPair = <span class="keyword">new</span> SessionSQLPair(sc.getSession2(), schema, sql, sqlType);</div><div class="line"> <span class="number">4</span>: 	MycatServer.getInstance().getSequnceProcessor().addNewSql(sessionSQLPair);</div><div class="line"> <span class="number">5</span>: &#125;</div><div class="line"> <span class="number">6</span>: <span class="comment">// ⬇️⬇️⬇️【MyCATSequnceProcessor.java】</span></div><div class="line"> <span class="number">7</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCATSequnceProcessor</span> </span>&#123;</div><div class="line"> <span class="number">8</span>: 	<span class="keyword">private</span> LinkedBlockingQueue&lt;SessionSQLPair&gt; seqSQLQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;SessionSQLPair&gt;();</div><div class="line"> <span class="number">9</span>: 	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running=<span class="keyword">true</span>;</div><div class="line"><span class="number">10</span>: 	</div><div class="line"><span class="number">11</span>: 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewSql</span><span class="params">(SessionSQLPair pair)</span> </span>&#123;</div><div class="line"><span class="number">12</span>: 		seqSQLQueue.add(pair);</div><div class="line"><span class="number">13</span>: 	&#125;</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: 	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeSeq</span><span class="params">(SessionSQLPair pair)</span> </span>&#123;</div><div class="line"><span class="number">16</span>: 		<span class="keyword">try</span> &#123;</div><div class="line"><span class="number">17</span>: 			</div><div class="line"><span class="number">18</span>: 			<span class="comment">// 使用Druid解析器实现sequence处理  @兵临城下</span></div><div class="line"><span class="number">19</span>: 			DruidSequenceHandler sequenceHandler = <span class="keyword">new</span> DruidSequenceHandler(MycatServer</div><div class="line"><span class="number">20</span>: 					.getInstance().getConfig().getSystem().getSequnceHandlerType());</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: 			<span class="comment">// 生成可执行 SQL ：目前主要是生成 id</span></div><div class="line"><span class="number">23</span>: 			String charset = pair.session.getSource().getCharset();</div><div class="line"><span class="number">24</span>: 			String executeSql = sequenceHandler.getExecuteSql(pair.sql,charset == <span class="keyword">null</span> ? <span class="string">"utf-8"</span>:charset);</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>: 			<span class="comment">// 执行 SQL</span></div><div class="line"><span class="number">27</span>: 			pair.session.getSource().routeEndExecuteSQL(executeSql, pair.type,pair.schema);</div><div class="line"><span class="number">28</span>: 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">29</span>: 			LOGGER.error(<span class="string">"MyCATSequenceProcessor.executeSeq(SesionSQLPair)"</span>,e);</div><div class="line"><span class="number">30</span>: 			pair.session.getSource().writeErrMessage(ErrorCode.ER_YES,<span class="string">"mycat sequnce err."</span> + e);</div><div class="line"><span class="number">31</span>: 			<span class="keyword">return</span>;</div><div class="line"><span class="number">32</span>: 		&#125;</div><div class="line"><span class="number">33</span>: 	&#125;</div><div class="line"><span class="number">34</span>: 	</div><div class="line"><span class="number">35</span>: 	<span class="class"><span class="keyword">class</span> <span class="title">ExecuteThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"><span class="number">36</span>: 		</div><div class="line"><span class="number">37</span>: 		<span class="function"><span class="keyword">public</span> <span class="title">ExecuteThread</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">38</span>: 			setDaemon(<span class="keyword">true</span>); <span class="comment">// 设置为后台线程,防止throw RuntimeExecption进程仍然存在的问题</span></div><div class="line"><span class="number">39</span>: 		&#125;</div><div class="line"><span class="number">40</span>: 		</div><div class="line"><span class="number">41</span>: 		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">42</span>: 			<span class="keyword">while</span> (running) &#123;</div><div class="line"><span class="number">43</span>: 				<span class="keyword">try</span> &#123;</div><div class="line"><span class="number">44</span>: 					SessionSQLPair pair=seqSQLQueue.poll(<span class="number">100</span>,TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">45</span>: 					<span class="keyword">if</span>(pair!=<span class="keyword">null</span>)&#123;</div><div class="line"><span class="number">46</span>:                         executeSeq(pair);</div><div class="line"><span class="number">47</span>: 					&#125;</div><div class="line"><span class="number">48</span>: 				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">49</span>: 					LOGGER.warn(<span class="string">"MyCATSequenceProcessor$ExecutorThread"</span>,e);</div><div class="line"><span class="number">50</span>: 				&#125;</div><div class="line"><span class="number">51</span>: 			&#125;</div><div class="line"><span class="number">52</span>: 		&#125;</div><div class="line"><span class="number">53</span>: 	&#125;</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure>
<p>❓此处有个疑问：<code>MyCATSequnceProcessor</code> 是单线程，会不会插入性能有一定的影响？后续咱做下性能测试。</p>
<h1 id="4-获得-MySQL-连接，执行-SQL"><a href="#4-获得-MySQL-连接，执行-SQL" class="headerlink" title="4. 获得 MySQL 连接，执行 SQL"></a>4. 获得 MySQL 连接，执行 SQL</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/03.png" alt="【单库单表】插入（03执行 SQL）"></p>
<h2 id="【-1-8-】"><a href="#【-1-8-】" class="headerlink" title="【 1 - 8 】"></a>【 1 - 8 】</h2><p>获得 MySQL 连接。</p>
<ul>
<li>PhysicalDBNode ：物理数据库节点。</li>
<li>PhysicalDatasource ：物理数据库数据源。</li>
</ul>
<h2 id="【-9-13-】"><a href="#【-9-13-】" class="headerlink" title="【 9 - 13 】"></a>【 9 - 13 】</h2><p>发送 SQL 到 MySQL Server，执行 SQL。</p>
<h1 id="5-响应执行-SQL-结果"><a href="#5-响应执行-SQL-结果" class="headerlink" title="5. 响应执行 SQL 结果"></a>5. 响应执行 SQL 结果</h1><p><img src="http://www.yunai.me/images/MyCAT/2017_05_29/04.png" alt="【单库单表】插入（04执行响应）"></p>
<h2 id="【-1-4-】"><a href="#【-1-4-】" class="headerlink" title="【 1 - 4 】"></a>【 1 - 4 】</h2><p>处理 MySQL Server 响应数据包。</p>
<h2 id="【-5-8-】"><a href="#【-5-8-】" class="headerlink" title="【 5 - 8 】"></a>【 5 - 8 】</h2><p>发送插入成功结果给 MySQL Client。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/strong
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
</feed>
