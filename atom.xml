<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-10-05T16:04:54.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现 （二）之续租</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-renew/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-renew/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2017-10-05T16:04:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">http://www.iocoder.cn/Eureka/instance-registry-renew/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2. Eureka-Client 发起续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.1 初始化定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.2 HeartbeatThread</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">2.3 TimedSupervisorTask</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3. Eureka-Server 接收续租</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.1 接收续租请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">3.2 续租应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 续租应用实例的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li></ul><h1 id="2-Eureka-Client-发起续租"><a href="#2-Eureka-Client-发起续租" class="headerlink" title="2. Eureka-Client 发起续租"></a>2. Eureka-Client 发起续租</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例成功后获得租约 ( Lease )。<br>Eureka-Client <strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )，避免租约过期。</p><p>默认情况下，租约有效期为 90 秒，续租频率为 30 秒。两者比例为 1 : 3 ，保证在网络异常等情况下，有三次重试的机会。</p><h2 id="2-1-初始化定时任务"><a href="#2-1-初始化定时任务" class="headerlink" title="2.1 初始化定时任务"></a>2.1 初始化定时任务</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>心跳</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>续租</strong>( renew )。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">               <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                       .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                       .setDaemon(<span class="keyword">true</span>)</div><div class="line">                       .build());</div><div class="line"></div><div class="line">    heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">              <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">              <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                      .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">                      .setDaemon(<span class="keyword">true</span>)</div><div class="line">                      .build()</div><div class="line">    );  <span class="comment">// use direct handoff</span></div><div class="line">      </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">  </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); <span class="comment">// 续租频率</span></div><div class="line">        <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); <span class="comment">//</span></div><div class="line">        logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">        <span class="comment">// Heartbeat timer</span></div><div class="line">        scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line">               </div><div class="line">          <span class="comment">// ... 省略无关代码</span></div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>scheduler</code>，定时任务服务，用于定时触发心跳( 续租 )。细心如你，会发现任务提交的方式是 <code>ScheduledExecutorService#schedule(...)</code> 方法，<strong>只延迟执行一次心跳，说好的固定频率执行心跳呢</strong>！！！答案在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li><code>heartbeatExecutor</code>，心跳任务执行线程池。为什么有 <code>scheduler</code> 的情况下，还有 <code>heartbeatExecutor</code> ？？？答案也在 <a href="#">「2.3 TimedSupervisorTask」</a> 揭晓。</li><li>HeartbeatThread，心跳线程，在<a href="#">「2.2 TimedSupervisorTask」</a> 详细解析。</li></ul><h2 id="2-2-HeartbeatThread"><a href="#2-2-HeartbeatThread" class="headerlink" title="2.2 HeartbeatThread"></a>2.2 HeartbeatThread</h2><p><code>com.netflix.discovery.DiscoveryClient.HeartbeatThread</code>，心跳线程，<strong>实现</strong>执行 Eureka-Client 向 Eureka-Server 发起<strong>续租</strong>( renew )请求。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (renew()) &#123;</div><div class="line">           lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#renew</code> 方法，执行续租逻辑。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</div><div class="line">       logger.debug(<span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">       <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</div><div class="line">           REREGISTER_COUNTER.increment();</div><div class="line">           logger.info(<span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, PREFIX + appPathIdentifier, instanceInfo.getAppName());</div><div class="line">           <span class="keyword">long</span> timestamp = instanceInfo.setIsDirtyWithTime();</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           <span class="keyword">boolean</span> success = register();</div><div class="line">           <span class="keyword">if</span> (success) &#123;</div><div class="line">               instanceInfo.unsetIsDirty(timestamp);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> success;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, PREFIX + appPathIdentifier, e);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>AbstractJerseyEurekaHttpClient#sendHeartBeat(...)</code> 方法，发起<strong>续租请求</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;InstanceInfo&gt; <span class="title">sendHeartBeat</span><span class="params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl)</div><div class="line">               .path(urlPath)</div><div class="line">               .queryParam(<span class="string">"status"</span>, info.getStatus().toString())</div><div class="line">               .queryParam(<span class="string">"lastDirtyTimestamp"</span>, info.getLastDirtyTimestamp().toString());</div><div class="line">       <span class="keyword">if</span> (overriddenStatus != <span class="keyword">null</span>) &#123;</div><div class="line">           webResource = webResource.queryParam(<span class="string">"overriddenstatus"</span>, overriddenStatus.name());</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.put(ClientResponse.class);</div><div class="line">       EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(response.getStatus(), InstanceInfo.class).headers(headersOf(response));</div><div class="line">       <span class="keyword">if</span> (response.hasEntity()) &#123;</div><div class="line">           eurekaResponseBuilder.entity(response.getEntity(InstanceInfo.class));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> eurekaResponseBuilder.build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP PUT &#123;&#125;/&#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>PUT 请求 Eureka-Server 的 <code>apps/${APP_NAME}/${INSTANCE_INFO_ID}</code> 接口，参数为 <code>status</code>、<code>lastDirtyTimestamp</code>、<code>overriddenstatus</code>，实现续租。</li></ul></li><li><p>调用 <code>AbstractJerseyEurekaHttpClient#register(...)</code> 方法，当 Eureka-Server <strong>不存在租约</strong>时，重新发起注册，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a>有详细解析。</p></li></ul></li></ul><h2 id="2-3-TimedSupervisorTask"><a href="#2-3-TimedSupervisorTask" class="headerlink" title="2.3 TimedSupervisorTask"></a>2.3 TimedSupervisorTask</h2><p><code>com.netflix.discovery.TimedSupervisorTask</code>，监管<strong>定时任务</strong>的任务。</p><blockquote><p>A supervisor task that schedules subtasks while enforce a timeout.</p></blockquote><p>创建 TimedSupervisorTask 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedSupervisorTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter timeoutCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter rejectedCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Counter throwableCounter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongGauge threadPoolLevelGauge;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行子任务线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务执行超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 子任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前任子务执行频率</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong delay;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最大子任务执行频率</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 子任务执行超时情况下使用</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDelay;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimedSupervisorTask</span><span class="params">(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> timeout, TimeUnit timeUnit, <span class="keyword">int</span> expBackOffBound, Runnable task)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">        <span class="keyword">this</span>.timeoutMillis = timeUnit.toMillis(timeout);</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.delay = <span class="keyword">new</span> AtomicLong(timeoutMillis);</div><div class="line">        <span class="keyword">this</span>.maxDelay = timeoutMillis * expBackOffBound;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the counters and register.</span></div><div class="line">        timeoutCounter = Monitors.newCounter(<span class="string">"timeouts"</span>);</div><div class="line">        rejectedCounter = Monitors.newCounter(<span class="string">"rejectedExecutions"</span>);</div><div class="line">        throwableCounter = Monitors.newCounter(<span class="string">"throwables"</span>);</div><div class="line">        threadPoolLevelGauge = <span class="keyword">new</span> LongGauge(MonitorConfig.builder(<span class="string">"threadPoolUsed"</span>).build());</div><div class="line">        Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>scheduler</code> ，定时任务服务，用于定时【<strong>发起</strong>】子任务。</li><li><code>executor</code> ，执行子任务线程池，用于【<strong>提交</strong>】子任务执行。</li><li><code>task</code> ，子任务。</li><li><code>timeoutMillis</code> ，子任务执行超时时间，单位：毫秒。</li><li><code>delay</code> ，当前子任务执行频率，单位：毫秒。值等于 <code>timeout</code> 参数。</li><li><code>maxDelay</code> ，<strong>最大</strong>子任务执行频率，单位：毫秒。值等于 <code>timeout * expBackOffBound</code> 参数。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_01/02.png" alt=""></p><ul><li><code>scheduler</code> 初始化延迟执行 TimedSupervisorTask 。</li><li>TimedSupervisorTask 执行时，提交 <code>task</code> 到 <code>executor</code> 执行任务。<ul><li>当 <code>task</code> 执行正常，TimedSupervisorTask <strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟 <code>timeoutMillis</code> 执行。</li><li>当 <code>task</code> 执行超时，重新计算延迟时间( 不允许超过 <code>maxDelay</code> )，<strong>再次</strong>提交<strong>自己</strong>到<code>scheduler</code> 延迟执行。</li></ul></li></ul><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TimedSupervisorTask.java</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     Future&lt;?&gt; future = <span class="keyword">null</span>;</div><div class="line">  <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">5</span>:         <span class="comment">// 提交 任务</span></div><div class="line">  <span class="number">6</span>:         future = executor.submit(task);</div><div class="line">  <span class="number">7</span>:         <span class="comment">//</span></div><div class="line">  <span class="number">8</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 等待任务 执行完成 或 超时</span></div><div class="line"> <span class="number">10</span>:         future.get(timeoutMillis, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line"> <span class="number">11</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">12</span>:         delay.set(timeoutMillis);</div><div class="line"> <span class="number">13</span>:         <span class="comment">//</span></div><div class="line"> <span class="number">14</span>:         threadPoolLevelGauge.set((<span class="keyword">long</span>) executor.getActiveCount());</div><div class="line"> <span class="number">15</span>:     &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</div><div class="line"> <span class="number">16</span>:         logger.error(<span class="string">"task supervisor timed out"</span>, e);</div><div class="line"> <span class="number">17</span>:         timeoutCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">18</span>: </div><div class="line"> <span class="number">19</span>:         <span class="comment">// 设置 下一次任务执行频率</span></div><div class="line"> <span class="number">20</span>:         <span class="keyword">long</span> currentDelay = delay.get();</div><div class="line"> <span class="number">21</span>:         <span class="keyword">long</span> newDelay = Math.min(maxDelay, currentDelay * <span class="number">2</span>);</div><div class="line"> <span class="number">22</span>:         delay.compareAndSet(currentDelay, newDelay);</div><div class="line"> <span class="number">23</span>: </div><div class="line"> <span class="number">24</span>:     &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">26</span>:             logger.warn(<span class="string">"task supervisor shutting down, reject the task"</span>, e);</div><div class="line"> <span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">28</span>:             logger.error(<span class="string">"task supervisor rejected the task"</span>, e);</div><div class="line"> <span class="number">29</span>:         &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:         rejectedCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (executor.isShutdown() || scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">34</span>:             logger.warn(<span class="string">"task supervisor shutting down, can't accept the task"</span>);</div><div class="line"> <span class="number">35</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">36</span>:             logger.error(<span class="string">"task supervisor threw an exception"</span>, e);</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>: </div><div class="line"> <span class="number">39</span>:         throwableCounter.increment(); <span class="comment">//</span></div><div class="line"> <span class="number">40</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">41</span>:         <span class="comment">// 取消 未完成的任务</span></div><div class="line"> <span class="number">42</span>:         <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">43</span>:             future.cancel(<span class="keyword">true</span>);</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 调度 下次任务</span></div><div class="line"> <span class="number">47</span>:         <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line"> <span class="number">48</span>:             scheduler.schedule(<span class="keyword">this</span>, delay.get(), TimeUnit.MILLISECONDS);</div><div class="line"> <span class="number">49</span>:         &#125;</div><div class="line"> <span class="number">50</span>:     &#125;</div><div class="line"> <span class="number">51</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 6 行 ：提交子任务 <code>task</code> 到执行子任务线程池 <code>executor</code> 。</li><li>第 9 至 10 行 ：等待子任务 <code>task</code> 执行完成或执行超时。</li><li>第 11 至 12 行 ：子任务 <code>task</code> 执行完成，设置下一次执行延迟 <code>delay</code> 。</li><li>第 19 至 22 行 ：子任务 <code>task</code> 执行超时，重新计算下一次执行延迟 <code>delay</code> 。计算公式为 <code>Math.min(maxDelay, currentDelay * 2)</code> 。如果多次超时，超时时间不断乘以 2 ，不允许超过最大延迟时间( <code>maxDelay</code> )。</li><li>第 41 至 44 行 ：<strong>强制</strong>取消未完成的子任务。</li><li>第 46 至 49 行 ：调度下一次 TimedSupervisorTask 。</li></ul><h1 id="3-Eureka-Server-接收续租"><a href="#3-Eureka-Server-接收续租" class="headerlink" title="3. Eureka-Server 接收续租"></a>3. Eureka-Server 接收续租</h1><h2 id="3-1-接收续租请求"><a href="#3-1-接收续租请求" class="headerlink" title="3.1 接收续租请求"></a>3.1 接收续租请求</h2><p><code>com.netflix.eureka.resources.InstanceResource</code>，处理<strong>单个</strong>应用实例信息的请求操作的 Resource ( Controller )。</p><p>续租应用实例信息的请求，映射 <code>InstanceResource#renewLease()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@PUT</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:         @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function"> 4:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</span></div><div class="line"><span class="function"> 5:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</span></div><div class="line"><span class="function"> 6:         @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 续租</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 续租失败</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// Not found in the registry, immediately ask for a register</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">if</span> (!isSuccess) &#123;</div><div class="line"><span class="number">14</span>:         logger.warn(<span class="string">"Not Found (Renew): &#123;&#125; - &#123;&#125;"</span>, app.getName(), id);</div><div class="line"><span class="number">15</span>:         <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="comment">// 比较 InstanceInfo 的 lastDirtyTimestamp 属性</span></div><div class="line"><span class="number">19</span>:     <span class="comment">// Check if we need to sync based on dirty time stamp, the client</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// instance might have changed some value</span></div><div class="line"><span class="number">21</span>:     Response response = <span class="keyword">null</span>;</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span> &amp;&amp; serverConfig.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"><span class="number">23</span>:         response = <span class="keyword">this</span>.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);</div><div class="line"><span class="number">24</span>:         <span class="comment">// Store the overridden status since the validation found out the node that replicates wins</span></div><div class="line"><span class="number">25</span>:         <span class="keyword">if</span> (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()</div><div class="line"><span class="number">26</span>:                 &amp;&amp; (overriddenStatus != <span class="keyword">null</span>)</div><div class="line"><span class="number">27</span>:                 &amp;&amp; !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))</div><div class="line"><span class="number">28</span>:                 &amp;&amp; isFromReplicaNode) &#123;</div><div class="line"><span class="number">29</span>:             registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 成功</span></div><div class="line"><span class="number">32</span>:         response = Response.ok().build();</div><div class="line"><span class="number">33</span>:     &#125;</div><div class="line"><span class="number">34</span>:     logger.debug(<span class="string">"Found (Renew): &#123;&#125; - &#123;&#125;; reply status=&#123;&#125;"</span> + app.getName(), id, response.getStatus());</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 8 至 9 行 ：调用 <code>PeerAwareInstanceRegistryImpl#renew(...)</code> 方法，续租。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.renew(appName, id, isReplication)) &#123; <span class="comment">// 续租</span></div><div class="line">       <span class="comment">// Eureka-Server 复制</span></div><div class="line">       replicateToPeers(Action.Heartbeat, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#renew(...)</code> 方法，注册应用实例信息。</li></ul></li><li><p>第 11 至 16 行 ：续租失败，返回 404 响应。当 Eureka-Client 收到 404 响应后，会重新发起 InstanceInfo 的注册。</p></li><li><p>第 18 至 30 行 ：比较请求的 <code>lastDirtyTimestamp</code> 和 Server 的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 属性差异，需要配置 <code>eureka.syncWhenTimestampDiffers = true</code> ( 默认开启 )。</p><ul><li><p>第 23 行 ：调用 <code>#validateDirtyTimestamp(...)</code> 方法，比较 <code>lastDirtyTimestamp</code> 的差异。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceResource.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Response <span class="title">validateDirtyTimestamp</span><span class="params">(Long lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 获取 InstanceInfo</span></div><div class="line">  <span class="number">3</span>:     InstanceInfo appInfo = registry.getInstanceByAppAndId(app.getName(), id, <span class="keyword">false</span>);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (appInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">5</span>:         <span class="keyword">if</span> ((lastDirtyTimestamp != <span class="keyword">null</span>) &amp;&amp; (!lastDirtyTimestamp.equals(appInfo.getLastDirtyTimestamp()))) &#123;</div><div class="line">  <span class="number">6</span>:             Object[] args = &#123;id, appInfo.getLastDirtyTimestamp(), lastDirtyTimestamp, isReplication&#125;;</div><div class="line">  <span class="number">7</span>:             <span class="comment">// 请求 的 较大</span></div><div class="line">  <span class="number">8</span>:             <span class="keyword">if</span> (lastDirtyTimestamp &gt; appInfo.getLastDirtyTimestamp()) &#123;</div><div class="line">  <span class="number">9</span>:                 logger.debug(<span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">10</span>:                                 + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>, args);</div><div class="line"> <span class="number">11</span>:                 <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line"> <span class="number">12</span>:             <span class="comment">// Server 的 较大</span></div><div class="line"> <span class="number">13</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appInfo.getLastDirtyTimestamp() &gt; lastDirtyTimestamp) &#123;</div><div class="line"> <span class="number">14</span>:                 <span class="comment">// In the case of replication, send the current instance info in the registry for the</span></div><div class="line"> <span class="number">15</span>:                 <span class="comment">// replicating node to sync itself with this one.</span></div><div class="line"> <span class="number">16</span>:                 <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">17</span>:                     logger.debug(</div><div class="line"> <span class="number">18</span>:                             <span class="string">"Time to sync, since the last dirty timestamp differs -"</span></div><div class="line"> <span class="number">19</span>:                                     + <span class="string">" ReplicationInstance id : &#123;&#125;,Registry : &#123;&#125; Incoming: &#123;&#125; Replication: &#123;&#125;"</span>,</div><div class="line"> <span class="number">20</span>:                             args);</div><div class="line"> <span class="number">21</span>:                     <span class="keyword">return</span> Response.status(Status.CONFLICT).entity(appInfo).build();</div><div class="line"> <span class="number">22</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">23</span>:                     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">24</span>:                 &#125;</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:         &#125;</div><div class="line"> <span class="number">27</span>: </div><div class="line"> <span class="number">28</span>:     &#125;</div><div class="line"> <span class="number">29</span>:     <span class="keyword">return</span> Response.ok().build();</div><div class="line"> <span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 11 行 ：请求的 <code>lastDirtyTimestamp</code> 较大，<strong>意味着请求方( 可能是 Eureka-Client ，也可能是 Eureka-Server 集群内的其他 Server )存在 InstanceInfo 和 Eureka-Server 的 InstanceInfo 的数据不一致，返回 404 响应。请求方收到 404 响应后重新发起注册</strong>。</li><li>第 16 至 21 行 ：TODO[0021]：集群同步</li><li>第 22 至 24 行 ：Server 的 <code>lastDirtyTimestamp</code> 较大，并且请求方为 Eureka-Client，续租成功，返回 200 成功响应。</li><li>第 29 行 ：<code>lastDirtyTimestamp</code> 一致，返回 200 成功响应。</li></ul><ul><li>第 24 至 30 行 ：TODO[0022]：状态更新。</li></ul></li></ul></li><li><p>第 31 至 33 行 ：续租成功，返回 200 成功响应。</p></li></ul><h2 id="3-2-续租应用实例信息"><a href="#3-2-续租应用实例信息" class="headerlink" title="3.2 续租应用实例信息"></a>3.2 续租应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#renew(...)</code> 方法，续租应用实例信息，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 增加 续租次数 到 监控</span></div><div class="line"> <span class="number">3</span>:     RENEW.increment(isReplication);</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获得 租约</span></div><div class="line"> <span class="number">5</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"> <span class="number">6</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">8</span>:         leaseToRenew = gMap.get(id);</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">15</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></div><div class="line"><span class="number">19</span>:             <span class="comment">// TODO 芋艿：over status</span></div><div class="line"><span class="number">20</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"><span class="number">21</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"><span class="number">22</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"><span class="number">23</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"><span class="number">24</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"><span class="number">25</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"><span class="number">26</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"><span class="number">29</span>:                 Object[] args = &#123;</div><div class="line"><span class="number">30</span>:                         instanceInfo.getStatus().name(),</div><div class="line"><span class="number">31</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"><span class="number">32</span>:                         instanceInfo.getId()</div><div class="line"><span class="number">33</span>:                 &#125;;</div><div class="line"><span class="number">34</span>:                 logger.info(</div><div class="line"><span class="number">35</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"><span class="number">36</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"><span class="number">37</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">38</span>:             &#125;</div><div class="line"><span class="number">39</span>:         &#125;</div><div class="line"><span class="number">40</span>:         <span class="comment">// TODO 芋艿：可能和自我保护</span></div><div class="line"><span class="number">41</span>:         renewsLastMin.increment();</div><div class="line"><span class="number">42</span>:         <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">43</span>:         leaseToRenew.renew();</div><div class="line"><span class="number">44</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 3 行 ：增加续租次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 4 至 9 行 ：获得租约( Lease )。</li><li>第 10 至 14 行 ：租约不存在，返回续租失败( <code>false</code> )。</li><li>第 19 至 39 行 ：TODO[0022]：状态更新。</li><li>第 40 至 41 行 ：TODO[0023]：自我保护。</li><li><p>第 42 至 43 行 ：调用 <code>Lease#renew()</code> 方法，设置租约最后更新时间( 续租 )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 44 行 ：返回续租成功( <code>true</code> )。</p></li><li><strong>整个过程修改的租约的过期时间，即使并发请求，也不会对数据的一致性产生不一致的影响，因此像注册操作一样加锁</strong>。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>效率比想象的低一些，加油继续更新下一篇。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-renew/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-renew/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现 （一）之注册</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-register/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-register/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2017-10-05T15:43:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-register/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2. Eureka-Client 发起注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.1 应用实例信息复制器</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.2 刷新应用实例信息</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">2.3 发起注册应用实例</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3. Eureka-Server 接收注册</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.1 接收注册请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.2 Lease</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">3.3 注册应用实例信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-register/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 注册应用实例的过程</strong>。</p><blockquote><p>FROM <a href="%E3%80%8Ahttp://techshow.ctrip.com/archives/1699.html%E3%80%8B">《深度剖析服务发现组件Netflix Eureka》</a> 二次编辑<br><img src="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg" alt=""></p></blockquote><ul><li><strong>蓝框</strong>部分，为本文重点。</li><li>非<strong>蓝框</strong>部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. Eureka-Client 发起注册</h1><p>Eureka-Client 向 Eureka-Server 发起注册应用实例需要符合如下条件：</p><ul><li>配置 <code>eureka.registration.enabled = true</code>，Eureka-Client 向 Eureka-Server 发起注册应用实例的<strong>开关</strong>。</li><li>InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致。</li></ul><p>每次 InstanceInfo 发生<strong>属性变化</strong>时，标记 <code>isInstanceInfoDirty</code> 属性为 <code>true</code>，表示 InstanceInfo 在 Eureka-Client 和 Eureka-Server 数据不一致，需要注册。另外，InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册。</p><p>当符合条件时，InstanceInfo 不会立即向 Eureka-Server 注册，而是后台线程<strong>定时</strong>注册。</p><p>当 InstanceInfo 的状态( <code>status</code> ) 属性发生变化时，并且配置 <code>eureka.shouldOnDemandUpdateStatusChange = true</code> 时，立即向 Eureka-Server 注册。<strong>因为状态属性非常重要，一般情况下建议开启，当然默认情况也是开启的</strong>。</p><p>Let's Go。让我们看看代码的实现。</p><h2>2.1 应用实例信息复制器</h2><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClient</span> <span class="keyword">implements</span> <span class="title">EurekaClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ApplicationInfoManager.StatusChangeListener statusChangeListener;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息复制器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfoReplicator instanceInfoReplicator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">        </div><div class="line">            <span class="comment">// ... 省略无关代码</span></div><div class="line">            </div><div class="line">            <span class="comment">// 创建 应用实例信息复制器</span></div><div class="line">            <span class="comment">// InstanceInfo replicator</span></div><div class="line">            instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">                    <span class="keyword">this</span>,</div><div class="line">                    instanceInfo,</div><div class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">                    <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">            <span class="comment">// 创建 应用实例状态变更监听器</span></div><div class="line">            statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                        <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                        logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">                    &#125;</div><div class="line">                    instanceInfoReplicator.onDemandUpdate();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">            <span class="comment">// 注册 应用实例状态变更监听器</span></div><div class="line">            <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">                applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 开启 应用实例信息复制器</span></div><div class="line">            instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.discovery.InstanceInfoReplicator</code>，应用实例信息复制器。</p><ul><li><p>调用 <code>InstanceInfoReplicator#start(...)</code> 方法，<strong>开启</strong>应用实例信息复制器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InstanceInfoReplicator.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscoveryClient discoveryClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行频率，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicationIntervalSeconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时执行任务的 Future</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Future&gt; scheduledPeriodicRef;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否开启调度</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean started;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> burstSize; <span class="comment">// 限流相关，跳过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> allowedRatePerMinute; <span class="comment">// 限流相关，跳过</span></div><div class="line"></div><div class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, <span class="keyword">int</span> replicationIntervalSeconds, <span class="keyword">int</span> burstSize) &#123;</div><div class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.scheduler = Executors.newScheduledThreadPool(<span class="number">1</span>,</div><div class="line">                <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                        .setNameFormat(<span class="string">"DiscoveryClient-InstanceInfoReplicator-%d"</span>)</div><div class="line">                        .setDaemon(<span class="keyword">true</span>)</div><div class="line">                        .build());</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.scheduledPeriodicRef = <span class="keyword">new</span> AtomicReference&lt;Future&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.started = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">this</span>.rateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">this</span>.replicationIntervalSeconds = replicationIntervalSeconds;</div><div class="line">        <span class="keyword">this</span>.burstSize = burstSize;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.allowedRatePerMinute = <span class="number">60</span> * <span class="keyword">this</span>.burstSize / <span class="keyword">this</span>.replicationIntervalSeconds;</div><div class="line">        logger.info(<span class="string">"InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;"</span>, allowedRatePerMinute);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> initialDelayMs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (started.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            <span class="comment">// 设置 应用实例信息 数据不一致</span></div><div class="line">            instanceInfo.setIsDirty();  <span class="comment">// for initial register</span></div><div class="line">            <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">            Future next = scheduler.schedule(<span class="keyword">this</span>, initialDelayMs, TimeUnit.SECONDS);</div><div class="line">            scheduledPeriodicRef.set(next);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Long lastDirtyTimestamp;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setIsDirty</span><span class="params">()</span> </span>&#123;</div><div class="line">   isInstanceInfoDirty = <span class="keyword">true</span>;</div><div class="line">   lastDirtyTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>执行 <code>instanceInfo.setIsDirty()</code> 代码块，因为 <strong>InstanceInfo 刚被创建时，在 Eureka-Server 不存在，也会被注册</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，延迟 <code>initialDelayMs</code> 毫秒执行<strong>一次</strong>任务。为什么此处设置 <code>scheduledPeriodicRef</code> ？在 <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法会看到具体用途。</li></ul></li><li><p><strong>定时</strong>检查 InstanceInfo 的状态( <code>status</code> ) 属性是否发生变化。<strong>若是</strong>，发起注册。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 刷新 应用实例信息</span></div><div class="line">       discoveryClient.refreshInstanceInfo();</div><div class="line">       <span class="comment">// 判断 应用实例信息 是否数据不一致</span></div><div class="line">       Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</div><div class="line">       <span class="keyword">if</span> (dirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">// 发起注册</span></div><div class="line">           discoveryClient.register();</div><div class="line">           <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">           instanceInfo.unsetIsDirty(dirtyTimestamp);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.warn(<span class="string">"There was a problem with the instance info replicator"</span>, t);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 提交任务，并设置该任务的 Future</span></div><div class="line">       Future next = scheduler.schedule(<span class="keyword">this</span>, replicationIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">       scheduledPeriodicRef.set(next);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">setIsDirtyWithTime</span><span class="params">()</span> </span>&#123;</div><div class="line">   setIsDirty();</div><div class="line">   <span class="keyword">return</span> lastDirtyTimestamp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unsetIsDirty</span><span class="params">(<span class="keyword">long</span> unsetDirtyTimestamp)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (lastDirtyTimestamp &lt;= unsetDirtyTimestamp) &#123;</div><div class="line">       isInstanceInfoDirty = <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，在<a href="#">「2.2」刷新应用实例信息</a> 详细解析。</li><li>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>。</li><li>调用 <code>ScheduledExecutorService#schedule(...)</code> 方法，再次延迟执行任务，并设置 <code>scheduledPeriodicRef</code>。通过这样的方式，不断<strong>循环</strong>定时执行任务。</li></ul></li></ul></li><li><p><code>com.netflix.appinfo.ApplicationInfoManager.StatusChangeListener</code> <strong>内部类</strong>，监听应用实例信息状态的变更。</p><ul><li><p>调用 <code>ApplicationInfoManager#registerStatusChangeListener(...)</code> 方法，注册应用实例状态变更监听器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStatusChangeListener</span><span class="params">(StatusChangeListener listener)</span> </span>&#123;</div><div class="line">        listeners.put(listener.getId(), listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><strong>业务里</strong>，调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法，设置应用实例信息的状态，从而<strong>通知</strong> <code>InstanceInfoReplicator#onDemandUpdate()</code> 方法的调用。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setInstanceStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   InstanceStatus next = instanceStatusMapper.map(status);</div><div class="line">   <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceStatus prev = instanceInfo.setStatus(next);</div><div class="line">   <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (StatusChangeListener listener : listeners.values()) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               listener.notify(<span class="keyword">new</span> StatusChangeEvent(prev, next));</div><div class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">               logger.warn(<span class="string">"failed to notify listener: &#123;&#125;"</span>, listener.getId(), e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceStatus <span class="title">setStatus</span><span class="params">(InstanceStatus status)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status != status) &#123;</div><div class="line">       InstanceStatus prev = <span class="keyword">this</span>.status;</div><div class="line">       <span class="keyword">this</span>.status = status;</div><div class="line">       <span class="comment">// 设置 应用实例信息 数据一致</span></div><div class="line">       setIsDirty();</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>InstanceInfoReplicator#onDemandUpdate()</code>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfoReplicator.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDemandUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123; <span class="comment">// 限流相关，跳过</span></div><div class="line">       scheduler.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               logger.debug(<span class="string">"Executing on-demand update of local InstanceInfo"</span>);</div><div class="line">               <span class="comment">// 取消任务</span></div><div class="line">               Future latestPeriodic = scheduledPeriodicRef.get();</div><div class="line">               <span class="keyword">if</span> (latestPeriodic != <span class="keyword">null</span> &amp;&amp; !latestPeriodic.isDone()) &#123;</div><div class="line">                   logger.debug(<span class="string">"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update"</span>);</div><div class="line">                   latestPeriodic.cancel(<span class="keyword">false</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="comment">// 再次调用</span></div><div class="line">               InstanceInfoReplicator.<span class="keyword">this</span>.run();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.warn(<span class="string">"Ignoring onDemand update due to rate limiter"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>Future#cancel(false)</code> 方法，取消定时任务，<strong>避免无用的注册</strong>。</li><li>调用 <code>InstanceInfoReplicator#run()</code> 方法，发起注册。</li></ul></li></ul></li></ul><h2>2.2 刷新应用实例信息</h2><p>调用 <code>DiscoveryClient#refreshInstanceInfo()</code> 方法，刷新应用实例信息。<strong>此处可能导致应用实例信息数据不一致</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">refreshInstanceInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 刷新 数据中心信息</span></div><div class="line">   applicationInfoManager.refreshDataCenterInfoIfRequired();</div><div class="line">   <span class="comment">// 刷新 租约信息</span></div><div class="line">   applicationInfoManager.refreshLeaseInfoIfRequired();</div><div class="line">   <span class="comment">// 健康检查</span></div><div class="line">   InstanceStatus status;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       status = getHealthCheckHandler().getStatus(instanceInfo.getStatus());</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Exception from healthcheckHandler.getStatus, setting status to DOWN"</span>, e);</div><div class="line">       status = InstanceStatus.DOWN;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</div><div class="line">       applicationInfoManager.setInstanceStatus(status);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>ApplicationInfoManager#refreshDataCenterInfoIfRequired()</code> 方法，刷新数据中心相关信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshDataCenterInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// hostname</span></div><div class="line">   String existingAddress = instanceInfo.getHostName();</div><div class="line">   String newAddress;</div><div class="line">   <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line">       <span class="comment">// Refresh data center info, and return up to date address</span></div><div class="line">       newAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">true</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       newAddress = config.getHostName(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ip</span></div><div class="line">   String newIp = config.getIpAddress();</div><div class="line">   <span class="keyword">if</span> (newAddress != <span class="keyword">null</span> &amp;&amp; !newAddress.equals(existingAddress)) &#123;</div><div class="line">       logger.warn(<span class="string">"The address changed from : &#123;&#125; =&gt; &#123;&#125;"</span>, existingAddress, newAddress);</div><div class="line">       <span class="comment">// :( in the legacy code here the builder is acting as a mutator.</span></div><div class="line">       <span class="comment">// This is hard to fix as this same instanceInfo instance is referenced elsewhere.</span></div><div class="line">       <span class="comment">// We will most likely re-write the client at sometime so not fixing for now.</span></div><div class="line">       InstanceInfo.Builder builder = <span class="keyword">new</span> InstanceInfo.Builder(instanceInfo);</div><div class="line">       builder.setHostName(newAddress) <span class="comment">// hostname</span></div><div class="line">               .setIPAddr(newIp) <span class="comment">// ip</span></div><div class="line">               .setDataCenterInfo(config.getDataCenterInfo()); <span class="comment">// dataCenterInfo</span></div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">(<span class="keyword">boolean</span> refresh)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.second();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hostInfo.first();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>关注应用实例信息的 <code>hostName</code> 、 <code>ipAddr</code> 、 <code>dataCenterInfo</code> 属性的变化。</li><li>一般情况下，我们使用的是非 RefreshableInstanceConfig 实现的配置类( 一般是 MyDataCenterInstanceConfig )，因为 <code>AbstractInstanceConfig.hostInfo</code> 是<strong>静态属性</strong>，<strong>即使本机修改了 IP 等信息，Eureka-Client 进程也不会感知到</strong>。TODO[0022]：看下springcloud 的实现</li></ul></li><li><p>调用 <code>ApplicationInfoManager#refreshLeaseInfoIfRequired()</code> 方法，刷新租约相关信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshLeaseInfoIfRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">   LeaseInfo leaseInfo = instanceInfo.getLeaseInfo();</div><div class="line">   <span class="keyword">if</span> (leaseInfo == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> currentLeaseDuration = config.getLeaseExpirationDurationInSeconds();</div><div class="line">   <span class="keyword">int</span> currentLeaseRenewal = config.getLeaseRenewalIntervalInSeconds();</div><div class="line">   <span class="keyword">if</span> (leaseInfo.getDurationInSecs() != currentLeaseDuration <span class="comment">// 租约过期时间 改变</span></div><div class="line">           || leaseInfo.getRenewalIntervalInSecs() != currentLeaseRenewal) &#123; <span class="comment">// 租约续约频率 改变</span></div><div class="line">       LeaseInfo newLeaseInfo = LeaseInfo.Builder.newBuilder()</div><div class="line">               .setRenewalIntervalInSecs(currentLeaseRenewal)</div><div class="line">               .setDurationInSecs(currentLeaseDuration)</div><div class="line">               .build();</div><div class="line">       instanceInfo.setLeaseInfo(newLeaseInfo);</div><div class="line">       instanceInfo.setIsDirty();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>关注应用实例信息的 <code>renewalIntervalInSecs</code> 、 <code>durationInSecs</code> 属性的变化。</li></ul></li><li><p>调用 <code>HealthCheckHandler#getStatus()</code> 方法，健康检查。这里先暂时跳过，我们在<a href="#">TODO[0004]：健康检查</a> 详细解析。</p></li></ul><h2>2.3 发起注册应用实例</h2><p>调用 <code>DiscoveryClient#register()</code> 方法，<strong>Eureka-Client 向 Eureka-Server 注册应用实例</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   logger.info(PREFIX + appPathIdentifier + <span class="string">": registering service..."</span>);</div><div class="line">   EurekaHttpResponse&lt;Void&gt; httpResponse;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"&#123;&#125; - registration failed &#123;&#125;"</span>, PREFIX + appPathIdentifier, e.getMessage(), e);</div><div class="line">       <span class="keyword">throw</span> e;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">       logger.info(<span class="string">"&#123;&#125; - registration status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">204</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line">   String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line">       addExtraHeaders(resourceBuilder);</div><div class="line">       response = resourceBuilder</div><div class="line">               .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</div><div class="line">               .type(MediaType.APPLICATION_JSON_TYPE)</div><div class="line">               .accept(MediaType.APPLICATION_JSON)</div><div class="line">               .post(ClientResponse.class, info);</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>EurekaHttpResponse#register(...)</code> 方法，<code>POST</code> 请求 Eureka-Server 的 <code>apps/${APP_NAME}</code> 接口，参数为 InstanceInfo ，实现注册实例信息的注册。</li></ul><h1>3. Eureka-Server 接收注册</h1><h2>3.1 接收注册请求</h2><p><code>com.netflix.eureka.resources.ApplicationResource</code>，处理<strong>单个</strong>应用的请求操作的 Resource ( Controller )。</p><p>注册应用实例信息的请求，映射 <code>ApplicationResource#addInstance()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@POST</span></div><div class="line">    <span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></div><div class="line"><span class="function"><span class="params">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</div><div class="line">        <span class="comment">// 校验参数是否合法</span></div><div class="line">        logger.debug(<span class="string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);</div><div class="line">        <span class="comment">// validate that the instanceinfo contains all the necessary required fields</span></div><div class="line">        <span class="keyword">if</span> (isBlank(info.getId())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing instanceId"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getHostName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing hostname"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getIPAddr())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing ip address"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing appName"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!appName.equals(info.getAppName())) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Mismatched appName, expecting "</span> + appName + <span class="string">" but was "</span> + info.getAppName()).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo"</span>).build();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo().getName() == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo Name"</span>).build();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// AWS 相关，跳过</span></div><div class="line">        <span class="comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span></div><div class="line">        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</div><div class="line">        <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line">            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line">            <span class="keyword">if</span> (isBlank(dataCenterInfoId)) &#123;</div><div class="line">                <span class="keyword">boolean</span> experimental = <span class="string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="string">"registration.validation.dataCenterInfoId"</span>));</div><div class="line">                <span class="keyword">if</span> (experimental) &#123;</div><div class="line">                    String entity = <span class="string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="string">" must contain a valid id"</span>;</div><div class="line">                    <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(entity).build();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> AmazonInfo) &#123;</div><div class="line">                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</div><div class="line">                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</div><div class="line">                    <span class="keyword">if</span> (effectiveId == <span class="keyword">null</span>) &#123;</div><div class="line">                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    logger.warn(<span class="string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 注册应用实例信息</span></div><div class="line">        registry.register(info, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">        <span class="comment">// 返回 204 成功</span></div><div class="line">        <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>请求头 <code>isReplication</code> 参数，和 Eureka-Server 集群复制相关，暂时跳过。</p></li><li><p>调用 <code>PeerAwareInstanceRegistryImpl#register(...)</code> 方法，注册应用实例信息。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用父类 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息。</li></ul></li></ul><h2>3.2 Lease</h2><p>在看具体的注册应用实例信息的逻辑之前，我们先来看下 <code>com.netflix.eureka.lease.Lease</code>，租约。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lease</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> T holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> registrationTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始服务时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serviceUpTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消注册时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> evictionTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">// Make it volatile so that the expiration task would see this quicker</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastUpdateTimestamp;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约持续时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> duration;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lease</span><span class="params">(T r, <span class="keyword">int</span> durationInSecs)</span> </span>&#123;</div><div class="line">        holder = r;</div><div class="line">        registrationTimestamp = System.currentTimeMillis();</div><div class="line">        lastUpdateTimestamp = registrationTimestamp;</div><div class="line">        duration = (durationInSecs * <span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>holder</code> 属性，租约的持有者。在 Eureka-Server 里，暂时只有 InstanceInfo 使用。</p></li><li><p><code>registrationTimestamp</code> 属性，注册( 创建 )租约时间戳。在<strong>构造方法</strong>里可以看租约对象的创建时间戳即为注册租约时间戳。</p></li><li><p><code>serviceUpTimestamp</code> 属性，开始服务时间戳。注册应用实例信息会使用到它如下两个方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serviceUpTimestamp == <span class="number">0</span>) &#123; <span class="comment">// 第一次有效</span></div><div class="line">       serviceUpTimestamp = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceUpTimestamp</span><span class="params">(<span class="keyword">long</span> serviceUpTimestamp)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.serviceUpTimestamp = serviceUpTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>lastUpdatedTimestamp</code> 属性，最后更新租约时间戳。每次续租时，更新该时间戳。注册应用实例信息会使用到它如下方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdatedTimestamp</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.lastUpdatedTimestamp = System.currentTimeMillis();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>duration</code> 属性，租约持续时间，单位：毫秒。当租约过久未续租，即当前时间 - <code>lastUpdatedTimestamp</code> &gt; <code>duration</code> 时，租约过期。</p></li><li><p><code>evictionTimestamp</code> 属性，租约过期时间戳。</p></li></ul><h2>3.3 注册应用实例信息</h2><p>调用 <code>AbstractInstanceRegistry#register(...)</code> 方法，注册应用实例信息，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// TODO 为什么是读锁</span></div><div class="line"> <span class="number">4</span>:         read.lock();</div><div class="line"> <span class="number">5</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 增加 注册次数 到 监控</span></div><div class="line"> <span class="number">7</span>:         REGISTER.increment(isReplication);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 获得 应用实例信息 对应的 租约</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</div><div class="line"><span class="number">11</span>:             gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap); <span class="comment">// 添加 应用</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (gMap == <span class="keyword">null</span>) &#123; <span class="comment">// 添加 应用 成功</span></div><div class="line"><span class="number">13</span>:                 gMap = gNewMap;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line"><span class="number">17</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"><span class="number">19</span>:             Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp(); <span class="comment">// Server 注册的 InstanceInfo</span></div><div class="line"><span class="number">20</span>:             Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp(); <span class="comment">// Client 请求的 InstanceInfo</span></div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span></div><div class="line"><span class="number">24</span>:             <span class="comment">// InstanceInfo instead of the server local copy.</span></div><div class="line"><span class="number">25</span>:             <span class="keyword">if</span> (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</div><div class="line"><span class="number">26</span>:                 logger.warn(<span class="string">"There is an existing lease and the existing lease's dirty timestamp &#123;&#125; is greater"</span> +</div><div class="line"><span class="number">27</span>:                         <span class="string">" than the one that is being registered &#123;&#125;"</span>, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</div><div class="line"><span class="number">28</span>:                 logger.warn(<span class="string">"Using the existing instanceInfo instead of the new instanceInfo as the registrant"</span>);</div><div class="line"><span class="number">29</span>:                 registrant = existingLease.getHolder();</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">32</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"><span class="number">33</span>:             <span class="comment">// TODO 芋艿：可能和限流或者自我保护有关</span></div><div class="line"><span class="number">34</span>:             <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     <span class="comment">// Since the client wants to cancel it, reduce the threshold</span></div><div class="line"><span class="number">37</span>:                     <span class="comment">// (1</span></div><div class="line"><span class="number">38</span>:                     <span class="comment">// for 30 seconds, 2 for a minute)</span></div><div class="line"><span class="number">39</span>:                     <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin + <span class="number">2</span>;</div><div class="line"><span class="number">40</span>:                     <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line"><span class="number">41</span>:                             (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">42</span>:                 &#125;</div><div class="line"><span class="number">43</span>:             &#125;</div><div class="line"><span class="number">44</span>:             logger.debug(<span class="string">"No previous lease information found; it is new registration"</span>);</div><div class="line"><span class="number">45</span>:         &#125;</div><div class="line"><span class="number">46</span>:         <span class="comment">// 创建 租约</span></div><div class="line"><span class="number">47</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"><span class="number">48</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"><span class="number">49</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"><span class="number">50</span>:         &#125;</div><div class="line"><span class="number">51</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"><span class="number">52</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"><span class="number">53</span>:         <span class="comment">// 添加到 最近注册的调试队列</span></div><div class="line"><span class="number">54</span>:         <span class="keyword">synchronized</span> (recentRegisteredQueue) &#123;</div><div class="line"><span class="number">55</span>:             recentRegisteredQueue.add(<span class="keyword">new</span> Pair&lt;Long, String&gt;(</div><div class="line"><span class="number">56</span>:                     System.currentTimeMillis(),</div><div class="line"><span class="number">57</span>:                     registrant.getAppName() + <span class="string">"("</span> + registrant.getId() + <span class="string">")"</span>));</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:         <span class="comment">// TODO 芋艿</span></div><div class="line"><span class="number">60</span>:         <span class="comment">// This is where the initial state transfer of overridden status happens</span></div><div class="line"><span class="number">61</span>:         <span class="keyword">if</span> (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</div><div class="line"><span class="number">62</span>:             logger.debug(<span class="string">"Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the "</span></div><div class="line"><span class="number">63</span>:                             + <span class="string">"overrides"</span>, registrant.getOverriddenStatus(), registrant.getId());</div><div class="line"><span class="number">64</span>:             <span class="keyword">if</span> (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</div><div class="line"><span class="number">65</span>:                 logger.info(<span class="string">"Not found overridden id &#123;&#125; and hence adding it"</span>, registrant.getId());</div><div class="line"><span class="number">66</span>:                 overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</div><div class="line"><span class="number">67</span>:             &#125;</div><div class="line"><span class="number">68</span>:         &#125;</div><div class="line"><span class="number">69</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"><span class="number">70</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">71</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"><span class="number">72</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"><span class="number">73</span>:         &#125;</div><div class="line"><span class="number">74</span>: </div><div class="line"><span class="number">75</span>:         <span class="comment">// TODO 芋艿</span></div><div class="line"><span class="number">76</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"><span class="number">77</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"><span class="number">78</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"><span class="number">79</span>: </div><div class="line"><span class="number">80</span>:         <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">81</span>:         <span class="comment">// If the lease is registered with UP status, set lease service up timestamp</span></div><div class="line"><span class="number">82</span>:         <span class="keyword">if</span> (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</div><div class="line"><span class="number">83</span>:             lease.serviceUp();</div><div class="line"><span class="number">84</span>:         &#125;</div><div class="line"><span class="number">85</span>:         <span class="comment">// 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"><span class="number">86</span>:         registrant.setActionType(ActionType.ADDED);</div><div class="line"><span class="number">87</span>:         <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">88</span>:         recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">89</span>:         <span class="comment">// 设置 租约的最后更新时间戳</span></div><div class="line"><span class="number">90</span>:         registrant.setLastUpdatedTimestamp();</div><div class="line"><span class="number">91</span>:         <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">92</span>:         invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</div><div class="line"><span class="number">93</span>:         logger.info(<span class="string">"Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)"</span>,</div><div class="line"><span class="number">94</span>:                 registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</div><div class="line"><span class="number">95</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">96</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">97</span>:         read.unlock();</div><div class="line"><span class="number">98</span>:     &#125;</div><div class="line"><span class="number">99</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 行 ：TODO 为什么是读锁。</p></li><li><p>第 6 至 7 行 ：增加注册次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p></li><li><p>第 5 至 16 行 ：获得应用实例信息对应的<strong>租约</strong>。<code>registry</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 租约映射</span></div><div class="line"><span class="comment"> * key1 ：应用名 &#123;<span class="doctag">@link</span> InstanceInfo#appName&#125;</span></div><div class="line"><span class="comment"> * key2 ：应用实例信息编号 &#123;<span class="doctag">@link</span> InstanceInfo#instanceId&#125;</span></div><div class="line"><span class="comment"> * value ：租约</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</div></pre></td></tr></table></figure></p></li><li><p>第 17 至 30 行 ：当租约<strong>已存在</strong>，判断 Server 已存在的 InstanceInfo 的 <code>lastDirtyTimestamp</code> 是否<strong>大于</strong>( 不包括等于 ) Client 请求的 InstanceInfo ，<strong>若是，使用 Server 的 InstanceInfo 进行替代</strong>。</p></li><li><p>第 31 至 44 行 ：TODO 芋艿：可能和限流或者自我保护有关</p></li><li><p>第 45 至 52 行 ：创建租约，并添加到租约映射( <code>registry</code> )。</p></li><li><p>第 53 至 58 行 ：添加到最近注册的<strong>调试</strong>队列( <code>recentRegisteredQueue</code> )，用于 Eureka-Server 运维界面的显示，无实际业务逻辑使用。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近注册的调试队列</span></div><div class="line"><span class="comment">* key ：添加时的时间戳</span></div><div class="line"><span class="comment">* value ：字符串 = 应用名(应用实例信息编号)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CircularQueue&lt;Pair&lt;Long, String&gt;&gt; recentRegisteredQueue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 循环队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;E&gt; 泛型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 队列大小</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.size = size;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 保证空间足够</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * 当空间不够时，移除首元素</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSpaceIfNotAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.size() == size) &#123;</div><div class="line">           <span class="keyword">this</span>.remove();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.makeSpaceIfNotAvailable();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.offer(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 59 至 73 行 ： TODO 芋艿</p></li><li><p>第 75 至 78 行 ： TODO 芋艿</p></li><li><p>第 80 至 84 行 ：设置租约的开始服务的时间戳( <strong>只有第一次有效</strong> )。</p></li><li><p>第 85 至 88 行 ：设置应用实例信息的<strong>操作类型为添加</strong>，并添加到最近租约变更记录队列( <code>recentlyChangedQueue</code> )。<code>recentlyChangedQueue</code> 用于注册信息的<strong>增量</strong>获取，在<a href="TODO">《应用实例注册发现 （五）之增量获取》</a>详细解析。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div></pre></td></tr></table></figure></p></li><li><p>第 89 至 90 行 ：设置租约的最后更新时间戳。</p></li><li><p>第 91 至 92 行 ：设置响应缓存( ResponseCache )过期，在<a href="TODO">《Eureka 源码解析 —— 应用实例注册发现 （五）之全量获取》</a>详细解析。</p></li><li><p>第 96 至 97 行 ：释放锁。</p></li></ul><h1>666. 彩蛋</h1><p>嘿嘿，蛮嗨的，比起前面几篇写配置相关的文章来说。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-register/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iocoder.cn/Eureka/
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 注册表 InstanceRegistry 类关系</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-class-diagram/</id>
    <published>2018-05-20T16:00:00.000Z</published>
    <updated>2017-10-05T04:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/">http://www.iocoder.cn/Eureka/instance-registry-class-diagram/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">2. 类图</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">3. LookupService</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">4. LeaseManager</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">5. InstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">6. AbstractInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">7. PeerAwareInstanceRegistry</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">8. PeerAwareInstanceRegistryImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?toc">666. 彩蛋</a></li></ul><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要简介 <strong>注册表 InstanceRegistry 的类关系</strong>，为后文的<strong>应用实例注册发现</strong>、<strong>Eureka-Server 集群复制</strong>做整体的铺垫。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-类图"><a href="#2-类图" class="headerlink" title="2. 类图"></a>2. 类图</h1><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_21/01.png" alt=""></p><ul><li><code>com.netflix.eureka.registry.AwsInstanceRegistry</code>，主要用于亚马逊 AWS，跳过。</li><li><code>com.netflix.eureka.registry.RemoteRegionRegistry</code>，笔者暂时不太理解它的用途。目前猜测 Eureka-Server 集群和集群之间的注册信息的交互方式。查阅官方资料，<a href="https://github.com/Netflix/eureka/issues/29" rel="external nofollow noopener noreferrer" target="_blank">《Add ability to retrieve instances from any remote region》</a> 在做了简单介绍。翻看目前网络上的博客、书籍、项目实战，暂时都没提及此块。估摸和亚马逊 AWS 跨区域( <code>region</code> ) 机制有一定关系，先暂时跳过。有了解此块的同学，麻烦告知下笔者，万分感谢。TODO[0009]：RemoteRegionRegistry。</li><li><strong>蓝框</strong>部分，本文主角。</li></ul><h1 id="3-LookupService"><a href="#3-LookupService" class="headerlink" title="3. LookupService"></a>3. LookupService</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LookupService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Application <span class="title">getApplication</span><span class="params">(String appName)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">Applications <span class="title">getApplications</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">List&lt;InstanceInfo&gt; <span class="title">getInstancesById</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">InstanceInfo <span class="title">getNextServerFromEureka</span><span class="params">(String virtualHostname, <span class="keyword">boolean</span> secure)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1 id="4-LeaseManager"><a href="#4-LeaseManager" class="headerlink" title="4. LeaseManager"></a>4. LeaseManager</h1><p><code>com.netflix.eureka.lease.LeaseManager</code>，租约管理器<strong>接口</strong>，提供租约的注册、续租、取消( 主动下线 )、过期( 过期下线 )。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LeaseManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T r, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="5-InstanceRegistry"><a href="#5-InstanceRegistry" class="headerlink" title="5. InstanceRegistry"></a>5. InstanceRegistry</h1><p><code>com.netflix.eureka.registry.InstanceRegistry</code>，<strong>应用实例</strong>注册表<strong>接口</strong>。它继承了 LookupService 、LeaseManager 接口，提供应用实例的<strong>注册</strong>与<strong>发现</strong>服务。另外，它结合实际业务场景，定义了<strong>更加丰富</strong>的接口方法。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceRegistry</span> <span class="keyword">extends</span> <span class="title">LeaseManager</span>&lt;<span class="title">InstanceInfo</span>&gt;, <span class="title">LookupService</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 开启与关闭相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 应用实例状态变更相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeOverriddenStatusIfRequired</span><span class="params">(String appName, String id, InstanceStatus overriddenStatus)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                         String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                 String lastDirtyTimestamp, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Map&lt;String, InstanceStatus&gt; <span class="title">overriddenInstanceStatusesSnapshot</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// ====== 响应缓存相关 ======</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initializedResponseCache</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ResponseCache <span class="title">getResponseCache</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 自我保护模式相关 ======</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNumOfRenewsInLastMin</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumOfRenewsPerMinThreshold</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isBelowRenewThresold</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSelfPreservationModeEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaseExpirationEnabled</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// ====== 调试/监控相关 ======</span></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNRegisteredInstances();</div><div class="line"></div><div class="line">    List&lt;Pair&lt;Long, String&gt;&gt; getLastNCanceledInstances();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="6-AbstractInstanceRegistry"><a href="#6-AbstractInstanceRegistry" class="headerlink" title="6. AbstractInstanceRegistry"></a>6. AbstractInstanceRegistry</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry</code>，应用对象注册表<strong>抽象实现</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— 应用实例注册发现》系列</a> 逐篇分享。</p><h1 id="7-PeerAwareInstanceRegistry"><a href="#7-PeerAwareInstanceRegistry" class="headerlink" title="7. PeerAwareInstanceRegistry"></a>7. PeerAwareInstanceRegistry</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistry</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>接口</strong>，提供 Eureka-Server 集群内注册信息的<strong>同步</strong>服务。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PeerAwareInstanceRegistry</span> <span class="keyword">extends</span> <span class="title">InstanceRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PeerEurekaNodes peerEurekaNodes)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo info, <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String asgName, <span class="keyword">final</span> ASGResource.ASGStatus newStatus, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="8-PeerAwareInstanceRegistryImpl"><a href="#8-PeerAwareInstanceRegistryImpl" class="headerlink" title="8. PeerAwareInstanceRegistryImpl"></a>8. PeerAwareInstanceRegistryImpl</h1><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl</code>，PeerAware ( 暂时找不到合适的翻译 ) 应用对象注册表<strong>实现类</strong>。</p><p>这里先不拓展开，<a href="http://www.iocoder.cn/categories/Eureka/?self">《Eureka 源码解析 —— Eureka-Server 集群》系列</a> 逐篇分享。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文是一篇<strong>简介</strong>( 啪啪啪，打脸 )，如果胖友比较着急想了解原理，可以阅读 <a href="http://techshow.ctrip.com/archives/1699.html?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">携程 ——《深度剖析服务发现组件Netflix Eureka》</a> 先，写的非常非常非常不错。</p><p>快马加鞭，更新 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》</a> <strong>ing</strong> …</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-class-diagram/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-class-dia
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（二）之 EurekaBootStrap</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-second/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2017-10-05T04:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/">http://www.iocoder.cn/Eureka/eureka-server-init-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-eurekabootstrap">2. EurekaBootStrap</a><ul><li><a href="#21-%E5%88%9D%E5%A7%8B%E5%8C%96-eureka-server-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83">2.1 初始化 Eureka-Server 配置环境</a></li><li><a href="#22-%E5%88%9D%E5%A7%8B%E5%8C%96-eureka-server-%E4%B8%8A%E4%B8%8B%E6%96%87">2.2 初始化 Eureka-Server 上下文</a></li></ul></li><li><a href="#3-filter">3. Filter</a><ul><li><a href="#31-statusfilter">3.1 StatusFilter</a></li><li><a href="#32-serverrequestauthfilter">3.2 ServerRequestAuthFilter</a></li><li><a href="#33-ratelimitingfilter">3.3 RateLimitingFilter</a></li><li><a href="#34-gzipencodingenforcingfilter">3.4 GzipEncodingEnforcingFilter</a></li><li><a href="#35-servletcontainer">3.5 ServletContainer</a></li></ul></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 EurekaServerConfig》</a>，主要分享 <strong>Eureka-Server 启动的过程</strong>的第二部分 —— <strong>EurekaBootStrap</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">ServerConfig</a></li><li>【本文】EurekaBootStrap</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaBootStrap"><a href="#2-EurekaBootStrap" class="headerlink" title="2. EurekaBootStrap"></a>2. EurekaBootStrap</h1><p><code>com.netflix.eureka.EurekaBootStrap</code>，Eureka-Server <strong>启动入口</strong>。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/01.png" alt=""></p><p>EurekaBootStrap 实现了 <code>javax.servlet.ServletContextListener</code> <strong>接口</strong>，在 Servlet 容器( 例如 Tomcat、Jetty )启动时，调用 <code>#contextInitialized()</code> 方法，初始化 Eureka-Server，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 省略无关变量和方法</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 初始化 Eureka-Server 配置环境</span></div><div class="line">            initEurekaEnvironment();</div><div class="line"></div><div class="line">            <span class="comment">// 初始化 Eureka-Server 上下文</span></div><div class="line">            initEurekaServerContext();</div><div class="line"></div><div class="line">            ServletContext sc = event.getServletContext();</div><div class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot bootstrap eureka server :"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#initEurekaEnvironment()</code> 方法，初始化 Eureka-Server <strong>配置</strong>环境。</li><li>调用 <code>#initEurekaServerContext()</code> 方法，初始化 Eureka-Server 上下文。</li></ul><h2 id="2-1-初始化-Eureka-Server-配置环境"><a href="#2-1-初始化-Eureka-Server-配置环境" class="headerlink" title="2.1 初始化 Eureka-Server 配置环境"></a>2.1 初始化 Eureka-Server 配置环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaBootStrap.java</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署环境 - 测服</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - CLOUD</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOUD = <span class="string">"cloud"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 部署数据中心 - 默认</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT = <span class="string">"default"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_DATACENTER = <span class="string">"archaius.deployment.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_DATACENTER = <span class="string">"eureka.datacenter"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initEurekaEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    logger.info(<span class="string">"Setting the eureka configuration.."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的数据中心</span></div><div class="line">   String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);</div><div class="line">   <span class="keyword">if</span> (dataCenter == <span class="keyword">null</span>) &#123;</div><div class="line">       logger.info(<span class="string">"Eureka data center value eureka.datacenter is not set, defaulting to default"</span>);</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 设置配置文件的环境</span></div><div class="line">   String environment = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT);</div><div class="line">   <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</div><div class="line">       ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);</div><div class="line">       logger.info(<span class="string">"Eureka environment value eureka.environment is not set, defaulting to test"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>设置基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius</a> 实现的配置文件的上下文，从而读取<strong>合适</strong>的配置文件。大多数情况下，只需要设置 <code>EUREKA_ENVIRONMENT</code> 即可，不同的服务器环境( 例如，<code>PROD</code> / <code>TEST</code> 等) 读取不同的配置文件。实现原理，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>有详细解析。</li><li>感兴趣的也可以阅读：<a href="https://github.com/Netflix/archaius/wiki/Deployment-context" rel="external nofollow noopener noreferrer" target="_blank">《Netflix Archaius 官方文档 —— Deployment context》</a>。</li></ul><h2 id="2-2-初始化-Eureka-Server-上下文"><a href="#2-2-初始化-Eureka-Server-上下文" class="headerlink" title="2.2 初始化 Eureka-Server 上下文"></a>2.2 初始化 Eureka-Server 上下文</h2><p>EurekaBootStrap 的 <code>#initEurekaServerContext()</code> 方法的实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/a1c6074fd038f1182132a43b1ebc4cc08166f0be/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L137" rel="external nofollow noopener noreferrer" target="_blank">EurekaBootStrap</a> 链接，对照下面每个小结阅读理解。</p><h3 id="2-2-1-创建-Eureka-Server-配置"><a href="#2-2-1-创建-Eureka-Server-配置" class="headerlink" title="2.2.1 创建 Eureka-Server 配置"></a>2.2.1 创建 Eureka-Server 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerConfig eurekaServerConfig = <span class="keyword">new</span> DefaultEurekaServerConfig();</div></pre></td></tr></table></figure><ul><li>在 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/?self">《Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig》「2.3 DefaultEurekaServerConfig」</a> 有详细解析。</li></ul><h3 id="2-2-2-Eureka-Server-请求和响应的数据兼容"><a href="#2-2-2-Eureka-Server-请求和响应的数据兼容" class="headerlink" title="2.2.2 Eureka-Server 请求和响应的数据兼容"></a>2.2.2 Eureka-Server 请求和响应的数据兼容</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// For backward compatibility</span></div><div class="line">JsonXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div><div class="line">XmlXStream.getInstance().registerConverter(<span class="keyword">new</span> V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div></pre></td></tr></table></figure><ul><li>目前 Eureka-Server 提供 V2 版本 API ，如上代码主要对 V1 版本 API 做兼容。可以选择跳过。</li></ul><h3 id="2-2-3-创建-Eureka-Server-请求和响应编解码器"><a href="#2-2-3-创建-Eureka-Server-请求和响应编解码器" class="headerlink" title="2.2.3 创建 Eureka-Server 请求和响应编解码器"></a>2.2.3 创建 Eureka-Server 请求和响应编解码器</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">logger.info(<span class="string">"Initializing the eureka client..."</span>);</div><div class="line">logger.info(eurekaServerConfig.getJsonCodecName());</div><div class="line">ServerCodecs serverCodecs = <span class="keyword">new</span> DefaultServerCodecs(eurekaServerConfig);</div></pre></td></tr></table></figure><h3 id="2-2-4-创建-Eureka-Client"><a href="#2-2-4-创建-Eureka-Client" class="headerlink" title="2.2.4 创建 Eureka-Client"></a>2.2.4 创建 Eureka-Client</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ApplicationInfoManager applicationInfoManager;</div><div class="line"><span class="keyword">if</span> (eurekaClient == <span class="keyword">null</span>) &#123;</div><div class="line">  EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</div><div class="line">          ? <span class="keyword">new</span> CloudInstanceConfig()</div><div class="line">          : <span class="keyword">new</span> MyDataCenterInstanceConfig();</div><div class="line">  </div><div class="line">  applicationInfoManager = <span class="keyword">new</span> ApplicationInfoManager(</div><div class="line">          instanceConfig, <span class="keyword">new</span> EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</div><div class="line">  </div><div class="line">  EurekaClientConfig eurekaClientConfig = <span class="keyword">new</span> DefaultEurekaClientConfig();</div><div class="line">  eurekaClient = <span class="keyword">new</span> DiscoveryClient(applicationInfoManager, eurekaClientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  applicationInfoManager = eurekaClient.getApplicationInfoManager();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Eureka-Server 内嵌 Eureka-Client，用于和 Eureka-Server 集群里其他节点通信交互。</li><li>Eureka-Client 的初始化过程，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">《Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient》「3. DiscoveryClient」</a>有详细解析。</li><li><p>Eureka-Client 也可以通过 EurekaBootStrap 构造方法传递，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaBootStrap</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> EurekaClient eurekaClient;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaBootStrap</span><span class="params">(EurekaClient eurekaClient)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.eurekaClient = eurekaClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>大多数情况下用不到</strong>。</li></ul></li></ul><h3 id="2-2-5-创建应用实例信息的注册表"><a href="#2-2-5-创建应用实例信息的注册表" class="headerlink" title="2.2.5 创建应用实例信息的注册表"></a>2.2.5 创建应用实例信息的注册表</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerAwareInstanceRegistry registry;</div><div class="line"><span class="keyword">if</span> (isAws(applicationInfoManager.getInfo())) &#123; <span class="comment">// AWS 相关，跳过</span></div><div class="line">  registry = <span class="keyword">new</span> AwsInstanceRegistry(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">  awsBinder = <span class="keyword">new</span> AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);</div><div class="line">  awsBinder.start();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  registry = <span class="keyword">new</span> PeerAwareInstanceRegistryImpl(</div><div class="line">          eurekaServerConfig,</div><div class="line">          eurekaClient.getEurekaClientConfig(),</div><div class="line">          serverCodecs,</div><div class="line">          eurekaClient</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>应用实例信息的注册表<strong>类关系图</strong>如下：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_05_14/02.png" alt=""></p></li><li><p>本文不展开分享，在<a href="http://www.iocoder.cn/Eureka/instance-registry-class-diagram/?self">《Eureka 源码解析 —— 注册表 InstanceRegistry 类关系》</a>详细解析。</p></li></ul><h3 id="2-2-6-创建-Eureka-Server-集群节点集合"><a href="#2-2-6-创建-Eureka-Server-集群节点集合" class="headerlink" title="2.2.6 创建 Eureka-Server 集群节点集合"></a>2.2.6 创建 Eureka-Server 集群节点集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</div><div class="line">      registry,</div><div class="line">      eurekaServerConfig,</div><div class="line">      eurekaClient.getEurekaClientConfig(),</div><div class="line">      serverCodecs,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.cluster.PeerEurekaNodes</code>，Eureka-Server 集群节点集合，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3 id="2-2-7-创建-Eureka-Server-上下文"><a href="#2-2-7-创建-Eureka-Server-上下文" class="headerlink" title="2.2.7 创建 Eureka-Server 上下文"></a>2.2.7 创建 Eureka-Server 上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext = <span class="keyword">new</span> DefaultEurekaServerContext(</div><div class="line">      eurekaServerConfig,</div><div class="line">      serverCodecs,</div><div class="line">      registry,</div><div class="line">      peerEurekaNodes,</div><div class="line">      applicationInfoManager</div><div class="line">);</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.EurekaServerContext</code>，Eureka-Server 上下文<strong>接口</strong>，提供Eureka-Server 内部各组件对象的<strong>初始化</strong>、<strong>关闭</strong>、<strong>获取</strong>等方法。</li><li><p><code>com.netflix.eureka.EurekaServerContext.DefaultEurekaServerContext</code>，Eureka-Server 上下文<strong>实现类</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerContext</span> <span class="keyword">implements</span> <span class="title">EurekaServerContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 请求和响应编解码器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息的注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerEurekaNodes peerEurekaNodes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-8-初始化-EurekaServerContextHolder"><a href="#2-2-8-初始化-EurekaServerContextHolder" class="headerlink" title="2.2.8 初始化 EurekaServerContextHolder"></a>2.2.8 初始化 EurekaServerContextHolder</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EurekaServerContextHolder.initialize(serverContext);</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.eureka.EurekaServerContextHolder</code>，Eureka-Server 上下文持有者。通过它，可以很方便的获取到 Eureka-Server 上下文，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerContextHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 持有者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EurekaServerContextHolder holder;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerContext serverContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EurekaServerContextHolder</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serverContext = serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaServerContext <span class="title">getServerContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.serverContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serverContext Eureka-Server 上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(EurekaServerContext serverContext)</span> </span>&#123;</div><div class="line">        holder = <span class="keyword">new</span> EurekaServerContextHolder(serverContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaServerContextHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> holder;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-9-初始化-Eureka-Server-上下文"><a href="#2-2-9-初始化-Eureka-Server-上下文" class="headerlink" title="2.2.9 初始化 Eureka-Server 上下文"></a>2.2.9 初始化 Eureka-Server 上下文</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverContext.initialize();</div><div class="line">logger.info(<span class="string">"Initialized server context"</span>);</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ServerContext#initialize()</code> 方法，初始化 Eureka-Server 上下文，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DefaultEurekaServerContext.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   logger.info(<span class="string">"Initializing ..."</span>);</div><div class="line"></div><div class="line">   <span class="comment">// 启动 Eureka-Server 集群节点集合（复制）</span></div><div class="line">   peerEurekaNodes.start();</div><div class="line">   <span class="comment">// 初始化 应用实例信息的注册表</span></div><div class="line">   registry.init(peerEurekaNodes);</div><div class="line"></div><div class="line">   logger.info(<span class="string">"Initialized"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="2-2-10-从其他-Eureka-Server-拉取注册信息"><a href="#2-2-10-从其他-Eureka-Server-拉取注册信息" class="headerlink" title="2.2.10 从其他 Eureka-Server 拉取注册信息"></a>2.2.10 从其他 Eureka-Server 拉取注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Copy registry from neighboring eureka node</span></div><div class="line"><span class="keyword">int</span> registryCount = registry.syncUp();</div><div class="line">registry.openForTraffic(applicationInfoManager, registryCount);</div></pre></td></tr></table></figure><ul><li>本文不展开分享，在<a href="#">《TODO[0019]：集群初始化》</a>详细解析。</li></ul><h3 id="2-2-11-注册监控"><a href="#2-2-11-注册监控" class="headerlink" title="2.2.11 注册监控"></a>2.2.11 注册监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Register all monitoring statistics.</span></div><div class="line">EurekaMonitors.registerAllStats();</div></pre></td></tr></table></figure><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h1 id="3-Filter"><a href="#3-Filter" class="headerlink" title="3. Filter"></a>3. Filter</h1><p>Eureka-Server 过滤器( <code>javax.servlet.Filter</code> ) <strong>顺序</strong>如下：</p><ul><li>StatusFilter</li><li>ServerRequestAuthFilter</li><li>RateLimitingFilter</li><li>GzipEncodingEnforcingFilter</li><li>ServletContainer</li></ul><h2 id="3-1-StatusFilter"><a href="#3-1-StatusFilter" class="headerlink" title="3.1 StatusFilter"></a>3.1 StatusFilter</h2><p><code>com.netflix.eureka.StatusFilter</code>，Eureka-Server 状态过滤器。当 Eureka-Server 未处于开启( <code>InstanceStatus.UP</code> )状态，返回 HTTP 状态码 307 重定向，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatusFilter.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SC_TEMPORARY_REDIRECT = <span class="number">307</span>;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line"><span class="function"><span class="params">                   FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">  InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();</div><div class="line">  InstanceStatus status = myInfo.getStatus();</div><div class="line">  <span class="keyword">if</span> (status != InstanceStatus.UP &amp;&amp; response <span class="keyword">instanceof</span> HttpServletResponse) &#123;</div><div class="line">      HttpServletResponse httpRespone = (HttpServletResponse) response;</div><div class="line">      httpRespone.sendError(SC_TEMPORARY_REDIRECT,</div><div class="line">              <span class="string">"Current node is currently not ready to serve requests -- current status: "</span></div><div class="line">                      + status + <span class="string">" - try another DS node: "</span>);</div><div class="line">  &#125;</div><div class="line">  chain.doFilter(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-ServerRequestAuthFilter"><a href="#3-2-ServerRequestAuthFilter" class="headerlink" title="3.2 ServerRequestAuthFilter"></a>3.2 ServerRequestAuthFilter</h2><p><code>com.netflix.eureka.ServerRequestAuthFilter</code>，Eureka-Server 请求认证过滤器。Eureka-Server 未实现认证。目前打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerRequestAuthFilter.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logAuth</span><span class="params">(ServletRequest request)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (serverConfig.shouldLogIdentityHeaders()) &#123;</div><div class="line">       <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpServletRequest) &#123;</div><div class="line">           HttpServletRequest httpRequest = (HttpServletRequest) request;</div><div class="line"></div><div class="line">           String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</div><div class="line">           String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);</div><div class="line"></div><div class="line">           DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + <span class="string">"-"</span> + clientVersion).build());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><h2 id="3-3-RateLimitingFilter"><a href="#3-3-RateLimitingFilter" class="headerlink" title="3.3 RateLimitingFilter"></a>3.3 RateLimitingFilter</h2><p><code>com.netflix.eureka.RateLimitingFilter</code>，请求限流过滤器。在<a href="#">《TODO[0020]：限流》</a>详细解析。</p><h2 id="3-4-GzipEncodingEnforcingFilter"><a href="#3-4-GzipEncodingEnforcingFilter" class="headerlink" title="3.4 GzipEncodingEnforcingFilter"></a>3.4 GzipEncodingEnforcingFilter</h2><p><code>com.netflix.eureka.GzipEncodingEnforcingFilter</code>，GZIP 编码过滤器。</p><h2 id="3-5-ServletContainer"><a href="#3-5-ServletContainer" class="headerlink" title="3.5 ServletContainer"></a>3.5 ServletContainer</h2><p><code>com.sun.jersey.spi.container.servlet.ServletContainer</code>，Jersey MVC 请求过滤器。</p><ul><li><p>Jersey MVC 模式如下图：</p><blockquote><p>FROM <a href="http://blog.csdn.net/wangqyoho/article/details/51981916" rel="external nofollow noopener noreferrer" target="_blank">《Jersey框架的MVC》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_05_14/03.png" alt=""></p></blockquote></li><li><p>在 <code>com.netflix.eureka.resources</code> 包里，有所有的 Eureka-Server Jersey Resource ( Controller )。</p></li><li><p>过滤器在 <code>web.xml</code> 配置如下：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.sun.jersey.spi.container.servlet.ServletContainer<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.WebPageContentRegex<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/(flex|images|js|css|jsp)/.*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.config.property.packages<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey;com.netflix<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- GZIP content encoding/decoding --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerRequestFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>com.sun.jersey.spi.container.ContainerResponseFilters<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.sun.jersey.api.container.filter.GZIPContentEncodingFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></div><div class="line">   </div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>jersey<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>啦啦啦，Eureka-Server 启动完成！</p><p>准备工作已经完成，可以开始更加有趣的注册、续约、取消注册、过期等等 Eureka-Client 与 Eureka-Server 的交互。</p><p>搞起！</p><p>胖友，分享一波朋友圈可好！？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-server-init-second/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-server-init-second/&lt;/a&gt; 「芋
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 启动（一）之 ServerConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-server-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-server-init-first/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2017-10-05T03:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-server-init-first/">http://www.iocoder.cn/Eureka/eureka-server-init-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-eurekaserverconfig">2. EurekaServerConfig</a><ul><li><a href="#21-%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE">2.1 类关系图</a></li><li><a href="#22-%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7">2.2 配置属性</a></li><li><a href="#23-defaulteurekaserverconfig">2.3 DefaultEurekaServerConfig</a></li></ul></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 启动的过程</strong>。</p><p>考虑到整个初始化的过程中涉及的代码特别多，拆分成两两篇文章：</p><ul><li>【本文】ServerConfig</li><li><a href="http://www.iocoder.cn/Eureka/eureka-server-init-second/?self">EurekaBootStrap</a></li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaServerConfig"><a href="#2-EurekaServerConfig" class="headerlink" title="2. EurekaServerConfig"></a>2. EurekaServerConfig</h1><p><code>com.netflix.eureka.EurekaServerConfig</code>，<strong>Eureka-Server</strong> 配置<strong>接口</strong>。</p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p><img src="http://www/iocoder.cn/images/Eureka/2018_05_07/01.png" alt=""></p><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaServerConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><strong>请求认证相关</strong><ul><li>Eureka-Server 未实现认证。在 Spring-Cloud-Eureka-Server，通过 <code>spring-boot-starter-security</code> 模块支持。<a href="http://blog.csdn.net/liuchuanhong1/article/details/54729556" rel="external nofollow noopener noreferrer" target="_blank">《spring cloud-给Eureka Server加上安全的用户认证》</a>有详细解析。</li><li><code>#shouldLogIdentityHeaders()</code> ：打印访问的客户端名和版本号，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul></li><li><strong>请求限流相关</strong><ul><li>TODO[0020]：限流</li><li><code>#isRateLimiterEnabled()</code> ：请求限流是否开启。</li><li><code>#isRateLimiterThrottleStandardClients()</code> ：是否限制<strong>非标准</strong>客户端的访问。<strong>标准客户端</strong>通过请求头( <code>header</code> )的 <code>&quot;DiscoveryIdentity-Name&quot;</code> 来判断，是否在标准客户端名集合里。</li><li><code>#getRateLimiterPrivilegedClients()</code> ：<strong>标准</strong>客户端名集合。默认包含<code>&quot;DefaultClient&quot;</code> 和 <code>&quot;DefaultServer&quot;</code> 。</li><li><code>#getRateLimiterBurstSize()</code> ：速率限制的 burst size ，使用<strong>令牌桶算法</strong>。</li><li><code>#getRateLimiterRegistryFetchAverageRate()</code> ：<strong>增量</strong>拉取注册信息的速率限制。</li><li><code>#getRateLimiterFullFetchAverageRate()</code> ：<strong>全量</strong>拉取注册信息的速率限制。</li></ul></li><li><strong>拉取注册信息请求响应缓存相关</strong><ul><li>TODO[0014]：全量拉取</li><li><code>#shouldUseReadOnlyResponseCache()</code> ：是否开启只读请求响应缓存。响应缓存 ( ResponseCache ) 机制目前使用两层缓存策略。优先读取<strong>永不过期</strong>的<strong>只读缓存</strong>，读取不到后读取<strong>固定过期</strong>的<strong>读写缓存</strong>。</li><li><code>#getResponseCacheUpdateIntervalMs()</code> ：<strong>只读缓存</strong>更新频率，单位：毫秒。<strong>只读缓存</strong>定时更新任务只更新读取过请求 (<code>com.netflix.eureka.registry.Key</code>)，因此虽然永不过期，也会存在读取不到的情况。</li><li><code>#getResponseCacheAutoExpirationInSeconds()</code> ：<strong>读写缓存</strong>写入后过期时间，单位：秒。</li></ul></li><li><p><strong>注册的应用实例的租约过期相关</strong></p><ul><li>TODO[0017]：租约过期</li><li><p><code>#shouldEnableSelfPreservation()</code> ：是否开启自我保护模式。</p><blockquote><p>FROM <a href="http://www.itmuch.com/spring-cloud-sum/understanding-eureka-self-preservation/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立——《理解Eureka的自我保护模式》</a><br>当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。<br>一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。<br>当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</p></blockquote></li><li><p><code>#getRenewalPercentThreshold()</code> ：开启自我保护模式比例，超过该比例后开启自我保护模式。</p></li><li><code>#getRenewalThresholdUpdateIntervalMs()</code> ：自我保护模式比例更新定时任务执行频率，单位：毫秒。</li><li><code>#getEvictionIntervalTimerInMs()</code> ：租约过期定时任务执行频率，单位：毫秒。</li></ul></li><li><strong>Eureka-Server 远程节点( 非集群 )读取相关</strong><ul><li>TODO[0009]：RemoteRegionRegistry</li><li><code>#getRemoteRegionUrlsWithName()</code> ：TODO[0009]：RemoteRegionRegistry。<ul><li><code>key</code> ：Eureka-Server 区域( <code>region</code> )</li><li><code>value</code> ：Eureka-Server 地址</li></ul></li><li><code>#getRemoteRegionAppWhitelist()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRemoteRegionRegistryFetchInterval()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#getRegistrySyncRetries()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败重试次数。</li><li><code>#getRegistrySyncRetryWaitMs()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取失败等待( <code>sleep</code> )间隔，单位：毫秒。 </li><li><code>#getRemoteRegionFetchThreadPoolSize()</code> ：TODO[0009]：RemoteRegionRegistry。</li><li><code>#disableTransparentFallbackToOtherRegion()</code> ：是否禁用本地读取不到注册信息，从远程 Eureka-Server 读取。</li></ul></li><li><strong>Eureka-Server 集群同步相关</strong><ul><li>TODO[0021]：集群同步</li><li><code>#getMaxThreadsForPeerReplication()</code> ：同步应用实例信息最大线程数。</li><li><code>#getMaxElementsInPeerReplicationPool()</code> ：待执行同步应用实例信息事件缓冲最大数量。</li><li><code>#getMaxTimeForReplication()</code> ：执行单个同步应用实例信息状态任务最大时间。</li><li><code>#shouldSyncWhenTimestampDiffers()</code> ：是否同步应用实例信息，当应用实例信息最后更新时间戳( <code>lastDirtyTimestamp</code> )发生改变。</li><li><code>#getWaitTimeInMsWhenSyncEmpty()</code> ：Eureka-Server <strong>启动</strong>时，从远程 Eureka-Server 读取不到注册信息时，多长时间不允许 Eureka-Client 访问。TODO[0019]：集群初始化</li><li><code>#getPeerEurekaNodesUpdateIntervalMs()</code> ：Eureka-Server 集群节点更新频率，单位：毫秒。TTODO[0019]：集群初始化</li></ul></li><li><code>#getRetentionTimeInMSInDeltaQueue()</code>：TODO[0018]：增量拉取</li><li><code>#DeltaRetentionTimerIntervalInMs()</code>：TODO[0018]：增量拉取</li></ul><h2 id="2-3-DefaultEurekaServerConfig"><a href="#2-3-DefaultEurekaServerConfig" class="headerlink" title="2.3 DefaultEurekaServerConfig"></a>2.3 DefaultEurekaServerConfig</h2><p><code>com.netflix.eureka.DefaultEurekaServerConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Server</strong> 配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaServerConfig</span> <span class="keyword">implements</span> <span class="title">EurekaServerConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略部分方法和属性</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEST = <span class="string">"test"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance = com.netflix.config.DynamicPropertyFactory.getInstance();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DynamicStringProperty EUREKA_PROPS_FILE = DynamicPropertyFactory</div><div class="line">            .getInstance().getStringProperty(<span class="string">"eureka.server.props"</span>, <span class="string">"eureka-server"</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String namespace = <span class="string">"eureka."</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaServerConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, TEST);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// ConfigurationManager</span></div><div class="line">            <span class="comment">// .loadPropertiesFromResources(eurekaPropsFile);</span></div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(<span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>, eurekaPropsFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#init()</code> 方法，初始化配置文件对象。类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。<strong>默认配置文件名</strong>为 <code>eureka-server</code>。</li><li>无配置文件的每个属性 KEY 的枚举类。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-server-init-first/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-server-init-first/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（三）之 EurekaClient</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-third/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-third/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2017-10-05T03:37:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">http://www.iocoder.cn/Eureka/eureka-client-init-third/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-eurekaclient">2. EurekaClient</a><ul><li><a href="#21-lookupservice">2.1 LookupService</a></li></ul></li><li><a href="#3-discoveryclient">3. DiscoveryClient</a><ul><li><a href="#31-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0">3.1 构造方法参数</a></li><li><a href="#32-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">3.2 构造方法</a></li></ul></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/?self">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第三部分 —— <strong>EurekaClient</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/">EurekaInstanceConfig</a>)</li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li><strong>【本文】</strong>（三）EurekaClient</li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaClient"><a href="#2-EurekaClient" class="headerlink" title="2. EurekaClient"></a>2. EurekaClient</h1><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.EurekaClient</code></a>，Eureka-Client <strong>接口</strong>，声明如下方法：</p><ul><li>提供<strong>多种</strong>方法获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</li><li>提供方法获取<strong>本地</strong>客户端信息，例如，应用管理器( <code>com.netflix.appinfo.ApplicationInfoManager</code> )和 Eureka-Client 配置( <code>com.netflix.discovery.EurekaClientConfig</code> )。</li><li>提供方法<strong>注册</strong>本地客户端的健康检查和 Eureka 事件监听器。</li></ul><p>另外，Eureka 2.X 版本正在开发，该接口为 Eureka 1.X 和 2.X 提供平滑过渡接口。</p><blockquote><p>This interface does NOT try to clean up the current client interface for eureka 1.x. Rather it tries to provide an easier transition path from eureka 1.x to eureka 2.x.</p></blockquote><h2 id="2-1-LookupService"><a href="#2-1-LookupService" class="headerlink" title="2.1 LookupService"></a>2.1 LookupService</h2><p><a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.shared.LookupService</code></a>，查找服务<strong>接口</strong>，提供<strong>简单单一</strong>的方式获取应用集合(<code>com.netflix.discovery.shared.Applications</code>) 和 应用实例信息集合( <code>com.netflix.appinfo.InstanceInfo</code> )。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_29/01.png" alt=""></p><ul><li>在 Eureka-Client 里，EurekaClient 继承该接口。</li><li>在 Eureka-Server 里，<code>com.netflix.eureka.registry.InstanceRegistry</code> 继承该接口。</li></ul><h1 id="3-DiscoveryClient"><a href="#3-DiscoveryClient" class="headerlink" title="3. DiscoveryClient"></a>3. DiscoveryClient</h1><p><code>com.netflix.discovery.DiscoveryClient</code>，实现 EurekaClient <strong>接口</strong>，用于与 Eureka-Server 交互。实现如下方法：</p><ul><li>向 Eureka-Server <strong>注册</strong>自身服务</li><li>向 Eureka-Server <strong>续约</strong>自身服务</li><li>向 Eureka-Server <strong>取消</strong>自身服务，当关闭时</li><li>从 Eureka-Server <strong>查询</strong>应用集合和应用实例信息</li><li><em>简单来理解，对 Eureka-Server 服务的增删改查</em></li></ul><h2 id="3-1-构造方法参数"><a href="#3-1-构造方法参数" class="headerlink" title="3.1 构造方法参数"></a>3.1 构造方法参数</h2><p>DiscoveryClient <strong>完整</strong>构造方法需要传入四个参数，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">     <span class="comment">// .... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ApplicationInfoManager，在<a href="ttp://www.iocoder.cn/Eureka/eureka-client-init-first/">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>有详细解析。</li><li>EurekaClientConfig，在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">《Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig》</a>有详细解析。</li><li><p><code>com.netflix.discovery.BackupRegistry</code>，备份注册中心<strong>接口</strong>。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BackupRegistry.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NotImplementedRegistryImpl.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotImplementedRegistryImpl</span> <span class="keyword">implements</span> <span class="title">BackupRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Applications <span class="title">fetchRegistry</span><span class="params">(String[] includeRemoteRegions)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>com.netflix.discovery.NotImplementedRegistryImpl</code> 可以看出，目前 Eureka-Client 未提供合适的默认实现。</li></ul></li><li><p><code>com.netflix.discovery.AbstractDiscoveryClientOptionalArgs</code>，DiscoveryClient 可选参数抽象基类。不同于上面三个<strong>必填</strong>参数，该参数是<strong>选填</strong>参数，实际生产下使用较少。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查回调的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckCallback&gt; healthCheckCallbackProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成健康检查处理器的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Provider&lt;HealthCheckHandler&gt; healthCheckHandlerProvider;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 向 Eureka-Server 注册之前的处理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    PreRegistrationHandler preRegistrationHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 过滤器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Collection&lt;T&gt; additionalFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey 客户端</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    EurekaJerseyClient eurekaJerseyClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 生成 Jersey 客户端的工厂的工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TransportClientFactories transportClientFactories;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka 事件监听器集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Set&lt;EurekaEventListener&gt; eventListeners;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.appinfo.HealthCheckCallback</code>，健康检查回调<strong>接口</strong>，目前已经废弃，使用 HealthCheckHandler 替代，<strong>你可以不关注该参数</strong>。</li><li><p><code>com.netflix.appinfo.HealthCheckHandler</code>，健康检查处理器<strong>接口</strong>，目前暂未提供合适的<strong>默认</strong>实现，唯一提供的 <code>com.netflix.appinfo.HealthCheckCallbackToHandlerBridge</code>，用于将 HealthCheckCallback <strong>桥接</strong>成 HealthCheckHandler，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HealthCheckHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HealthCheckCallbackToHandlerBridge.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HealthCheckCallbackToHandlerBridge</span> <span class="keyword">implements</span> <span class="title">HealthCheckHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HealthCheckCallback callback;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">()</span> </span>&#123;</div><div class="line">        callback = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HealthCheckCallbackToHandlerBridge</span><span class="params">(HealthCheckCallback callback)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.callback = callback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getStatus</span><span class="params">(InstanceInfo.InstanceStatus currentStatus)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == callback || InstanceInfo.InstanceStatus.STARTING == currentStatus</div><div class="line">                || InstanceInfo.InstanceStatus.OUT_OF_SERVICE == currentStatus) &#123; <span class="comment">// Do not go to healthcheck handler if the status is starting or OOS.</span></div><div class="line">            <span class="keyword">return</span> currentStatus;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> callback.isHealthy() ? InstanceInfo.InstanceStatus.UP : InstanceInfo.InstanceStatus.DOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 Spring-Cloud-Eureka-Client，提供了默认实现 <a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/82991a7fc2859b6345b7f67e2461dbf5d7663836/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaHealthCheckHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.cloud.netflix.eureka.EurekaHealthCheckHandler</code></a>，需要结合 <a href="https://github.com/spring-projects/spring-boot/tree/c79568886406662736dcdce78f65e7f46dd62696/spring-boot-actuator/" rel="external nofollow noopener noreferrer" target="_blank"><code>spirng-boot-actuate</code></a> 使用，感兴趣的同学可以看看。本文暂不拓展开，后面另开文章分享。（TODO[0004]：健康检查）</li></ul></li><li><p><code>com.netflix.discovery.PreRegistrationHandler</code>，向 Eureka-Server 注册之前的处理器<strong>接口</strong>，目前暂未提供默认实现。通过实现该接口，可以在注册前做一些自定义的处理。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PreRegistrationHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeRegistration</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul><ul><li><p><code>additionalFilters</code>，Jersey 过滤器集合。这里声明泛型 <code>&lt;T&gt;</code> 的原因，Jersey 1.X 和 Jersey 2.X 的过滤器接口<strong>不同</strong>，通过泛型来支持。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// Jersey2DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jersey2DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">AbstractDiscoveryClientOptionalArgs</span>&lt;<span class="title">ClientRequestFilter</span>&gt; </span>&#123;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"><span class="comment">// DiscoveryClientOptionalArgs.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryClientOptionalArgs</span> <span class="keyword">extends</span> <span class="title">Jersey1DiscoveryClientOptionalArgs</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Jersey 1.X 使用 ClientFilter 。ClientFilter 目前有两个过滤器实现：EurekaIdentityHeaderFilter 、DynamicGZIPContentEncodingFilter 。</li><li>Jersey 2.X 使用 ClientRequestFilter 。</li><li>DiscoveryClient 使用 DiscoveryClientOptionalArgs，即 Jersey 1.X 。</li></ul></li></ul></li></ul><ul><li><code>eurekaJerseyClient</code>，Jersey 客户端。该<strong>参数</strong>目前废弃，使用下面 TransportClientFactories 参数来进行生成。</li><li><p><code>com.netflix.discovery.shared.transport.jersey.TransportClientFactories</code>，生成 Jersey 客户端<strong>工厂的工厂</strong>接口。目前有 Jersey1TransportClientFactories 、Jersey2TransportClientFactories 两个实现。TransportClientFactories 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransportClientFactories.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactories</span>&lt;<span class="title">F</span>&gt; </span>&#123;</div><div class="line">  </div><div class="line">      <span class="meta">@Deprecated</span></div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> EurekaJerseyClient providedJerseyClient)</span></span>;</div><div class="line">  </div><div class="line">      <span class="function">TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> Collection&lt;F&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TransportClientFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line">    </div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一个方法已经废弃，这就是为什么说上面的 <code>eurekaJerseyClient</code> <strong>参数</strong>( 不是 EurekaJerseyClient 类)已经废弃，被第二个方法取代。相比来说，第二个方法对 EurekaJerseyClient 创建封装会更好。</li></ul></li><li><p><code>com.netflix.discovery.EurekaEventListener</code>，Eureka 事件监听器。实现代码如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaEventListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEventListener</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// EurekaEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryEvent.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryEvent</span> <span class="keyword">implements</span> <span class="title">EurekaEvent</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestamp;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.StatusChangeEvent</code>，应用实例状态变更事件，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li><li>CacheRefreshedEvent （TODO[0014]：全量拉取）</li></ul></li></ul></li></ul><h2 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h2><p>DiscoveryClient 的构造方法实现代码相对较多，已经将代码<strong>切块</strong> + <strong>中文注册</strong>，点击 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L298" rel="external nofollow noopener noreferrer" target="_blank">DiscoveryClient</a> 链接，对照下面每个小结阅读理解。</p><h3 id="3-2-1-赋值-AbstractDiscoveryClientOptionalArgs"><a href="#3-2-1-赋值-AbstractDiscoveryClientOptionalArgs" class="headerlink" title="3.2.1 赋值 AbstractDiscoveryClientOptionalArgs"></a>3.2.1 赋值 AbstractDiscoveryClientOptionalArgs</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = args.healthCheckHandlerProvider;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = args.healthCheckCallbackProvider;</div><div class="line">  <span class="keyword">this</span>.eventListeners.addAll(args.getEventListeners());</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = args.preRegistrationHandler;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.healthCheckCallbackProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.healthCheckHandlerProvider = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-2-赋值-ApplicationInfoManager、EurekaClientConfig"><a href="#3-2-2-赋值-ApplicationInfoManager、EurekaClientConfig" class="headerlink" title="3.2.2 赋值 ApplicationInfoManager、EurekaClientConfig"></a>3.2.2 赋值 ApplicationInfoManager、EurekaClientConfig</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"></div><div class="line">clientConfig = config;</div><div class="line">staticClientConfig = clientConfig;</div><div class="line">transportConfig = config.getTransportConfig();</div><div class="line">instanceInfo = myInfo;</div><div class="line"><span class="keyword">if</span> (myInfo != <span class="keyword">null</span>) &#123;</div><div class="line">  appPathIdentifier = instanceInfo.getAppName() + <span class="string">"/"</span> + instanceInfo.getId(); <span class="comment">// 无实际业务用途，用于打 logger</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  logger.warn(<span class="string">"Setting instanceInfo to a passed in null value"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-3-赋值-BackupRegistry"><a href="#3-2-3-赋值-BackupRegistry" class="headerlink" title="3.2.3 赋值 BackupRegistry"></a>3.2.3 赋值 BackupRegistry</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.backupRegistryProvider = backupRegistryProvider;</div></pre></td></tr></table></figure><h3 id="3-2-4-初始化-InstanceInfoBasedUrlRandomizer"><a href="#3-2-4-初始化-InstanceInfoBasedUrlRandomizer" class="headerlink" title="3.2.4 初始化 InstanceInfoBasedUrlRandomizer"></a>3.2.4 初始化 InstanceInfoBasedUrlRandomizer</h3><p>TODO[0016]：InstanceInfoBasedUrlRandomizer</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.urlRandomizer = <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);</div></pre></td></tr></table></figure><h3 id="3-2-5-初始化-Applications-在本地的缓存"><a href="#3-2-5-初始化-Applications-在本地的缓存" class="headerlink" title="3.2.5 初始化 Applications 在本地的缓存"></a>3.2.5 初始化 Applications 在本地的缓存</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取注册信息次数</span></div><div class="line"><span class="comment">* monotonically increasing generation counter to ensure stale threads do not reset registry to an older version</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong fetchRegistryGeneration;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line"></div><div class="line">fetchRegistryGeneration = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div></pre></td></tr></table></figure><ul><li>在创建 DiscoveryClient 时，<code>localRegionApps</code> 为空。</li><li>定时任务<strong>间隔</strong>从 Eureka-Server 拉取注册应用信息到本地缓存，在 (TODO[0014]：全量拉取)详细解析。</li></ul><h3 id="3-2-6-获取哪些-Region-集合的注册信息"><a href="#3-2-6-获取哪些-Region-集合的注册信息" class="headerlink" title="3.2.6 获取哪些 Region 集合的注册信息"></a>3.2.6 获取哪些 Region 集合的注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; remoteRegionsToFetch;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取哪些区域( Region )集合的注册信息</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String[]&gt; remoteRegionsRef;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">remoteRegionsToFetch = <span class="keyword">new</span> AtomicReference&lt;&gt;(clientConfig.fetchRegistryForRemoteRegions());</div><div class="line">remoteRegionsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(remoteRegionsToFetch.get() == <span class="keyword">null</span> ? <span class="keyword">null</span> : remoteRegionsToFetch.get().split(<span class="string">","</span>));</div></pre></td></tr></table></figure><h3 id="3-2-7-初始化拉取、心跳的监控"><a href="#3-2-7-初始化拉取、心跳的监控" class="headerlink" title="3.2.7 初始化拉取、心跳的监控"></a>3.2.7 初始化拉取、心跳的监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功向 Eureka-Server 心跳时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulHeartbeatTimestamp = -<span class="number">1</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric heartbeatStalenessMonitor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拉取监控</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThresholdLevelsMetric registryStalenessMonitor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (config.shouldFetchRegistry()) &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRY_PREFIX + <span class="string">"lastUpdateSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.registryStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (config.shouldRegisterWithEureka()) &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = <span class="keyword">new</span> ThresholdLevelsMetric(<span class="keyword">this</span>, METRIC_REGISTRATION_PREFIX + <span class="string">"lastHeartbeatSec_"</span>, <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">15L</span>, <span class="number">30L</span>, <span class="number">60L</span>, <span class="number">120L</span>, <span class="number">240L</span>, <span class="number">480L</span>&#125;);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.heartbeatStalenessMonitor = ThresholdLevelsMetric.NO_OP_METRIC;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每次成功向 Eureka-Serve 心跳或者从从 Eureka-Server 拉取注册信息后，都会更新相应时间戳。</li><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>对 <a href="https://github.com/YunaiV/eureka/blob/3ef162f20a28c75de84321b69412c4ef138ad55a/eureka-client/src/main/java/com/netflix/discovery/util/ThresholdLevelsMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.discovery.util.ThresholdLevelsMetric</code></a> 感兴趣的同学可以点击链接查看。本文暂不拓展开，后面另开文章分享。（TODO[0012]：监控相关）</li></ul><h3 id="3-2-8-结束初始化，当无需和-Eureka-Server-交互"><a href="#3-2-8-结束初始化，当无需和-Eureka-Server-交互" class="headerlink" title="3.2.8 结束初始化，当无需和 Eureka-Server 交互"></a>3.2.8 结束初始化，当无需和 Eureka-Server 交互</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) &#123;</div><div class="line">  logger.info(<span class="string">"Client configured to neither register nor query for data."</span>);</div><div class="line">  scheduler = <span class="keyword">null</span>;</div><div class="line">  heartbeatExecutor = <span class="keyword">null</span>;</div><div class="line">  cacheRefreshExecutor = <span class="keyword">null</span>;</div><div class="line">  eurekaTransport = <span class="keyword">null</span>;</div><div class="line">  instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(<span class="keyword">new</span> PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());</div><div class="line"></div><div class="line">  <span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line">  <span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">  DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">  DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">  initTimestampMs = System.currentTimeMillis();</div><div class="line">  logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">          initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div><div class="line"></div><div class="line">  <span class="keyword">return</span>;  <span class="comment">// no need to setup up an network tasks and we are done</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-9-初始化线程池"><a href="#3-2-9-初始化线程池" class="headerlink" title="3.2.9 初始化线程池"></a>3.2.9 初始化线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* A scheduler to be used for the following 3 tasks: 【目前只有两个】</span></div><div class="line"><span class="comment">* - updating service urls</span></div><div class="line"><span class="comment">* - scheduling a TimedSuperVisorTask</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduler;</div><div class="line"><span class="comment">// additional executors for supervised subtasks</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 心跳执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor heartbeatExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #localRegionApps&#125; 刷新执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor cacheRefreshExecutor;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build());</div><div class="line"></div><div class="line">heartbeatExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-HeartbeatExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div><div class="line"></div><div class="line">cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">     <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">     <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">             .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">             .setDaemon(<span class="keyword">true</span>)</div><div class="line">             .build()</div><div class="line">);  <span class="comment">// use direct handoff</span></div></pre></td></tr></table></figure><ul><li><code>scheduler</code>，<strong>定时任务</strong>线程池，初始化大小为 2，一个给 <code>heartbeatExecutor</code>，一个给 <code>cacheRefreshExecutor</code>。</li><li><code>heartbeatExecutor</code>、<code>cacheRefreshExecutor</code> 在提交给 <code>scheduler</code> 才声明具体的<strong>任务</strong>。</li></ul><h3 id="3-2-10-初始化-Eureka-网络通信相关"><a href="#3-2-10-初始化-Eureka-网络通信相关" class="headerlink" title="3.2.10 初始化 Eureka 网络通信相关"></a>3.2.10 初始化 Eureka 网络通信相关</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">eurekaTransport = <span class="keyword">new</span> EurekaTransport();</div><div class="line">scheduleServerEndpointTask(eurekaTransport, args);</div></pre></td></tr></table></figure><ul><li>本文暂不拓展开，后面另开文章分享。（TODO[0013]：网络传输相关）</li></ul><h3 id="3-2-11-初始化-InstanceRegionChecker"><a href="#3-2-11-初始化-InstanceRegionChecker" class="headerlink" title="3.2.11 初始化 InstanceRegionChecker"></a>3.2.11 初始化 InstanceRegionChecker</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">AzToRegionMapper azToRegionMapper;</div><div class="line"><span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> DNSBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    azToRegionMapper = <span class="keyword">new</span> PropertyBasedAzToRegionMapper(clientConfig);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsToFetch.get()) &#123;</div><div class="line">    azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(<span class="string">","</span>));</div><div class="line">&#125;</div><div class="line">instanceRegionChecker = <span class="keyword">new</span> InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.AzToRegionMapper</code>，主要用于亚马逊 AWS，跳过。</li><li><p><code>com.netflix.discovery.InstanceRegionChecker</code>，应用实例信息区域( <code>region</code> )校验，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceRegionChecker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略和亚马逊 AWS 相关的属性和方法</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 本地区域( Region )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String localRegion;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocalRegion</span><span class="params">(@Nullable String instanceRegion)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == instanceRegion || instanceRegion.equals(localRegion); <span class="comment">// no region == local</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLocalRegion</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> localRegion;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="3-2-12-从-Eureka-Server-拉取注册信息"><a href="#3-2-12-从-Eureka-Server-拉取注册信息" class="headerlink" title="3.2.12 从 Eureka-Server 拉取注册信息"></a>3.2.12 从 Eureka-Server 拉取注册信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">  fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>初始</strong>拉取注册信息。在（TO后文链接）详细解析。</li><li><p>调用 <code>#fetchRegistryFromBackup()</code> 方法，若<strong>初始</strong>拉取注册信息失败，从备份注册中心获取。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchRegistryFromBackup</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        BackupRegistry backupRegistryInstance = newBackupRegistryInstance();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == backupRegistryInstance) &#123; <span class="comment">// backward compatibility with the old protected method, in case it is being used.</span></div><div class="line">            backupRegistryInstance = backupRegistryProvider.get();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != backupRegistryInstance) &#123;</div><div class="line">            Applications apps = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (isFetchingRemoteRegionRegistries()) &#123;</div><div class="line">                String remoteRegionsStr = remoteRegionsToFetch.get();</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegionsStr) &#123;</div><div class="line">                    apps = backupRegistryInstance.fetchRegistry(remoteRegionsStr.split(<span class="string">","</span>));</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                apps = backupRegistryInstance.fetchRegistry();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (apps != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> Applications applications = <span class="keyword">this</span>.filterAndShuffle(apps);</div><div class="line">                applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line">                localRegionApps.set(applications);</div><div class="line">                logTotalInstances();</div><div class="line">                logger.info(<span class="string">"Fetched registry successfully from the backup"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.warn(<span class="string">"No backup registry instance defined &amp; unable to find any discovery servers."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        logger.warn(<span class="string">"Cannot fetch applications from apps although backup registry was specified"</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>BackupRegistry 目前暂未提供默认实现，需要自行相关逻辑。</li></ul></li></ul><h3 id="3-2-13-执行向-Eureka-Server-注册之前的处理器"><a href="#3-2-13-执行向-Eureka-Server-注册之前的处理器" class="headerlink" title="3.2.13 执行向 Eureka-Server 注册之前的处理器"></a>3.2.13 执行向 Eureka-Server 注册之前的处理器</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// call and execute the pre registration handler before all background tasks (inc registration) is started</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.preRegistrationHandler != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">this</span>.preRegistrationHandler.beforeRegistration();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-14-初始化定时任务"><a href="#3-2-14-初始化定时任务" class="headerlink" title="3.2.14 初始化定时任务"></a>3.2.14 初始化定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line">initScheduledTasks();</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Eureka-Server 拉取注册信息执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">   <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">       <span class="keyword">int</span> renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</div><div class="line">       logger.info(<span class="string">"Starting heartbeat executor: "</span> + <span class="string">"renew interval is: "</span> + renewalIntervalInSecs);</div><div class="line"></div><div class="line">       <span class="comment">// Heartbeat timer</span></div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"heartbeat"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       heartbeatExecutor,</div><div class="line">                       renewalIntervalInSecs,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> HeartbeatThread()</div><div class="line">               ),</div><div class="line">               renewalIntervalInSecs, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">       <span class="comment">// InstanceInfo replicator</span></div><div class="line">       instanceInfoReplicator = <span class="keyword">new</span> InstanceInfoReplicator(</div><div class="line">               <span class="keyword">this</span>,</div><div class="line">               instanceInfo,</div><div class="line">               clientConfig.getInstanceInfoReplicationIntervalSeconds(),</div><div class="line">               <span class="number">2</span>); <span class="comment">// burstSize</span></div><div class="line"></div><div class="line">       statusChangeListener = <span class="keyword">new</span> ApplicationInfoManager.StatusChangeListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="string">"statusChangeListener"</span>;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(StatusChangeEvent statusChangeEvent)</span> </span>&#123;</div><div class="line">               <span class="keyword">if</span> (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</div><div class="line">                       InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</div><div class="line">                   <span class="comment">// log at warn level if DOWN was involved</span></div><div class="line">                   logger.warn(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   logger.info(<span class="string">"Saw local status change event &#123;&#125;"</span>, statusChangeEvent);</div><div class="line">               &#125;</div><div class="line">               instanceInfoReplicator.onDemandUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</div><div class="line">           applicationInfoManager.registerStatusChangeListener(statusChangeListener);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.info(<span class="string">"Not registering with Eureka server per configuration"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>初始化</strong>从 Eureka-Server 拉取注册信息执行器，在（TODO[0014]：全量拉取）详细解析。</li><li><strong>初始化</strong>向 Eureka-Server 心跳（续租）执行器，在（TODO[0015]：租约续约）详细解析。</li></ul><h3 id="3-2-15-向-Servo-注册监控"><a href="#3-2-15-向-Servo-注册监控" class="headerlink" title="3.2.15 向 Servo 注册监控"></a>3.2.15 向 Servo 注册监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  Monitors.registerObject(<span class="keyword">this</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">  logger.warn(<span class="string">"Cannot register timers"</span>, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li></ul><h3 id="3-2-16-初始化完成"><a href="#3-2-16-初始化完成" class="headerlink" title="3.2.16 初始化完成"></a>3.2.16 初始化完成</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java 变量</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 初始化完成时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initTimestampMs;</div><div class="line"></div><div class="line"><span class="comment">// DiscoveryClient.java 构造方法</span></div><div class="line"><span class="comment">// 【3.2.16】初始化完成</span></div><div class="line"><span class="comment">// This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()</span></div><div class="line"><span class="comment">// to work with DI'd DiscoveryClient</span></div><div class="line">DiscoveryManager.getInstance().setDiscoveryClient(<span class="keyword">this</span>);</div><div class="line">DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line"></div><div class="line">initTimestampMs = System.currentTimeMillis();</div><div class="line">logger.info(<span class="string">"Discovery Client initialized at timestamp &#123;&#125; with initial instances count: &#123;&#125;"</span>,</div><div class="line">      initTimestampMs, <span class="keyword">this</span>.getApplications().size());</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>由于笔者是边理解源码边输出博客内容，如果有错误或者不清晰的地方，<strong>欢迎</strong>微笑给我的微信公众号( <strong>芋道源码</strong> ) 留言，我会<strong>仔细</strong>回复。感谢 + 1024。</p><p>后面文章不断更新，会慢慢完善本文中的。</p><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 源码分析</li><li><strong>买盗版书，等于编写一个初级 BUG</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-third/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-third/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（二）之 EurekaClientConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-second/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-second/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2017-10-05T03:28:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">http://www.iocoder.cn/Eureka/eureka-client-init-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. EurekaClientConfig</a><ul><li><a href="#">2.1 类关系图</a></li><li><a href="#">2.2 配置属性</a></li><li><a href="#">2.3 DefaultEurekaClientConfig</a></li><li><a href="#">2.4 DefaultEurekaClientConfigProvider</a></li><li><a href="#">2.5 小结</a></li></ul></li><li><a href="#">3. EurekaTransportConfig</a><ul><li><a href="#">3.1 类关系图</a></li><li><a href="#">3.2 配置属性</a></li><li><a href="#">3.3 DefaultEurekaTransportConfig</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg"></a></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》</a>，主要分享 <strong>Eureka-Client 自身初始化的过程</strong>的第二部分 —— <strong>EurekaClientConfig</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li>（一）<a href="(http://www.iocoder.cn/Eureka/eureka-client-init-first/">EurekaInstanceConfig</a>)</li><li><strong>【本文】</strong>（二）EurekaClientConfig</li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaClientConfig"><a href="#2-EurekaClientConfig" class="headerlink" title="2. EurekaClientConfig"></a>2. EurekaClientConfig</h1><p><code>com.netflix.discovery.EurekaClientConfig</code>，<strong>Eureka-Client</strong> 配置<strong>接口</strong>。</p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p>EurekaClientConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/04.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaClientConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><p><strong>Region、Zone 相关</strong></p><ul><li><code>#getRegion()</code> ：Eureka-Client 所在区域( <code>region</code> )。</li><li><p><code>#getAvailabilityZones()</code> ：Eureka-Client 所在地区( <code>region</code> ) 可用区( <code>zone</code> )集合。<strong>该参数虽然是数组，第一个元素代表其所在的可用区</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getZone</span><span class="params">(String[] availZones, InstanceInfo myInfo)</span> </span>&#123;</div><div class="line">    String instanceZone = ((availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) ? <span class="string">"default"</span></div><div class="line">            : availZones[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">if</span> (myInfo != <span class="keyword">null</span></div><div class="line">            &amp;&amp; myInfo.getDataCenterInfo().getName() == DataCenterInfo.Name.Amazon) &#123;</div><div class="line">    </div><div class="line">        String awsInstanceZone = ((AmazonInfo) myInfo.getDataCenterInfo())</div><div class="line">                .get(AmazonInfo.MetaDataKey.availabilityZone);</div><div class="line">        <span class="keyword">if</span> (awsInstanceZone != <span class="keyword">null</span>) &#123;</div><div class="line">            instanceZone = awsInstanceZone;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instanceZone;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul><ul><li>进步一步理解 Region、Zone 查看<a href="http://www.itmuch.com/spring-cloud-1/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《周立 —— Region、Zone解析》</a>。</li></ul></li></ul></li><li><strong>使用 DNS 获取 Eureka-Server URL 相关</strong><ul><li><code>#shouldUseDnsForFetchingServiceUrls()</code> ：是否使用 DNS 方式获取 Eureka-Server URL 地址。</li><li><code>#getEurekaServerDNSName()</code> ：Eureka-Server 的 DNS 名。</li><li><code>#getEurekaServerPort()</code> ：Eureka-Server 的端口。</li><li><code>#getEurekaServerURLContext()</code> ：Eureka-Server 的 URL Context 。</li><li><code>#getEurekaServiceUrlPollIntervalSeconds()</code> ：轮询获取 Eureka-Server 地址变更频率，单位：秒。默认：300 秒。</li><li><code>#shouldPreferSameZoneEureka()</code> ：优先使用相同区( <code>zone</code> )的 Eureka-Server。</li></ul></li><li><strong>直接配合 Eureka-Server URL 相关</strong><ul><li><code>#getEurekaServerServiceUrls()</code> ： Eureka-Server 的 URL 集合。</li></ul></li><li><strong>发现：从 Eureka-Server 获取注册信息相关</strong><ul><li><code>#shouldFetchRegistry()</code> ：是否从 Eureka-Server 拉取注册信息。</li><li><code>#getRegistryFetchIntervalSeconds()</code> ：从 Eureka-Server 拉取注册信息频率，单位：秒。默认：30 秒。</li><li><code>#shouldFilterOnlyUpInstances()</code> ：是否过滤，只获取状态为开启( Up )的应用实例集合。</li><li><code>#fetchRegistryForRemoteRegions()</code> ：TODO[0009]：RemoteRegionRegistry</li><li><code>#getCacheRefreshExecutorThreadPoolSize()</code> ：注册信息缓存刷新线程池大小。</li><li><code>#getCacheRefreshExecutorExponentialBackOffBound()</code> ：注册信息缓存刷新执行超时后的延迟重试的时间。</li><li><code>#getRegistryRefreshSingleVipAddress()</code> ：TODO[0010]：getRegistryRefreshSingleVipAddress</li></ul></li><li><strong>注册：向 Eureka-Server 注册自身服务</strong><ul><li><code>#shouldRegisterWithEureka()</code> ：是否向 Eureka-Server 注册自身服务。</li><li><code>#shouldUnregisterOnShutdown()</code> ：是否向 Eureka-Server 取消注册自身服务，当进程关闭时。</li><li><code>#getInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用实例信息变化频率，单位：秒。</li><li><code>#getInitialInstanceInfoReplicationIntervalSeconds()</code> ：向 Eureka-Server 同步应用信息变化初始化延迟，单位：秒。</li><li><code>#getBackupRegistryImpl()</code> ：获取备份注册中心实现类。当 Eureka-Client 启动时，无法从 Eureka-Server 读取注册信息（可能挂了），从备份注册中心读取注册信息。目前 Eureka-Client 未提供合适的实现。</li><li><code>#getHeartbeatExecutorThreadPoolSize()</code> ：心跳执行线程池大小。</li><li><code>#getHeartbeatExecutorExponentialBackOffBound()</code> ：心跳执行超时后的延迟重试的时间。</li></ul></li></ul><h2 id="2-3-DefaultEurekaClientConfig"><a href="#2-3-DefaultEurekaClientConfig" class="headerlink" title="2.3 DefaultEurekaClientConfig"></a>2.3 DefaultEurekaClientConfig</h2><p><code>com.netflix.discovery.DefaultEurekaClientConfig</code>，基于<strong>配置文件</strong>的 <strong>Eureka-Client</strong> 配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfig</span> <span class="keyword">implements</span> <span class="title">EurekaClientConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_ZONE = <span class="string">"defaultZone"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * HTTP 传输配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaTransportConfig transportConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaClientConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">        <span class="comment">// 创建 HTTP 传输配置</span></div><div class="line">        <span class="keyword">this</span>.transportConfig = <span class="keyword">new</span> DefaultEurekaTransportConfig(namespace, configInstance);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.PropertyBasedClientConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li><li><code>transportConfig</code> 属性，在 <a href="#">「3. EurekaTransportConfig」</a> 详细解析。</li></ul><h2 id="2-4-DefaultEurekaClientConfigProvider"><a href="#2-4-DefaultEurekaClientConfigProvider" class="headerlink" title="2.4 DefaultEurekaClientConfigProvider"></a>2.4 DefaultEurekaClientConfigProvider</h2><p><code>com.netflix.discovery.providers.DefaultEurekaClientConfigProvider</code>，创建 DefaultEurekaClientConfig 的工厂，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaClientConfigProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">EurekaClientConfig</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line">    <span class="meta">@EurekaNamespace</span></div><div class="line">    <span class="keyword">private</span> String namespace;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DefaultEurekaClientConfig config;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> EurekaClientConfig <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</div><div class="line">            config = (namespace == <span class="keyword">null</span>)</div><div class="line">                    ? <span class="keyword">new</span> DefaultEurekaClientConfig()</div><div class="line">                    : <span class="keyword">new</span> DefaultEurekaClientConfig(namespace);</div><div class="line">                    </div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> Remove this when DiscoveryManager is finally no longer used</span></div><div class="line">            DiscoveryManager.getInstance().setEurekaClientConfig(config);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> config;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>推荐参考阅读：</p><ul><li><a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">程序猿DD —— 《Spring Cloud微服务实战》</a> Spring Cloud Eureka —— 配置详解</li><li><a href="http://www.cnblogs.com/fangfuhai/p/7070325.html" rel="external nofollow noopener noreferrer" target="_blank">风中程序猿 —— 《微服务架构：Eureka参数配置项详解》</a></li></ul><h1 id="3-EurekaTransportConfig"><a href="#3-EurekaTransportConfig" class="headerlink" title="3. EurekaTransportConfig"></a>3. EurekaTransportConfig</h1><h2 id="3-1-类关系图"><a href="#3-1-类关系图" class="headerlink" title="3.1 类关系图"></a>3.1 类关系图</h2><p>EurekaTransportConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_22/05.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2TransportConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li></ul><h2 id="3-2-配置属性"><a href="#3-2-配置属性" class="headerlink" title="3.2 配置属性"></a>3.2 配置属性</h2><p>TODO[0011]：EurekaTransportConfig 后面看到那部分源码在补充，没理顺。</p><h2 id="3-3-DefaultEurekaTransportConfig"><a href="#3-3-DefaultEurekaTransportConfig" class="headerlink" title="3.3 DefaultEurekaTransportConfig"></a>3.3 DefaultEurekaTransportConfig</h2><p><code>com.netflix.discovery.shared.transport.DefaultEurekaTransportConfig</code>，基于<strong>配置文件</strong>的<strong>网络传输</strong>配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEurekaTransportConfig</span> <span class="keyword">implements</span> <span class="title">EurekaTransportConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_NAMESPACE = TRANSPORT_CONFIG_SUB_NAMESPACE + <span class="string">"."</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEurekaTransportConfig</span><span class="params">(String parentNamespace, DynamicPropertyFactory configInstance)</span> </span>&#123;</div><div class="line">        <span class="comment">// 命名空间</span></div><div class="line">        <span class="keyword">this</span>.namespace = parentNamespace == <span class="keyword">null</span></div><div class="line">                ? SUB_NAMESPACE</div><div class="line">                : (parentNamespace.endsWith(<span class="string">"."</span>)</div><div class="line">                    ? parentNamespace + SUB_NAMESPACE</div><div class="line">                    : parentNamespace + <span class="string">"."</span> + SUB_NAMESPACE);</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = configInstance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>类似 PropertiesInstanceConfig，点击<a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/?self">《Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig》「2.4 PropertiesInstanceConfig」</a>查看详细解析。</li><li>在 <code>com.netflix.discovery.shared.transport.PropertyBasedTransportConfigConstants</code> 可以看到配置文件的每个属性 KEY 。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-second/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-second/&lt;/a&gt; 「芋
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Client 初始化（一）之 EurekaInstanceConfig</title>
    <link href="http://www.iocoder.cn/Eureka/eureka-client-init-first/"/>
    <id>http://www.iocoder.cn/Eureka/eureka-client-init-first/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2017-10-05T03:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/eureka-client-init-first/">http://www.iocoder.cn/Eureka/eureka-client-init-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-eurekainstanceconfig">2. EurekaInstanceConfig</a><ul><li><a href="#21-%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE">2.1 类关系图</a></li><li><a href="#22-%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7">2.2 配置属性</a></li><li><a href="#23-abstractinstanceconfig">2.3 AbstractInstanceConfig</a></li><li><a href="#24-propertiesinstanceconfig">2.4 PropertiesInstanceConfig</a></li><li><a href="#25-mydatacenterinstanceconfig">2.5 MyDataCenterInstanceConfig</a></li><li><a href="#26-%E5%B0%8F%E7%BB%93">2.6 小结</a></li></ul></li><li><a href="#3-instanceinfo">3. InstanceInfo</a></li><li><a href="#4-applicationinfomanager">4. ApplicationInfoManager</a></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 自身初始化的过程</strong>，不包含 Eureka-Client 向 Eureka-Server 的注册过程( 🙂后面会另外文章分享 )。</p><p>Eureka-Client 自身初始化过程中，涉及到主要对象如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/01.png" alt=""></p><ol><li><strong>创建</strong> EurekaInstanceConfig对象</li><li>使用 EurekaInstanceConfig对象 <strong>创建</strong> InstanceInfo对象</li><li>使用 EurekaInstanceConfig对象 + InstanceInfo对象 <strong>创建</strong> ApplicationInfoManager对象</li><li><strong>创建</strong> EurekaClientConfig对象</li><li>使用 ApplicationInfoManager对象 + EurekaClientConfig对象 <strong>创建</strong> EurekaClient对象</li></ol><p>考虑到整个初始化的过程中涉及的配置特别多，拆分成三篇文章：</p><ol><li><strong>【本文】</strong>（一）EurekaInstanceConfig</li><li>（二）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-second/">EurekaClientConfig</a></li><li>（三）<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/">EurekaClient</a></li></ol><p>下面我们来看看每个<strong>类</strong>的实现。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaInstanceConfig"><a href="#2-EurekaInstanceConfig" class="headerlink" title="2. EurekaInstanceConfig"></a>2. EurekaInstanceConfig</h1><p><code>com.netflix.appinfo.EurekaInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>接口</strong>。在下文你会看到 EurekaClientConfig <strong>接口</strong>，两者的区别如下：</p><ul><li>EurekaInstanceConfig，重在<strong>应用实例</strong>，例如，应用名、应用的端口等等。此处应用指的是，Application Consumer 和 Application Provider。</li><li>EurekaClientConfig，重在 <strong>Eureka-Client</strong>，例如， 连接的 Eureka-Server 的地址、获取服务提供者列表的频率、注册自身为服务提供者的频率等等。</li></ul><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/02.jpeg" alt=""></p><h2 id="2-1-类关系图"><a href="#2-1-类关系图" class="headerlink" title="2.1 类关系图"></a>2.1 类关系图</h2><p>EurekaInstanceConfig 整体类关系如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_15/03.png" alt=""></p><ul><li>本文只解析<strong>红圈</strong>部分类。</li><li>EurekaArchaius2ClientConfig 基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 2.x</a> 实现，目前还在开发中，因此暂不解析。</li><li>CloudInstanceConfig、Ec2EurekaArchaius2InstanceConfig 基于亚马逊 AWS，大多数读者和我对 AWS 都不了解，因此暂不解析。</li></ul><h2 id="2-2-配置属性"><a href="#2-2-配置属性" class="headerlink" title="2.2 配置属性"></a>2.2 配置属性</h2><p>点击 <a href="https://github.com/YunaiV/eureka/blob/8b0f67ac33116ee05faad1ff5125034cfcf573bf/eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java" rel="external nofollow noopener noreferrer" target="_blank">EurekaInstanceConfig</a> 查看配置属性简介，已经添加中文注释，可以对照着英文注释一起理解。这里笔者摘出部分较为重要的属性：</p><ul><li><code>#getLeaseRenewalIntervalInSeconds()</code> ：租约续约频率，单位：秒。应用不断通过按照该频率发送心跳给 Eureka-Server 以达到续约的作用。当 Eureka-Server 超过最大频率未收到续约（心跳），契约失效，进行应用移除。应用移除后，其他应用无法从 Eureka-Server 获取该应用。</li><li><code>#getLeaseExpirationDurationInSeconds()</code> ：契约过期时间，单位：秒。</li><li><p><code>#getDataCenterInfo()</code> ：数据中心信息。<code>com.netflix.appinfo.DataCenterInfo</code>，数据中心信息<strong>接口</strong>，目前较为简单，标记所属数据中心名。一般情况下，我们使用 <code>Name.MyOwn</code>。接口实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataCenterInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心名枚举</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> Name &#123;</div><div class="line">        Netflix,</div><div class="line">        Amazon,</div><div class="line">        MyOwn</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 归属的数据中心名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Name <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>#getNamespace()</code> ：配置命名空间，默认使用 <code>eureka</code>。以 <code>eureka-client.properties</code> 举个例子：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">eureka.name=eureka</div><div class="line">eureka.port=<span class="number">8080</span></div><div class="line">eureka.vipAddress=eureka.mydomain.net</div></pre></td></tr></table></figure><ul><li>每个属性<strong>最前面</strong>的 <code>eureka</code> 即是配置命名空间，一般情况无需修改。</li></ul></li><li><p>TODO[0004]：健康检查</p></li><li>TODO[0006]：getDefaultAddressResolutionOrder</li><li><code>#isInstanceEnabledOnit()</code> ：应用初始化后是否开启。在<a href="#">「3. InstanceInfo」</a>详细解析。</li></ul><h2 id="2-3-AbstractInstanceConfig"><a href="#2-3-AbstractInstanceConfig" class="headerlink" title="2.3 AbstractInstanceConfig"></a>2.3 AbstractInstanceConfig</h2><p><code>com.netflix.appinfo.AbstractInstanceConfig</code>，Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，主要实现一些相对<strong>通用</strong>的配置，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 契约过期时间，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_EXPIRATION_DURATION_SECONDS = <span class="number">90</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 租约续约频率，单位：秒。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEASE_RENEWAL_INTERVAL_SECONDS = <span class="number">30</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SECURE_PORT_ENABLED = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> NON_SECURE_PORT_ENABLED = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 http 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NON_SECURE_PORT = <span class="number">80</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用 https 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECURE_PORT = <span class="number">443</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用初始化后开启</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> INSTANCE_ENABLED_ON_INIT = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机信息</span></div><div class="line"><span class="comment">     * key：主机 IP 地址</span></div><div class="line"><span class="comment">     * value：主机名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pair&lt;String, String&gt; hostInfo = getHostInfo();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据中心信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> DataCenterInfo info = <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> Name.MyOwn;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Pair&lt;String, String&gt; <span class="title">getHostInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        Pair&lt;String, String&gt; pair;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InetAddress localHost = InetAddress.getLocalHost();</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(localHost.getHostAddress(), localHost.getHostName());</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.error(<span class="string">"Cannot get host info"</span>, e);</div><div class="line">            pair = <span class="keyword">new</span> Pair&lt;String, String&gt;(<span class="string">""</span>, <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> pair;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略 setting / getting 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#getHostInfo()</code> 方法，获取本地服务器的主机名和主机 IP 地址。<strong>如果主机有多网卡或者虚拟机网卡</strong>，这块要小心，解决方式如下：<ul><li>手动配置本机的 <code>hostname</code> + <code>etc/hosts</code> 文件，从而映射主机名和 IP 地址。</li><li>使用 Spring-Cloud-Eureka-Client 的话，参考<a href="http://www.itmuch.com/spring-cloud-code-read/spring-cloud-code-read-eureka-registry-ip/?from=www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">周立 —— 《Eureka服务注册过程详解之IpAddress》</a>解决。</li></ul></li></ul><h2 id="2-4-PropertiesInstanceConfig"><a href="#2-4-PropertiesInstanceConfig" class="headerlink" title="2.4 PropertiesInstanceConfig"></a>2.4 PropertiesInstanceConfig</h2><p><code>com.netflix.appinfo.PropertiesInstanceConfig</code>，基于<strong>配置文件</strong>的 Eureka <strong>应用实例</strong>配置<strong>抽象基类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">extends</span> <span class="title">AbstractInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 命名空间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String namespace;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 配置文件对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> DynamicPropertyFactory configInstance;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用分组</span></div><div class="line"><span class="comment">     * 从 环境变量 获取</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String appGrpNameFromEnv;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(CommonConstants.DEFAULT_CONFIG_NAMESPACE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(namespace, <span class="keyword">new</span> DataCenterInfo() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Name <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Name.MyOwn;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesInstanceConfig</span><span class="params">(String namespace, DataCenterInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(info);</div><div class="line">        <span class="comment">// 设置 namespace，为 "." 结尾</span></div><div class="line">        <span class="keyword">this</span>.namespace = namespace.endsWith(<span class="string">"."</span>)</div><div class="line">                ? namespace</div><div class="line">                : namespace + <span class="string">"."</span>;</div><div class="line">        <span class="comment">// 从 环境变量 获取 应用分组</span></div><div class="line">        appGrpNameFromEnv = ConfigurationManager.getConfigInstance()</div><div class="line">                .getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);</div><div class="line">        <span class="comment">// 初始化 配置文件对象</span></div><div class="line">        <span class="keyword">this</span>.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppGroupName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> configInstance.getStringProperty(namespace + APP_GROUP_KEY, appGrpNameFromEnv).get().trim();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>configInstance</code> 属性，配置文件对象，基于 <a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Netflix Archaius 1.x</a> 实现配置文件的读取。在 <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/PropertyBasedInstanceConfigConstants.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.PropertyBasedInstanceConfigConstants</code></a> 可以看到配置文件的每个属性 KEY 。</li><li><p><code>appGrpNameFromEnv</code> 属性，应用分组，从<strong>环境变量</strong>中获取。从 <code>#getAppGroupName()</code> 方法中，可以看到优先还是从配置文件读取。设置方法如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">System.setProperty(FALLBACK_APP_GROUP_KEY, <span class="string">"app_gropu_name"</span>);</div></pre></td></tr></table></figure><ul><li><code>FALLBACK_APP_GROUP_KEY</code>，私有静态变量，实际得使用 <code>NETFLIX_APP_GROUP</code>。</li><li><code>com.netflix.config.ConfigurationManager</code> 可以从<strong>环境变量</strong>获取到值。</li></ul></li><li><p>调用 <code>Archaius1Utils#initConfig(...)</code> 方法，初始化读取的配置文件对象，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1Utils</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Archaius1Utils.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = <span class="string">"archaius.deployment.environment"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EUREKA_ENVIRONMENT = <span class="string">"eureka.environment"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicPropertyFactory <span class="title">initConfig</span><span class="params">(String configName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 配置文件对象</span></div><div class="line">        DynamicPropertyFactory configInstance = DynamicPropertyFactory.getInstance();</div><div class="line">        <span class="comment">// 配置文件名</span></div><div class="line">        DynamicStringProperty EUREKA_PROPS_FILE = configInstance.getStringProperty(<span class="string">"eureka.client.props"</span>, configName);</div><div class="line">        <span class="comment">// 配置文件环境</span></div><div class="line">        String env = ConfigurationManager.getConfigInstance().getString(EUREKA_ENVIRONMENT, <span class="string">"test"</span>);</div><div class="line">        ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, env);</div><div class="line">        <span class="comment">// 将配置文件加载到环境变量</span></div><div class="line">        String eurekaPropsFile = EUREKA_PROPS_FILE.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ConfigurationManager.loadCascadedPropertiesFromResources(eurekaPropsFile);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(</div><div class="line">                    <span class="string">"Cannot find the properties specified : &#123;&#125;. This may be okay if there are other environment "</span></div><div class="line">                            + <span class="string">"specific properties or the configuration is installed with a different mechanism."</span>,</div><div class="line">                    eurekaPropsFile);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> configInstance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从环境变量 <code>eureka.client.props</code>，获取配置文件名。如果未配置，使用参数 <code>configName</code>，即 <code>CommonConstants.CONFIG_FILE_NAME</code> ( <code>&quot;eureka-client&quot;</code> )。</li><li>从环境变量 <code>eureka.environment</code> ( EUREKA_ENVIRONMENT )，获取配置文件环境。</li><li>调用 <code>ConfigurationManager#loadCascadedPropertiesFromResources(...)</code> 方法，读取配置文件到环境变量，首先读取 <code>${eureka.client.props}</code> 对应的配置文件；然后读取 <code>${eureka.client.props}-${eureka.environment}</code> 对应的配置文件。若有相同属性，进行覆盖。</li></ul></li></ul><h2 id="2-5-MyDataCenterInstanceConfig"><a href="#2-5-MyDataCenterInstanceConfig" class="headerlink" title="2.5 MyDataCenterInstanceConfig"></a>2.5 MyDataCenterInstanceConfig</h2><p><code>com.netflix.appinfo.MyDataCenterInstanceConfig</code>，非 AWS 数据中心的 Eureka <strong>应用实例</strong>配置<strong>实现类</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataCenterInstanceConfig</span> <span class="keyword">extends</span> <span class="title">PropertiesInstanceConfig</span> <span class="keyword">implements</span> <span class="title">EurekaInstanceConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDataCenterInstanceConfig</span><span class="params">(String namespace, DataCenterInfo dataCenterInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(namespace, dataCenterInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h2><p>一般情况下，使用 MyDataCenterInstanceConfig 配置 Eureka 应用实例。</p><p>在 Spring-Cloud-Eureka 里，<strong>直接</strong>基于 EurekaInstanceConfig 接口重新实现了配置类，实际逻辑差别不大，在<a href="#">TODO[0007] ：《Spring-Cloud-Eureka-Client》</a>详细解析。</p><h1 id="3-InstanceInfo"><a href="#3-InstanceInfo" class="headerlink" title="3. InstanceInfo"></a>3. InstanceInfo</h1><p><code>com.netflix.appinfo.InstanceInfo</code>，<strong>应用实例</strong>信息。Eureka-Client 向 Eureka-Server <strong>注册</strong>该对象信息。注册成功后，可以被其他 Eureka-Client <strong>发现</strong>。</p><p><strong>本文仅分享 InstanceInfo 的初始化</strong>。InstanceInfo 里和注册发现相关的属性和方法，暂时跳过。</p><p><code>com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider</code>，基于 EurekaInstanceConfig 创建 InstanceInfo 的工厂，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="meta">@Singleton</span></div><div class="line">  <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span> <span class="keyword">implements</span> <span class="title">Provider</span>&lt;<span class="title">InstanceInfo</span>&gt; </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(EurekaConfigBasedInstanceInfoProvider.class);</div><div class="line">  <span class="number">4</span>: </div><div class="line">  <span class="number">5</span>:     <span class="keyword">private</span> <span class="keyword">final</span> EurekaInstanceConfig config;</div><div class="line">  <span class="number">6</span>: </div><div class="line">  <span class="number">7</span>:     <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">  <span class="number">8</span>: </div><div class="line">  <span class="number">9</span>:     <span class="meta">@Inject</span>(optional = <span class="keyword">true</span>)</div><div class="line"> <span class="number">10</span>:     <span class="keyword">private</span> VipAddressResolver vipAddressResolver = <span class="keyword">null</span>;</div><div class="line"> <span class="number">11</span>: </div><div class="line"> <span class="number">12</span>:     <span class="meta">@Inject</span></div><div class="line"> <span class="number">13</span>:     <span class="function"><span class="keyword">public</span> <span class="title">EurekaConfigBasedInstanceInfoProvider</span><span class="params">(EurekaInstanceConfig config)</span> </span>&#123;</div><div class="line"> <span class="number">14</span>:         <span class="keyword">this</span>.config = config;</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>: </div><div class="line"> <span class="number">17</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">18</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> InstanceInfo <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">19</span>:         <span class="keyword">if</span> (instanceInfo == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">20</span>:             <span class="comment">// Build the lease information to be passed to the server based on config</span></div><div class="line"> <span class="number">21</span>:             <span class="comment">// 创建 租约信息构建器，并设置属性</span></div><div class="line"> <span class="number">22</span>:             LeaseInfo.Builder leaseInfoBuilder = LeaseInfo.Builder.newBuilder()</div><div class="line"> <span class="number">23</span>:                     .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())</div><div class="line"> <span class="number">24</span>:                     .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// 创建 VIP地址解析器</span></div><div class="line"> <span class="number">27</span>:             <span class="keyword">if</span> (vipAddressResolver == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">28</span>:                 vipAddressResolver = <span class="keyword">new</span> Archaius1VipAddressResolver();</div><div class="line"> <span class="number">29</span>:             &#125;</div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:             <span class="comment">// Builder the instance information to be registered with eureka server</span></div><div class="line"> <span class="number">32</span>:             <span class="comment">// 创建 应用实例信息构建器</span></div><div class="line"> <span class="number">33</span>:             InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder(vipAddressResolver);</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:             <span class="comment">// 应用实例编号</span></div><div class="line"> <span class="number">36</span>:             <span class="comment">// set the appropriate id for the InstanceInfo, falling back to datacenter Id if applicable, else hostname</span></div><div class="line"> <span class="number">37</span>:             String instanceId = config.getInstanceId();</div><div class="line"> <span class="number">38</span>:             DataCenterInfo dataCenterInfo = config.getDataCenterInfo();</div><div class="line"> <span class="number">39</span>:             <span class="keyword">if</span> (instanceId == <span class="keyword">null</span> || instanceId.isEmpty()) &#123;</div><div class="line"> <span class="number">40</span>:                 <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</div><div class="line"> <span class="number">41</span>:                     instanceId = ((UniqueIdentifier) dataCenterInfo).getId();</div><div class="line"> <span class="number">42</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">43</span>:                     instanceId = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">44</span>:                 &#125;</div><div class="line"> <span class="number">45</span>:             &#125;</div><div class="line"> <span class="number">46</span>: </div><div class="line"> <span class="number">47</span>:             <span class="comment">// 获得 主机名</span></div><div class="line"> <span class="number">48</span>:             String defaultAddress;</div><div class="line"> <span class="number">49</span>:             <span class="keyword">if</span> (config <span class="keyword">instanceof</span> RefreshableInstanceConfig) &#123;</div><div class="line"> <span class="number">50</span>:                 <span class="comment">// Refresh AWS data center info, and return up to date address</span></div><div class="line"> <span class="number">51</span>:                 defaultAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(<span class="keyword">false</span>);</div><div class="line"> <span class="number">52</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">53</span>:                 defaultAddress = config.getHostName(<span class="keyword">false</span>);</div><div class="line"> <span class="number">54</span>:             &#125;</div><div class="line"> <span class="number">55</span>:             <span class="comment">// fail safe</span></div><div class="line"> <span class="number">56</span>:             <span class="keyword">if</span> (defaultAddress == <span class="keyword">null</span> || defaultAddress.isEmpty()) &#123;</div><div class="line"> <span class="number">57</span>:                 defaultAddress = config.getIpAddress();</div><div class="line"> <span class="number">58</span>:             &#125;</div><div class="line"> <span class="number">59</span>: </div><div class="line"> <span class="number">60</span>:             <span class="comment">// 设置 应用实例信息构建器 的 属性</span></div><div class="line"> <span class="number">61</span>:             builder.setNamespace(config.getNamespace())</div><div class="line"> <span class="number">62</span>:                     .setInstanceId(instanceId)</div><div class="line"> <span class="number">63</span>:                     .setAppName(config.getAppname())</div><div class="line"> <span class="number">64</span>:                     .setAppGroupName(config.getAppGroupName())</div><div class="line"> <span class="number">65</span>:                     .setDataCenterInfo(config.getDataCenterInfo())</div><div class="line"> <span class="number">66</span>:                     .setIPAddr(config.getIpAddress())</div><div class="line"> <span class="number">67</span>:                     .setHostName(defaultAddress) <span class="comment">// 主机名</span></div><div class="line"> <span class="number">68</span>:                     .setPort(config.getNonSecurePort())</div><div class="line"> <span class="number">69</span>:                     .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())</div><div class="line"> <span class="number">70</span>:                     .setSecurePort(config.getSecurePort())</div><div class="line"> <span class="number">71</span>:                     .enablePort(PortType.SECURE, config.getSecurePortEnabled())</div><div class="line"> <span class="number">72</span>:                     .setVIPAddress(config.getVirtualHostName()) <span class="comment">// VIP 地址</span></div><div class="line"> <span class="number">73</span>:                     .setSecureVIPAddress(config.getSecureVirtualHostName())</div><div class="line"> <span class="number">74</span>:                     .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())</div><div class="line"> <span class="number">75</span>:                     .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())</div><div class="line"> <span class="number">76</span>:                     .setASGName(config.getASGName())</div><div class="line"> <span class="number">77</span>:                     .setHealthCheckUrls(config.getHealthCheckUrlPath(),</div><div class="line"> <span class="number">78</span>:                             config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());</div><div class="line"> <span class="number">79</span>: </div><div class="line"> <span class="number">80</span>:             <span class="comment">// 应用初始化后是否开启</span></div><div class="line"> <span class="number">81</span>:             <span class="comment">// Start off with the STARTING state to avoid traffic</span></div><div class="line"> <span class="number">82</span>:             <span class="keyword">if</span> (!config.isInstanceEnabledOnit()) &#123;</div><div class="line"> <span class="number">83</span>:                 InstanceStatus initialStatus = InstanceStatus.STARTING;</div><div class="line"> <span class="number">84</span>:                 LOG.info(<span class="string">"Setting initial instance status as: "</span> + initialStatus);</div><div class="line"> <span class="number">85</span>:                 builder.setStatus(initialStatus);</div><div class="line"> <span class="number">86</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">87</span>:                 LOG.info(<span class="string">"Setting initial instance status as: &#123;&#125;. This may be too early for the instance to advertise "</span></div><div class="line"> <span class="number">88</span>:                          + <span class="string">"itself as available. You would instead want to control this via a healthcheck handler."</span>,</div><div class="line"> <span class="number">89</span>:                          InstanceStatus.UP);</div><div class="line"> <span class="number">90</span>:             &#125;</div><div class="line"> <span class="number">91</span>: </div><div class="line"> <span class="number">92</span>:             <span class="comment">// 设置 应用实例信息构建器 的 元数据( Metadata )集合</span></div><div class="line"> <span class="number">93</span>:             <span class="comment">// Add any user-specific metadata information</span></div><div class="line"> <span class="number">94</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; mapEntry : config.getMetadataMap().entrySet()) &#123;</div><div class="line"> <span class="number">95</span>:                 String key = mapEntry.getKey();</div><div class="line"> <span class="number">96</span>:                 String value = mapEntry.getValue();</div><div class="line"> <span class="number">97</span>:                 builder.add(key, value);</div><div class="line"> <span class="number">98</span>:             &#125;</div><div class="line"> <span class="number">99</span>: </div><div class="line"><span class="number">100</span>:             <span class="comment">// 创建 应用实例信息</span></div><div class="line"><span class="number">101</span>:             instanceInfo = builder.build();</div><div class="line"><span class="number">102</span>: </div><div class="line"><span class="number">103</span>:             <span class="comment">// 设置 应用实例信息 的 租约信息</span></div><div class="line"><span class="number">104</span>:             instanceInfo.setLeaseInfo(leaseInfoBuilder.build());</div><div class="line"><span class="number">105</span>:         &#125;</div><div class="line"><span class="number">106</span>:         <span class="keyword">return</span> instanceInfo;</div><div class="line"><span class="number">107</span>:     &#125;</div><div class="line"><span class="number">108</span>: </div><div class="line"><span class="number">109</span>: &#125;</div></pre></td></tr></table></figure><ul><li>该类实现 <code>javax.inject.Provider</code> 接口，设置 InstanceInfo 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。目前处于<strong>试验</strong>阶段，未完成。</li><li><code>EurekaConfigBasedInstanceInfoProvider(config)</code> 构造方法，设置生成 InstanceInfo 的 EurekaInstanceConfig 配置。</li><li><p>调用 <code>#get()</code> 方法，根据 EurekaInstanceConfig 创建 InstanceInfo。InstanceInfo 的绝大数属性和 EurekaInstanceConfig 是一致的 。实现代码如下：</p><ul><li>第 21 至 24 行 ：创建租约信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/LeaseInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.LeaseInfo.Builder</code></a> )，并设置 <code>renewalIntervalInSecs</code> / <code>durationInSecs</code> 属性。</li><li><p>第 26 至 29 行 ：创建 VIP地址解析器( <code>com.netflix.appinfo.providers.VipAddressResolver</code> )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// VipAddressResolver.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Archaius1VipAddressResolver</span> <span class="keyword">implements</span> <span class="title">VipAddressResolver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern VIP_ATTRIBUTES_PATTERN = Pattern.compile(<span class="string">"\\$\\&#123;(.*?)\\&#125;"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">resolveDeploymentContextBasedVipAddresses</span><span class="params">(String vipAddressMacro)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (vipAddressMacro == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        String result = vipAddressMacro;</div><div class="line">        <span class="comment">// 替换表达式</span></div><div class="line">        Matcher matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</div><div class="line">            String key = matcher.group(<span class="number">1</span>);</div><div class="line">            String value = DynamicPropertyFactory.getInstance().getStringProperty(key, <span class="string">""</span>).get();</div><div class="line"></div><div class="line">            logger.debug(<span class="string">"att:"</span> + matcher.group());</div><div class="line">            logger.debug(<span class="string">", att key:"</span> + key);</div><div class="line">            logger.debug(<span class="string">", att value:"</span> + value);</div><div class="line">            logger.debug(<span class="string">""</span>);</div><div class="line"></div><div class="line">            result = result.replaceAll(<span class="string">"\\$\\&#123;"</span> + key + <span class="string">"\\&#125;"</span>, value);</div><div class="line">            matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>#resolveDeploymentContextBasedVipAddresses()</code> 方法，将 <strong>VIP地址</strong> 里的 <code>${(.*?)}</code> 查找配置文件里的键值进行替换。例如，<code>${eureka.env}.domain.com</code>，查找配置文件里的键 <code>${eureka.env}</code> 对应值进行替换。TODO[0005]：调试下来，发现 Archaius 已经替换，等到找到答案修改此处。</li></ul></li><li><p>第 32 至 33 行 ：创建应用实例信息构建器( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo.Builder</code></a> )。</p></li><li>第 35 至 45 行 ：获得应用实例编号( <code>instanceId</code> )。</li><li>第 47 至 58 行 ：获得主机名。</li><li>第 60 至 78 行 ：设置应用实例信息构建器的属性。</li><li>第 80 至 90 行 ：应用初始化后是否开启。<ul><li>第 82 至 85 行 ：应用<strong>不开启</strong>，应用实例处于 STARTING 状态。</li><li>第 86 至 90 行 ：应用<strong>开启</strong>，应用实例处于 UP 状态。</li><li><strong>使用应用初始化后不开启</strong>，可以通过调用 <code>ApplicationInfoManager#setInstanceStatus(...)</code> 方法改变应用实例状态，在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li></ul></li><li>第 92 至 98 行 ：设置应用实例信息构建器的元数据( Metadata )集合。</li><li>第 100 至 101 行 ：创建应用实例信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</li><li>第 103 至 104 行 ：设置应用实例信息的租约信息( <a href="https://github.com/YunaiV/eureka/blob/671d7fc20bd6353040431d6e298eac5f82293497/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.netflix.appinfo.InstanceInfo</code></a> )。</li></ul></li></ul><h1 id="4-ApplicationInfoManager"><a href="#4-ApplicationInfoManager" class="headerlink" title="4. ApplicationInfoManager"></a>4. ApplicationInfoManager</h1><p><code>com.netflix.appinfo.ApplicationInfoManager</code>，应用信息管理器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationInfoManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationInfoManager instance = <span class="keyword">new</span> ApplicationInfoManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 状态变更监听器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, StatusChangeListener&gt; listeners;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例状态匹配</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusMapper instanceStatusMapper;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InstanceInfo instanceInfo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> EurekaInstanceConfig config;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它构造方法</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationInfoManager</span><span class="params">(EurekaInstanceConfig config, InstanceInfo instanceInfo, OptionalArgs optionalArgs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.config = config;</div><div class="line">        <span class="keyword">this</span>.instanceInfo = instanceInfo;</div><div class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ConcurrentHashMap&lt;String, StatusChangeListener&gt;();</div><div class="line">        <span class="keyword">if</span> (optionalArgs != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = optionalArgs.getInstanceStatusMapper();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.instanceStatusMapper = NO_OP_MAPPER;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Hack to allow for getInstance() to use the DI'd ApplicationInfoManager</span></div><div class="line">        instance = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>listeners</code> 属性，状态变更监听器集合。在<a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现 （一）之注册》「2.1 应用实例信息复制器」</a>有详细解析。</li><li><p><code>instanceStatusMapper</code> 属性，应用实例状态匹配。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationInfoManager.java</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusMapper</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InstanceStatusMapper NO_OP_MAPPER = <span class="keyword">new</span> InstanceStatusMapper() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> InstanceStatus <span class="title">map</span><span class="params">(InstanceStatus prev)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> prev;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>#map</code> 方法，根据传入 <code>pre</code> 参数，转换成对应的应用实例状态。</li><li>默认情况下，使用 NO_OP_MAPPER 。一般情况下，不需要关注该类。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>涉及到配置，内容初看起来会比较多，慢慢理解后，就会变得很“啰嗦”，请保持耐心。</p><p>胖友，分享一个朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/eureka-client-init-first/&quot;&gt;http://www.iocoder.cn/Eureka/eureka-client-init-first/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/Eureka/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/Eureka/build-debugging-environment/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2017-10-05T02:35:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/build-debugging-environment/">http://www.iocoder.cn/Eureka/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="#">1. 依赖工具</a></li><li><a href="#">2. 源码拉取</a></li><li><a href="#">3. Eureka-Server 启动</a><ul><li><a href="#">3.1 MockRemoteEurekaServer</a></li><li><a href="#">3.2 Eureka-Server war 包</a></li><li><a href="#">3.3 Eureka-Server 直接启动</a></li></ul></li><li><a href="#">4. Eureka-Client 启动</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Gradle</li><li>JDK</li><li>IntelliJ IDEA</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/Netflix/eureka.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Gradle</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-Eureka-Server-启动"><a href="#3-Eureka-Server-启动" class="headerlink" title="3. Eureka-Server 启动"></a>3. Eureka-Server 启动</h1><p>Eureka-Server 启动调试方式，有三种方式，我们来尝试每一种。</p><h2 id="3-1-MockRemoteEurekaServer"><a href="#3-1-MockRemoteEurekaServer" class="headerlink" title="3.1 MockRemoteEurekaServer"></a>3.1 MockRemoteEurekaServer</h2><p><code>com.netflix.eureka.AbstractTester</code>，测试抽象类，有如下实现子类：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/01.png" alt=""></p><p>使用任意一个子类的单元测试执行即可执行 Eureka-Server 逻辑的调试，这里以 <code>com.netflix.eureka.resources.ApplicationsResourceTest</code> 作为例子。</p><p>Debug 运行 <code>ApplicationsResourceTest#testFullAppsGetJson()</code> 单元测试。在方法执行前，<code>ApplicationsResourceTest#setUp()</code> 会运行，初始化 Eureka-Server <strong>模拟环境</strong>，例如：<br><code>com.netflix.eureka.mock.MockRemoteEurekaServer</code> ( 模拟 Eureka-Server )。</p><p>因为是<strong>模拟环境</strong>，对 Eureka-Server 的操作不是 Eureka-Client 请求 Eureka-Server 的方式，而是直接调用单元测试对应的方法。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ApplicationsResourceTest.java</span></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFullAppsGetJson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   Response response = applicationsResource.getContainers(</div><div class="line">           Version.V2.name(),</div><div class="line">           MediaType.APPLICATION_JSON,</div><div class="line">           <span class="keyword">null</span>, <span class="comment">// encoding</span></div><div class="line">           EurekaAccept.full.name(),</div><div class="line">           <span class="keyword">null</span>,  <span class="comment">// uriInfo</span></div><div class="line">           <span class="keyword">null</span>  <span class="comment">// remote regions</span></div><div class="line">   );</div><div class="line"></div><div class="line">   String json = String.valueOf(response.getEntity());</div><div class="line">   DecoderWrapper decoder = CodecWrappers.getDecoder(CodecWrappers.LegacyJacksonJson.class);</div><div class="line"></div><div class="line">   Applications decoded = decoder.decode(json, Applications.class);</div><div class="line">   <span class="comment">// test per app as the full apps list include the mock server that is not part of the test apps</span></div><div class="line">   <span class="keyword">for</span> (Application application : testApplications.getRegisteredApplications()) &#123;</div><div class="line">       Application decodedApp = decoded.getRegisteredApplications(application.getName());</div><div class="line">       assertThat(EurekaEntityComparators.equal(application, decodedApp), is(<span class="keyword">true</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>直接调用 <code>ApplicationsResource#getContainers(...)</code> 方法。</li></ul><p><strong>总结</strong>：这种方式，简单粗暴，容易上手。当然，它的缺点是<strong>模拟</strong>。刚开始调试 Eureka-Server 可以尝试这种方式。</p><h2 id="3-2-Eureka-Server-war-包"><a href="#3-2-Eureka-Server-war-包" class="headerlink" title="3.2 Eureka-Server war 包"></a>3.2 Eureka-Server war 包</h2><p>第一步，编译 Eureka-Server war 包。该步骤可能消耗漫长的时间，如果执行失败，请不断重试。命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cd</span> eureka</div><div class="line">./gradlew clean build</div></pre></td></tr></table></figure><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。</p><p><strong>总结</strong>：这种方式，编译的过程比较痛苦，不排除失败的可能性。每次增加对代码的注册后，都需要重新编译打包。因此不建议采用。那咋办呢？见第三种。良心如博主，赶紧关注博主的微信公众号：【<strong>芋道源码</strong>】。</p><h2 id="3-3-Eureka-Server-直接启动"><a href="#3-3-Eureka-Server-直接启动" class="headerlink" title="3.3 Eureka-Server 直接启动"></a>3.3 Eureka-Server 直接启动</h2><p>第一步，修改 <code>EurekaClientServerRestIntegrationTest#startServer()</code> 方法，解决第二种方式使用 war 包运行每次修改代码都需要重新编译的问题，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaClientServerRestIntegrationTest.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line"></div><div class="line">   <span class="comment">// TODO Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</span></div><div class="line">   WebAppContext webAppCtx = <span class="keyword">new</span> WebAppContext(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp"</span>).getAbsolutePath(), <span class="string">"/"</span>);</div><div class="line">   webAppCtx.setDescriptor(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/webapp/WEB-INF/web.xml"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setResourceBase(<span class="keyword">new</span> File(<span class="string">"./eureka-server/src/main/resources"</span>).getAbsolutePath());</div><div class="line">   webAppCtx.setClassLoader(Thread.currentThread().getContextClassLoader());</div><div class="line">   server.setHandler(webAppCtx);</div><div class="line">   server.start();</div><div class="line"></div><div class="line">   eurekaServiceUrl = <span class="string">"http://localhost:8080/v2"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>笔者不太熟悉 Gradle 的打包方式，使用 <code>Thread.currentThread().getContextClassLoader().getResource()</code> 方法，一直无法拿到路径，有知道的同学麻烦告知下。</li></ul><p>第二步，Debug 运行<code>com.netflix.eureka.resources.EurekaClientServerRestIntegrationTest</code> 任意单元测试方法。TODO[0003]：Thread.currentThread().getContextClassLoader() 获取不到路径，先暂时这样；</p><p><strong>总结</strong>：这种方式，完美。建议使用该方式调试。</p><h1 id="4-Eureka-Client-启动"><a href="#4-Eureka-Client-启动" class="headerlink" title="4. Eureka-Client 启动"></a>4. Eureka-Client 启动</h1><p>我们以 <code>com.netflix.eureka.ExampleEurekaClient</code> 为例子。</p><p>第一步，在 <code>EurekaClientServerRestIntegrationTest#setUp()</code> 方法末尾添加 <code>Thread.sleep(Long.MAX_VALUE)</code> 代码。</p><p>第二步，按照<a href="#">「 3.3 Eureka-Server 直接启动」</a>方法启动 Eureka-Server。</p><p>第三步，将 <code>EurekaClientServerRestIntegrationTest#injectEurekaConfiguration</code> 复制到 ExampleEurekaClient 类里。</p><p>第四步，在 <code>ExampleEurekaClient#main()</code> 方法的第一行，添加 <code>injectEurekaConfiguration()</code> 代码。</p><p>第五步，Debug 运行 <code>ExampleEurekaClient#main()</code> 方法。</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_08/02.png" alt=""></p><p><code>eureka-examples</code> 模块还提供别的例子，可以逐个调试。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文写的，相对比较简洁，如果有任何疑问，可以给我公众号留言。</p><p>下一篇更新？恩，我还没想好，整理<a href="#">《Eureka 源码解析》</a>整个系列的目录ing。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/Eureka/build-debugging-environment/&lt;/a
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 项目结构简介</title>
    <link href="http://www.iocoder.cn/Eureka/project-structure/"/>
    <id>http://www.iocoder.cn/Eureka/project-structure/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2017-10-05T02:31:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/project-structure/">http://www.iocoder.cn/Eureka/project-structure/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong>  </p><ul><li><a href="#">1. 概述</a><ul><li><a href="#">1.1 简介</a></li><li><a href="#">1.2 项目结构</a></li></ul></li><li><a href="#">2. eureka-client</a><ul><li><a href="#">2.1 eureka-client-archaius2</a></li><li><a href="#">2.2 eureka-client-jersey2</a></li></ul></li><li><a href="#">3. eureka-core</a><ul><li><a href="#">3.1 eureka-core-jersey2</a></li></ul></li><li><a href="#">4. eureka-resources</a></li><li><a href="#">5. eureka-server</a><ul><li><a href="#">5.1 eureka-server-governator</a></li></ul></li><li><a href="#">6. eureka-examples</a></li><li><a href="#">7. eureka-test-utils</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 的项目结构</strong>，附带部分简介和原理。</p><p>Eureka 项目地址：<a href="https://github.com/Netflix/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/eureka</a></p><ul><li>请注意下，不是 <code>spring-cloud-netflix-eureka-client</code> / <code>spring-cloud-netflix-eureka-server</code> 。</li><li>笔者 Fork 的代码仓库 <a href="https://github.com/YunaiV/eureka" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/eureka</a>，会随着这个系列的文章逐渐增加<strong>中文注释</strong>，可以先 Star 一下。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Eureka 是 <a href="https://zh.wikipedia.org/wiki/Netflix" rel="external nofollow noopener noreferrer" target="_blank">Netflix</a> 开源的服务注册发现组件，分成 Client 和 Server 两部分。简化架构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/01.png" alt=""></p><ul><li>Eureka-Server ：通过 REST 协议暴露服务，提供应用服务的注册和发现的功能。</li><li>Application Provider ：应用服务提供者，内嵌 Eureka-Client ，通过它向 Eureka-Server 注册自身服务。</li><li>Application Consumer ：应用服务消费者，内嵌 Eureka-Client ，通过它从 Eureka-Server 获取服务列表。</li><li>请注意下，Application Provider 和 Application Consumer 强调扮演的角色，实际可以在同一 JVM 进程，即是服务的提供者，又是服务的消费者。</li></ul><h2 id="1-2-项目结构"><a href="#1-2-项目结构" class="headerlink" title="1.2 项目结构"></a>1.2 项目结构</h2><p>Eureka 项目结构如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/02.png" alt=""></p><p>❓❓❓不只 Eureka-Client 、 Eureka-Server ❓❓❓</p><p>淡定。我们一起来了解每个模块的功能和结构。</p><h1 id="2-eureka-client"><a href="#2-eureka-client" class="headerlink" title="2. eureka-client"></a>2. <code>eureka-client</code></h1><p><code>eureka-client</code> 模块为 Eureka-Client 的功能实现：</p><ul><li><code>com.netflix.appinfo</code> 包：Eureka-Client 的应用配置。此处的应用指的就是上文提到的 Application Provider，Application Consumer。</li><li><p><code>com.netflix.discovery</code> 包：Eureka-Client 的注册与发现相关功能。</p><ul><li><code>com.netflix.discovery.DiscoveryClient</code> 类：注册发现客户端实现类。</li><li><p><code>com.netflix.discovery.guice</code> 包：Eureka <strong>计划</strong>使用 <a href="https://github.com/google/guice" rel="external nofollow noopener noreferrer" target="_blank">Google Guice</a> 实现依赖注入，参见本文「5.1 <code>eureka-server-governator</code>」。一方面 Guice 是轻量级的依赖注入框架，另一方面避免和业务代码的 Spring 版本冲突。</p><blockquote><p>Guice (pronounced ‘juice’) is a lightweight dependency injection framework for Java 6 and above, brought to you by Google. </p></blockquote></li><li><p><code>com.netflix.discovery.converters</code> 包：Eureka 内部传输数据编解码转换器，支持 XML / JSON 格式。</p></li><li><code>com.netflix.discovery.endpoint</code> 包：目前该包正在重构，和下文的 <code>com.netflix.discovery.shared.dns</code> 和 <code>com.netflix.discovery.shared.resolver</code> 用途相近。</li><li><code>com.netflix.disvoery.provider</code> 包：目前仅有 DiscoveryJerseyProvider 类。该类声明自定义的 Jersey 请求和响应的序列化和反序列化实现。</li><li><code>com.netflix.disvoery.providers</code> 包：目前仅有 DefaultEurekaClientConfigProvider 类。该类实现 <code>javax.inject.Provider</code> 接口，设置 EurekaClientConfig ( Eureka 客户端配置 ) 的生成工厂。感兴趣的同学，可以点击<a href="http://blog.csdn.net/derekjiang/article/details/7231490" rel="external nofollow noopener noreferrer" target="_blank">《Google-Guice入门介绍》</a>搜索 <strong>Provider</strong> 关键字。</li><li><p><code>com.netflix.discovery.shared</code> 包：Eureka-Client 和 Eureka-Server 注册发现相关的共享重用的代码。下文你会看到，Eureka-Server 通过 <code>eureka-core</code> 模块实现，<code>eureka-core</code> 依赖 <code>eureka-client</code>。<strong>粗一看，我们会感觉 What ？Eureka-Server 代码依赖 Eureka-Client 代码</strong>！？这个和 Eureka-Server 多节点注册信息 P2P 同步的实现有关。一个 Eureka-Server 收到 Eureka-Client 注册请求后，Eureka-Server 会自己模拟 Eureka-Client 发送注册请求到其它的 Eureka-Server，因此部分实现代码就使用到了这个包，在<a href="#">TODO[0002]：《Eureka 源码解析 —— Eureka-Server 集群（二）之同步注册表》</a>详细解析。</p><ul><li><code>com.netflix.discovery.shared.transport</code> 包：Eureka-Client 对 Eureka-Server RESTful 的 HTTP 客户端，基于 Jersey Client 实现。Jersey 在下文「2.1 <code>eureka-client-jersey2</code>」详细解析。</li><li><code>com.netflix.discovery.shared.dns</code> 包 ：DNS 解析器。</li><li><code>com.netflix.discovery.shared.resolver</code> 包：EurekaEndpoint 解析器。【TODO[0001]：<code>com.netflix.discovery.shared.resolver</code>】</li></ul></li><li><p><code>com.netflix.discovery.util</code> 包 ：工具类。</p></li></ul></li></ul><h2 id="2-1-eureka-client-archaius2"><a href="#2-1-eureka-client-archaius2" class="headerlink" title="2.1 eureka-client-archaius2"></a>2.1 <code>eureka-client-archaius2</code></h2><p><a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">Archaius</a> 是 Netflix 开源的配置管理组件。</p><p>Archaius 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本仍然在开发中。</p><blockquote><p>FROM <a href="https://github.com/YunaiV/eureka/blob/103e0875b08c9ff4abb85eaab672df2041b63558/eureka-client-archaius2/README.md" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-archaius2 README</a><br>This is a version of eureka-client that has been ported to use Archaius 2.x as the backing configuration system. Please note that this client is still work in progress. This client is also only java8 compatible (as Archaius 2.x is only java8 compatible).</p></blockquote><h2 id="2-2-eureka-client-jersey2"><a href="#2-2-eureka-client-jersey2" class="headerlink" title="2.2 eureka-client-jersey2"></a>2.2 <code>eureka-client-jersey2</code></h2><p><a href="https://github.com/jersey/jersey" rel="external nofollow noopener noreferrer" target="_blank">Jersey</a> 是 JAX-RS（JSR311）开源参考实现，用于构建 RESTful Web Service。</p><ul><li>Eureka-Server 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-server/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Server</a> 创建 RESTful Server 。</li><li>Eureka-Client 使用 <a href="https://github.com/jersey/jersey/tree/9fdb7e386dc56b33f569ab198caf818d7a18525d/core-client/" rel="external nofollow noopener noreferrer" target="_blank">Jersey Client</a> 请求 Eureka-Server 。</li></ul><p>Jersey 目前有 1.x 和 2.x 版本，默认情况下，Eureka 使用 1.x 版本。从官方文档上来看，2.x 版本由社区实现，Netflix 自己暂未使用。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-client-jersey2/" rel="external nofollow noopener noreferrer" target="_blank">eureka-client-jersey2 README</a><br>Please note that this jersey2 compatible Eureka client (eureka-client-jersey2) is created and maintained by the community. Netflix does not currently use this library internally.</p></blockquote><h1 id="3-eureka-core"><a href="#3-eureka-core" class="headerlink" title="3. eureka-core"></a>3. <code>eureka-core</code></h1><p><code>eureka-core</code> 模块为 Eureka-Server 的功能实现：</p><ul><li><code>com.netflix.eureka.EurekaBootStrap</code> 类：Eureka-Server 启动类。</li><li><code>com.netflix.eureka.aws</code> 包：与亚马逊 AWS 服务相关的类。由于笔者和大多数读者都对 AWS 暂不了解，本系列<a href="#">《Eureka 源码解析》</a>会跳过和 AWS 相关的代码。</li><li><code>com.netflix.eureka.cluster</code> 包：Eureka-Server 集群数据复制相关的代码。</li><li><code>com.netflix.eureka.lease</code> 包：应用注册后的<strong>租约</strong>管理( 注册 / 取消 / 续期 / 过期 )。</li><li><code>com.netflix.eureka.resousrces</code> 包：资源，基于 Jersey Server 实现，相当于 Spring MVC 的控制层代码。</li><li><code>com.netflix.eureka.transport</code> 包：Eureka-Server 对 Eureka-Server 的 RESTful HTTP 客户端，基于 <code>com.netflix.discovery.shared.transport</code> 封装实现。</li><li><code>com.netflix.eureka.util</code> 包：工具类。</li></ul><h2 id="3-1-eureka-core-jersey2"><a href="#3-1-eureka-core-jersey2" class="headerlink" title="3.1 eureka-core-jersey2"></a>3.1 <code>eureka-core-jersey2</code></h2><p>参见本文「2.1 <code>eureka-client-jersey2</code>」。</p><h1 id="4-eureka-resources"><a href="#4-eureka-resources" class="headerlink" title="4. eureka-resources"></a>4. <code>eureka-resources</code></h1><p><code>eureka-resources</code> 模块，使用 JSP 实现 Eureka-Server 的运维后台界面。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/03.png" alt=""></p><h1 id="5-eureka-server"><a href="#5-eureka-server" class="headerlink" title="5. eureka-server"></a>5. <code>eureka-server</code></h1><p><code>eureka-server</code> 模块，将 <code>eureka-client</code> + <code>eureka-core</code> + <code>eureka-resources</code> 三者打包成 Eureka-Server 的 <code>war</code> 包。项目结构如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_04_01/04.png" alt=""></p><h2 id="5-1-eureka-server-governator"><a href="#5-1-eureka-server-governator" class="headerlink" title="5.1 eureka-server-governator"></a>5.1 <code>eureka-server-governator</code></h2><p><code>eureka-server-governator</code> 模块，使用 <a href="https://github.com/Netflix/governator" rel="external nofollow noopener noreferrer" target="_blank">Netflix Governator</a> 管理 Eureka-Server 的生命周期。</p><blockquote><p>FROM <a href="http://www.infoq.com/cn/news/2013/02/netflix-opensource" rel="external nofollow noopener noreferrer" target="_blank">http://www.infoq.com/cn/news/2013/02/netflix-opensource</a><br><strong>Governator</strong>，一款对 Google Guice 进行扩展的类库，提供了Classpath扫描及自动绑定、生命周期管理、成员属性验证等功能。</p></blockquote><p>目前该模块正在实现阶段。</p><blockquote><p>FROM <a href="https://github.com/Netflix/eureka/tree/30a85dc31be1c9d399e4e6ec5150759fb8777edf/eureka-server-governator/" rel="external nofollow noopener noreferrer" target="_blank">eureka-server-governator README</a><br>This server build is still experimental.</p></blockquote><h1 id="6-eureka-examples"><a href="#6-eureka-examples" class="headerlink" title="6. eureka-examples"></a>6. <code>eureka-examples</code></h1><p><code>eureka-examples</code> 模块，提供 Eureka-Client 使用例子。</p><h1 id="7-eureka-test-utils"><a href="#7-eureka-test-utils" class="headerlink" title="7. eureka-test-utils"></a>7. <code>eureka-test-utils</code></h1><p><code>eureka-test-utils</code> 模块，提供 Eureka 单元测试工具类。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>第一篇 Eureka 的文章，如果有地方写的不正确，还望指出，谢谢。</p><p>下一篇 Eureka 调试环境搭建。</p><p>更多 Eureka 内容，推荐阅读如下文章：</p><ul><li>携程 —— <a href="http://techshow.ctrip.com/archives/1699.html" rel="external nofollow noopener noreferrer" target="_blank">《深度剖析服务发现组件Netflix Eureka》</a></li><li>程序员DD —— <a href="http://blog.didispace.com/springcloud-sourcecode-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud源码分析（一）Eureka》</a></li><li>王鸿飞 —— <a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》</a></li><li>许进 —— <a href="http://xujin.org/sc/sc-netflix-eureka/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix之Eureka上篇》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/project-structure/&quot;&gt;http://www.iocoder.cn/Eureka/project-structure/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 项目实战</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/http-sample/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/http-sample/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2017-09-18T08:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-%E5%AE%9E%E4%BD%93%E7%BB%93%E6%9E%84">2. 实体结构</a><ul><li><a href="#21-%E5%95%86%E5%9F%8E%E6%9C%8D%E5%8A%A1">2.1 商城服务</a></li><li><a href="#22-%E8%B5%84%E9%87%91%E6%9C%8D%E5%8A%A1">2.2 资金服务</a></li><li><a href="#23-%E7%BA%A2%E5%8C%85%E6%9C%8D%E5%8A%A1">2.3 红包服务</a></li></ul></li><li><a href="#3-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8">3. 服务调用</a></li><li><a href="#4-%E4%B8%8B%E5%8D%95%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B">4. 下单支付流程</a><ul><li><a href="#41-try-%E9%98%B6%E6%AE%B5">4.1 Try 阶段</a></li><li><a href="#42-confirm--cancel-%E9%98%B6%E6%AE%B5">4.2 Confirm / Cancel 阶段</a></li></ul></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>TCC 项目实战</strong>。以官方 Maven项目 <code>tcc-transaction-http-sample</code> 为例子( <code>tcc-transaction-dubbo-sample</code> 类似 )。</p><p>建议你已经成功启动了该项目。如果不知道如何启动，可以先查看<a href="http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/?self">《TCC-Transaction 源码分析 —— 调试环境搭建》</a>。如果再碰到问题，欢迎加微信公众号( <strong>芋道源码</strong> )，我会一一仔细回复。</p><p>OK，首先我们简单了解下这个项目。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/01.png" alt=""></p><ul><li>首页 =&gt; 商品列表 =&gt; 确认支付页 =&gt; 支付结果页</li><li>使用账户余额 + 红包余额<strong>联合</strong>支付购买商品，并账户之间<strong>转账</strong>。</li></ul><p>项目拆分三个子 Maven 项目：</p><ul><li><code>tcc-transaction-http-order</code> ：商城服务，提供商品和商品订单逻辑。</li><li><code>tcc-transaction-http-capital</code> ：资金服务，提供账户余额逻辑。</li><li><code>tcc-transaction-http-redpacket</code> ：红包服务，提供红包余额逻辑。</li></ul><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/03.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-实体结构"><a href="#2-实体结构" class="headerlink" title="2. 实体结构"></a>2. 实体结构</h1><h2 id="2-1-商城服务"><a href="#2-1-商城服务" class="headerlink" title="2.1 商城服务"></a>2.1 商城服务</h2><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/02.png" alt=""></p><ul><li><p>Shop，商店表。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商店编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 所有者用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ownerUserId;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Product，商品表。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> productId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商店编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> shopId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String productName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单价</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal price;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Order，订单表。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5908730245224893590L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支付( 下单 )用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> payerUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 收款( 商店拥有者 )用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> payeeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 红包支付金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal redPacketPayAmount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户余额支付金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal capitalPayAmount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - PAYING ：支付中</span></div><div class="line"><span class="comment">     * - CONFIRMED ：支付成功</span></div><div class="line"><span class="comment">     * - PAY_FAILED ：支付失败</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号，使用 UUID 生成</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单明细数组</span></div><div class="line"><span class="comment">     * 非存储字段</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;OrderLine&gt; orderLines = <span class="keyword">new</span> ArrayList&lt;OrderLine&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>OrderLine，订单明细。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderLine</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2300754647209250837L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商品编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> productId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单价</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal unitPrice;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>业务逻辑</strong>：</p><p>下单时，插入订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( Order )记录，并插入购买的商品订单明细( OrderLine )记录。支付时，更新订单状态为 <code>&quot;PAYING&quot;</code>。</p><ul><li>订单支付成功，更新订单状态为 <code>&quot;CONFIRMED&quot;</code>。</li><li>订单支付失败，更新订单状体为 <code>&quot;PAY_FAILED&quot;</code>。</li></ul><h2 id="2-2-资金服务"><a href="#2-2-资金服务" class="headerlink" title="2.2 资金服务"></a>2.2 资金服务</h2><p>关系较为简单，有两个实体：</p><ul><li><p>CapitalAccount，资金账户余额。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 余额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal balanceAmount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>TradeOrder，交易订单表。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeOrder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转出用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> selfUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转入用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> oppositeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal amount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - CONFIRM ：交易成功</span></div><div class="line"><span class="comment">     * - CANCEL ：交易取消</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>业务逻辑</strong>：</p><p>订单支付支付中，插入交易订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( TradeOrder )记录，并更新<strong>减少</strong>下单用户的资金账户余额。</p><ul><li>订单支付成功，更新交易订单状态为 <code>&quot;CONFIRM&quot;</code>，并更新<strong>增加</strong>商店拥有用户的资金账户余额。</li><li>订单支付失败，更新交易订单状态为 <code>&quot;CANCEL&quot;</code>，并更新<strong>增加( 恢复 )</strong>下单用户的资金账户余额。</li></ul><h2 id="2-3-红包服务"><a href="#2-3-红包服务" class="headerlink" title="2.3 红包服务"></a>2.3 红包服务</h2><p>关系较为简单，<strong>和资金服务 99.99% 相同</strong>，有两个实体：</p><ul><li><p>RedPacketAccount，红包账户余额。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPacketAccount</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 账户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 余额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal balanceAmount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>TradeOrder，交易订单表。实体代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeOrder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转出用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> selfUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 转入用户编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> oppositeUserId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 商户订单号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String merchantOrderNo;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 金额</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> BigDecimal amount;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 交易订单状态</span></div><div class="line"><span class="comment">     * - DRAFT ：草稿</span></div><div class="line"><span class="comment">     * - CONFIRM ：交易成功</span></div><div class="line"><span class="comment">     * - CANCEL ：交易取消</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String status = <span class="string">"DRAFT"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><strong>业务逻辑</strong>：</p><p>订单支付支付中，插入交易订单状态为 <code>&quot;DRAFT&quot;</code> 的订单( TradeOrder )记录，并更新<strong>减少</strong>下单用户的红包账户余额。</p><ul><li>订单支付成功，更新交易订单状态为 <code>&quot;CONFIRM&quot;</code>，并更新<strong>增加</strong>商店拥有用户的红包账户余额。</li><li>订单支付失败，更新交易订单状态为 <code>&quot;CANCEL&quot;</code>，并更新<strong>增加( 恢复 )</strong>下单用户的红包账户余额。</li></ul><h1 id="3-服务调用"><a href="#3-服务调用" class="headerlink" title="3. 服务调用"></a>3. 服务调用</h1><p>服务之间，通过 <strong>HTTP</strong> 进行调用。</p><p><strong>红包服务和资金服务为商城服务提供调用( 以资金服务为例子 )</strong>：</p><ul><li><p>XML 配置如下 ：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-provider.xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountRepository"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.domain.repository.CapitalAccountRepository"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"tradeOrderRepository"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.domain.repository.TradeOrderRepository"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalTradeOrderService"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.service.CapitalTradeOrderServiceImpl"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountService"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.service.CapitalAccountServiceImpl"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalTradeOrderServiceExporter"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"capitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"capitalAccountServiceExporter"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"service"</span> <span class="attr">ref</span>=<span class="string">"capitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalAccountService"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpServer"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.support.SimpleHttpServerFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contexts"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalTradeOrderService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalTradeOrderServiceExporter"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalAccountService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalAccountServiceExporter"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"8081"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>Java 代码实现如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    CapitalAccountRepository capitalAccountRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> capitalAccountRepository.findByUserId(userId).getBalanceAmount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapitalAccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    CapitalAccountRepository capitalAccountRepository;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> capitalAccountRepository.findByUserId(userId).getBalanceAmount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p><strong>商城服务调用</strong></p><ul><li><p>XML 配置如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-consumer.xml</div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpInvokerRequestExecutor"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpClient"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.HttpClient"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpConnectionManager"</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"multiThreadHttpConnectionManager"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multiThreadHttpConnectionManager"</span></span></div><div class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.MultiThreadedHttpConnectionManager"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"params"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.httpclient.params.HttpConnectionManagerParams"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionTimeout"</span> <span class="attr">value</span>=<span class="string">"200000"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotalConnections"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultMaxConnectionsPerHost"</span> <span class="attr">value</span>=<span class="string">"512"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"soTimeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"captialTradeOrderService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8081/remoting/CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"capitalAccountService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8081/remoting/CapitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.capital.api.CapitalAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redPacketAccountService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8082/remoting/RedPacketAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.redpacket.api.RedPacketAccountService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redPacketTradeOrderService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceUrl"</span> <span class="attr">value</span>=<span class="string">"http://localhost:8082/remoting/RedPacketTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serviceInterface"</span></span></div><div class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">"org.mengyun.tcctransaction.sample.http.redpacket.api.RedPacketTradeOrderService"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpInvokerRequestExecutor"</span> <span class="attr">ref</span>=<span class="string">"httpInvokerRequestExecutor"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>Java 接口接口如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalAccountService</span> </span>&#123;</div><div class="line">    <span class="function">BigDecimal <span class="title">getCapitalAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketAccountService</span> </span>&#123;</div><div class="line">    <span class="function">BigDecimal <span class="title">getRedPacketAccountByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, RedPacketTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="4-下单支付流程"><a href="#4-下单支付流程" class="headerlink" title="4. 下单支付流程"></a>4. 下单支付流程</h1><p><strong>ps</strong>：数据访问的方法，请自己拉取代码，使用 IDE 查看。谢谢。🙂</p><p>下单支付流程，整体流程如下图( <a href="./../../images/TCC-Transaction/2018_03_15/04.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/04.png" alt=""></p><p>点击<strong>【支付】</strong>按钮，下单支付流程。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">""</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="meta">@RequestMapping</span>(value = <span class="string">"/placeorder"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">placeOrder</span><span class="params">(@RequestParam String redPacketPayAmount,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> shopId,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> payerUserId,</span></span></div><div class="line"><span class="function"><span class="params">                                   @RequestParam <span class="keyword">long</span> productId)</span> </span>&#123;</div><div class="line">        PlaceOrderRequest request = buildRequest(redPacketPayAmount, shopId, payerUserId, productId);</div><div class="line">        <span class="comment">// 下单并支付订单</span></div><div class="line">        String merchantOrderNo = placeOrderService.placeOrder(request.getPayerUserId(), request.getShopId(),</div><div class="line">                request.getProductQuantities(), request.getRedPacketPayAmount());</div><div class="line">        <span class="comment">// 返回</span></div><div class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">"pay_success"</span>);</div><div class="line">        <span class="comment">// 查询订单状态</span></div><div class="line">        String status = orderService.getOrderStatusByMerchantOrderNo(merchantOrderNo);</div><div class="line">        <span class="comment">// 支付结果提示</span></div><div class="line">        String payResultTip = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="string">"CONFIRMED"</span>.equals(status)) &#123;</div><div class="line">            payResultTip = <span class="string">"支付成功"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"PAY_FAILED"</span>.equals(status)) &#123;</div><div class="line">            payResultTip = <span class="string">"支付失败"</span>;</div><div class="line">        &#125;</div><div class="line">        mv.addObject(<span class="string">"payResult"</span>, payResultTip);</div><div class="line">        <span class="comment">// 商品信息</span></div><div class="line">        mv.addObject(<span class="string">"product"</span>, productRepository.findById(productId));</div><div class="line">        <span class="comment">// 资金账户金额 和 红包账户金额</span></div><div class="line">        mv.addObject(<span class="string">"capitalAmount"</span>, accountService.getCapitalAccountByUserId(payerUserId));</div><div class="line">        mv.addObject(<span class="string">"redPacketAmount"</span>, accountService.getRedPacketAccountByUserId(payerUserId));</div><div class="line">        <span class="keyword">return</span> mv;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>PlaceOrderService#placeOrder(...)</code> 方法，下单并支付订单。</li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-order/src/main/java/org/mengyun/tcctransaction/sample/http/order/domain/service/OrderServiceImpl.java" rel="external nofollow noopener noreferrer" target="_blank"><code>OrderService#getOrderStatusByMerchantOrderNo(...)</code></a> 方法，查询订单状态。</li></ul><hr><p>调用 <code>PlaceOrderService#placeOrder(...)</code> 方法，下单并支付订单。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">placeOrder</span><span class="params">(<span class="keyword">long</span> payerUserId, <span class="keyword">long</span> shopId, List&lt;Pair&lt;Long, Integer&gt;&gt; productQuantities, BigDecimal redPacketPayAmount)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取商店</span></div><div class="line">        Shop shop = shopRepository.findById(shopId);</div><div class="line">        <span class="comment">// 创建订单</span></div><div class="line">        Order order = orderService.createOrder(payerUserId, shop.getOwnerUserId(), productQuantities);</div><div class="line">        <span class="comment">// 发起支付</span></div><div class="line">        Boolean result = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            paymentService.makePayment(order, redPacketPayAmount, order.getTotalAmount().subtract(redPacketPayAmount));</div><div class="line">        &#125; <span class="keyword">catch</span> (ConfirmingException confirmingException) &#123;</div><div class="line">            <span class="comment">// exception throws with the tcc transaction status is CONFIRMING,</span></div><div class="line">            <span class="comment">// when tcc transaction is confirming status,</span></div><div class="line">            <span class="comment">// the tcc transaction recovery will try to confirm the whole transaction to ensure eventually consistent.</span></div><div class="line">            result = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (CancellingException cancellingException) &#123;</div><div class="line">            <span class="comment">// exception throws with the tcc transaction status is CANCELLING,</span></div><div class="line">            <span class="comment">// when tcc transaction is under CANCELLING status,</span></div><div class="line">            <span class="comment">// the tcc transaction recovery will try to cancel the whole transaction to ensure eventually consistent.</span></div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="comment">// other exceptions throws at TRYING stage.</span></div><div class="line">            <span class="comment">// you can retry or cancel the operation.</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> order.getMerchantOrderNo();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ShopRepository#findById(...)</code> 方法，查询商店。</li><li><p>调用 <code>OrderService#createOrder(...)</code> 方法，创建订单状态为 <code>&quot;DRAFT&quot;</code> 的<strong>商城</strong>订单。实际业务不会这么做，此处仅仅是例子，简化流程。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Transactional</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">createOrder</span><span class="params">(<span class="keyword">long</span> payerUserId, <span class="keyword">long</span> payeeUserId, List&lt;Pair&lt;Long, Integer&gt;&gt; productQuantities)</span> </span>&#123;</div><div class="line">        Order order = orderFactory.buildOrder(payerUserId, payeeUserId, productQuantities);</div><div class="line">        orderRepository.createOrder(order);</div><div class="line">        <span class="keyword">return</span> order;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li>调用 <code>PaymentService#makePayment(...)</code> 方法，发起支付，<strong>TCC 流程</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li><li><strong>生产代码对于异常需要进一步处理</strong>。</li></ul><h2 id="4-1-Try-阶段"><a href="#4-1-Try-阶段" class="headerlink" title="4.1 Try 阶段"></a>4.1 Try 阶段</h2><p><strong>商城服务</strong></p><p>调用 <code>PaymentService#makePayment(...)</code> 方法，发起 Try 流程，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmMakePayment"</span>, cancelMethod = <span class="string">"cancelMakePayment"</span>)</div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   System.out.println(<span class="string">"order try make payment called.time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付中</span></div><div class="line">   order.pay(redPacketPayAmount, capitalPayAmount);</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">   <span class="comment">// 资金账户余额支付订单</span></div><div class="line">   String result = tradeOrderServiceProxy.record(<span class="keyword">null</span>, buildCapitalTradeOrderDto(order));</div><div class="line">   <span class="comment">// 红包账户余额支付订单</span></div><div class="line">   String result2 = tradeOrderServiceProxy.record(<span class="keyword">null</span>, buildRedPacketTradeOrderDto(order));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置方法注解 @Compensable</p><ul><li>事务传播级别 Propagation.REQUIRED ( <strong>默认值</strong> )</li><li>设置 <code>confirmMethod</code> /  <code>cancelMethod</code> 方法名</li><li>事务上下文编辑类 DefaultTransactionContextEditor ( <strong>默认值</strong> )</li></ul></li><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为<strong>支付中</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.redPacketPayAmount = redPacketPayAmount;</div><div class="line">   <span class="keyword">this</span>.capitalPayAmount = capitalPayAmount;</div><div class="line">   <span class="keyword">this</span>.status = <span class="string">"PAYING"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>调用 <code>TradeOrderServiceProxy#record(...)</code> 方法，<strong>资金</strong>账户余额支付订单。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TradeOrderServiceProxy.java</span></div><div class="line"><span class="meta">@Compensable</span>(propagation = Propagation.SUPPORTS, confirmMethod = <span class="string">"record"</span>, cancelMethod = <span class="string">"record"</span>, transactionContextEditor = Compensable.DefaultTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> capitalTradeOrderService.record(transactionContext, tradeOrderDto);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CapitalTradeOrderService.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置方法注解 @Compensable</p><ul><li><code>propagation=Propagation.SUPPORTS</code> ：支持当前事务，如果当前没有事务，就以非事务方式执行。<strong>为什么不使用 REQUIRED</strong> ？如果使用 REQUIRED 事务传播级别，事务恢复重试时，会发起新的事务。</li><li><code>confirmMethod</code>、<code>cancelMethod</code> 使用和 try 方法<strong>相同方法名</strong>：<strong>本地发起</strong>远程服务 TCC confirm / cancel 阶段，调用相同方法进行事务的提交或回滚。远程服务的 CompensableTransactionInterceptor 会根据事务的状态是 CONFIRMING / CANCELLING 来调用对应方法。</li></ul></li><li><p>调用 <code>CapitalTradeOrderService#record(...)</code> 方法，远程调用，发起<strong>资金</strong>账户余额支付订单。</p><ul><li>本地方法调用时，参数 <code>transactionContext</code> 传递 <code>null</code> 即可，TransactionContextEditor 会设置。在<a href="http://www.iocoder.cn/TCC-Transaction/tcc-core/?self">《TCC-Transaction 源码分析 —— TCC 实现》「6.3 资源协调者拦截器」</a>有详细解析。</li><li>远程方法调用时，参数 <code>transactionContext</code> 需要传递。Dubbo 远程方法调用实际也进行了传递，传递方式较为特殊，通过隐式船舱，在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码分析 —— Dubbo 支持》「3. Dubbo 事务上下文编辑器」</a>有详细解析。</li></ul></li></ul></li><li><p>调用 <code>TradeOrderServiceProxy#record(...)</code> 方法，<strong>红包</strong>账户余额支付订单。和<strong>资金</strong>账户余额支付订单 99.99% 类似，不重复“复制粘贴”。</p></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#record(...)</code> 方法，<strong>红包</strong>账户余额支付订单。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmRecord"</span>, cancelMethod = <span class="string">"cancelRecord"</span>, transactionContextEditor = Compensable.DefaultTransactionContextEditor.class)</div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line"><span class="comment">//            Thread.sleep(10000000L);</span></div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital try record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 生成交易订单</span></div><div class="line">   TradeOrder tradeOrder = <span class="keyword">new</span> TradeOrder(</div><div class="line">           tradeOrderDto.getSelfUserId(),</div><div class="line">           tradeOrderDto.getOppositeUserId(),</div><div class="line">           tradeOrderDto.getMerchantOrderNo(),</div><div class="line">           tradeOrderDto.getAmount()</div><div class="line">   );</div><div class="line">   tradeOrderRepository.insert(tradeOrder);</div><div class="line">   <span class="comment">// 更新减少下单用户的资金账户余额</span></div><div class="line">   CapitalAccount transferFromAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getSelfUserId());</div><div class="line">   transferFromAccount.transferFrom(tradeOrderDto.getAmount());</div><div class="line">   capitalAccountRepository.save(transferFromAccount);</div><div class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>设置方法注解 @Compensable</p><ul><li>事务传播级别 Propagation.REQUIRED ( <strong>默认值</strong> )</li><li>设置 <code>confirmMethod</code> /  <code>cancelMethod</code> 方法名</li><li>事务上下文编辑类 DefaultTransactionContextEditor ( <strong>默认值</strong> )</li></ul></li><li><p>设置方法注解 @Transactional，保证方法操作原子性。</p></li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#insert(...)</code></a> 方法，生成订单状态为 <code>&quot;DRAFT&quot;</code> 的交易订单。</li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新减少下单用户的资金账户余额。<strong>Try 阶段锁定资源时，一定要先扣。TCC 是最终事务一致性，如果先添加，可能被使用</strong>。</li></ul><h2 id="4-2-Confirm-Cancel-阶段"><a href="#4-2-Confirm-Cancel-阶段" class="headerlink" title="4.2 Confirm / Cancel 阶段"></a>4.2 Confirm / Cancel 阶段</h2><p>当 Try 操作<strong>全部</strong>成功时，发起 Confirm 操作。<br>当 Try 操作存在<strong>任务</strong>失败时，发起 Cancel 操作。</p><h3 id="4-2-1-Confirm"><a href="#4-2-1-Confirm" class="headerlink" title="4.2.1 Confirm"></a>4.2.1 Confirm</h3><p><strong>商城服务</strong></p><p>调用 <code>PaymentServiceImpl#confirmMakePayment(...)</code> 方法，更新订单状态为支付<strong>成功</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmMakePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"order confirm make payment called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付成功</span></div><div class="line">   order.confirm();</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>生产代码该方法需要加下 @Transactional 注解，保证原子性</strong>。</li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为支付成功。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.status = <span class="string">"CONFIRMED"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#confirmRecord(...)</code> 方法，更新交易订单状态为交易<strong>成功</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital confirm record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 查询交易记录</span></div><div class="line">   TradeOrder tradeOrder = tradeOrderRepository.findByMerchantOrderNo(tradeOrderDto.getMerchantOrderNo());</div><div class="line">   <span class="comment">// 判断交易记录状态。因为 `#record()` 方法，可能事务回滚，记录不存在 / 状态不对</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != tradeOrder &amp;&amp; <span class="string">"DRAFT"</span>.equals(tradeOrder.getStatus())) &#123;</div><div class="line">       <span class="comment">// 更新订单状态为交易成功</span></div><div class="line">       tradeOrder.confirm();</div><div class="line">       tradeOrderRepository.update(tradeOrder);</div><div class="line">       <span class="comment">// 更新增加商店拥有者用户的资金账户余额</span></div><div class="line">       CapitalAccount transferToAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getOppositeUserId());</div><div class="line">       transferToAccount.transferTo(tradeOrderDto.getAmount());</div><div class="line">       capitalAccountRepository.save(transferToAccount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>设置方法注解 @Transactional，保证方法操作原子性。</li><li><strong>判断交易记录状态</strong>。因为 <code>#record()</code> 方法，可能事务回滚，记录不存在 / 状态不对。</li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#update(...)</code></a> 方法，更新交易订单状态为交易<strong>成功</strong>。</li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新增加商店拥有者用户的资金账户余额。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CapitalAccount.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferTo</span><span class="params">(BigDecimal amount)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.balanceAmount = <span class="keyword">this</span>.balanceAmount.add(amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p><strong>红包服务</strong></p><p>和<strong>资源服务</strong> 99.99% 相同，不重复“复制粘贴”。</p><h3 id="4-2-2-Cancel"><a href="#4-2-2-Cancel" class="headerlink" title="4.2.2 Cancel"></a>4.2.2 Cancel</h3><p><strong>商城服务</strong></p><p>调用 <code>PaymentServiceImpl#cancelMakePayment(...)</code> 方法，更新订单状态为支付<strong>失败</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelMakePayment</span><span class="params">(Order order, BigDecimal redPacketPayAmount, BigDecimal capitalPayAmount)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"order cancel make payment called.time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 更新订单状态为支付失败</span></div><div class="line">   order.cancelPayment();</div><div class="line">   orderRepository.updateOrder(order);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>生产代码该方法需要加下 @Transactional 注解，保证原子性</strong>。</li><li><p>调用 <code>OrderRepository#updateOrder(...)</code> 方法，更新订单状态为支付失败。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Order.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelPayment</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.status = <span class="string">"PAY_FAILED"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p><strong>资金服务</strong></p><p>调用 <code>CapitalTradeOrderServiceImpl#cancelRecord(...)</code> 方法，更新交易订单状态为交易<strong>失败</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;</div><div class="line">   <span class="comment">// 调试用</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">1000l</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">   &#125;</div><div class="line">   System.out.println(<span class="string">"capital cancel record called. time seq:"</span> + DateFormatUtils.format(Calendar.getInstance(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</div><div class="line">   <span class="comment">// 查询交易记录</span></div><div class="line">   TradeOrder tradeOrder = tradeOrderRepository.findByMerchantOrderNo(tradeOrderDto.getMerchantOrderNo());</div><div class="line">   <span class="comment">// 判断交易记录状态。因为 `#record()` 方法，可能事务回滚，记录不存在 / 状态不对</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != tradeOrder &amp;&amp; <span class="string">"DRAFT"</span>.equals(tradeOrder.getStatus())) &#123;</div><div class="line">       <span class="comment">// / 更新订单状态为交易失败</span></div><div class="line">       tradeOrder.cancel();</div><div class="line">       tradeOrderRepository.update(tradeOrder);</div><div class="line">       <span class="comment">// 更新增加( 恢复 )下单用户的资金账户余额</span></div><div class="line">       CapitalAccount capitalAccount = capitalAccountRepository.findByUserId(tradeOrderDto.getSelfUserId());</div><div class="line">       capitalAccount.cancelTransfer(tradeOrderDto.getAmount());</div><div class="line">       capitalAccountRepository.save(capitalAccount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>设置方法注解 @Transactional，保证方法操作原子性。</li><li><strong>判断交易记录状态</strong>。因为 <code>#record()</code> 方法，可能事务回滚，记录不存在 / 状态不对。</li><li>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/TradeOrderRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>TradeOrderRepository#update(...)</code></a> 方法，更新交易订单状态为交易<strong>失败</strong>。</li><li><p>调用 <a href="https://github.com/YunaiV/tcc-transaction/blob/ff443d9e6d39bd798ed042034bad123b83675922/tcc-transaction-tutorial-sample/tcc-transaction-http-sample/tcc-transaction-http-capital/src/main/java/org/mengyun/tcctransaction/sample/http/capital/domain/repository/CapitalAccountRepository.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CapitalAccountRepository#save(...)</code></a> 方法，更新增加( 恢复 )下单用户的资金账户余额。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CapitalAccount.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelTransfer</span><span class="params">(BigDecimal amount)</span> </span>&#123;</div><div class="line">    transferTo(amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p><strong>红包服务</strong></p><p>和<strong>资源服务</strong> 99.99% 相同，不重复“复制粘贴”。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>嘿嘿，代码只是看起来比较多，实际不多。</p><p>蚂蚁金融云提供了银行间转账的 TCC 过程例子，有兴趣的同学可以看看：<a href="https://www.cloud.alipay.com/docs/2/46886" rel="external nofollow noopener noreferrer" target="_blank">《蚂蚁金融云 —— 分布式事务服务（DTS） —— 场景介绍》</a>。</p><p>本系列 EOF ~撒花</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_15/05.png" alt=""></p><p>胖友，分享个朋友圈，可好？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-%E5%AE%
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 运维平台</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/console/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/console/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2017-09-17T11:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 数据访问层</a><ul><li><a href="#">2.1 JDBC 事务 DAO</a></li><li><a href="#">2.2 Redis 事务 DAO</a></li></ul></li><li><a href="#">3. 控制层</a><ul><li><a href="#">3.1 查看未完成的事务列表</a></li><li><a href="#">3.2 重置事务恢复重试次数</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>运维平台</strong>。TCC-Transaction 提供了相对精简的运维平台，用于查看在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码分析 —— 事务存储器》</a>提到的<strong>事务存储</strong>。目前暂时只有两个功能：</p><ul><li>查看未完成的事务列表</li><li>重置事务恢复重试次数</li></ul><p>运维平台( Maven 项目 <code>tcc-transaction-server</code> ) 整体代码结构如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/01.png" alt=""></p><p>本文自下而上，Dao =&gt; Controller =&gt; UI 的顺序进行解析实现。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1 id="2-数据访问层"><a href="#2-数据访问层" class="headerlink" title="2. 数据访问层"></a>2. 数据访问层</h1><p><code>org.mengyun.tcctransaction.server.dao.TransactionDao</code>，事务Dao <strong>接口</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务 VO 数组</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pageNum 第几页</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 分页大小</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务 VO 数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;TransactionVo&gt; <span class="title">findTransactions</span><span class="params">(String domain, Integer pageNum, <span class="keyword">int</span> pageSize)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务总数量</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Integer <span class="title">countOfFindTransactions</span><span class="params">(String domain)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重置事务重试次数</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> domain 领域</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> globalTxId 全局事务编号</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> branchQualifier 分支事务编号</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否重置成功</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">resetRetryCount</span><span class="params">(String domain, <span class="keyword">byte</span>[] globalTxId, <span class="keyword">byte</span>[] branchQualifier)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>TCC-Transaction 提供了四种事务存储器，但是目前只支持两种数据访问层的实现：</p><ul><li>JDBC 事务 DAO</li><li>Redis 事务 DAO</li></ul><h2 id="2-1-JDBC-事务-DAO"><a href="#2-1-JDBC-事务-DAO" class="headerlink" title="2.1 JDBC 事务 DAO"></a>2.1 JDBC 事务 DAO</h2><p><code>org.mengyun.tcctransaction.server.dao.JdbcTransactionDao</code>，JDBC 事务 DAO 实现。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Repository</span>(<span class="string">"jdbcTransactionDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransactionDao</span> <span class="keyword">implements</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME_PREFIX = <span class="string">"TCC_TRANSACTION"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> DataSource dataSource;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 读取 jdbc-domain-suffix.properties</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;jdbcDomainSuffix&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> Properties domainSuffix;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>dataSource</code>，数据源。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></div><div class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></div><div class="line"><span class="tag">     <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logAbandoned"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"removeAbandoned"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"removeAbandonedTimeout"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"numTestsPerEvictionRun"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT NOW() FROM DUAL"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">// tcc-transaction-server.properties</div><div class="line">jdbc.url=jdbc:mysql://127.0.0.1:33061/TCC?useUnicode=true&amp;characterEncoding=UTF-8</div><div class="line">jdbc.username=root</div><div class="line">jdbc.password=123456</div></pre></td></tr></table></figure><ul><li>在 <code>appcontext-server-dao.xml</code>，配置数据源 Bean 对象。</li><li>在 <code>tcc-transaction-server.properties</code>，配置数据源属性。</li></ul></li><li><p><code>domainSuffix</code>，<code>domian</code> 和 表后缀( <code>suffix</code> ) 的映射关系。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// jdbc-domain-suffix.properties</div><div class="line">CAPITAL=_CAP</div><div class="line">ORDER=_ORD</div><div class="line">REDPACKET=_RED</div></pre></td></tr></table></figure><ul><li>键 ：domain。</li><li>值 ：suffix。</li></ul></li></ul><p>JdbcTransactionDao 代码实现上比较易懂，点击<a href="https://github.com/YunaiV/tcc-transaction/blob/e54c3e43a2e47a7765bdb18a485860cb31acbb72/tcc-transaction-server/src/main/java/org/mengyun/tcctransaction/server/dao/JdbcTransactionDao.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看，已经添加中文注释。</p><h2 id="2-2-Redis-事务-DAO"><a href="#2-2-Redis-事务-DAO" class="headerlink" title="2.2 Redis 事务 DAO"></a>2.2 Redis 事务 DAO</h2><p><code>org.mengyun.tcctransaction.server.dao.RedisTransactionDao</code>，Redis 事务 DAO。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Repository</span>(<span class="string">"redisTransactionDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTransactionDao</span> <span class="keyword">implements</span> <span class="title">TransactionDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * redis pool</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JedisPool jedisPool;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 序列化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ObjectSerializer serializer = <span class="keyword">new</span> JdkSerializationSerializer();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 读取 redis-domain-key-prefix.properties</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;redisDomainKeyPrefix&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> Properties domainKeyPrefix;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>jedisPool</code>，Redis 连接池。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"6000"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"4"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">null</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"5"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.db&#125;"</span> <span class="attr">type</span>=<span class="string">"int"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">// tcc-transaction-server.properties</div><div class="line">redis.host=127.0.0.1</div><div class="line">redis.port=6379</div><div class="line">redis.password=</div><div class="line">redis.db=0</div></pre></td></tr></table></figure><ul><li>在 <code>appcontext-server-dao.xml</code>，配置 Redis 连接池 Bean 对象。</li><li>在 <code>tcc-transaction-server.properties</code>，配置 Redis 连接池属性。</li></ul></li><li><p><code>domainKeyPrefix</code>，domain 和 Redis Key 前缀( <code>prefix</code> )的映射。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">CAPITAL=TCC:CAP:</div><div class="line">ORDER=TCC:ORD:</div><div class="line">REDPACKET=TCC:RED:</div></pre></td></tr></table></figure><ul><li>键 ：domain。</li><li>值 ：suffix。</li></ul></li></ul><p>RedisTransactionDao 代码实现上比较易懂，点击[链接]<a href="https://github.com/YunaiV/tcc-transaction/blob/e54c3e43a2e47a7765bdb18a485860cb31acbb72/tcc-transaction-server/src/main/java/org/mengyun/tcctransaction/server/dao/RedisTransactionDao.java)查看，已经添加中文注释。" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/tcc-transaction/blob/e54c3e43a2e47a7765bdb18a485860cb31acbb72/tcc-transaction-server/src/main/java/org/mengyun/tcctransaction/server/dao/RedisTransactionDao.java)查看，已经添加中文注释。</a></p><h1 id="3-控制层"><a href="#3-控制层" class="headerlink" title="3. 控制层"></a>3. 控制层</h1><p><code>org.mengyun.tcctransaction.server.controller.TransactionController</code>，事务 Controller。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PAGE_NUM = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PAGE_SIZE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据访问对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="meta">@Qualifier</span>(<span class="string">"jdbcTransactionDao"</span>)</div><div class="line">    <span class="keyword">private</span> TransactionDao transactionDao;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 项目访问根目录</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;tcc_domain&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String tccDomain;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>transactionDao</code>，数据访问对象。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-server-dao.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionDao"</span> <span class="attr">class</span>=<span class="string">"org.mengyun.tcctransaction.server.dao.JdbcTransactionDao"</span>/&gt;</span></div></pre></td></tr></table></figure><ul><li>目前运维平台只能读取一个数据源，如果你的数据源是多个，需要对运维平台做一定的改造，或启动多个项目。</li></ul></li><li><p><code>tccDomain</code>，项目访问根目录。配置方式如下：</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// tcc-transaction-server.properties</div><div class="line">tcc_domain=</div></pre></td></tr></table></figure><ul><li>一般情况下不用配置，如果你放在 Tomcat 根目录。</li></ul></li></ul><h2 id="3-1-查看未完成的事务列表"><a href="#3-1-查看未完成的事务列表" class="headerlink" title="3.1 查看未完成的事务列表"></a>3.1 查看未完成的事务列表</h2><p>调用 <code>TransactionController#manager(...)</code> 方法，查看事务列表。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"manager"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management/domain/&#123;domain&#125;"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">(@PathVariable String domain)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> manager(domain, DEFAULT_PAGE_NUM);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/management/domain/&#123;domain&#125;/pagenum/&#123;pageNum&#125;"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">manager</span><span class="params">(@PathVariable String domain, @PathVariable Integer pageNum)</span> </span>&#123;</div><div class="line">   ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"manager"</span>);</div><div class="line">   <span class="comment">// 获得事务 VO 数组</span></div><div class="line">   List&lt;TransactionVo&gt; transactionVos = transactionDao.findTransactions(domain, pageNum, DEFAULT_PAGE_SIZE);</div><div class="line">   <span class="comment">// 获得事务总数量</span></div><div class="line">   Integer totalCount = transactionDao.countOfFindTransactions(domain);</div><div class="line">   <span class="comment">// 计算总页数</span></div><div class="line">   Integer pages = totalCount / DEFAULT_PAGE_SIZE;</div><div class="line">   <span class="keyword">if</span> (totalCount % DEFAULT_PAGE_SIZE &gt; <span class="number">0</span>) &#123;</div><div class="line">       pages++;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回</span></div><div class="line">   modelAndView.addObject(<span class="string">"transactionVos"</span>, transactionVos);</div><div class="line">   modelAndView.addObject(<span class="string">"pageNum"</span>, pageNum);</div><div class="line">   modelAndView.addObject(<span class="string">"pageSize"</span>, DEFAULT_PAGE_SIZE);</div><div class="line">   modelAndView.addObject(<span class="string">"pages"</span>, pages);</div><div class="line">   modelAndView.addObject(<span class="string">"domain"</span>, domain);</div><div class="line">   modelAndView.addObject(<span class="string">"urlWithoutPaging"</span>, tccDomain + <span class="string">"/management/domain/"</span> + domain);</div><div class="line">   <span class="keyword">return</span> modelAndView;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UI 界面如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/02.png" alt=""></p><h2 id="3-2-重置事务恢复重试次数"><a href="#3-2-重置事务恢复重试次数" class="headerlink" title="3.2 重置事务恢复重试次数"></a>3.2 重置事务恢复重试次数</h2><p>调用 <code>TransactionController#reset(...)</code> 方法，事务重置重试次数。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/domain/&#123;domain&#125;/retry/reset"</span>, method = RequestMethod.PUT)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> CommonResponse&lt;Void&gt; <span class="title">reset</span><span class="params">(@PathVariable String domain, String globalTxId, String branchQualifier)</span> </span>&#123;</div><div class="line">   transactionDao.resetRetryCount(domain,</div><div class="line">           DatatypeConverter.parseHexBinary(globalTxId),</div><div class="line">           DatatypeConverter.parseHexBinary(branchQualifier));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CommonResponse&lt;Void&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UI 界面如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/03.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>可能有人会吐槽运维平台怎么做的这么简陋。这个不是 TCC-Transaction 一个开源项目存在的问题，其他例如 Dubbo、Disconf 等等都会存在这个情况。</p><p>开源作者因为时间关系，更多的精力关注在核心代码，所以对运维友好性可能花费的精力较少。</p><p>当然，因为是开源的关系，我们可以自己做运维平台反向的贡献到这些项目。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_28/04.png" alt=""></p><p>胖友，分享一个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 数据访问层&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— Dubbo 支持</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/dubbo-support/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2017-09-26T18:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li><li><a href="#2-dubbo-%E4%BB%A3%E7%90%86">2. Dubbo 代理</a><ul><li><a href="#21-javassistproxyfactory">2.1 JavassistProxyFactory</a><ul><li><a href="#211-javassist">2.1.1 Javassist</a></li><li><a href="#212-tccjavassistproxyfactory">2.1.2 TccJavassistProxyFactory</a></li><li><a href="#213-tccproxy--tccclassgenerator">2.1.3 TccProxy &amp; TccClassGenerator</a></li><li><a href="#214-%E9%85%8D%E7%BD%AE-dubbo-proxy">2.1.4 配置 Dubbo Proxy</a></li></ul></li><li><a href="#22-jdkproxyfactory">2.2 JdkProxyFactory</a><ul><li><a href="#221-jdk-proxy">2.2.1 JDK Proxy</a></li><li><a href="#222-tccjdkproxyfactory">2.2.2 TccJdkProxyFactory</a></li><li><a href="#223-tccinvokerinvocationhandler">2.2.3 TccInvokerInvocationHandler</a></li><li><a href="#224-%E9%85%8D%E7%BD%AE-dubbo-proxy">2.2.4 配置 Dubbo Proxy</a></li></ul></li></ul></li><li><a href="#3-dubbo-%E4%BA%8B%E5%8A%A1%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BC%96%E8%BE%91%E5%99%A8">3. Dubbo 事务上下文编辑器</a></li><li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>Dubbo 支持</strong>。</p><p>TCC-Transaction 通过 Dubbo <strong>隐式传参</strong>的功能，避免自己对业务代码的入侵。可能有同学不太理解为什么说 TCC-Transaction 对业务代码有一定的入侵性，一起来看个代码例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>代码来自 <code>tcc-transaction-http-sample</code> 。声明远程调用时，增加了参数 TransactionContext。当然你也可以通过自己使用的远程调用框架做一定封装，避免入侵。</li></ul><p>如下是对 Dubbo 封装了后，Dubbo Service 方法的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CapitalTradeOrderService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span></div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(CapitalTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>代码来自 <code>http-transaction-dubbo-sample</code> 。是不是不需要传入参数 TransactionContext。当然，注解是肯定需要的，否则 TCC-Transaction 怎么知道哪些方法是 TCC 方法。</li></ul><p>TCC-Transaction 通过 Dubbo Proxy 的机制，实现 <code>@Compensable</code> 属性自动生成，增加开发体验，也避免出错。</p><hr><p>Dubbo 支持( Maven 项目 <code>tcc-transaction-dubbo</code> ) 整体代码结构如下：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/01.png" alt=""></p><ul><li><code>proxy</code></li><li><code>context</code></li></ul><p>我们分成两个小节分享这两个包实现的功能。</p><p><strong>笔者暂时对 Dubbo 了解的不够深入，如果有错误的地方，还烦请指出，谢谢。</strong></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1 id="2-Dubbo-代理"><a href="#2-Dubbo-代理" class="headerlink" title="2. Dubbo 代理"></a>2. Dubbo 代理</h1><p>将 Dubbo Service 方法上的<strong>注解</strong> <code>@Compensable</code> ，自动生成注解的 <code>confirmMethod</code>、<code>cancelMethod</code>、<code>transactionContextEditor</code> 属性，例子代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Compensable</span>(propagation=Propagation.SUPPORTS, confirmMethod=<span class="string">"record"</span>, cancelMethod=<span class="string">"record"</span>, transactionContextEditor=DubboTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>该代码通过 Javassist 生成的 Proxy 代码的示例。</li><li><code>propagation=Propagation.SUPPORTS</code> ：支持当前事务，如果当前没有事务，就以非事务方式执行。<strong>为什么不使用 REQUIRED</strong> ？如果使用 REQUIRED 事务传播级别，事务恢复重试时，会发起新的事务。</li><li><code>confirmMethod</code>、<code>cancelMethod</code> 使用和 try 方法<strong>相同方法名</strong>：<strong>本地发起</strong>远程服务 TCC confirm / cancel 阶段，调用相同方法进行事务的提交或回滚。远程服务的 CompensableTransactionInterceptor 会根据事务的状态是 CONFIRMING / CANCELLING 来调用对应方法。<ul><li><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/02.png" alt=""> </li></ul></li><li><code>transactionContextEditor=DubboTransactionContextEditor.class</code>，使用 Dubbo 事务上下文编辑器，在<a href="#">「3. Dubbo 事务上下文编辑器」</a>详细分享。</li></ul><p>Dubbo Service Proxy 提供了两种生成方式：</p><ul><li>JavassistProxyFactory，基于 Javassist 方式</li><li>JdkProxyFactory，基于 JDK 动态代理机制</li></ul><p>这块内容我们不拓展开，感兴趣的同学点击如下文章：</p><ul><li><a href="http://daveztong.github.io/2016/11/23/Dubbo%E5%AD%A6%E4%B9%A0-%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo学习-理解动态代理》</a></li><li><a href="http://javatar.iteye.com/blog/814426" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo 作者博客 —— 动态代理方案性能对比》</a></li><li><a href="http://blog.csdn.net/quhongwei_zhanqiu/article/details/41597261" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo原理解析-代理之Javassist生成的伪代码》</a></li><li><strong><a href="http://blog.kazaff.me/2015/01/27/dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%BB%86%E8%8A%82/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo的服务暴露细节》</a></strong></li></ul><p>Dubbo 的 Invoker 模型是非常关键的概念，看下图：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/03.jpeg" alt=""></p><h2 id="2-1-JavassistProxyFactory"><a href="#2-1-JavassistProxyFactory" class="headerlink" title="2.1 JavassistProxyFactory"></a>2.1 JavassistProxyFactory</h2><h3 id="2-1-1-Javassist"><a href="#2-1-1-Javassist" class="headerlink" title="2.1.1 Javassist"></a>2.1.1 Javassist</h3><blockquote><p>Javassist 是一个开源的分析、编辑和创建 Java 字节码的类库。通过使用Javassist 对字节码操作可以实现动态 ”AOP” 框架。  </p><p>关于 Java 字节码的处理，目前有很多工具，如 bcel，asm( cglib只是对asm又封装了一层 )。不过这些都需要直接跟虚拟机指令打交道。  </p><p>Javassist 的主要的优点，在于简单，而且快速，直接使用 Java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。  </p></blockquote><ul><li>粗略一看，可能不够形象，下面我们通过看 TCC-Transaction 如何使用来理解理解。</li><li><a href="http://www.cnblogs.com/sunfie/p/5154246.html" rel="external nofollow noopener noreferrer" target="_blank">《Java学习之javassist<br>》</a></li><li><a href="http://blog.csdn.net/qbg19881206/article/details/8993562" rel="external nofollow noopener noreferrer" target="_blank">《Javassist 字节码操作》</a></li></ul><h3 id="2-1-2-TccJavassistProxyFactory"><a href="#2-1-2-TccJavassistProxyFactory" class="headerlink" title="2.1.2 TccJavassistProxyFactory"></a>2.1.2 TccJavassistProxyFactory</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccJavassistProxyFactory</code>，TCC Javassist 代理工厂。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccJavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">JavassistProxyFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) TccProxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>项目启动时</strong>，调用 <code>TccJavassistProxyFactory#getProxy(...)</code> 方法，生成 Dubbo Service 调用 Proxy。</li><li><code>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler</code>，Dubbo 调用处理器，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/InvokerInvocationHandler.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li></ul><h3 id="2-1-3-TccProxy-amp-TccClassGenerator"><a href="#2-1-3-TccProxy-amp-TccClassGenerator" class="headerlink" title="2.1.3 TccProxy &amp; TccClassGenerator"></a>2.1.3 TccProxy &amp; TccClassGenerator</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccProxy</code>，TCC Proxy 工厂，生成 Dubbo Service 调用 Proxy 。笔者认为，TccProxy 改成 TccProxyFactory 更合适，原因在下文。</p><p><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator</code>，TCC 类代码生成器，基于 Javassist 实现。 </p><p><strong>🦅案例</strong></p><p>一个 Dubbo Service，TccProxy 会动态生成两个类：</p><ul><li>Dubbo Service 调用 Proxy</li><li>Dubbo Service 调用 ProxyFactory，生成对应的 Dubbo Service Proxy</li></ul><p>例如 Dubbo Service 接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedPacketTradeOrderService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span></div><div class="line">    <span class="function">String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto tradeOrderDto)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>生成 Dubbo Service 调用 <strong>ProxyFactory</strong> 如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccProxy3</span> <span class="keyword">extends</span> <span class="title">TccProxy</span> <span class="keyword">implements</span> <span class="title">TccClassGenerator</span>.<span class="title">DC</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> proxy3(paramInvocationHandler);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TccProxy 提供 <code>#newInstance(handler)</code> 方法，创建 Proxy，所以笔者认为，TccProxy 改成 TccProxyFactory 更合适。</li><li><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li></ul><p>生成 Dubbo Service 调用 <strong>Proxy</strong> 如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy3</span> <span class="keyword">implements</span> <span class="title">TccClassGenerator</span>.<span class="title">DC</span>, <span class="title">RedPacketTradeOrderService</span>, <span class="title">EchoService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</div><div class="line">    <span class="keyword">private</span> InvocationHandler handler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy3</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy3</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.handler = paramInvocationHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Compensable</span>(propagation = Propagation.SUPPORTS, confirmMethod = <span class="string">"record"</span>, cancelMethod = <span class="string">"record"</span>, transactionContextEditor = DubboTransactionContextEditor.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        arrayOfObject[<span class="number">0</span>] = paramRedPacketTradeOrderDto;</div><div class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</div><div class="line">        <span class="keyword">return</span> (String) localObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object $echo(Object paramObject) &#123;</div><div class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        arrayOfObject[<span class="number">0</span>] = paramObject;</div><div class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrayOfObject);</div><div class="line">        <span class="keyword">return</span> (Object) localObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.alibaba.dubbo.rpc.service.EchoService</code>，Dubbo Service 回声服务接口，用于服务健康检查，Dubbo Service 默认自动实现该接口，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/service/EchoService.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li><li><code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li></ul><p><strong>🦅实现</strong></p><p>调用 <code>TccProxy#getProxy(...)</code> 方法，获得 <strong>TCC Proxy 工厂</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="comment">// 【TccProxy.java】</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TccProxy <span class="title">getProxy</span><span class="params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="comment">// 校验接口超过上限</span></div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (ics.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">  <span class="number">5</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">  <span class="number">6</span>:     &#125;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:     <span class="comment">// use interface class name list as key.</span></div><div class="line">  <span class="number">9</span>:     StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line"> <span class="number">10</span>:     <span class="keyword">for</span> (Class&lt;?&gt; ic : ics) &#123;</div><div class="line"> <span class="number">11</span>:         String itf = ic.getName();</div><div class="line"> <span class="number">12</span>:         <span class="comment">// 校验是否为接口</span></div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (!ic.isInterface()) &#123;</div><div class="line"> <span class="number">14</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(itf + <span class="string">" is not a interface."</span>);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:         <span class="comment">// 加载接口类</span></div><div class="line"> <span class="number">17</span>:         Class&lt;?&gt; tmp = <span class="keyword">null</span>;</div><div class="line"> <span class="number">18</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">19</span>:             tmp = Class.forName(itf, <span class="keyword">false</span>, cl);</div><div class="line"> <span class="number">20</span>:         &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</div><div class="line"> <span class="number">21</span>:         &#125;</div><div class="line"> <span class="number">22</span>:         <span class="keyword">if</span> (tmp != ic) &#123; <span class="comment">// 加载接口类失败</span></div><div class="line"> <span class="number">23</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ic + <span class="string">" is not visible from class loader"</span>);</div><div class="line"> <span class="number">24</span>:         &#125;</div><div class="line"> <span class="number">25</span>:         sb.append(itf).append(<span class="string">';'</span>);</div><div class="line"> <span class="number">26</span>:     &#125;</div><div class="line"> <span class="number">27</span>:     String key = sb.toString();</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:     <span class="comment">// get cache by class loader.</span></div><div class="line"> <span class="number">30</span>:     Map&lt;String, Object&gt; cache;</div><div class="line"> <span class="number">31</span>:     <span class="keyword">synchronized</span> (ProxyCacheMap) &#123;</div><div class="line"> <span class="number">32</span>:         cache = ProxyCacheMap.get(cl);</div><div class="line"> <span class="number">33</span>:         <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">34</span>:             cache = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line"> <span class="number">35</span>:             ProxyCacheMap.put(cl, cache);</div><div class="line"> <span class="number">36</span>:         &#125;</div><div class="line"> <span class="number">37</span>:     &#125;</div><div class="line"> <span class="number">38</span>: </div><div class="line"> <span class="number">39</span>:     <span class="comment">// 获得 TccProxy 工厂</span></div><div class="line"> <span class="number">40</span>:     TccProxy proxy = <span class="keyword">null</span>;</div><div class="line"> <span class="number">41</span>:     <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line"> <span class="number">42</span>:         <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">43</span>:             <span class="comment">// 从缓存中获取 TccProxy 工厂</span></div><div class="line"> <span class="number">44</span>:             Object value = cache.get(key);</div><div class="line"> <span class="number">45</span>:             <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference&lt;?&gt;) &#123;</div><div class="line"> <span class="number">46</span>:                 proxy = (TccProxy) ((Reference&lt;?&gt;) value).get();</div><div class="line"> <span class="number">47</span>:                 <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">48</span>:                     <span class="keyword">return</span> proxy;</div><div class="line"> <span class="number">49</span>:                 &#125;</div><div class="line"> <span class="number">50</span>:             &#125;</div><div class="line"> <span class="number">51</span>:             <span class="comment">// 缓存中不存在，设置生成 TccProxy 代码标记。创建中时，其他创建请求等待，避免并发。</span></div><div class="line"> <span class="number">52</span>:             <span class="keyword">if</span> (value == PendingGenerationMarker) &#123;</div><div class="line"> <span class="number">53</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">54</span>:                     cache.wait();</div><div class="line"> <span class="number">55</span>:                 &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line"> <span class="number">56</span>:                 &#125;</div><div class="line"> <span class="number">57</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">58</span>:                 cache.put(key, PendingGenerationMarker);</div><div class="line"> <span class="number">59</span>:                 <span class="keyword">break</span>;</div><div class="line"> <span class="number">60</span>:             &#125;</div><div class="line"> <span class="number">61</span>:         &#125;</div><div class="line"> <span class="number">62</span>:         <span class="keyword">while</span> (<span class="keyword">true</span>);</div><div class="line"> <span class="number">63</span>:     &#125;</div><div class="line"> <span class="number">64</span>: </div><div class="line"> <span class="number">65</span>:     <span class="keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();</div><div class="line"> <span class="number">66</span>:     String pkg = <span class="keyword">null</span>;</div><div class="line"> <span class="number">67</span>:     TccClassGenerator ccp = <span class="keyword">null</span>; <span class="comment">// proxy class generator</span></div><div class="line"> <span class="number">68</span>:     TccClassGenerator ccm = <span class="keyword">null</span>; <span class="comment">// proxy factory class generator</span></div><div class="line"> <span class="number">69</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">70</span>:         <span class="comment">// 创建 Tcc class 代码生成器</span></div><div class="line"> <span class="number">71</span>:         ccp = TccClassGenerator.newInstance(cl);</div><div class="line"> <span class="number">72</span>: </div><div class="line"> <span class="number">73</span>:         Set&lt;String&gt; worked = <span class="keyword">new</span> HashSet&lt;String&gt;(); <span class="comment">// 已处理方法签名集合。key：方法签名</span></div><div class="line"> <span class="number">74</span>:         List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;Method&gt;(); <span class="comment">// 已处理方法集合。</span></div><div class="line"> <span class="number">75</span>: </div><div class="line"> <span class="number">76</span>:         <span class="comment">// 处理接口</span></div><div class="line"> <span class="number">77</span>:         <span class="keyword">for</span> (Class&lt;?&gt; ic : ics) &#123;</div><div class="line"> <span class="number">78</span>:             <span class="comment">// 非 public 接口，使用接口包名</span></div><div class="line"> <span class="number">79</span>:             <span class="keyword">if</span> (!Modifier.isPublic(ic.getModifiers())) &#123;</div><div class="line"> <span class="number">80</span>:                 String npkg = ic.getPackage().getName();</div><div class="line"> <span class="number">81</span>:                 <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">82</span>:                     pkg = npkg;</div><div class="line"> <span class="number">83</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">84</span>:                     <span class="keyword">if</span> (!pkg.equals(npkg)) &#123; <span class="comment">// 实现了两个非 public 的接口，</span></div><div class="line"> <span class="number">85</span>:                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</div><div class="line"> <span class="number">86</span>:                     &#125;</div><div class="line"> <span class="number">87</span>:                 &#125;</div><div class="line"> <span class="number">88</span>:             &#125;</div><div class="line"> <span class="number">89</span>:             <span class="comment">// 添加接口</span></div><div class="line"> <span class="number">90</span>:             ccp.addInterface(ic);</div><div class="line"> <span class="number">91</span>:             <span class="comment">// 处理接口方法</span></div><div class="line"> <span class="number">92</span>:             <span class="keyword">for</span> (Method method : ic.getMethods()) &#123;</div><div class="line"> <span class="number">93</span>:                 <span class="comment">// 添加方法签名到已处理方法签名集合</span></div><div class="line"> <span class="number">94</span>:                 String desc = ReflectUtils.getDesc(method);</div><div class="line"> <span class="number">95</span>:                 <span class="keyword">if</span> (worked.contains(desc)) &#123;</div><div class="line"> <span class="number">96</span>:                     <span class="keyword">continue</span>;</div><div class="line"> <span class="number">97</span>:                 &#125;</div><div class="line"> <span class="number">98</span>:                 worked.add(desc);</div><div class="line"> <span class="number">99</span>:                 <span class="comment">// 生成接口方法实现代码</span></div><div class="line"><span class="number">100</span>:                 <span class="keyword">int</span> ix = methods.size();</div><div class="line"><span class="number">101</span>:                 Class&lt;?&gt; rt = method.getReturnType();</div><div class="line"><span class="number">102</span>:                 Class&lt;?&gt;[] pts = method.getParameterTypes();</div><div class="line"><span class="number">103</span>:                 StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="string">"];"</span>);</div><div class="line"><span class="number">104</span>:                 <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</div><div class="line"><span class="number">105</span>:                     code.append(<span class="string">" args["</span>).append(j).append(<span class="string">"] = ($w)$"</span>).append(j + <span class="number">1</span>).append(<span class="string">";"</span>);</div><div class="line"><span class="number">106</span>:                 &#125;</div><div class="line"><span class="number">107</span>:                 code.append(<span class="string">" Object ret = handler.invoke(this, methods["</span>).append(ix).append(<span class="string">"], args);"</span>);</div><div class="line"><span class="number">108</span>:                 <span class="keyword">if</span> (!Void.TYPE.equals(rt)) &#123;</div><div class="line"><span class="number">109</span>:                     code.append(<span class="string">" return "</span>).append(asArgument(rt, <span class="string">"ret"</span>)).append(<span class="string">";"</span>);</div><div class="line"><span class="number">110</span>:                 &#125;</div><div class="line"><span class="number">111</span>:                 methods.add(method);</div><div class="line"><span class="number">112</span>:                 <span class="comment">// 添加方法</span></div><div class="line"><span class="number">113</span>:                 Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line"><span class="number">114</span>:                 <span class="keyword">if</span> (compensable != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">115</span>:                     ccp.addMethod(<span class="keyword">true</span>, method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</div><div class="line"><span class="number">116</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">117</span>:                     ccp.addMethod(<span class="keyword">false</span>, method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</div><div class="line"><span class="number">118</span>:                 &#125;</div><div class="line"><span class="number">119</span>:             &#125;</div><div class="line"><span class="number">120</span>:         &#125;</div><div class="line"><span class="number">121</span>: </div><div class="line"><span class="number">122</span>:         <span class="comment">// 设置包路径</span></div><div class="line"><span class="number">123</span>:         <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">124</span>:             pkg = PACKAGE_NAME;</div><div class="line"><span class="number">125</span>:         &#125;</div><div class="line"><span class="number">126</span>: </div><div class="line"><span class="number">127</span>:         <span class="comment">// create ProxyInstance class.</span></div><div class="line"><span class="number">128</span>:         <span class="comment">// 设置类名</span></div><div class="line"><span class="number">129</span>:         String pcn = pkg + <span class="string">".proxy"</span> + id;</div><div class="line"><span class="number">130</span>:         ccp.setClassName(pcn);</div><div class="line"><span class="number">131</span>:         <span class="comment">// 添加静态属性 methods</span></div><div class="line"><span class="number">132</span>:         ccp.addField(<span class="string">"public static java.lang.reflect.Method[] methods;"</span>);</div><div class="line"><span class="number">133</span>:         <span class="comment">// 添加属性 handler</span></div><div class="line"><span class="number">134</span>:         ccp.addField(<span class="string">"private "</span> + InvocationHandler.class.getName() + <span class="string">" handler;"</span>);</div><div class="line"><span class="number">135</span>:         <span class="comment">// 添加构造方法，参数 handler</span></div><div class="line"><span class="number">136</span>:         ccp.addConstructor(Modifier.PUBLIC, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="string">"handler=$1;"</span>);</div><div class="line"><span class="number">137</span>:         <span class="comment">// 添加构造方法，参数 空</span></div><div class="line"><span class="number">138</span>:         ccp.addDefaultConstructor();</div><div class="line"><span class="number">139</span>:         <span class="comment">// 生成类</span></div><div class="line"><span class="number">140</span>:         Class&lt;?&gt; clazz = ccp.toClass();</div><div class="line"><span class="number">141</span>:         <span class="comment">// 设置静态属性 methods</span></div><div class="line"><span class="number">142</span>:         clazz.getField(<span class="string">"methods"</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</div><div class="line"><span class="number">143</span>: </div><div class="line"><span class="number">144</span>:         <span class="comment">// create TccProxy class.</span></div><div class="line"><span class="number">145</span>:         <span class="comment">// 创建 Tcc class 代码生成器</span></div><div class="line"><span class="number">146</span>:         ccm = TccClassGenerator.newInstance(cl);</div><div class="line"><span class="number">147</span>:         <span class="comment">// 设置类名</span></div><div class="line"><span class="number">148</span>:         String fcn = TccProxy.class.getName() + id;</div><div class="line"><span class="number">149</span>:         ccm.setClassName(fcn);</div><div class="line"><span class="number">150</span>:         <span class="comment">// 添加构造方法，参数 空</span></div><div class="line"><span class="number">151</span>:         ccm.addDefaultConstructor();</div><div class="line"><span class="number">152</span>:         <span class="comment">// 设置父类为 TccProxy.class</span></div><div class="line"><span class="number">153</span>:         ccm.setSuperClass(TccProxy.class);</div><div class="line"><span class="number">154</span>:         <span class="comment">// 添加方法 #newInstance(handler)</span></div><div class="line"><span class="number">155</span>:         ccm.addMethod(<span class="string">"public Object newInstance("</span> + InvocationHandler.class.getName() + <span class="string">" h)&#123; return new "</span> + pcn + <span class="string">"($1); &#125;"</span>);</div><div class="line"><span class="number">156</span>:         <span class="comment">// 生成类</span></div><div class="line"><span class="number">157</span>:         Class&lt;?&gt; pc = ccm.toClass();</div><div class="line"><span class="number">158</span>:         <span class="comment">// 创建 TccProxy 对象</span></div><div class="line"><span class="number">159</span>:         proxy = (TccProxy) pc.newInstance();</div><div class="line"><span class="number">160</span>:     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">161</span>:         <span class="keyword">throw</span> e;</div><div class="line"><span class="number">162</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">163</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">164</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">165</span>:         <span class="comment">// release TccClassGenerator</span></div><div class="line"><span class="number">166</span>:         <span class="keyword">if</span> (ccp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">167</span>:             ccp.release();</div><div class="line"><span class="number">168</span>:         &#125;</div><div class="line"><span class="number">169</span>:         <span class="keyword">if</span> (ccm != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">170</span>:             ccm.release();</div><div class="line"><span class="number">171</span>:         &#125;</div><div class="line"><span class="number">172</span>:         <span class="comment">// 唤醒缓存 wait</span></div><div class="line"><span class="number">173</span>:         <span class="keyword">synchronized</span> (cache) &#123;</div><div class="line"><span class="number">174</span>:             <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">175</span>:                 cache.remove(key);</div><div class="line"><span class="number">176</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">177</span>:                 cache.put(key, <span class="keyword">new</span> WeakReference&lt;TccProxy&gt;(proxy));</div><div class="line"><span class="number">178</span>:             &#125;</div><div class="line"><span class="number">179</span>:             cache.notifyAll();</div><div class="line"><span class="number">180</span>:         &#125;</div><div class="line"><span class="number">181</span>:     &#125;</div><div class="line"><span class="number">182</span>:     <span class="keyword">return</span> proxy;</div><div class="line"><span class="number">183</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 至 7 行 ：校验接口超过上限。</li><li>第 8 至 27 行 ：使用接口集合类名以 <code>;</code> 分隔拼接，作为 Proxy 的唯一标识。例如 ：<code>key=org.mengyun.tcctransaction.sample.dubbo.redpacket.api.RedPacketAccountService;com.alibaba.dubbo.rpc.service.EchoService;</code> 。</li><li><p>第 29 至 37 行 ：获得 Proxy 对应的 ClassLoader。这里我们看下静态属性 <code>ProxyCacheMap</code> 的定义：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Proxy 对象缓存</span></div><div class="line"><span class="comment">* key ：ClassLoader</span></div><div class="line"><span class="comment">* value.key ：Tcc Proxy 标识。使用 Tcc Proxy 实现接口名拼接</span></div><div class="line"><span class="comment">* value.value ：Tcc Proxy 工厂对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, Map&lt;String, Object&gt;&gt; ProxyCacheMap = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, Map&lt;String, Object&gt;&gt;();</div></pre></td></tr></table></figure><ul><li>使用 WeakHashMap，当 ClassLoader 被回收时，其对应的值一起被移除。</li><li><a href="http://blog.csdn.net/yangzl2008/article/details/6980709" rel="external nofollow noopener noreferrer" target="_blank">《WeakHashMap和HashMap的区别》</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3311092.html" rel="external nofollow noopener noreferrer" target="_blank">《Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例》</a></li></ul></li><li>第 39 至 63 行 ：一直获得 <strong>TCC Proxy 工厂</strong>直到成功。<ul><li>第 43 至 50 行 ：从<strong>缓存</strong>中获取 TCC Proxy 工厂。</li><li>第 51 至 60 行 ：若缓存中不存在，设置<strong>正在生成 TccProxy 代码标记</strong>。创建中时，其他创建请求等待，避免并发。</li></ul></li><li><p>第 65 行 ：<code>PROXY_CLASS_COUNTER</code>，Proxy Class 计数，用于生成 Proxy 类名自增。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong PROXY_CLASS_COUNTER = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div></pre></td></tr></table></figure></li><li><p>第 66 至 67 行</p><ul><li><code>ccm</code>，生成 Dubbo Service 调用 <strong>ProxyFactory</strong> 的代码生成器</li><li><code>ccp</code>，生成 Dubbo Service 调用 <strong>Proxy</strong> 的代码生成器</li></ul></li><li><p><strong>第 70 至 142 行 ：生成 Dubbo Service 调用 Proxy 的代码</strong>。</p><ul><li><p>第 70 至 71 行 ：调用 <code>TccClassGenerator#newInstance(loader)</code> 方法， 创建生成 Dubbo Service 调用 <strong>Proxy</strong> 的代码生成器。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TccClassGenerator.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TccClassGenerator</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * CtClass hash 集合</span></div><div class="line"><span class="comment">     * key：类名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ClassPool mPool;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TccClassGenerator <span class="title">newInstance</span><span class="params">(ClassLoader loader)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TccClassGenerator(getClassPool(loader));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TccClassGenerator</span><span class="params">(ClassPool pool)</span> </span>&#123;</div><div class="line">        mPool = pool;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>ClassPool</strong> 是一个 CtClass 对象的 hash 表，类名做为 key 。ClassPool 的 <code>#get(key)</code> 搜索 hash 表找到与指定 key 关联的 CtClass 对象。如果没有找到 CtClass 对象，<code>#get(key)</code> 读一个类文件构建新的 CtClass 对象，它是被记录在 hash 表中然后返回这个对象。</li></ul></li><li><p>第 76 至 120 行，处理接口。</p><ul><li>第 79 至 88 行，生成类的包名。</li><li><p>第 89 至 90 行，调用 <code>TccClassGenerator#addInterface(cl)</code> 方法，添加生成类的接口( <strong>Dubbo Service 接口</strong> )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的接口集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Set&lt;String&gt; mInterfaces;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> addInterface(cl.getName());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addInterface</span><span class="params">(String cn)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mInterfaces == <span class="keyword">null</span>) &#123;</div><div class="line">       mInterfaces = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mInterfaces.add(cn);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 93 至 98 行，添加方法签名到已处理方法签名集合。多个接口可能存在相同的接口方法，跳过相同的方法，避免冲突。</p></li><li><p>第 99 至 110 行，生成 Dubbo Service 调用实现代码。案例代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(RedPacketTradeOrderDto paramRedPacketTradeOrderDto)</span> </span>&#123;</div><div class="line">  Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">  arrayOfObject[<span class="number">0</span>] = paramRedPacketTradeOrderDto;</div><div class="line">  Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</div><div class="line">  <span class="keyword">return</span> (String)localObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/04.png" alt=""></li></ul></li><li><p>第 112 至 118 行 ：调用 <code>TccClassGenerator#addMethod(...)</code> 方法，添加生成的方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mMethods;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 带 <span class="doctag">@Compensable</span> 方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Set&lt;String&gt; compensableMethods = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addMethod</span><span class="params">(<span class="keyword">boolean</span> isCompensableMethod, String name, <span class="keyword">int</span> mod, Class&lt;?&gt; rt, Class&lt;?&gt;[] pts, Class&lt;?&gt;[] ets, String body)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接方法</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   sb.append(modifier(mod)).append(<span class="string">' '</span>).append(ReflectUtils.getName(rt)).append(<span class="string">' '</span>).append(name);</div><div class="line">   sb.append(<span class="string">'('</span>);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">           sb.append(<span class="string">','</span>);</div><div class="line">       sb.append(ReflectUtils.getName(pts[i]));</div><div class="line">       sb.append(<span class="string">" arg"</span>).append(i);</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">')'</span>);</div><div class="line">   <span class="keyword">if</span> (ets != <span class="keyword">null</span> &amp;&amp; ets.length &gt; <span class="number">0</span>) &#123;</div><div class="line">       sb.append(<span class="string">" throws "</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">               sb.append(<span class="string">','</span>);</div><div class="line">           sb.append(ReflectUtils.getName(ets[i]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">'&#123;'</span>).append(body).append(<span class="string">'&#125;'</span>);</div><div class="line">   <span class="comment">// 是否有 @Compensable 注解</span></div><div class="line">   <span class="keyword">if</span> (isCompensableMethod) &#123;</div><div class="line">       compensableMethods.add(sb.toString());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> addMethod(sb.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addMethod</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mMethods == <span class="keyword">null</span>) &#123;</div><div class="line">       mMethods = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mMethods.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>第 122 至 130 行，生成类名( 例如，<code>org.mengyun.tcctransaction.dubbo.proxy.javassist.proxy3</code> )，并调用 <code>TccClassGenerator#setClassName(...)</code> 方法，设置类名。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的类名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String mClassName;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">setClassName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">   mClassName = name;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 131 至 134 行，调用 <code>TccClassGenerator#addField(...)</code> 方法，添加<strong>静态</strong>属性 <code>methods</code> ( Dubbo Service 方法集合 )和属性 <code>handler</code> ( Dubbo InvocationHandler )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的属性集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mFields;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addField</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mFields == <span class="keyword">null</span>) &#123;</div><div class="line">       mFields = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mFields.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 135 至 136 行，调用 <code>TccClassGenerator#addConstructor(...)</code> 方法，添加参数为 <code>handler</code> 的构造方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的非空构造方法代码集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> List&lt;String&gt; mConstructors;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(<span class="keyword">int</span> mod, Class&lt;?&gt;[] pts, Class&lt;?&gt;[] ets, String body)</span> </span>&#123;</div><div class="line">   <span class="comment">// 构造方法代码</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   sb.append(modifier(mod)).append(<span class="string">' '</span>).append(SIMPLE_NAME_TAG);</div><div class="line">   sb.append(<span class="string">'('</span>);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">           sb.append(<span class="string">','</span>);</div><div class="line">       sb.append(ReflectUtils.getName(pts[i]));</div><div class="line">       sb.append(<span class="string">" arg"</span>).append(i);</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">')'</span>);</div><div class="line">   <span class="keyword">if</span> (ets != <span class="keyword">null</span> &amp;&amp; ets.length &gt; <span class="number">0</span>) &#123;</div><div class="line">       sb.append(<span class="string">" throws "</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</div><div class="line">               sb.append(<span class="string">','</span>);</div><div class="line">           sb.append(ReflectUtils.getName(ets[i]));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   sb.append(<span class="string">'&#123;'</span>).append(body).append(<span class="string">'&#125;'</span>);</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">return</span> addConstructor(sb.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mConstructors == <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mConstructors.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addConstructor</span><span class="params">(String code)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mConstructors == <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors = <span class="keyword">new</span> LinkedList&lt;String&gt;();</div><div class="line">   &#125;</div><div class="line">   mConstructors.add(code);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 137 至 138 行，调用 <code>TccClassGenerator#addDefaultConstructor()</code> 方法，添加默认空构造方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 默认空构造方法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDefaultConstructor = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">addDefaultConstructor</span><span class="params">()</span> </span>&#123;</div><div class="line">   mDefaultConstructor = <span class="keyword">true</span>;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 139 行，调用 <code>TccClassGenerator#toClass()</code> 方法，<strong>生成类</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> Class&lt;?&gt; toClass() &#123;</div><div class="line"> <span class="number">2</span>:    <span class="comment">// mCtc 非空时，进行释放；下面会进行创建 mCtc</span></div><div class="line"> <span class="number">3</span>:    <span class="keyword">if</span> (mCtc != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">4</span>:        mCtc.detach();</div><div class="line"> <span class="number">5</span>:    &#125;</div><div class="line"> <span class="number">6</span>:    <span class="keyword">long</span> id = CLASS_NAME_COUNTER.getAndIncrement();</div><div class="line"> <span class="number">7</span>:    <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">8</span>:        CtClass ctcs = mSuperClass == <span class="keyword">null</span> ? <span class="keyword">null</span> : mPool.get(mSuperClass);</div><div class="line"> <span class="number">9</span>:        <span class="keyword">if</span> (mClassName == <span class="keyword">null</span>) &#123; <span class="comment">// 类名</span></div><div class="line"><span class="number">10</span>:            mClassName = (mSuperClass == <span class="keyword">null</span> || javassist.Modifier.isPublic(ctcs.getModifiers())</div><div class="line"><span class="number">11</span>:                    ? TccClassGenerator.class.getName() : mSuperClass + <span class="string">"$sc"</span>) + id;</div><div class="line"><span class="number">12</span>:        &#125;</div><div class="line"><span class="number">13</span>:        <span class="comment">// 创建 mCtc</span></div><div class="line"><span class="number">14</span>:        mCtc = mPool.makeClass(mClassName);</div><div class="line"><span class="number">15</span>:        <span class="keyword">if</span> (mSuperClass != <span class="keyword">null</span>) &#123; <span class="comment">// 继承类</span></div><div class="line"><span class="number">16</span>:            mCtc.setSuperclass(ctcs);</div><div class="line"><span class="number">17</span>:        &#125;</div><div class="line"><span class="number">18</span>:        mCtc.addInterface(mPool.get(DC.class.getName())); <span class="comment">// add dynamic class tag.</span></div><div class="line"><span class="number">19</span>:        <span class="keyword">if</span> (mInterfaces != <span class="keyword">null</span>) &#123; <span class="comment">// 实现接口集合</span></div><div class="line"><span class="number">20</span>:            <span class="keyword">for</span> (String cl : mInterfaces) &#123;</div><div class="line"><span class="number">21</span>:                mCtc.addInterface(mPool.get(cl));</div><div class="line"><span class="number">22</span>:            &#125;</div><div class="line"><span class="number">23</span>:        &#125;</div><div class="line"><span class="number">24</span>:        <span class="keyword">if</span> (mFields != <span class="keyword">null</span>) &#123; <span class="comment">// 属性集合</span></div><div class="line"><span class="number">25</span>:            <span class="keyword">for</span> (String code : mFields) &#123;</div><div class="line"><span class="number">26</span>:                mCtc.addField(CtField.make(code, mCtc));</div><div class="line"><span class="number">27</span>:            &#125;</div><div class="line"><span class="number">28</span>:        &#125;</div><div class="line"><span class="number">29</span>:        <span class="keyword">if</span> (mMethods != <span class="keyword">null</span>) &#123; <span class="comment">// 方法集合</span></div><div class="line"><span class="number">30</span>:            <span class="keyword">for</span> (String code : mMethods) &#123;</div><div class="line"><span class="number">31</span>:                <span class="keyword">if</span> (code.charAt(<span class="number">0</span>) == <span class="string">':'</span>) &#123;</div><div class="line"><span class="number">32</span>:                    mCtc.addMethod(CtNewMethod.copy(getCtMethod(mCopyMethods.get(code.substring(<span class="number">1</span>))), code.substring(<span class="number">1</span>, code.indexOf(<span class="string">'('</span>)), mCtc, <span class="keyword">null</span>));</div><div class="line"><span class="number">33</span>:                &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">34</span>:                    CtMethod ctMethod = CtNewMethod.make(code, mCtc);</div><div class="line"><span class="number">35</span>:                    <span class="keyword">if</span> (compensableMethods.contains(code)) &#123;</div><div class="line"><span class="number">36</span>:                        <span class="comment">// 设置 @Compensable 属性</span></div><div class="line"><span class="number">37</span>:                        ConstPool constpool = mCtc.getClassFile().getConstPool();</div><div class="line"><span class="number">38</span>:                        AnnotationsAttribute attr = <span class="keyword">new</span> AnnotationsAttribute(constpool, AnnotationsAttribute.visibleTag);</div><div class="line"><span class="number">39</span>:                        Annotation annot = <span class="keyword">new</span> Annotation(<span class="string">"org.mengyun.tcctransaction.api.Compensable"</span>, constpool);</div><div class="line"><span class="number">40</span>:                        EnumMemberValue enumMemberValue = <span class="keyword">new</span> EnumMemberValue(constpool);</div><div class="line"><span class="number">41</span>:                        enumMemberValue.setType(<span class="string">"org.mengyun.tcctransaction.api.Propagation"</span>);</div><div class="line"><span class="number">42</span>:                        enumMemberValue.setValue(<span class="string">"SUPPORTS"</span>);</div><div class="line"><span class="number">43</span>:                        annot.addMemberValue(<span class="string">"propagation"</span>, enumMemberValue);</div><div class="line"><span class="number">44</span>:                        annot.addMemberValue(<span class="string">"confirmMethod"</span>, <span class="keyword">new</span> StringMemberValue(ctMethod.getName(), constpool));</div><div class="line"><span class="number">45</span>:                        annot.addMemberValue(<span class="string">"cancelMethod"</span>, <span class="keyword">new</span> StringMemberValue(ctMethod.getName(), constpool));</div><div class="line"><span class="number">46</span>:                        ClassMemberValue classMemberValue = <span class="keyword">new</span> ClassMemberValue(<span class="string">"org.mengyun.tcctransaction.dubbo.context.DubboTransactionContextEditor"</span>, constpool);</div><div class="line"><span class="number">47</span>:                        annot.addMemberValue(<span class="string">"transactionContextEditor"</span>, classMemberValue);</div><div class="line"><span class="number">48</span>:                        attr.addAnnotation(annot);</div><div class="line"><span class="number">49</span>:                        ctMethod.getMethodInfo().addAttribute(attr);</div><div class="line"><span class="number">50</span>:                    &#125;</div><div class="line"><span class="number">51</span>:                    mCtc.addMethod(ctMethod);</div><div class="line"><span class="number">52</span>:                &#125;</div><div class="line"><span class="number">53</span>:            &#125;</div><div class="line"><span class="number">54</span>:        &#125;</div><div class="line"><span class="number">55</span>:        <span class="keyword">if</span> (mDefaultConstructor) &#123; <span class="comment">// 空参数构造方法</span></div><div class="line"><span class="number">56</span>:            mCtc.addConstructor(CtNewConstructor.defaultConstructor(mCtc));</div><div class="line"><span class="number">57</span>:        &#125;</div><div class="line"><span class="number">58</span>:        <span class="keyword">if</span> (mConstructors != <span class="keyword">null</span>) &#123; <span class="comment">// 带参数构造方法</span></div><div class="line"><span class="number">59</span>:            <span class="keyword">for</span> (String code : mConstructors) &#123;</div><div class="line"><span class="number">60</span>:                <span class="keyword">if</span> (code.charAt(<span class="number">0</span>) == <span class="string">':'</span>) &#123;</div><div class="line"><span class="number">61</span>:                    mCtc.addConstructor(CtNewConstructor.copy(getCtConstructor(mCopyConstructors.get(code.substring(<span class="number">1</span>))), mCtc, <span class="keyword">null</span>));</div><div class="line"><span class="number">62</span>:                &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">63</span>:                    String[] sn = mCtc.getSimpleName().split(<span class="string">"\\$+"</span>); <span class="comment">// inner class name include $.</span></div><div class="line"><span class="number">64</span>:                    mCtc.addConstructor(CtNewConstructor.make(code.replaceFirst(SIMPLE_NAME_TAG, sn[sn.length - <span class="number">1</span>]), mCtc));</div><div class="line"><span class="number">65</span>:                &#125;</div><div class="line"><span class="number">66</span>:            &#125;</div><div class="line"><span class="number">67</span>:        &#125;</div><div class="line"><span class="number">68</span>: <span class="comment">//            mCtc.debugWriteFile("/Users/yunai/test/" + mCtc.getSimpleName().replaceAll(".", "/") + ".class");</span></div><div class="line"><span class="number">69</span>:        <span class="comment">// 生成</span></div><div class="line"><span class="number">70</span>:        <span class="keyword">return</span> mCtc.toClass();</div><div class="line"><span class="number">71</span>:    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">72</span>:        <span class="keyword">throw</span> e;</div><div class="line"><span class="number">73</span>:    &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</div><div class="line"><span class="number">74</span>:        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">75</span>:    &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</div><div class="line"><span class="number">76</span>:        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</div><div class="line"><span class="number">77</span>:    &#125;</div><div class="line"><span class="number">78</span>: &#125;</div></pre></td></tr></table></figure><ul><li>基于 Javassist 生成类。这里不做拓展解释，配合<a href="http://www.cnblogs.com/sunfie/p/5154246.html" rel="external nofollow noopener noreferrer" target="_blank">《Java学习之javassist》</a>一起理解。</li><li>第 18 行，添加 <code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccClassGenerator.DC</code> 动态生成类标记，标记该类由 TccClassGenerator 生成的。</li><li>第 34 至 50 行，设置 @Compensable 默认属性。</li></ul></li><li><p>第 141 至 142 行，设置 Dubbo Service 方法集合设置到静态属性 <code>methods</code> 上。</p></li></ul></li><li><p><strong>第 144 至 157 行，生成 Dubbo Service 调用 Proxy 工厂的代码</strong>。</p><ul><li>第 146 行，调用 <code>TccClassGenerator#newInstance(loader)</code> 方法， 创建生成 Dubbo Service 调用 <strong>Proxy 工厂</strong> 的代码生成器。</li><li>第 147 至 149 行，生成类名( 例如，<code>org.mengyun.tcctransaction.dubbo.proxy.javassist.TccProxy3</code> )，并调用 <code>TccClassGenerator#setClassName(...)</code> 方法，设置类名。</li><li>第 150 至 151 行，调用 <code>TccClassGenerator#addDefaultConstructor()</code> 方法，添加默认空构造方法。</li><li><p>第 152 至 153 行，调用 <code>TccClassGenerator#mSuperClass()</code> 方法，设置继承父类 <strong><code>TccProxy</code></strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成类的父类名字</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String mSuperClass;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> TccClassGenerator <span class="title">setSuperClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</div><div class="line">   mSuperClass = cl.getName();</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 154 至 155 行，调用 <code>TccClassGenerator#addInterface(cl)</code> 方法，添加生成 Proxy 实现代码的方法。代码案例如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">new</span> proxy3(paramInvocationHandler);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 156 至 157 行，调用 <code>TccClassGenerator#toClass()</code> 方法，<strong>生成类</strong>。</p></li></ul></li><li><p>第 159 行，调用 <code>TccProxy#newInstance()</code> 方法，创建 Proxy 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* get instance with default handler.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> instance.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> newInstance(THROW_UNSUPPORTED_INVOKER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* get instance with special handler.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> instance.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler handler)</span></span>;</div></pre></td></tr></table></figure><ul><li><code>#newInstance(handler)</code>，抽象方法，上面第 154 至 155 行生成。TccJavassistProxyFactory 调用该方法，获得 Proxy 。</li></ul></li><li><p>第 165 至 171 行，释放 TccClassGenerator 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (mCtc != <span class="keyword">null</span>) &#123;</div><div class="line">       mCtc.detach();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mInterfaces != <span class="keyword">null</span>) &#123;</div><div class="line">       mInterfaces.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mFields != <span class="keyword">null</span>) &#123;</div><div class="line">       mFields.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mMethods != <span class="keyword">null</span>) &#123;</div><div class="line">       mMethods.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mConstructors != <span class="keyword">null</span>) &#123;</div><div class="line">       mConstructors.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mCopyMethods != <span class="keyword">null</span>) &#123;</div><div class="line">       mCopyMethods.clear();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (mCopyConstructors != <span class="keyword">null</span>) &#123;</div><div class="line">       mCopyConstructors.clear();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 172 至 180 行，设置 Proxy 工厂缓存，并唤醒等待线程。</p></li></ul><p><strong>ps：</strong>代码比较多，收获会比较多，算是 Javassist 实战案例了。TCC-Transaction 作者在实现上述类，可能参考了 Dubbo 自带的实现：</p><ul><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Proxy.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.Proxy</code></a></li><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/ClassGenerator.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.ClassGenerator</code></a></li><li><a href="https://github.com/alibaba/dubbo/blob/8f20e3a68efc350e3fbaa965e0a8e8a59fef1b3c/dubbo-common/src/main/java/com/alibaba/dubbo/common/bytecode/Wrapper.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.alibaba.dubbo.common.bytecode.Wrapper</code></a></li></ul><h3 id="2-1-4-配置-Dubbo-Proxy"><a href="#2-1-4-配置-Dubbo-Proxy" class="headerlink" title="2.1.4 配置 Dubbo Proxy"></a>2.1.4 配置 Dubbo Proxy</h3><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// META-INF.dubbo/com.alibaba.dubbo.rpc.ProxyFactory</div><div class="line">tccJavassist=org.mengyun.tcctransaction.dubbo.proxy.javassist.TccJavassistProxyFactory</div><div class="line"></div><div class="line">// tcc-transaction-dubbo.xml</div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">proxy</span>=<span class="string">"tccJavassist"</span>/&gt;</span></div></pre></td></tr></table></figure><p>目前 Maven 项目 <code>tcc-transaction-dubbo</code> 已经<strong>默认</strong>配置，引入即可。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/05.png" alt=""></p><h2 id="2-2-JdkProxyFactory"><a href="#2-2-JdkProxyFactory" class="headerlink" title="2.2 JdkProxyFactory"></a>2.2 JdkProxyFactory</h2><h3 id="2-2-1-JDK-Proxy"><a href="#2-2-1-JDK-Proxy" class="headerlink" title="2.2.1 JDK Proxy"></a>2.2.1 JDK Proxy</h3><p><a href="http://blog.csdn.net/jiankunking/article/details/52143504#" rel="external nofollow noopener noreferrer" target="_blank">《 Java JDK 动态代理（AOP）使用及实现原理分析》</a></p><h3 id="2-2-2-TccJdkProxyFactory"><a href="#2-2-2-TccJdkProxyFactory" class="headerlink" title="2.2.2 TccJdkProxyFactory"></a>2.2.2 TccJdkProxyFactory</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.jd.TccJdkProxyFactory</code>，TCC JDK 代理工厂。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccJdkProxyFactory</span> <span class="keyword">extends</span> <span class="title">JdkProxyFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</div><div class="line">        T proxy = (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> InvokerInvocationHandler(invoker));</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, <span class="keyword">new</span> TccInvokerInvocationHandler(proxy, invoker));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>项目启动时</strong>，调用 <code>TccJavassistProxyFactory#getProxy(...)</code> 方法，生成 Dubbo Service 调用 Proxy。</li><li><strong>第一次</strong>调用 <code>Proxy#newProxyInstance(...)</code> 方法，创建调用 Dubbo Service 服务的 Proxy。<code>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler</code>，Dubbo 调用处理器，点击<a href="https://github.com/alibaba/dubbo/blob/17619dfa974457b00fe27cf68ae3f9d266709666/dubbo-rpc/dubbo-rpc-api/src/main/java/com/alibaba/dubbo/rpc/proxy/InvokerInvocationHandler.java" rel="external nofollow noopener noreferrer" target="_blank">连接</a>查看代码。</li><li><strong>第二次</strong>调用 <code>Proxy#newProxyInstance(...)</code> 方法，创建对调用 Dubbo Service 的 Proxy 的 Proxy。为什么会有两层 Proxy？答案在下节 TccInvokerInvocationHandler 。</li></ul><h3 id="2-2-3-TccInvokerInvocationHandler"><a href="#2-2-3-TccInvokerInvocationHandler" class="headerlink" title="2.2.3 TccInvokerInvocationHandler"></a>2.2.3 TccInvokerInvocationHandler</h3><p><code>org.mengyun.tcctransaction.dubbo.proxy.jdk.TccInvokerInvocationHandler</code>，TCC 调用处理器，在调用 Dubbo Service 服务时，使用 ResourceCoordinatorInterceptor 拦截处理。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TccInvokerInvocationHandler</span> <span class="keyword">extends</span> <span class="title">InvokerInvocationHandler</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 4:      * proxy</span></div><div class="line"><span class="comment"> 5:      */</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">private</span> Object target;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="function"><span class="keyword">public</span> <span class="title">TccInvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>:         <span class="keyword">super</span>(handler);</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     <span class="keyword">public</span> &lt;T&gt; TccInvokerInvocationHandler(T target, Invoker&lt;T&gt; invoker) &#123;</div><div class="line"><span class="number">13</span>:         <span class="keyword">super</span>(invoker);</div><div class="line"><span class="number">14</span>:         <span class="keyword">this</span>.target = target;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="number">18</span>:         Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line"><span class="number">19</span>:         <span class="keyword">if</span> (compensable != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">20</span>:             <span class="comment">// 设置 @Compensable 属性</span></div><div class="line"><span class="number">21</span>:             <span class="keyword">if</span> (StringUtils.isEmpty(compensable.confirmMethod())) &#123;</div><div class="line"><span class="number">22</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"confirmMethod"</span>, method.getName());</div><div class="line"><span class="number">23</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"cancelMethod"</span>, method.getName());</div><div class="line"><span class="number">24</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"transactionContextEditor"</span>, DubboTransactionContextEditor.class);</div><div class="line"><span class="number">25</span>:                 ReflectionUtils.changeAnnotationValue(compensable, <span class="string">"propagation"</span>, Propagation.SUPPORTS);</div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:             <span class="comment">// 生成切面</span></div><div class="line"><span class="number">28</span>:             ProceedingJoinPoint pjp = <span class="keyword">new</span> MethodProceedingJoinPoint(proxy, target, method, args);</div><div class="line"><span class="number">29</span>:             <span class="comment">// 执行</span></div><div class="line"><span class="number">30</span>:             <span class="keyword">return</span> FactoryBuilder.factoryOf(ResourceCoordinatorAspect.class).getInstance().interceptTransactionContextMethod(pjp);</div><div class="line"><span class="number">31</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">32</span>:             <span class="keyword">return</span> <span class="keyword">super</span>.invoke(target, method, args);</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 18 至 26 行，设置带有 @Compensable 属性的默认属性。</li><li><p>第 28 行，生成方法切面 <code>org.mengyun.tcctransaction.dubbo.proxy.jdk.MethodProceedingJoinPoint</code>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodProceedingJoinPoint</span> <span class="keyword">implements</span> <span class="title">ProceedingJoinPoint</span>, <span class="title">JoinPoint</span>.<span class="title">StaticPart</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 代理对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object proxy;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 目标对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object target;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Method method;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object[] args;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// Use reflection to invoke the method.</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ReflectionUtils.makeAccessible(method);</div><div class="line">            <span class="keyword">return</span> method.invoke(target, args);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</div><div class="line">            <span class="comment">// Invoked method threw a checked exception.</span></div><div class="line">            <span class="comment">// We must rethrow it. The client won't see the interceptor.</span></div><div class="line">            <span class="keyword">throw</span> ex.getTargetException();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Tried calling method ["</span> +</div><div class="line">                    method + <span class="string">"] on target ["</span> + target + <span class="string">"] failed"</span>, ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">(Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//        throw new UnsupportedOperationException(); // TODO 芋艿：疑问</span></div><div class="line">        <span class="keyword">return</span> proceed();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略不重要的方法和对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>该类参考 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-aop/src/main/java/org/springframework/aop/aspectj/MethodInvocationProceedingJoinPoint.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint</code></a> 实现。</li><li>TODO【1】 proxy 和 target 是否保留一个即可？</li><li>在切面处理完成后，调用 <code>#proceed(...)</code> 方法，进行远程 Dubbo Service 服务调用。</li><li>TODO【2】<code>#proceed(objects)</code> 抛出 throw new UnsupportedOperationException();。需要跟作者确认下。</li></ul></li><li>调用 <code>ResourceCoordinatorAspect#interceptTransactionContextMethod(...)</code> 方法，对方法切面拦截处理。<strong>为什么无需调用 CompensableTransactionAspect 切面</strong>？因为传播级别为 Propagation.SUPPORTS，不会发起事务。</li></ul><h3 id="2-2-4-配置-Dubbo-Proxy"><a href="#2-2-4-配置-Dubbo-Proxy" class="headerlink" title="2.2.4 配置 Dubbo Proxy"></a>2.2.4 配置 Dubbo Proxy</h3><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// META-INF.dubbo/com.alibaba.dubbo.rpc.ProxyFactory</div><div class="line">tccJdk=org.mengyun.tcctransaction.dubbo.proxy.jdk.TccJdkProxyFactory</div><div class="line"></div><div class="line">// appcontext-service-dubbo.xml</div><div class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">proxy</span>=<span class="string">"tccJdk"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"tccJdk"</span> <span class="attr">id</span>=<span class="string">"captialTradeOrderService"</span></span></div><div class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.mengyun.tcctransaction.sample.dubbo.capital.api.CapitalTradeOrderService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>/&gt;</span></div></pre></td></tr></table></figure><ul><li>ProxyFactory 的 <code>tccJdk</code> 在 Maven 项 <code>tcc-transaction-dubbo</code> 已经声明。</li><li>声明 <code>dubbo:provider</code> 的 <code>proxy=&quot;tccJdk&quot;</code>。</li><li>声明 <code>dubbo:reference</code> 的 <code>proxy=&quot;tccJdk&quot;</code>，否则不生效。</li></ul><h1 id="3-Dubbo-事务上下文编辑器"><a href="#3-Dubbo-事务上下文编辑器" class="headerlink" title="3. Dubbo 事务上下文编辑器"></a>3. Dubbo 事务上下文编辑器</h1><p><code>org.mengyun.tcctransaction.dubbo.context.DubboTransactionContextEditor</code>，Dubbo 事务上下文编辑器实现，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        String context = RpcContext.getContext().getAttachment(TransactionContextConstants.TRANSACTION_CONTEXT);</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(context)) &#123;</div><div class="line">            <span class="keyword">return</span> JSON.parseObject(context, TransactionContext.class);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        RpcContext.getContext().setAttachment(TransactionContextConstants.TRANSACTION_CONTEXT, JSON.toJSONString(transactionContext));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过 Dubbo 的隐式传参的方式，避免在 Dubbo Service 接口上声明 TransactionContext 参数，对接口产生一定的入侵。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>HOHO，对动态代理又学习了一遍，蛮 High 的。</p><p>这里推荐动态代理无关，和 Dubbo 相关的文章：</p><ul><li><a href="http://blog.kazaff.me/2015/01/27/dubbo%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E7%9A%84%E7%BB%86%E8%8A%82/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo的服务暴露细节》</a>。</li><li><a href="http://weifuwu.io/2016/01/03/dubbo-provider-start/" rel="external nofollow noopener noreferrer" target="_blank">《Dubbo Provider启动主流程》</a></li></ul><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_03_07/06.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-dubbo-%
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 事务恢复</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/transaction-recovery/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2017-09-17T11:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 事务重试配置</a></li><li><a href="#">3. 事务重试定时任务</a></li><li><a href="#">4. 异常事务恢复</a><ul><li><a href="#">4.1 加载异常事务集合</a></li><li><a href="#">4.2 恢复异常事务集合</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>TCC 恢复</strong>。主要涉及如下二个 package 路径下的类：</p><ul><li><code>org.mengyun.tcctransaction.recover</code><ul><li>RecoverConfig，事务恢复配置<strong>接口</strong>  </li><li>TransactionRecovery，事务恢复逻辑</li></ul></li><li><code>org.mengyun.tcctransaction.spring.recover</code> ：<ul><li>DefaultRecoverConfig，默认事务恢复配置<strong>实现</strong></li><li>RecoverScheduledJob，事务恢复定时任务</li></ul></li></ul><p>本文涉及到的类关系如下图( <a href="http://www.iocoder.cn/images/TCC-Transaction/2018_02_22/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_22/01.png" alt=""></p><p>在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码分析 —— 事务存储器》</a>中，事务信息被持久化到外部的存储器中。<strong>事务存储是事务恢复的基础</strong>。通过读取外部存储器中的异常事务，定时任务会按照一定频率对事务进行重试，直到事务完成或超过最大重试次数。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_15/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1 id="2-事务重试配置"><a href="#2-事务重试配置" class="headerlink" title="2. 事务重试配置"></a>2. 事务重试配置</h1><p><code>org.mengyun.tcctransaction.recover.RecoverConfig</code>，事务恢复配置<strong>接口</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RecoverConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 最大重试次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxRetryCount</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 恢复间隔时间，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRecoverDuration</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> cron 表达式</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getCronExpression</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟取消异常集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Set&lt;Class&lt;? extends Exception&gt;&gt; getDelayCancelExceptions();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置延迟取消异常集合</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> delayRecoverExceptions 延迟取消异常集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelayCancelExceptions</span><span class="params">(Set&lt;Class&lt;? extends Exception&gt;&gt; delayRecoverExceptions)</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#getMaxRetryCount()</code>，单个事务恢复最大重试次数。超过最大重试次数后，目前仅打出错误日志，下文会看到实现。</li><li><code>#getRecoverDuration()</code>，单个事务恢复重试的间隔时间，单位：秒。</li><li><code>#getCronExpression()</code>，定时任务 cron 表达式。</li><li><code>#getDelayCancelExceptions()</code>，延迟取消异常集合。</li></ul><hr><p><code>org.mengyun.tcctransaction.spring.recover.DefaultRecoverConfig</code>，<strong>默认</strong>事务恢复配置实现，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRecoverConfig</span> <span class="keyword">implements</span> <span class="title">RecoverConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RecoverConfig INSTANCE = <span class="keyword">new</span> DefaultRecoverConfig();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最大重试次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRetryCount = <span class="number">30</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 恢复间隔时间，单位：秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> recoverDuration = <span class="number">120</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cron 表达式</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String cronExpression = <span class="string">"0 */1 * * * ?"</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 延迟取消异常集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Set&lt;Class&lt;? extends Exception&gt;&gt; delayCancelExceptions = <span class="keyword">new</span> HashSet&lt;Class&lt;? extends Exception&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultRecoverConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        delayCancelExceptions.add(OptimisticLockException.class);</div><div class="line">        delayCancelExceptions.add(SocketTimeoutException.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayCancelExceptions</span><span class="params">(Set&lt;Class&lt;? extends Exception&gt;&gt; delayCancelExceptions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delayCancelExceptions.addAll(delayCancelExceptions);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>maxRetryCount</code>，单个事务恢复最大重试次数 为 30。</li><li><code>recoverDuration</code>，单个事务恢复重试的间隔时间为 120 秒。</li><li><code>cronExpression</code>，定时任务 cron 表达式为 <code>&quot;0 */1 * * * ?&quot;</code>，每分钟执行一次。如果你希望定时任务执行的更频繁，可以修改 cron 表达式，例如 <code>0/30 * * * * ?</code>，每 30 秒执行一次。</li><li><code>delayCancelExceptions</code>，延迟取消异常集合。在 DefaultRecoverConfig 构造方法里，预先添加了 OptimisticLockException / SocketTimeoutException 。<ul><li>针对 <strong>SocketTimeoutException</strong> ：try 阶段，本地参与者调用远程参与者( 远程服务，例如 Dubbo，Http 服务)，远程参与者 try 阶段的方法逻辑执行时间较长，超过 Socket 等待时长，发生 SocketTimeoutException，如果立刻执行事务回滚，远程参与者 try 的方法未执行完成，可能导致 cancel 的方法实际未执行( try 的方法未执行完成，数据库事务【非 TCC 事务】未提交，cancel 的方法读取数据时发现未变更，导致方法实际未执行，最终 try 的方法执行完后，提交数据库事务【非 TCC 事务】，较为极端 )，最终引起数据不一致。在<strong>事务恢复</strong>时，会对这种情况的事务进行取消回滚，如果此时远程参与者的 try 的方法还未结束，还是可能发生数据不一致。<ul><li>官方解释：<a href="https://github.com/changmingxie/tcc-transaction/issues/87" rel="external nofollow noopener noreferrer" target="_blank">为什么 tcc 事务切面中对乐观锁与socket超时异常不做回滚处理，只抛异常？</a></li></ul></li><li>针对 OptimisticLockException ：还是 SocketTimeoutException 的情况，事务恢复间隔时间小于 Socket 超时时间，此时事务恢复调用远程参与者取消回滚事务，远程参与者下次更新事务时，会因为乐观锁更新失败，抛出 OptimisticLockException。如果 CompensableTransactionInterceptor 此时立刻取消回滚，可能会和定时任务的取消回滚冲突，因此统一交给定时任务处理。<ul><li>官方解释：<a href="https://github.com/changmingxie/tcc-transaction/issues/53" rel="external nofollow noopener noreferrer" target="_blank">事务恢复的疑问</a></li><li>这块笔者还有一些疑问，如果有别的可能性导致这个情况，麻烦告知下笔者。谢谢。</li></ul></li></ul></li></ul><h1 id="3-事务重试定时任务"><a href="#3-事务重试定时任务" class="headerlink" title="3. 事务重试定时任务"></a>3. 事务重试定时任务</h1><p><code>org.mengyun.tcctransaction.spring.recover.RecoverScheduledJob</code>，事务恢复定时任务，基于 Quartz 实现调度，不断不断不断执行事务恢复。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecoverScheduledJob</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TransactionRecovery transactionRecovery;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TransactionConfigurator transactionConfigurator;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Scheduler scheduler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// Quartz JobDetail</span></div><div class="line">            MethodInvokingJobDetailFactoryBean jobDetail = <span class="keyword">new</span> MethodInvokingJobDetailFactoryBean();</div><div class="line">            jobDetail.setTargetObject(transactionRecovery);</div><div class="line">            jobDetail.setTargetMethod(<span class="string">"startRecover"</span>);</div><div class="line">            jobDetail.setName(<span class="string">"transactionRecoveryJob"</span>);</div><div class="line">            jobDetail.setConcurrent(<span class="keyword">false</span>); <span class="comment">// 禁止并发</span></div><div class="line">            jobDetail.afterPropertiesSet();</div><div class="line">            <span class="comment">// Quartz CronTriggerFactoryBean</span></div><div class="line">            CronTriggerFactoryBean cronTrigger = <span class="keyword">new</span> CronTriggerFactoryBean();</div><div class="line">            cronTrigger.setBeanName(<span class="string">"transactionRecoveryCronTrigger"</span>);</div><div class="line">            cronTrigger.setCronExpression(transactionConfigurator.getRecoverConfig().getCronExpression());</div><div class="line">            cronTrigger.setJobDetail(jobDetail.getObject());</div><div class="line">            cronTrigger.afterPropertiesSet();</div><div class="line">            <span class="comment">// 启动任务调度</span></div><div class="line">            scheduler.scheduleJob(jobDetail.getObject(), cronTrigger.getObject());</div><div class="line">            <span class="comment">// 启动 Quartz Scheduler</span></div><div class="line">            scheduler.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>MethodInvokingJobDetailFactoryBean#setConcurrent(false)</code> 方法，禁用任务并发执行。</li><li>调用 <code>MethodInvokingJobDetailFactoryBean#setTargetObject(...)</code> + <code>MethodInvokingJobDetailFactoryBean#setTargetMethod(...)</code> 方法，设置任务调用 <code>TransactionRecovery#startRecover(...)</code> 方法执行。</li></ul><p><strong>如果应用集群部署，会不会相同事务被多个定时任务同时重试</strong>？</p><p>答案是不会，事务在重试时会乐观锁更新，同时只有一个应用节点能更新成功。</p><p>官方解释：<a href="https://github.com/changmingxie/tcc-transaction/issues/98" rel="external nofollow noopener noreferrer" target="_blank">多机部署下，所有机器都宕机，从异常中恢复时，所有的机器岂不是都可以查询到所有的需要恢复的服务？</a></p><p>当然极端情况下，Socket 调用超时时间大于事务重试间隔，第一个节点在重试某个事务，一直未执行完成，第二个节点已经可以重试。</p><p>ps：建议，Socket 调用超时时间小于事务重试间隔。</p><p><strong>是否定时任务和应用服务器解耦</strong>？</p><p>蚂蚁金服的分布式事务服务 DTS 采用 client-server 模式：</p><ul><li>xts-client ：负责事务的创建、提交、回滚、记录。</li><li>xts-server ：负责异常事务的恢复。</li></ul><blockquote><p>FROM <a href="https://www.cloud.alipay.com/docs/2/46887" rel="external nofollow noopener noreferrer" target="_blank">《蚂蚁金融云 DTS 文档》</a><br>分布式事务服务 (Distributed Transaction Service, DTS) 是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。DTS 从架构上分为 xts-client 和 xts-server 两部分，前者是一个嵌入客户端应用的 JAR 包，主要负责事务数据的写入和处理；后者是一个独立的系统，主要负责异常事务的恢复。</p></blockquote><h1 id="4-异常事务恢复"><a href="#4-异常事务恢复" class="headerlink" title="4. 异常事务恢复"></a>4. 异常事务恢复</h1><p> <code>org.mengyun.tcctransaction.recover.TransactionRecovery</code>，异常事务恢复，实现主体代码如下：</p> <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionRecovery</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 启动恢复事务逻辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRecover</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 加载异常事务集合</span></div><div class="line">        List&lt;Transaction&gt; transactions = loadErrorTransactions();</div><div class="line">        <span class="comment">// 恢复异常事务集合</span></div><div class="line">        recoverErrorTransactions(transactions);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-1-加载异常事务集合"><a href="#4-1-加载异常事务集合" class="headerlink" title="4.1 加载异常事务集合"></a>4.1 加载异常事务集合</h2><p>调用 <code>#loadErrorTransactions()</code> 方法，加载异常事务集合。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title">loadErrorTransactions</span><span class="params">()</span> </span>&#123;</div><div class="line">   TransactionRepository transactionRepository = transactionConfigurator.getTransactionRepository();</div><div class="line">   <span class="keyword">long</span> currentTimeInMillis = Calendar.getInstance().getTimeInMillis();</div><div class="line">   RecoverConfig recoverConfig = transactionConfigurator.getRecoverConfig();</div><div class="line">   <span class="keyword">return</span> transactionRepository.findAllUnmodifiedSince(<span class="keyword">new</span> Date(currentTimeInMillis - recoverConfig.getRecoverDuration() * <span class="number">1000</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>异常事务的定义</strong>：当前时间超过 - 事务变更时间( 最后执行时间 ) &gt;= 事务恢复间隔( <code>RecoverConfig#getRecoverDuration()</code> )。这里有一点要注意，已完成的事务会从事务存储器删除。</li></ul><h2 id="4-2-恢复异常事务集合"><a href="#4-2-恢复异常事务集合" class="headerlink" title="4.2 恢复异常事务集合"></a>4.2 恢复异常事务集合</h2><p>调用 <code>#recoverErrorTransactions(...)</code> 方法，恢复异常事务集合。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recoverErrorTransactions</span><span class="params">(List&lt;Transaction&gt; transactions)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Transaction transaction : transactions) &#123;</div><div class="line">       <span class="comment">// 超过最大重试次数</span></div><div class="line">       <span class="keyword">if</span> (transaction.getRetriedCount() &gt; transactionConfigurator.getRecoverConfig().getMaxRetryCount()) &#123;</div><div class="line">           logger.error(String.format(<span class="string">"recover failed with max retry count,will not try again. txid:%s, status:%s,retried count:%d,transaction content:%s"</span>, transaction.getXid(), transaction.getStatus().getId(), transaction.getRetriedCount(), JSON.toJSONString(transaction)));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 分支事务超过最大可重试时间</span></div><div class="line">       <span class="keyword">if</span> (transaction.getTransactionType().equals(TransactionType.BRANCH)</div><div class="line">               &amp;&amp; (transaction.getCreateTime().getTime() +</div><div class="line">               transactionConfigurator.getRecoverConfig().getMaxRetryCount() *</div><div class="line">                       transactionConfigurator.getRecoverConfig().getRecoverDuration() * <span class="number">1000</span></div><div class="line">               &gt; System.currentTimeMillis())) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Confirm / Cancel</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 增加重试次数</span></div><div class="line">           transaction.addRetriedCount();</div><div class="line">           <span class="comment">// Confirm</span></div><div class="line">           <span class="keyword">if</span> (transaction.getStatus().equals(TransactionStatus.CONFIRMING)) &#123;</div><div class="line">               transaction.changeStatus(TransactionStatus.CONFIRMING);</div><div class="line">               transactionConfigurator.getTransactionRepository().update(transaction);</div><div class="line">               transaction.commit();</div><div class="line">               transactionConfigurator.getTransactionRepository().delete(transaction);</div><div class="line">           <span class="comment">// Cancel</span></div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transaction.getStatus().equals(TransactionStatus.CANCELLING)</div><div class="line">                   || transaction.getTransactionType().equals(TransactionType.ROOT)) &#123; <span class="comment">// 处理延迟取消的情况</span></div><div class="line">               transaction.changeStatus(TransactionStatus.CANCELLING);</div><div class="line">               transactionConfigurator.getTransactionRepository().update(transaction);</div><div class="line">               transaction.rollback();</div><div class="line">               transactionConfigurator.getTransactionRepository().delete(transaction);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">           <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> OptimisticLockException</div><div class="line">                   || ExceptionUtils.getRootCause(throwable) <span class="keyword">instanceof</span> OptimisticLockException) &#123;</div><div class="line">               logger.warn(String.format(<span class="string">"optimisticLockException happened while recover. txid:%s, status:%s,retried count:%d,transaction content:%s"</span>, transaction.getXid(), transaction.getStatus().getId(), transaction.getRetriedCount(), JSON.toJSONString(transaction)), throwable);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               logger.error(String.format(<span class="string">"recover failed, txid:%s, status:%s,retried count:%d,transaction content:%s"</span>, transaction.getXid(), transaction.getStatus().getId(), transaction.getRetriedCount(), JSON.toJSONString(transaction)), throwable);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当单个事务超过最大重试次数时，不再重试，只打印异常，此时需要<strong>人工介入</strong>解决。可以接入 ELK 收集日志监控报警。</li><li>当<strong>分支事务</strong>超过最大可重试时间时，不再重试。可能有同学和我一开始理解的是相同的，实际<strong>分支事务</strong>对应的应用服务器也可以重试<strong>分支事务</strong>，不是必须<strong>根事务</strong>发起重试，从而一起重试<strong>分支事务</strong>。这点要注意下。</li><li>当事务处于 TransactionStatus.CONFIRMING 状态时，提交事务，逻辑和 <code>TransactionManager#commit()</code> 类似。</li><li>当事务处于 TransactionStatus.CONFIRMING 状态，或者<strong>事务类型为根事务</strong>，回滚事务，逻辑和 <code>TransactionManager#rollback()</code> 类似。这里加判断的<strong>事务类型为根事务</strong>，用于处理延迟回滚异常的事务的回滚。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在写本文的过程中，无意中翻到蚂蚁云的文档，分享给看到此处的真爱们。</p><p>真爱们，请猛击<a href="https://git.cloud.alipay.com/dx/AntCloudPayPublic" rel="external nofollow noopener noreferrer" target="_blank">《AntCloudPayPublic》</a>跳转。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_22/02.png" alt=""></p><p>胖友，分享一个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 事务重试配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 事务存储器</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/transaction-repository/</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2017-09-17T11:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 序列化</a><ul><li><a href="#">2.1 JDK 序列化实现</a></li><li><a href="#">2.2 Kyro 序列化实现</a></li><li><a href="#">2.3 JSON 序列化实现</a></li></ul></li><li><a href="#">3. 存储器</a><ul><li><a href="#">3.1 可缓存的事务存储器抽象类</a></li><li><a href="#">3.2 JDBC 事务存储器</a></li><li><a href="#">3.3 Redis 事务存储器</a></li><li><a href="#">3.4 Zookeeper 事务存储器</a></li><li><a href="#">3.5 File 事务存储器</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>事务存储器</strong>。主要涉及如下 Maven 项目：</p><ul><li><code>tcc-transaction-core</code> ：tcc-transaction 底层实现。</li></ul><p>在 TCC 的过程中，根据应用内存中的事务信息完成整个事务流程。But 实际业务场景中，将事务信息只放在应用内存中是远远不够可靠的。例如：</p><ol><li>应用进程异常崩溃，未完成的事务信息将丢失。</li><li>应用进程集群，当提供远程服务调用时，事务信息需要集群内共享。</li><li>发起事务的应用需要重启部署新版本，因为各种原因，有未完成的事务。</li></ol><p>因此，TCC-Transaction 将事务信息添加到内存中的同时，会使用外部存储进行持久化。目前提供四种外部存储：</p><ul><li>JdbcTransactionRepository，JDBC 事务存储器</li><li>RedisTransactionRepository，Redis 事务存储器</li><li>ZooKeeperTransactionRepository，Zookeeper 事务存储器</li><li>FileSystemTransactionRepository，File 事务存储器</li></ul><p>本文涉及到的类关系如下图( <a href="http://www.iocoder.cn/images/TCC-Transaction/2018_02_15/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_15/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><h1 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2. 序列化"></a>2. 序列化</h1><p>在<a href="http://www.iocoder.cn/TCC-Transaction/tcc-core/?self">《TCC-Transaction 源码分析 —— TCC 实现》「4. 事务与参与者」</a>，可以看到 Transaction 是一个比较复杂的对象，内嵌 Participant 数组，而 Participant 本身也是复杂的对象，内嵌了更多的其他对象，因此，存储器在持久化 Transaction 时，需要序列化后才能存储。</p><p><code>org.mengyun.tcctransaction.serializer.ObjectSerializer</code>，对象序列化<strong>接口</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectSerializer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">byte</span>[] serialize(T t);</div><div class="line">    </div><div class="line">    <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>目前提供 <strong>JDK自带序列化</strong> 和 <strong>Kyro序列化</strong> 两种实现。</p><h2 id="2-1-JDK-序列化实现"><a href="#2-1-JDK-序列化实现" class="headerlink" title="2.1 JDK 序列化实现"></a>2.1 JDK 序列化实现</h2><p><code>org.mengyun.tcctransaction.serializer.JdkSerializationSerializer</code>，JDK 序列化实现。比较易懂，点击<a href="https://github.com/changmingxie/tcc-transaction/blob/70130d12004456fd4b97510c210c24502a1b3acb/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/serializer/JdkSerializationSerializer.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p><p><strong>TCC-Transaction 使用的默认的序列化</strong>。</p><h2 id="2-2-Kyro-序列化实现"><a href="#2-2-Kyro-序列化实现" class="headerlink" title="2.2 Kyro 序列化实现"></a>2.2 Kyro 序列化实现</h2><p><code>org.mengyun.tcctransaction.serializer.KryoTransactionSerializer</code>，Kyro 序列化实现。比较易懂，点击<a href="https://github.com/changmingxie/tcc-transaction/blob/70130d12004456fd4b97510c210c24502a1b3acb/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/serializer/KryoTransactionSerializer.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p><h2 id="2-3-JSON-序列化实现"><a href="#2-3-JSON-序列化实现" class="headerlink" title="2.3 JSON 序列化实现"></a>2.3 JSON 序列化实现</h2><p>JDK 和 Kyro 的序列化实现，肉眼无法直观具体存储事务的信息，你可以通过实现 ObjectSerializer 接口，实现自定义的 JSON 序列化。</p><h1 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3. 存储器"></a>3. 存储器</h1><p><code>org.mengyun.tcctransaction.TransactionRepository</code>，事务存储器<strong>接口</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新增事务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 新增数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(Transaction transaction)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 更新事务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 更新数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(Transaction transaction)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 删除事务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 删除数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">(Transaction transaction)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取事务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> xid 事务编号</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Transaction <span class="title">findByXid</span><span class="params">(TransactionXid xid)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取超过指定时间的事务集合</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> date 指定时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;Transaction&gt; <span class="title">findAllUnmodifiedSince</span><span class="params">(Date date)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不同的存储器通过实现该接口，提供事务的增删改查功能。</p><h2 id="3-1-可缓存的事务存储器抽象类"><a href="#3-1-可缓存的事务存储器抽象类" class="headerlink" title="3.1 可缓存的事务存储器抽象类"></a>3.1 可缓存的事务存储器抽象类</h2><p><code>org.mengyun.tcctransaction.repository.CachableTransactionRepository</code>，<strong>可缓存</strong>的事务存储器<strong>抽象类</strong>，实现增删改查事务时，同时缓存事务信息。在上面类图，我们也可以看到 TCC-Transaction 自带的多种存储器都继承该抽象类。</p><p><strong>CachableTransactionRepository 构造方法</strong>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CachableTransactionRepository</span> <span class="keyword">implements</span> <span class="title">TransactionRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 缓存过期时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireDuration = <span class="number">120</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 缓存</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Cache&lt;Xid, Transaction&gt; transactionXidCompensableTransactionCache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CachableTransactionRepository</span><span class="params">()</span> </span>&#123;</div><div class="line">        transactionXidCompensableTransactionCache = CacheBuilder.newBuilder().expireAfterAccess(expireDuration, TimeUnit.SECONDS).maximumSize(<span class="number">1000</span>).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <a href="https://github.com/google/guava/wiki/CachesExplained" rel="external nofollow noopener noreferrer" target="_blank">Guava Cache</a> 内存缓存事务信息，设置最大缓存个数为 1000 个，缓存过期时间为最后访问时间 120 秒。</li></ul><hr><p><strong><code>#create(...)</code></strong> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = doCreate(transaction);</div><div class="line">   <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</div><div class="line">       putToCache(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加到缓存</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putToCache</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   transactionXidCompensableTransactionCache.put(transaction.getXid(), transaction);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 新增事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 新增数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doCreate</span><span class="params">(Transaction transaction)</span></span>;</div></pre></td></tr></table></figure><ul><li>调用 <code>#doCreate(...)</code> 方法，新增事务。新增成功后，调用 <code>#putToCache(...)</code> 方法，添加事务到缓存。</li><li><code>#doCreate(...)</code> 为抽象方法，子类实现该方法，提供新增事务功能。</li></ul><hr><p><strong><code>#update(...)</code></strong> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = doUpdate(transaction);</div><div class="line">       <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</div><div class="line">           putToCache(transaction);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OptimisticLockException();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123; <span class="comment">// 更新失败，移除缓存。下次访问，从存储器读取</span></div><div class="line">           removeFromCache(transaction);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 移除事务从缓存</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeFromCache</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   transactionXidCompensableTransactionCache.invalidate(transaction.getXid());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 更新事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 更新数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(Transaction transaction)</span></span>;</div></pre></td></tr></table></figure><ul><li>调用 <code>#doUpdate(...)</code> 方法，更新事务。<ul><li>若更新成功后，调用 <code>#putToCache(...)</code> 方法，添加事务到缓存。</li><li>若更新失败后，抛出 OptimisticLockException 异常。有两种情况会导致更新失败：(1) 该事务已经被提交，被删除；(2) 乐观锁更新时，缓存的事务的版本号( <code>Transaction.version</code> )和存储器里的事务的版本号不同，更新失败。<strong>为什么</strong>？在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/">《TCC-Transaction 源码分析 —— 事务恢复》</a>详细解析。更新失败，意味着缓存已经不不一致，调用 <code>#removeFromCache(...)</code> 方法，移除事务从缓存中。</li></ul></li><li><code>#doUpdate(...)</code> 为抽象方法，子类实现该方法，提供更新事务功能。</li></ul><hr><p><strong><code>#delete(...)</code></strong> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = doDelete(transaction);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       removeFromCache(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 删除事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 删除数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doDelete</span><span class="params">(Transaction transaction)</span></span>;</div></pre></td></tr></table></figure><ul><li>调用 <code>#doDelete(...)</code> 方法，删除事务。</li><li>调用 <code>#removeFromCache(...)</code> 方法，移除事务从缓存中。</li><li><code>#doDelete(...)</code> 为抽象方法，子类实现该方法，提供删除事务功能。</li></ul><hr><p><strong><code>#findByXid(...)</code></strong> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">findByXid</span><span class="params">(TransactionXid transactionXid)</span> </span>&#123;</div><div class="line">   Transaction transaction = findFromCache(transactionXid);</div><div class="line">   <span class="keyword">if</span> (transaction == <span class="keyword">null</span>) &#123;</div><div class="line">       transaction = doFindOne(transactionXid);</div><div class="line">       <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">           putToCache(transaction);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得事务从缓存中</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionXid 事务编号</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Transaction <span class="title">findFromCache</span><span class="params">(TransactionXid transactionXid)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> transactionXidCompensableTransactionCache.getIfPresent(transactionXid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 查询事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> xid 事务编号</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Transaction <span class="title">doFindOne</span><span class="params">(Xid xid)</span></span>;</div></pre></td></tr></table></figure><ul><li>调用 <code>#findFromCache()</code> 方法，优先从缓存中获取事务。</li><li>调用 <code>#doFindOne()</code> 方法，缓存中事务不存在，从存储器中获取。获取到后，调用 <code>#putToCache()</code> 方法，添加事务到缓存中。</li><li><code>#doFindOne(...)</code> 为抽象方法，子类实现该方法，提供查询事务功能。</li></ul><hr><p><strong><code>#findAllUnmodifiedSince(...)</code></strong> 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">findAllUnmodifiedSince</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line">   List&lt;Transaction&gt; transactions = doFindAllUnmodifiedSince(date);</div><div class="line">   <span class="comment">// 添加到缓存</span></div><div class="line">   <span class="keyword">for</span> (Transaction transaction : transactions) &#123;</div><div class="line">       putToCache(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> transactions;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取超过指定时间的事务集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> date 指定时间</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Transaction&gt; <span class="title">doFindAllUnmodifiedSince</span><span class="params">(Date date)</span></span>;</div></pre></td></tr></table></figure><ul><li>调用 <code>#findAllUnmodifiedSince(...)</code> 方法，从存储器获取超过指定时间的事务集合。调用 <code>#putToCache(...)</code> 方法，循环事务集合添加到缓存。</li><li><code>#doFindAllUnmodifiedSince(...)</code> 为抽象方法，子类实现该方法，提供获取超过指定时间的事务集合功能。</li></ul><h2 id="3-2-JDBC-事务存储器"><a href="#3-2-JDBC-事务存储器" class="headerlink" title="3.2 JDBC 事务存储器"></a>3.2 JDBC 事务存储器</h2><p><code>org.mengyun.tcctransaction.repository.JdbcTransactionRepository</code>，JDBC 事务存储器，通过 JDBC 驱动，将 Transaction 存储到 MySQL / Oracle / PostgreSQL / SQLServer 等关系数据库。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTransactionRepository</span> <span class="keyword">extends</span> <span class="title">CachableTransactionRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 领域</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String domain;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 表后缀</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String tbSuffix;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> DataSource dataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 序列化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ObjectSerializer serializer = <span class="keyword">new</span> JdkSerializationSerializer();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>domain</code>，领域，或者也可以称为模块名，应用名，<strong>用于唯一标识一个资源</strong>。例如，Maven 模块 <code>xxx-order</code>，我们可以配置该属性为 <code>ORDER</code>。</li><li><code>tbSuffix</code>，表后缀。默认存储表名为 <code>TCC_TRANSACTION</code>，配置表名后，为 <code>TCC_TRANSACTION${tbSuffix}</code>。</li><li><code>dataSource</code>，存储数据的数据源。</li><li><code>serializer</code>，序列化。<strong>当数据库里已经有数据的情况下，不要更换别的序列化，否则会导致反序列化报错。</strong>建议：TCC-Transaction 存储时，新增字段，记录序列化的方式。</li></ul><p>表结构如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CREATE TABLE `TCC_TRANSACTION` (</div><div class="line">  `TRANSACTION_ID` <span class="keyword">int</span>(<span class="number">11</span>) NOT NULL AUTO_INCREMENT,</div><div class="line">  `DOMAIN` varchar(<span class="number">100</span>) DEFAULT NULL,</div><div class="line">  `GLOBAL_TX_ID` varbinary(<span class="number">32</span>) NOT NULL,</div><div class="line">  `BRANCH_QUALIFIER` varbinary(<span class="number">32</span>) NOT NULL,</div><div class="line">  `CONTENT` varbinary(<span class="number">8000</span>) DEFAULT NULL,</div><div class="line">  `STATUS` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT NULL,</div><div class="line">  `TRANSACTION_TYPE` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT NULL,</div><div class="line">  `RETRIED_COUNT` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT NULL,</div><div class="line">  `CREATE_TIME` datetime DEFAULT NULL,</div><div class="line">  `LAST_UPDATE_TIME` datetime DEFAULT NULL,</div><div class="line">  `VERSION` <span class="keyword">int</span>(<span class="number">11</span>) DEFAULT NULL,</div><div class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`TRANSACTION_ID`)</span>,</span></div><div class="line"><span class="function">  UNIQUE KEY `UX_TX_BQ` <span class="params">(`GLOBAL_TX_ID`,`BRANCH_QUALIFIER`)</span></span></div><div class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8</div></pre></td></tr></table></figure><ul><li><code>TRANSACTION_ID</code>，仅仅数据库自增，无实际用途。</li><li><code>CONTENT</code>，Transaction 序列化。</li></ul><p>ps：点击<a href="https://github.com/YunaiV/tcc-transaction/blob/c164ff5ab29d31e08bc7061de5bc7403f3e40f1d/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/repository/JdbcTransactionRepository.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看 JdbcTransactionRepository 代码实现，已经添加完整中文注释。</p><h2 id="3-3-Redis-事务存储器"><a href="#3-3-Redis-事务存储器" class="headerlink" title="3.3 Redis 事务存储器"></a>3.3 Redis 事务存储器</h2><p><code>org.mengyun.tcctransaction.repository.RedisTransactionRepository</code>，Redis 事务存储器，将 Transaction 存储到 Redis。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTransactionRepository</span> <span class="keyword">extends</span> <span class="title">CachableTransactionRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jedis Pool</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> JedisPool jedisPool;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * key 前缀</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String keyPrefix = <span class="string">"TCC:"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 序列化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ObjectSerializer serializer = <span class="keyword">new</span> JdkSerializationSerializer();</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>keyPrefix</code>，key 前缀。类似 JdbcTransactionRepository 的 <code>domain</code> 属性。</li></ul><p>一个事务存储到 Reids，使用 Redis 的数据结构为 <a href="https://redis.io/commands#hash" rel="external nofollow noopener noreferrer" target="_blank">HASHES</a>。</p><ul><li><p>key : 使用 <code>keyPrefix</code> + <code>xid</code>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建事务的 Redis Key</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> keyPrefix key 前缀</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> xid 事务</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> Redis Key</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getRedisKey(String keyPrefix, Xid xid) &#123;</div><div class="line">   <span class="keyword">byte</span>[] prefix = keyPrefix.getBytes();</div><div class="line">   <span class="keyword">byte</span>[] globalTransactionId = xid.getGlobalTransactionId();</div><div class="line">   <span class="keyword">byte</span>[] branchQualifier = xid.getBranchQualifier();</div><div class="line">   <span class="comment">// 拼接 key</span></div><div class="line">   <span class="keyword">byte</span>[] key = <span class="keyword">new</span> <span class="keyword">byte</span>[prefix.length + globalTransactionId.length + branchQualifier.length];</div><div class="line">   System.arraycopy(prefix, <span class="number">0</span>, key, <span class="number">0</span>, prefix.length);</div><div class="line">   System.arraycopy(globalTransactionId, <span class="number">0</span>, key, prefix.length, globalTransactionId.length);</div><div class="line">   System.arraycopy(branchQualifier, <span class="number">0</span>, key, prefix.length + globalTransactionId.length, branchQualifier.length);</div><div class="line">   <span class="keyword">return</span> key;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>HASHES 的 key ：使用 <code>version</code>。</p><ul><li>添加和更新 Transaction 时，使用 Redis <a href="https://redis.io/commands/hsetnx" rel="external nofollow noopener noreferrer" target="_blank">HSETNX</a>，不存在当前版本的值时，进行设置，重而实现类似乐观锁的更新。</li><li>读取 Transaction 时，使用 Redis <a href="https://redis.io/commands/hgetall" rel="external nofollow noopener noreferrer" target="_blank">HGETALL</a>，将 Transaction 所有 <code>version</code> 对应的值读取到内存后，取 <code>version</code> 值最大的对应的值。</li></ul></li><li><p>HASHES 的 value ：调用 <code>TransactionSerializer#serialize(...)</code> 方法，序列化 Transaction。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(ObjectSerializer serializer, Transaction transaction) &#123;</div><div class="line">   Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">   map.put(<span class="string">"GLOBAL_TX_ID"</span>, transaction.getXid().getGlobalTransactionId());</div><div class="line">   map.put(<span class="string">"BRANCH_QUALIFIER"</span>, transaction.getXid().getBranchQualifier());</div><div class="line">   map.put(<span class="string">"STATUS"</span>, transaction.getStatus().getId());</div><div class="line">   map.put(<span class="string">"TRANSACTION_TYPE"</span>, transaction.getTransactionType().getId());</div><div class="line">   map.put(<span class="string">"RETRIED_COUNT"</span>, transaction.getRetriedCount());</div><div class="line">   map.put(<span class="string">"CREATE_TIME"</span>, transaction.getCreateTime());</div><div class="line">   map.put(<span class="string">"LAST_UPDATE_TIME"</span>, transaction.getLastUpdateTime());</div><div class="line">   map.put(<span class="string">"VERSION"</span>, transaction.getVersion());</div><div class="line">   <span class="comment">// 序列化</span></div><div class="line">   map.put(<span class="string">"CONTENT"</span>, serializer.serialize(transaction));</div><div class="line">   <span class="keyword">return</span> serializer.serialize(map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TODO 为什么序列化两次</li></ul></li></ul><p>在实现 <code>#doFindAllUnmodifiedSince(date)</code> 方法，无法像数据库使用时间条件进行过滤，因此，加载所有事务后在内存中过滤。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> List&lt;Transaction&gt; <span class="title">doFindAllUnmodifiedSince</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得所有事务</span></div><div class="line">   List&lt;Transaction&gt; allTransactions = doFindAll();</div><div class="line">   <span class="comment">// 过滤时间</span></div><div class="line">   List&lt;Transaction&gt; allUnmodifiedSince = <span class="keyword">new</span> ArrayList&lt;Transaction&gt;();</div><div class="line">   <span class="keyword">for</span> (Transaction transaction : allTransactions) &#123;</div><div class="line">       <span class="keyword">if</span> (transaction.getLastUpdateTime().compareTo(date) &lt; <span class="number">0</span>) &#123;</div><div class="line">           allUnmodifiedSince.add(transaction);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> allUnmodifiedSince;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ps：点击<a href="https://github.com/YunaiV/tcc-transaction/blob/c164ff5ab29d31e08bc7061de5bc7403f3e40f1d/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/repository/RedisTransactionRepository.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看 RedisTransactionRepository 代码实现，已经添加完整中文注释。</p><blockquote><p>FROM <a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x#%E9%85%8D%E7%BD%AEtcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">《TCC-Transaction 官方文档 —— 使用指南1.2.x》</a><br>使用 RedisTransactionRepository 需要配置 Redis 服务器如下：<br>appendonly yes<br>appendfsync always</p></blockquote><h2 id="3-4-Zookeeper-事务存储器"><a href="#3-4-Zookeeper-事务存储器" class="headerlink" title="3.4 Zookeeper 事务存储器"></a>3.4 Zookeeper 事务存储器</h2><p><code>org.mengyun.tcctransaction.repository.ZooKeeperTransactionRepository</code>，Zookeeper 事务存储器，将 Transaction 存储到 Zookeeper。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperTransactionRepository</span> <span class="keyword">extends</span> <span class="title">CachableTransactionRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Zookeeper 服务器地址数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String zkServers;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Zookeeper 超时时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> zkTimeout;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TCC 存储 Zookeeper 根目录</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String zkRootPath = <span class="string">"/tcc"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Zookeeper 连接</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ZooKeeper zk;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 序列化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ObjectSerializer serializer = <span class="keyword">new</span> JdkSerializationSerializer();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>zkRootPath</code>，存储 Zookeeper 根目录，类似 JdbcTransactionRepository 的 <code>domain</code> 属性。</li></ul><p>一个事务存储到 Zookeeper，使用 Zookeeper 的<strong>持久数据节点</strong>。</p><ul><li><p>path：<code>${zkRootPath}</code> + <code>/</code> + <code>${xid}</code>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZooKeeperTransactionRepository.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTxidPath</span><span class="params">(Xid xid)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> String.format(<span class="string">"%s/%s"</span>, zkRootPath, xid);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TransactionXid.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">   StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">   stringBuilder.append(<span class="string">"globalTransactionId:"</span>).append(UUID.nameUUIDFromBytes(globalTransactionId).toString());</div><div class="line">   stringBuilder.append(<span class="string">","</span>).append(<span class="string">"branchQualifier:"</span>).append(UUID.nameUUIDFromBytes(branchQualifier).toString());</div><div class="line">   <span class="keyword">return</span> stringBuilder.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>data：调用 <code>TransactionSerializer#serialize(...)</code> 方法，序列化 Transaction。</p></li><li>version：使用 Zookeeper 数据节点自带版本功能。这里要注意下，Transaction 的版本从 1 开始，而 Zookeeper 数据节点版本从 0 开始。</li></ul><p>ps：点击<a href="https://github.com/YunaiV/tcc-transaction/blob/c164ff5ab29d31e08bc7061de5bc7403f3e40f1d/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/repository/ZooKeeperTransactionRepository.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看 ZooKeeperTransactionRepository 代码实现，已经添加完整中文注释。</p><p>另外，在生产上暂时不建议使用 ZooKeeperTransactionRepository，原因有两点：</p><ul><li>不支持 Zookeeper 安全认证。</li><li>使用 Zookeeper 时，未考虑断网重连等情况。</li></ul><p>如果你要使用 Zookeeper 进行事务的存储，可以考虑使用 <a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 操作 Zookeeper，重写 ZooKeeperTransactionRepository 部分代码。</p><h2 id="3-5-File-事务存储器"><a href="#3-5-File-事务存储器" class="headerlink" title="3.5 File 事务存储器"></a>3.5 File 事务存储器</h2><p><code>org.mengyun.tcctransaction.repository.FileSystemTransactionRepository</code>，File 事务存储器，将 Transaction 存储到文件系统。</p><p>实现上和 ZooKeeperTransactionRepository，区别主要在于不支持乐观锁更新。有兴趣的同学点击<a href="https://github.com/YunaiV/tcc-transaction/blob/c164ff5ab29d31e08bc7061de5bc7403f3e40f1d/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/repository/FileSystemTransactionRepository.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看，这里就不拓展开来。</p><p>另外，在生产上不建议使用 FileSystemTransactionRepository，因为不支持多节点共享。用分布式存储挂载文件另说，当然还是不建议，因为不支持乐观锁并发更新。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>这篇略( 超 )微( 级 )水更，哈哈哈，为<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recover/?self">《TCC-Transaction 源码分析 —— 事务恢复》</a>做铺垫啦。</p><p>使用 RedisTransactionRepository 和 ZooKeeperTransactionRepository 存储事务还是 Get 蛮多点的。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_15/02.png" alt=""></p><p>胖友，分享一个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 序列化&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— TCC 实现</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/tcc-core/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/tcc-core/</id>
    <published>2018-02-07T16:00:00.000Z</published>
    <updated>2017-09-17T11:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. TCC 原理</a></li><li><a href="#">3. TCC-Transaction 原理</a></li><li><a href="#">4. 事务与参与者</a><ul><li><a href="#">4.1 事务</a></li><li><a href="#">4.2 参与者</a></li></ul></li><li><a href="#">5. 事务管理器</a><ul><li><a href="#">5.1 发起根事务</a></li><li><a href="#">5.2 传播发起分支事务</a></li><li><a href="#">5.3 传播获取分支事务</a></li><li><a href="#">5.4 提交事务</a></li><li><a href="#">5.5 回滚事务</a></li><li><a href="#">5.6 添加参与者到事务</a></li></ul></li><li><a href="#">6. 事务拦截器</a><ul><li><a href="#">6.1 Compensable</a></li><li><a href="#">6.2 可补偿事务拦截器</a></li><li><a href="#">6.3 资源协调者拦截器</a></li></ul></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享 <strong>TCC 实现</strong>。主要涉及如下三个 Maven 项目：</p><ul><li><code>tcc-transaction-core</code> ：tcc-transaction 底层实现。</li><li><code>tcc-transaction-api</code> ：tcc-transaction 使用 API。</li><li><code>tcc-transaction-spring</code> ：tcc-transaction Spring 支持。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>OK，开始我们的第一段 TCC 旅程吧。</p><p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p><p>ps2：<strong>未特殊说明的情况下，本文事务指的是 TCC事务</strong>。</p><h1 id="2-TCC-原理"><a href="#2-TCC-原理" class="headerlink" title="2. TCC 原理"></a>2. TCC 原理</h1><blockquote><p>FROM <a href="https://support.hwclouds.com/devg-servicestage/zh-cn_topic_0056814426.html" rel="external nofollow noopener noreferrer" target="_blank">https://support.hwclouds.com/devg-servicestage/zh-cn_topic_0056814426.html</a><br><strong>TCC事务</strong><br>为了解决在事务运行过程中大颗粒度资源锁定的问题，业界提出一种新的事务模型，它是基于<strong>业务层面</strong>的事务定义。锁粒度完全由业务自己控制。它本质是一种补偿的思路。它把事务运行过程分成 Try、Confirm / Cancel 两个阶段。在每个阶段的逻辑由<strong>业务代码控制</strong>。这样就事务的锁粒度可以完全自由控制。业务可以在牺牲隔离性的情况下，获取更高的性能。</p></blockquote><ul><li>Try 阶段<ul><li>Try ：尝试执行业务 <ul><li>完成所有业务检查( 一致性 ) </li><li>预留必须业务资源( 准隔离性 )</li></ul></li></ul></li><li>Confirm / Cancel 阶段：<ul><li>Confirm ：确认执行业务<ul><li>真正执行业务</li><li>不做任务业务检查</li><li>Confirm 操作满足幂等性</li></ul></li><li>Cancel ：取消执行业务<ul><li>释放 Try 阶段预留的业务资源</li><li>Cancel 操作满足幂等性 </li></ul></li><li>Confirm 与 Cancel 互斥</li></ul></li></ul><p>整体流程如下图：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/01.jpeg" alt=""></p><ul><li><p><strong>红框部分</strong>功能由 <code>tcc-transaction-core</code> 实现：</p><ul><li>启动业务活动</li><li>登记业务操作</li><li>提交 / 回滚业务活动</li></ul></li><li><p><strong>黄框部分</strong>功能由 <code>tcc-transaction-http-sample</code> 实现( 官方提供的示例项目 )：</p><ul><li>Try 操作</li><li>Confirm 操作</li><li>Cancel 操作 </li></ul></li></ul><p><strong>与 2PC协议 比较</strong>：</p><ul><li>位于业务服务层而非自愿层</li><li>没有单独的准备( Prepare )阶段，Try 操作兼备自愿操作与准备能力</li><li>Try 操作可以灵活选择业务资源的锁定粒度</li><li>较高开发成本</li></ul><p>参考资料：</p><ul><li><a href="https://www.zhihu.com/question/31813039" rel="external nofollow noopener noreferrer" target="_blank">《支付宝运营架构中柔性事务指的是什么？》</a></li><li><a href="http://kaimingwan.com/post/fen-bu-shi/fen-bu-shi-shi-wu-de-dian-xing-chu-li-fang-shi-2pc-tcc-yi-bu-que-bao-he-zui-da-nu-li-xing" rel="external nofollow noopener noreferrer" target="_blank">《分布式事务的典型处理方式:2PC、TCC、异步确保和最大努力型》</a></li></ul><h1 id="3-TCC-Transaction-原理"><a href="#3-TCC-Transaction-原理" class="headerlink" title="3. TCC-Transaction 原理"></a>3. TCC-Transaction 原理</h1><p>在 TCC 里，一个业务活动可以有多个事务，每个业务操作归属于不同的事务，即一个事务可以包含多个业务操作。TCC-Transaction 将每个业务操作抽象成<strong>事务参与者</strong>，每个事务可以包含多个<strong>参与者</strong>。</p><p>参与者需要声明 try / confirm / cancel 三个类型的方法，和 TCC 的操作一一对应。在程序里，通过 @Compensable 注解标记在 try 方法上，并填写对应的 confirm / cancel 方法，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// try</span></div><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmRecord"</span>, cancelMethod = <span class="string">"cancelRecord"</span>, transactionContextEditor = MethodTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// confirm</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// cancel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure><ul><li>在示例代码中，我们看到 TransactionContext，事务上下文，这个是怎么生成的呢？这里先卖一个关子。</li></ul><p>TCC-Transaction 有两个拦截器，通过对 @Compensable AOP 切面( 参与者 try 方法 )进行拦截，透明化对参与者 confirm / cancel 方法调用，从而实现 TCC 。<strong>简化</strong>流程如下图：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/03.png" alt=""></p><p>第一个拦截器，可补偿事务拦截器，实现如下功能：</p><ul><li>在 Try 阶段，对事务的发起、传播。</li><li>在 Confirm / Cancel 阶段，对事务提交或回滚。</li><li><strong>为什么会有对事务的传播呢</strong>？在远程调用服务的参与者时，会通过<strong>“参数”</strong>( 需要序列化 )的形式传递事务给远程参与者。</li></ul><p>第二个拦截器，资源协调者拦截器，实现如下功能：</p><ul><li>在 Try 阶段，添加参与者到事务中。当事务上下文不存在时，进行创建。</li></ul><p>实际拦截器对事务的处理会比上图复杂一些，在本文<a href="#">「6. 事务拦截器」</a>详细解析。</p><p>在 TCC-Transaction 代码实现上，组件分层如下图：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/04.png" alt=""></p><p>本文按照如下顺序分享：</p><ul><li><a href="#">「4. 事务拦截器」</a></li><li><a href="#">「5. 事务管理器」</a></li><li><a href="#">「6. 事务管理器」</a></li></ul><p>内容是<strong>自下而上</strong>的方式分享，每个组件可以更加整体的被认识。当然这可能对你理解时产生一脸闷逼，所以推荐两种阅读方式：</p><ul><li>简读 x 1 + 深读 x 1</li><li>倒着读，发现未分享的方法，全文检索该方法。</li></ul><p>事务存储器在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码解析 —— 事务存储于恢复》</a>详细解析。</p><p>事务恢复在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码解析 —— 事务恢复》</a>详细解析。</p><h1 id="4-事务与参与者"><a href="#4-事务与参与者" class="headerlink" title="4. 事务与参与者"></a>4. 事务与参与者</h1><p>在 TCC 里，<strong>一个</strong>事务( <code>org.mengyun.tcctransaction.Transaction</code> ) 可以有<strong>多个</strong>参与者( <code>org.mengyun.tcctransaction.Participant</code> )参与业务活动。类图关系如下( <a href="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/02.png" alt=""></p><h2 id="4-1-事务"><a href="#4-1-事务" class="headerlink" title="4.1 事务"></a>4.1 事务</h2><p><strong>Transaction 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7291423944314337931L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionStatus status;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重试次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> retriedCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date createTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date lastUpdateTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> version = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参与者集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Participant&gt; participants = <span class="keyword">new</span> ArrayList&lt;Participant&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 附带属性映射</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加参与者</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">        participants.add(participant);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.rollback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>xid，事务编号( TransactionXid )，用于唯一标识一个事务。使用 UUID 算法生成，<strong>保证唯一性</strong>。<code>org.mengyun.tcctransaction.api.TransactionXid</code> 实现 <a href="https://docs.oracle.com/javase/8/docs/api/javax/transaction/xa/Xid.html" rel="external nofollow noopener noreferrer" target="_blank"><code>javax.transaction.xa.Xid</code></a> 接口，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionXid</span> <span class="keyword">implements</span> <span class="title">Xid</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6817267250789142043L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * xid 格式标识符</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> formatId = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 全局事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] globalTransactionId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分支事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] branchQualifier;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>TODO 为什么要继承 Xid 接口？</li></ul></li><li><p>status，事务状态( TransactionStatus )。<code>org.mengyun.tcctransaction.api.TransactionStatus</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionStatus &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 尝试中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TRYING(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CONFIRMING(<span class="number">2</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CANCELLING(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>transactionType，事务类型( TransactionType )。<code>org.mengyun.tcctransaction.common.TransactionType</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionType &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ROOT(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分支事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    BRANCH(<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在<a href="#">「6.2 可补偿事务拦截器」</a>有详细解析，可以看到看到这两种事务是如何发起。</li></ul></li><li><p>retriedCount，重试次数。在 TCC 过程中，可能参与者异常崩溃，这个时候会进行重试直到成功或超过最大次数。在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码解析 —— 事务恢复》</a>详细解析。</p></li><li>version，版本号，用于乐观锁更新事务。在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码解析 —— 事务存储器》</a>详细解析。</li><li>attachments，附带属性映射。在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</li><li>提供 <code>#enlistParticipant()</code> 方法，添加事务参与者。</li><li>提供 <code>#commit()</code> 方法，调用参与者们提交事务。</li><li>提供 <code>#rollback()</code> 方法，调用参与者回滚事务。</li></ul><h2 id="4-2-参与者"><a href="#4-2-参与者" class="headerlink" title="4.2 参与者"></a>4.2 参与者</h2><p><strong>Participant 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4127729421281425247L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法调用上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext confirmInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext cancelInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Terminator terminator = <span class="keyword">new</span> Terminator();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CONFIRMING.getId()), confirmInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CANCELLING.getId()), cancelInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>xid，参与者事务编号。通过 <code>TransactionXid.globalTransactionId</code> 属性，关联上其所属的事务。当参与者进行远程调用时，远程的<strong>分支</strong>事务的事务编号等于该参与者的事务编号。通过事务编号的关联，TCC Confirm / Cancel 阶段，使用参与者的事务编号和远程的<strong>分支</strong>事务进行关联，从而实现事务的提交和回滚，在<a href="#">「5.2 传播发起分支事务」 + 「6.2 可补偿事务拦截器」</a>可以看到具体实现。</li><li><p>confirmInvocationContext，确认执行业务方法调用上下文( InvocationContext )。<code>org.mengyun.tcctransaction.InvocationContext</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationContext</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7969140711432461165L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 类</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class targetClass;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String methodName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数类型数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class[] parameterTypes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object[] args;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>InvocationContext，执行方法调用上下文，记录类、方法名、参数类型数组、参数数组。通过这些属性，可以执行提交 / 回滚事务。在 <code>org.mengyun.tcctransaction.Terminator</code> 会看到具体的代码实现。<strong>本质上，TCC 通过多个参与者的 try / confirm / cancel 方法，实现事务的最终一致性</strong>。</li></ul></li><li><p>cancelInvocationContext，取消执行业务方法调用上下文( InvocationContext )。</p></li><li><p>terminator，执行器( Terminator )。<code>org.mengyun.tcctransaction.Terminator</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terminator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">164958655471605778L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(TransactionContext transactionContext, InvocationContext invocationContext, Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(invocationContext.getMethodName())) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 获得 参与者对象</span></div><div class="line">                Object target = FactoryBuilder.factoryOf(invocationContext.getTargetClass()).getInstance();</div><div class="line">                <span class="comment">// 获得 方法</span></div><div class="line">                Method method = target.getClass().getMethod(invocationContext.getMethodName(), invocationContext.getParameterTypes());</div><div class="line">                <span class="comment">// 设置 事务上下文 到方法参数</span></div><div class="line">                FactoryBuilder.factoryOf(transactionContextEditorClass).getInstance().set(transactionContext, target, method, invocationContext.getArgs());</div><div class="line">                <span class="comment">// 执行方法</span></div><div class="line">                <span class="keyword">return</span> method.invoke(target, invocationContext.getArgs());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>FactoryBuilder，工厂 Builder，感兴趣的同学点击<a href="https://github.com/YunaiV/tcc-transaction/blob/8553baad29597603d9007d61aec3ea5201632d1b/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/support/FactoryBuilder.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看，已经添加完整中文代码注释。</li><li>TransactionContextEditor，在本文<a href="#">「6.1 Compensable」</a>详细解析。</li></ul></li><li>transactionContextEditorClass，事务上下文编辑，在<a href="#">「6.1 Compensable」</a>详细解析。</li><li>提交 <code>#commit()</code> 方法，提交参与者自己的事务。</li><li>提交 <code>#rollback()</code> 方法，回滚参与者自己的事务。 </li></ul><h1 id="5-事务管理器"><a href="#5-事务管理器" class="headerlink" title="5. 事务管理器"></a>5. 事务管理器</h1><p><code>org.mengyun.tcctransaction.TransactionManager</code>，事务管理器，提供事务的获取、发起、提交、回滚，参与者的新增等等方法。</p><h2 id="5-1-发起根事务"><a href="#5-1-发起根事务" class="headerlink" title="5.1 发起根事务"></a>5.1 发起根事务</h2><p>提供 <code>begin()</code> 方法，发起根事务。该方法在<strong>调用方法类型为 MethodType.ROOT 并且 事务处于 Try 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 发起根事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 根事务</span></div><div class="line">   Transaction transaction = <span class="keyword">new</span> Transaction(TransactionType.ROOT);</div><div class="line">   <span class="comment">// 存储 事务</span></div><div class="line">   transactionRepository.create(transaction);</div><div class="line">   <span class="comment">// 注册 事务</span></div><div class="line">   registerTransaction(transaction);</div><div class="line">   <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 Transaction 构造方法，创建<strong>根事务</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Transaction.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建指定类型的事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionType 事务类型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionType transactionType)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = <span class="keyword">new</span> TransactionXid();</div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = transactionType;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>目前该构造方法只有 <code>TransactionManager#begin()</code> 在调用，即只创建<strong>根事务</strong>。</li></ul></li><li>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。</li><li><p>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 当前线程事务队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册事务到当前线程事务队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTransaction</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (CURRENT.get() == <span class="keyword">null</span>) &#123;</div><div class="line">       CURRENT.set(<span class="keyword">new</span> LinkedList&lt;Transaction&gt;());</div><div class="line">   &#125;</div><div class="line">   CURRENT.get().push(transaction); <span class="comment">// 添加到头部</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>可能有同学会比较好奇，为什么使用队列存储当前线程事务</strong>？TCC-Transaction 支持<strong>多个</strong>的事务<strong>独立存在</strong>，后创建的事务先提交，类似 Spring 的<code>org.springframework.transaction.annotation.Propagation.REQUIRES_NEW</code> 。在下文，很快我们就会看到 TCC-Transaction 自己的 <code>org.mengyun.tcctransaction.api.Propagation</code> 。</li></ul></li></ul><h2 id="5-2-传播发起分支事务"><a href="#5-2-传播发起分支事务" class="headerlink" title="5.2 传播发起分支事务"></a>5.2 传播发起分支事务</h2><p>调用 <code>#propagationNewBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Try 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播发起分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationNewBegin</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">  <span class="comment">// 创建 分支事务</span></div><div class="line">  Transaction transaction = <span class="keyword">new</span> Transaction(transactionContext);</div><div class="line">  <span class="comment">// 存储 事务</span></div><div class="line">  transactionRepository.create(transaction);</div><div class="line">  <span class="comment">// 注册 事务</span></div><div class="line">  registerTransaction(transaction);</div><div class="line">  <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 Transaction 构造方法，创建<strong>分支事务</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = transactionContext.getXid(); <span class="comment">// 事务上下文的 xid</span></div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = TransactionType.BRANCH; <span class="comment">// 分支事务</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>分支</strong>事务使用传播的事务上下文的事务编号。</li></ul></li><li>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。为什么要存储<strong>分支</strong>事务，在<a href="#">「6.3 资源协调者拦截器」</a>详细解析。</li><li>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</li></ul><h2 id="5-3-传播获取分支事务"><a href="#5-3-传播获取分支事务" class="headerlink" title="5.3 传播获取分支事务"></a>5.3 传播获取分支事务</h2><p>调用 <code>#propagationExistBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Confirm / Cancel 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播获取分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">* <span class="doctag">@throws</span> NoExistedTransactionException 当事务不存在时</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationExistBegin</span><span class="params">(TransactionContext transactionContext)</span> <span class="keyword">throws</span> NoExistedTransactionException </span>&#123;</div><div class="line">   <span class="comment">// 查询 事务</span></div><div class="line">   Transaction transaction = transactionRepository.findByXid(transactionContext.getXid());</div><div class="line">   <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// 设置 事务 状态</span></div><div class="line">       transaction.changeStatus(TransactionStatus.valueOf(transactionContext.getStatus()));</div><div class="line">       <span class="comment">// 注册 事务</span></div><div class="line">       registerTransaction(transaction);</div><div class="line">       <span class="keyword">return</span> transaction;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoExistedTransactionException();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>TransactionRepository#findByXid()</code> 方法，查询事务。</li><li>调用 <code>Transaction#changeStatus(...)</code> 方法，<strong>设置</strong>事务状态为 CONFIRMING 或 CANCELLING。</li><li>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</li><li>为什么此处是<strong>分支</strong>事务呢？结合 <code>#propagationNewBegin(...)</code> 思考下。 </li></ul><h2 id="5-4-提交事务"><a href="#5-4-提交事务" class="headerlink" title="5.4 提交事务"></a>5.4 提交事务</h2><p>调用 <code>#commit(...)</code> 方法，提交事务。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 提交事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CONFIRMING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CONFIRMING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.commit();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable commitException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction confirm failed."</span>, commitException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConfirmingException(commitException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getCurrentTransaction()</code> 方法， 获取事务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isTransactionActive()) &#123;</div><div class="line">       <span class="keyword">return</span> CURRENT.get().peek(); <span class="comment">// 获得头部元素</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransactionActive</span><span class="params">()</span> </span>&#123;</div><div class="line">   Deque&lt;Transaction&gt; transactions = CURRENT.get();</div><div class="line">   <span class="keyword">return</span> transactions != <span class="keyword">null</span> &amp;&amp; !transactions.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为什么获得队列<strong>头部</strong>元素呢？该元素即是上文调用 <code>#registerTransaction(...)</code> 注册到队列头部。</li></ul></li><li>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CONFIRMING。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li><li>调用 <code>Transaction#commit(...)</code> 方法， <strong>提交</strong>事务。</li><li>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</li></ul><h2 id="5-5-回滚事务"><a href="#5-5-回滚事务" class="headerlink" title="5.5 回滚事务"></a>5.5 回滚事务</h2><p>调用 <code>#rollback(...)</code> 方法，取消事务，和 <code>#commit()</code> 方法基本类似。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 回滚事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CANCELLING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CANCELLING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.rollback();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable rollbackException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction rollback failed."</span>, rollbackException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> CancellingException(rollbackException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li><li>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CANCELLING。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li><li>调用 <code>Transaction#rollback(...)</code> 方法， <strong>回滚</strong>事务。</li><li>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</li></ul><h2 id="5-6-添加参与者到事务"><a href="#5-6-添加参与者到事务" class="headerlink" title="5.6 添加参与者到事务"></a>5.6 添加参与者到事务</h2><p>调用 <code>#enlistParticipant(...)</code> 方法，添加参与者到事务。该方法在<strong>事务处于 Try 阶段</strong>被调用，在<a href="#">「6.3 资源协调者拦截器」</a>有详细解析。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加参与者到事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = <span class="keyword">this</span>.getCurrentTransaction();</div><div class="line">   <span class="comment">// 添加参与者</span></div><div class="line">   transaction.enlistParticipant(participant);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li><li>调用 <code>Transaction#enlistParticipant(...)</code> 方法， 添加参与者到事务。</li><li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li></ul><h1 id="6-事务拦截器"><a href="#6-事务拦截器" class="headerlink" title="6. 事务拦截器"></a>6. 事务拦截器</h1><p>TCC-Transaction 基于 <code>org.mengyun.tcctransaction.api.@Compensable</code> + <code>org.aspectj.lang.annotation.@Aspect</code> <strong>注解</strong> <strong>AOP 切面</strong>实现业务方法的 TCC 事务声明<strong>拦截</strong>，同 Spring 的 <code>org.springframework.transaction.annotation.@Transactional</code> 的实现。</p><p>TCC-Transaction 有两个拦截器：</p><ul><li><code>org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor</code>，可补偿事务拦截器。</li><li><code>org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor</code>，资源协调者拦截器。</li></ul><p>在分享拦截器的实现之前，我们先一起看看 @Compensable 注解。</p><h2 id="6-1-Compensable"><a href="#6-1-Compensable" class="headerlink" title="6.1 Compensable"></a>6.1 Compensable</h2><p>@Compensable，标记可补偿的方法注解。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Compensable &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 传播级别</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">confirmMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">cancelMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditor() <span class="keyword">default</span> DefaultTransactionContextEditor.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>propagation，传播级别( Propagation )，默认 Propagation.REQUIRED。和 Spring 的 Propagation 除了缺少几个属性，基本一致。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就新建一个事务。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRED(<span class="number">0</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就以非事务方式执行。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SUPPORTS(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就抛出异常。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    MANDATORY(<span class="number">2</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新建事务，如果当前存在事务，把当前事务挂起。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRES_NEW(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>confirmMethod，确认执行业务方法名。</p></li><li>cancelMethod，取消执行业务方法名。</li><li><p>TransactionContextEditor，事务上下文编辑器( TransactionContextEditor )，用于设置和获得事务上下文( TransactionContext )，在<a href="#">「6.3 资源协调者拦截器」</a>可以看到被调用，此处只看它的代码实现。<code>org.mengyun.tcctransaction.api.TransactionContextEditor</code> 接口代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 从参数中获得事务上下文</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置事务上下文到参数中</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>DefaultTransactionContextEditor，<strong>默认</strong>事务上下文编辑器实现。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (TransactionContext) args[position];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            args[position] = transactionContext; <span class="comment">// 设置方法参数</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务上下文在方法参数里的位置</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 参数类型集合</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTransactionContextParamPosition</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (parameterTypes[i].equals(org.mengyun.tcctransaction.api.TransactionContext.class)) &#123;</div><div class="line">                position = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul><ul><li><p>NullableTransactionContextEditor，无事务上下文编辑器实现。实现代码如下：</p>   <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullableTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></li><li><p>DubboTransactionContextEditor，Dubbo 事务上下文编辑器实现，通过 Dubbo 隐式传参方式获得事务上下文，在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</p></li></ul></li></ul><h2 id="6-2-可补偿事务拦截器"><a href="#6-2-可补偿事务拦截器" class="headerlink" title="6.2 可补偿事务拦截器"></a>6.2 可补偿事务拦截器</h2><p>先一起来看下可补偿事务拦截器对应的切面 <code>org.mengyun.tcctransaction.interceptor.CompensableTransactionAspect</code>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CompensableTransactionInterceptor compensableTransactionInterceptor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompensableTransactionInterceptor</span><span class="params">(CompensableTransactionInterceptor compensableTransactionInterceptor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.compensableTransactionInterceptor = compensableTransactionInterceptor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.mengyun.tcctransaction.api.Compensable)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compensableService</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"compensableService()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> compensableTransactionInterceptor.interceptCompensableMethod(pjp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过 <code>org.aspectj.lang.annotation.@Pointcut</code> + <code>org.aspectj.lang.annotation.@Around</code> 注解，配置对 <strong>@Compensable 注解的方法</strong>进行拦截，调用 <code>CompensableTransactionInterceptor#interceptCompensableMethod(...)</code> 方法进行处理。</li></ul><p><strong>CompensableTransactionInterceptor 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionInterceptor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Set&lt;Class&lt;? extends Exception&gt;&gt; delayCancelExceptions;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// 获得带 @Compensable 注解的方法</span></div><div class="line">        Method method = CompensableMethodUtils.getCompensableMethod(pjp);</div><div class="line">        <span class="comment">//</span></div><div class="line">        Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line">        Propagation propagation = compensable.propagation();</div><div class="line">        <span class="comment">// 获得 事务上下文</span></div><div class="line">        TransactionContext transactionContext = FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs());</div><div class="line">        <span class="comment">// 当前线程是否在事务中</span></div><div class="line">        <span class="keyword">boolean</span> isTransactionActive = transactionManager.isTransactionActive();</div><div class="line">        <span class="comment">// 判断事务上下文是否合法</span></div><div class="line">        <span class="keyword">if</span> (!TransactionUtils.isLegalTransactionContext(isTransactionActive, propagation, transactionContext)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"no active compensable transaction while propagation is mandatory for method "</span> + method.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算方法类型</span></div><div class="line">        MethodType methodType = CompensableMethodUtils.calculateMethodType(propagation, isTransactionActive, transactionContext);</div><div class="line">        <span class="comment">// 处理</span></div><div class="line">        <span class="keyword">switch</span> (methodType) &#123;</div><div class="line">            <span class="keyword">case</span> ROOT:</div><div class="line">                <span class="keyword">return</span> rootMethodProceed(pjp);</div><div class="line">            <span class="keyword">case</span> PROVIDER:</div><div class="line">                <span class="keyword">return</span> providerMethodProceed(pjp, transactionContext);</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>CompensableMethodUtils#getCompensableMethod(...)</code> 方法，获得带 @Compensable 注解的方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CompensableMethodUtils.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得带 <span class="doctag">@Compensable</span> 注解的方法</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> pjp 切面点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 方法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</div><div class="line">   Method method = ((MethodSignature) (pjp.getSignature())).getMethod(); <span class="comment">// 代理方法对象</span></div><div class="line">   <span class="keyword">if</span> (method.getAnnotation(Compensable.class) == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           method = pjp.getTarget().getClass().getMethod(method.getName(), method.getParameterTypes()); <span class="comment">// 实际方法对象</span></div><div class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> method;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>TransactionContextEditor#get(...)</code> 方法，从参数中获得事务上下文。<strong>为什么从参数中可以获得事务上下文呢</strong>？在<a href="#">「6.3 资源协调者拦截器」</a>揭晓答案。</p></li><li><p>调用 <code>TransactionManager#isTransactionActive()</code> 方法，当前线程是否在事务中。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransactionActive</span><span class="params">()</span> </span>&#123;</div><div class="line">   Deque&lt;Transaction&gt; transactions = CURRENT.get();</div><div class="line">   <span class="keyword">return</span> transactions != <span class="keyword">null</span> &amp;&amp; !transactions.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>TransactionUtils#isLegalTransactionContext(...)</code> 方法，判断事务上下文是否合法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionUtils.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断事务上下文是否合法</span></div><div class="line"><span class="comment">* 在 Propagation.MANDATORY 必须有在事务内</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isTransactionActive 是否</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> propagation 传播级别</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否合法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLegalTransactionContext</span><span class="params">(<span class="keyword">boolean</span> isTransactionActive, Propagation propagation, TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (propagation.equals(Propagation.MANDATORY) &amp;&amp; !isTransactionActive &amp;&amp; transactionContext == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当传播级别为 Propagation.MANDATORY 时，要求必须在事务中。</li></ul></li><li><p>调用 <code>CompensableMethodUtils#calculateMethodType(...)</code> 方法，计算方法类型。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算方法类型</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> propagation 传播级别</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isTransactionActive 是否事务开启</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 方法类型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">calculateMethodType</span><span class="params">(Propagation propagation, <span class="keyword">boolean</span> isTransactionActive, TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> ((propagation.equals(Propagation.REQUIRED) &amp;&amp; !isTransactionActive &amp;&amp; transactionContext == <span class="keyword">null</span>) <span class="comment">// Propagation.REQUIRED：支持当前事务，当前没有事务，就新建一个事务。</span></div><div class="line">           || propagation.equals(Propagation.REQUIRES_NEW)) &#123; <span class="comment">// Propagation.REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</span></div><div class="line">       <span class="keyword">return</span> MethodType.ROOT;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((propagation.equals(Propagation.REQUIRED) <span class="comment">// Propagation.REQUIRED：支持当前事务</span></div><div class="line">               || propagation.equals(Propagation.MANDATORY)) <span class="comment">// Propagation.MANDATORY：支持当前事务</span></div><div class="line">           &amp;&amp; !isTransactionActive &amp;&amp; transactionContext != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> MethodType.PROVIDER;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> MethodType.NORMAL;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>计算方法类型( MethodType )的目的，可以根据不同方法类型，做不同的事务处理。</li><li>方法类型为 MethodType.ROOT 时，发起<strong>根事务</strong>，判断条件如下二选一：<ul><li>事务传播级别为 Propagation.REQUIRED，并且当前没有事务。</li><li>事务传播级别为 Propagation.REQUIRES_NEW，新建事务，如果当前存在事务，把当前事务挂起。<strong>此时，事务管理器的当前线程事务队列可能会存在多个事务</strong>。<ul><li>方法类型为 MethodType.ROOT 时，发起<strong>分支事务</strong>，判断条件如下二选一：</li></ul></li><li>事务传播级别为 Propagation.REQUIRED，并且当前不存在事务，<strong>并且方法参数传递了事务上下文</strong>。</li><li>事务传播级别为 Propagation.PROVIDER，并且当前不存在事务，<strong>并且方法参数传递了事务上下文</strong>。</li><li><strong>当前不存在事务，方法参数传递了事务上下文是什么意思</strong>？当跨服务<strong>远程</strong>调用时，被调用服务本身( <strong>服务提供者</strong> )不在事务中，通过传递事务上下文参数，融入当前事务。<ul><li>方法类型为 MethodType.Normal 时，不进行事务处理。</li><li>MethodType.CONSUMER 项目已经不再使用，猜测已废弃。</li></ul></li></ul></li></ul></li><li><p>当方法类型为 MethodType.ROOT 时，调用 <code>#rootMethodProceed(...)</code> 方法，发起 <strong>TCC 整体流程</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rootMethodProceed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   Object returnValue;</div><div class="line">   Transaction transaction = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 发起根事务</span></div><div class="line">       transaction = transactionManager.begin();</div><div class="line">       <span class="comment">// 执行方法原逻辑</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           returnValue = pjp.proceed();</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable tryingException) &#123;</div><div class="line">           <span class="keyword">if</span> (isDelayCancelException(tryingException)) &#123; <span class="comment">// 是否延迟回滚</span></div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               logger.warn(String.format(<span class="string">"compensable transaction trying failed. transaction content:%s"</span>, JSON.toJSONString(transaction)), tryingException);</div><div class="line">               <span class="comment">// 回滚事务</span></div><div class="line">               transactionManager.rollback();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">throw</span> tryingException;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 提交事务</span></div><div class="line">       transactionManager.commit();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 将事务从当前线程事务队列移除</span></div><div class="line">       transactionManager.cleanAfterCompletion(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> returnValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#transactionManager()</code> 方法，发起<strong>根事务</strong>，<strong>TCC Try 阶段开始</strong>。</li><li>调用 <code>ProceedingJoinPoint#proceed()</code> 方法，执行方法<strong>原逻辑( 即 Try 逻辑 )</strong>。</li><li>当原逻辑执行异常时，<strong>TCC Try 阶段失败</strong>，调用 <code>TransactionManager#rollback(...)</code> 方法，<strong>TCC Cancel 阶段</strong>，回滚事务。此处 <code>#isDelayCancelException(...)</code> 方法，判断异常是否为延迟取消回滚异常，部分异常不适合立即回滚事务，在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码分析 —— 事务恢复》</a>详细解析。</li><li>当原逻辑执行成功时，<strong>TCC Try 阶段成功</strong>，调用 <code>TransactionManager#commit(...)</code> 方法，<strong>TCC Confirm 阶段</strong>，提交事务。</li><li><p>调用 <code>TransactionManager#cleanAfterCompletion(...)</code> 方法，将事务从当前线程事务队列移除，避免线程冲突。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanAfterCompletion</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isTransactionActive() &amp;&amp; transaction != <span class="keyword">null</span>) &#123;</div><div class="line">        Transaction currentTransaction = getCurrentTransaction();</div><div class="line">        <span class="keyword">if</span> (currentTransaction == transaction) &#123;</div><div class="line">            CURRENT.get().pop();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Illegal transaction when clean after completion"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>当方法类型为 Propagation.PROVIDER 时，服务提供者参与 <strong>TCC 整体流程</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">providerMethodProceed</span><span class="params">(ProceedingJoinPoint pjp, TransactionContext transactionContext)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   Transaction transaction = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">switch</span> (TransactionStatus.valueOf(transactionContext.getStatus())) &#123;</div><div class="line">           <span class="keyword">case</span> TRYING:</div><div class="line">               <span class="comment">// 传播发起分支事务</span></div><div class="line">               transaction = transactionManager.propagationNewBegin(transactionContext);</div><div class="line">               <span class="keyword">return</span> pjp.proceed();</div><div class="line">           <span class="keyword">case</span> CONFIRMING:</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 传播获取分支事务</span></div><div class="line">                   transaction = transactionManager.propagationExistBegin(transactionContext);</div><div class="line">                   <span class="comment">// 提交事务</span></div><div class="line">                   transactionManager.commit();</div><div class="line">               &#125; <span class="keyword">catch</span> (NoExistedTransactionException excepton) &#123;</div><div class="line">                   <span class="comment">//the transaction has been commit,ignore it.</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> CANCELLING:</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 传播获取分支事务</span></div><div class="line">                   transaction = transactionManager.propagationExistBegin(transactionContext);</div><div class="line">                   <span class="comment">// 回滚事务</span></div><div class="line">                   transactionManager.rollback();</div><div class="line">               &#125; <span class="keyword">catch</span> (NoExistedTransactionException exception) &#123;</div><div class="line">                   <span class="comment">//the transaction has been rollback,ignore it.</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 将事务从当前线程事务队列移除</span></div><div class="line">       transactionManager.cleanAfterCompletion(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回空值</span></div><div class="line">   Method method = ((MethodSignature) (pjp.getSignature())).getMethod();</div><div class="line">   <span class="keyword">return</span> ReflectionUtils.getNullValue(method.getReturnType());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当事务处于 TransactionStatus.TRYING 时，调用 <code>TransactionManager#propagationExistBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。发起<strong>分支</strong>事务完成后，调用 <code>ProceedingJoinPoint#proceed()</code> 方法，执行方法<strong>原逻辑( 即 Try 逻辑 )</strong>。<ul><li><strong>为什么要传播发起分支事务</strong>？在<strong>根事务</strong>进行 Confirm / Cancel 时，调用<strong>根事务</strong>上的参与者们提交或回滚事务时，进行远程服务方法调用的参与者，可以通过自己的事务编号关联上传播的<strong>分支</strong>事务( 两者的事务编号相等 )，进行事务的提交或回滚。</li></ul></li><li>当事务处于 TransactionStatus.CONFIRMING 时，调用 <code>TransactionManager#commit()</code> 方法，提交事务。</li><li>当事务处于 TransactionStatus.CANCELLING 时，调用 <code>TransactionManager#rollback()</code> 方法，提交事务。</li><li>调用 <code>TransactionManager#cleanAfterCompletion(...)</code> 方法，将事务从当前线程事务队列移除，避免线程冲突。</li><li><p>当事务处于 TransactionStatus.CONFIRMING / TransactionStatus.CANCELLING 时，调用 <code>ReflectionUtils#getNullValue(...)</code> 方法，返回空值。<strong>为什么返回空值</strong>？Confirm / Cancel 相关方法，是通过 AOP 切面调用，只调用，不处理返回值，但是又不能没有返回值，因此直接返回空。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getNullValue</span><span class="params">(Class type)</span> </span>&#123;</div><div class="line">   <span class="comment">// 处理基本类型</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">boolean</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">short</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">long</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">float</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">double</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理对象</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>当方法类型为 Propagation.NORMAL 时，执行方法原逻辑，<strong>不进行事务处理</strong>。</p></li></ul><h2 id="6-3-资源协调者拦截器"><a href="#6-3-资源协调者拦截器" class="headerlink" title="6.3 资源协调者拦截器"></a>6.3 资源协调者拦截器</h2><p>先一起来看下资源协调者拦截器  对应的切面 <code>org.mengyun.tcctransaction.interceptor.CompensableTransactionAspect</code>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ResourceCoordinatorInterceptor resourceCoordinatorInterceptor;</div><div class="line"></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.mengyun.tcctransaction.api.Compensable)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionContextCall</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"transactionContextCall()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> resourceCoordinatorInterceptor.interceptTransactionContextMethod(pjp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceCoordinatorInterceptor</span><span class="params">(ResourceCoordinatorInterceptor resourceCoordinatorInterceptor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.resourceCoordinatorInterceptor = resourceCoordinatorInterceptor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过 <code>org.aspectj.lang.annotation.@Pointcut</code> + <code>org.aspectj.lang.annotation.@Around</code> 注解，配置对 <strong>@Compensable 注解的方法</strong>进行拦截，调用 <code>ResourceCoordinatorInterceptor#interceptTransactionContextMethod(...)</code> 方法进行处理。</li></ul><p><strong>ResourceCoordinatorInterceptor 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Transaction transaction = transactionManager.getCurrentTransaction();</div><div class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">switch</span> (transaction.getStatus()) &#123;</div><div class="line">                <span class="keyword">case</span> TRYING:</div><div class="line">                    <span class="comment">// 添加事务参与者</span></div><div class="line">                    enlistParticipant(pjp);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CONFIRMING:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CANCELLING:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 执行方法原逻辑</span></div><div class="line">        <span class="keyword">return</span> pjp.proceed(pjp.getArgs());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当事务处于 TransactionStatus.TRYING 时，调用 <code>#enlistParticipant(...)</code> 方法，添加事务参与者。</li><li>调用 <code>ProceedingJoinPoint#proceed(...)</code> 方法，执行方法原逻辑。</li></ul><p><strong><code>ResourceCoordinatorInterceptor#enlistParticipant()</code> 实现代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">   <span class="comment">// 获得 @Compensable 注解</span></div><div class="line">   Method method = CompensableMethodUtils.getCompensableMethod(pjp);</div><div class="line">   <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"join point not found method, point is : %s"</span>, pjp.getSignature().getName()));</div><div class="line">   &#125;</div><div class="line">   Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line">   <span class="comment">// 获得 确认执行业务方法 和 取消执行业务方法</span></div><div class="line">   String confirmMethodName = compensable.confirmMethod();</div><div class="line">   String cancelMethodName = compensable.cancelMethod();</div><div class="line">   <span class="comment">// 获取 当前线程事务第一个(头部)元素</span></div><div class="line">   Transaction transaction = transactionManager.getCurrentTransaction();</div><div class="line">   <span class="comment">// 创建 事务编号</span></div><div class="line">   TransactionXid xid = <span class="keyword">new</span> TransactionXid(transaction.getXid().getGlobalTransactionId());</div><div class="line">   <span class="comment">// TODO</span></div><div class="line">   <span class="keyword">if</span> (FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs()) == <span class="keyword">null</span>) &#123;</div><div class="line">       FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().set(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.TRYING.getId()), pjp.getTarget(), ((MethodSignature) pjp.getSignature()).getMethod(), pjp.getArgs());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获得类</span></div><div class="line">   Class targetClass = ReflectionUtils.getDeclaringType(pjp.getTarget().getClass(), method.getName(), method.getParameterTypes());</div><div class="line">   <span class="comment">// 创建 确认执行方法调用上下文 和 取消执行方法调用上下文</span></div><div class="line">   InvocationContext confirmInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</div><div class="line">           confirmMethodName,</div><div class="line">           method.getParameterTypes(), pjp.getArgs());</div><div class="line">   InvocationContext cancelInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</div><div class="line">           cancelMethodName,</div><div class="line">           method.getParameterTypes(), pjp.getArgs());</div><div class="line">   <span class="comment">// 创建 事务参与者</span></div><div class="line">   Participant participant =</div><div class="line">           <span class="keyword">new</span> Participant(</div><div class="line">                   xid,</div><div class="line">                   confirmInvocation,</div><div class="line">                   cancelInvocation,</div><div class="line">                   compensable.transactionContextEditor());</div><div class="line">   <span class="comment">// 添加 事务参与者 到 事务</span></div><div class="line">   transactionManager.enlistParticipant(participant);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>CompensableMethodUtils#getCompensableMethod(...)</code> 方法，获得带 @Compensable 注解的方法。</li><li>调用 <code>#getCurrentTransaction()</code> 方法， 获取事务。</li><li><p>调用 TransactionXid 构造方法，创建<strong>分支</strong>事务编号。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 全局事务编号</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] globalTransactionId;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 分支事务编号</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] branchQualifier;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionXid</span><span class="params">(<span class="keyword">byte</span>[] globalTransactionId)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.globalTransactionId = globalTransactionId;</div><div class="line">   branchQualifier = uuidToByteArray(UUID.randomUUID()); <span class="comment">// 生成 分支事务编号</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>分支事务编号( <code>branchQualifier</code> ) 需要生成。</li></ul></li><li><p>TODO TransactionContext 和 Participant 的关系。</p></li><li><p>调用 <code>ReflectionUtils#getDeclaringType(...)</code> 方法，获得声明 @Compensable 方法的实际类。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getDeclaringType</span><span class="params">(Class aClass, String methodName, Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</div><div class="line">   Method method;</div><div class="line">   Class findClass = aClass;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       Class[] clazzes = findClass.getInterfaces();</div><div class="line">       <span class="keyword">for</span> (Class clazz : clazzes) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               method = clazz.getDeclaredMethod(methodName, parameterTypes);</div><div class="line">           &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">               method = <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">return</span> clazz;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       findClass = findClass.getSuperclass();</div><div class="line">   &#125; <span class="keyword">while</span> (!findClass.equals(Object.class));</div><div class="line">   <span class="keyword">return</span> aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 InvocationContext 构造方法，分别创建确认执行方法调用上下文和取消执行方法调用上下文。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 类</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class targetClass;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 方法名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String methodName;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 参数类型数组</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class[] parameterTypes;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 参数数组</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Object[] args;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvocationContext</span><span class="params">(Class targetClass, String methodName, Class[] parameterTypes, Object... args)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.methodName = methodName;</div><div class="line">  <span class="keyword">this</span>.parameterTypes = parameterTypes;</div><div class="line">  <span class="keyword">this</span>.targetClass = targetClass;</div><div class="line">  <span class="keyword">this</span>.args = args;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 Participant 构造方法，创建事务参与者。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4127729421281425247L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法调用上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext confirmInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext cancelInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Terminator terminator = <span class="keyword">new</span> Terminator();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">(TransactionXid xid, InvocationContext confirmInvocationContext, InvocationContext cancelInvocationContext, Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.xid = xid;</div><div class="line">        <span class="keyword">this</span>.confirmInvocationContext = confirmInvocationContext;</div><div class="line">        <span class="keyword">this</span>.cancelInvocationContext = cancelInvocationContext;</div><div class="line">        <span class="keyword">this</span>.transactionContextEditorClass = transactionContextEditorClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>TransactionManager#enlistParticipant(...)</code> 方法，添加事务参与者到事务。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>受限于本人的能力，蛮多处表达不够清晰或者易懂，非常抱歉。如果你对任何地方有任何疑问，欢迎添加本人微信号( wangwenbin-server )，期待与你的交流。不限于 TCC，也可以是分布式事务，也可以是微服务，以及等等。</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/05.png" alt=""></p><p>外送一本武林秘籍：带中文注释的 TCC-Transaction 仓库地址，目前正在慢慢完善。传送门：<a href="https://github.com/YunaiV/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/tcc-transaction</a>。</p><p>再送一本葵花宝典：<a href="https://my.oschina.net/fileoptions/blog/899991" rel="external nofollow noopener noreferrer" target="_blank">《TCC型分布式事务原理和实现》系列</a>。</p><p>胖友，分享一个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文主要基于 TCC-Transaction 1.2.3.3 正式版&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. TCC 原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>TCC-Transaction 源码分析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/TCC-Transaction/build-debugging-environment/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2017-10-04T18:13:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong>  </p><ul><li><a href="#">1. 依赖工具</a></li><li><a href="#">2. 源码拉取</a></li><li><a href="#">3. 初始化数据库</a></li><li><a href="#">4. 启动 capital 项目</a></li><li><a href="#">5. 启动 redpacket 项目</a></li><li><a href="#">6. 启动 order 项目</a></li><li><a href="#">7. 交流</a></li></ul><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Maven</li><li>Git</li><li>JDK</li><li>MySQL</li><li>IntelliJ IDEA</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/changmingxie/tcc-transaction.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/changmingxie/tcc-transaction.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master-1.2.x</code> 分支。</p><h1 id="3-初始化数据库"><a href="#3-初始化数据库" class="headerlink" title="3. 初始化数据库"></a>3. 初始化数据库</h1><p>官方提供了两个 Demo 项目例子：</p><ul><li>tcc-transaction-dubbo-sample</li><li>tcc-transaction-http-sample</li></ul><p>考虑到不是所有所有同学都使用过 Dubbo 服务化框架，我们以 tcc-transaction-http-sample 项为例子。</p><p>打开 tcc-transaction-http-sample/src/main/dbscripts 目录，有四个 SQL 脚本文件：</p><ul><li><code>create_db_cap.sql</code> ：tcc-transaction-http-capital  项目数据库初始化脚本。</li><li><code>create_db_ord.sql</code> ：tcc-transaction-http-order 项目数据库初始化脚本。</li><li><code>create_db_red.sql</code> ：tcc-transaction-http-redpacket 项目数据库初始化脚本。</li><li><code>create_db_tcc.sql</code> ：tcc-transaction <strong>底层</strong>数据库初始化脚本。</li></ul><p>笔者使用 Navicat 进行数据库脚本执行。使用方式为：Navicat 菜单 Connection -&gt; Execute SQL File，选择脚本文件，逐个执行。</p><p>目前数据库脚本未使用 <code>USE</code> 语句选择对应数据库，每个脚本都需要进行添加。以 <code>create_db_cap.sql</code> 举例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`tcc_cap`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span>;</div><div class="line"><span class="comment">-- 新增 USE</span></div><div class="line"><span class="keyword">USE</span> <span class="string">`tcc_cap`</span>;</div></pre></td></tr></table></figure><h1 id="4-启动-capital-项目"><a href="#4-启动-capital-项目" class="headerlink" title="4. 启动 capital 项目"></a>4. 启动 capital 项目</h1><ol><li>修改项目下 <code>jdbc.properties</code> 文件，<strong>填写成你的数据库地址</strong>。</li><li><p>使用 IDEA 配置 Tomcat 进行启动。这里要注意下：</p> <figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">// appcontext-service-provider.xml</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"httpServer"</span></span></div><div class="line"><span class="tag">     <span class="attr">class</span>=<span class="string">"org.springframework.remoting.support.SimpleHttpServerFactoryBean"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"contexts"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalTradeOrderService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalTradeOrderServiceExporter"</span>/&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"/remoting/CapitalAccountService"</span> <span class="attr">value-ref</span>=<span class="string">"capitalAccountServiceExporter"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"8081"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>默认开启 8081 端口提供接口服务。所以配置 Tomcat 的端口不能再使用 8081，避免冲突。例如，笔者使用 18081。</li></ul></li><li><p>访问 <code>http://127.0.0.1:18081/</code>，看到 “hello tcc transacton http sample capital”，代表项目启动完成。<strong><code>18081</code> 为你填写的 Tomcat 端口</strong>。</p></li></ol><h1 id="5-启动-redpacket-项目"><a href="#5-启动-redpacket-项目" class="headerlink" title="5. 启动 redpacket 项目"></a>5. 启动 redpacket 项目</h1><p>同 tcc-transaction-http-capital 项目。</p><h1 id="6-启动-order-项目"><a href="#6-启动-order-项目" class="headerlink" title="6. 启动 order 项目"></a>6. 启动 order 项目</h1><ol><li>修改项目下 <code>jdbc.properties</code> 文件，<strong>填写成你的数据库地址</strong>。</li><li>使用 IDEA 配置 Tomcat 进行启动。</li><li>访问 <code>http://127.0.0.1:8080/</code>，看到 “sample 说明…”，代表项目启动完成。<strong><code>8080</code> 为你填写的 Tomcat 端口</strong>。</li><li>点击 [商品列表链接] -&gt; [购买] -&gt; [支付]，如果看到 “支付成功” 或者 “支付失败”，恭喜你🎉，你已经成功搭建完你的调试环境。愉快的开始玩耍把。</li></ol><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>调试环境搭建是阅读源码的第一步，如果你碰到无法搭建成功的情况，请给笔者公众号( <strong>芋道源码</strong> )留言。笔者会给你 1:1 的高级( <strong>搞基</strong> )支持。</p><p>另外这是一个系列文，本系列更新 TCC-Transaction ，下一个系列更新 ByteTCC 。嗨皮不？！</p><p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_01/01.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;
      
    
    </summary>
    
      <category term="TCC-Transaction" scheme="http://www.iocoder.cn/categories/TCC-Transaction/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 高可用</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-high-availability/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-high-availability/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2017-09-16T04:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. Scheduler 集群</a></li><li><a href="#">3. Scheduler 部署</a></li><li><a href="#">4. Scheduler 故障转移</a></li><li><a href="#">5. Scheduler 数据存储</a><ul><li><a href="#">5.1 RunningService</a></li><li><a href="#">5.2 ProducerManager</a></li><li><a href="#">5.3 TaskScheduler</a></li></ul></li><li><a href="#">6. Mesos Master 崩溃</a></li><li><a href="#">7. Mesos Slave 崩溃</a></li><li><a href="#">8. Scheduler 核对</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 高可用</strong>。</p><p>一个高可用的 Elastic-Job-Cloud 组成如下图：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/01.png" alt=""></p><ul><li>Mesos Master 集群</li><li>Mesos Slave 集群</li><li>Zookeeper 集群</li><li>Elastic-Job-Cloud-Scheduler 集群</li><li>Elastic-Job-Cloud-Executor 集群</li></ul><p><strong>本文重点分享 Elastic-Job-Cloud-Scheduler 如何实现高可用。</strong></p><p>Mesos Master / Mesos Slave / Zookeeper 高可用，同学们可以自行 Google 解决。Elastic-Job-Cloud-Executor 运行在 Mesos Slave 上，通过 Mesos Slave 集群多节点实现高可用。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-Scheduler-集群"><a href="#2-Scheduler-集群" class="headerlink" title="2. Scheduler 集群"></a>2. Scheduler 集群</h1><p>Elastic-Job-Cloud-Scheduler 通过至少两个节点实现集群。<strong>集群中通过主节点选举一个主节点，只有主节点提供服务，从实例处于”待命”状态。当主节点故障时，从节点会选举出新的主节点继续提供服务。</strong>实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 初始化 注册中心</span></div><div class="line">        CoordinatorRegistryCenter regCenter = <span class="keyword">new</span> ZookeeperRegistryCenter(BootstrapEnvironment.getInstance().getZookeeperConfiguration());</div><div class="line">        regCenter.init();</div><div class="line">        <span class="comment">// 初始化 Zookeeper 选举服务</span></div><div class="line">        <span class="keyword">final</span> ZookeeperElectionService electionService = <span class="keyword">new</span> ZookeeperElectionService(</div><div class="line">                BootstrapEnvironment.getInstance().getFrameworkHostPort(), (CuratorFramework) regCenter.getRawClient(), HANode.ELECTION_NODE, <span class="keyword">new</span> SchedulerElectionCandidate(regCenter));</div><div class="line">        electionService.start();</div><div class="line">        <span class="comment">// 挂起 主进程</span></div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        latch.await();</div><div class="line">        <span class="comment">// Hook 貌似位置不对？</span></div><div class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"shutdown-hook"</span>) &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                electionService.stop();</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Bootstrap，Elastic-Job-Cloud-Scheduler 启动器（仿佛在说废话）。</li><li>CoordinatorRegistryCenter，用于协调分布式服务的注册中心，在<a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?">《Elastic-Job-Lite 源码分析 —— 注册中心》</a>有详细解析。</li><li>ZookeeperElectionService，Zookeeper 选举服务，本小节的主角。</li><li>ShutdownHook 关闭进程钩子，代码放置的位置不对，需要放在 <code>CountDownLatch#await()</code> 方法上面。目前实际不影响使用。</li></ul><p>调用 <code>ZookeeperElectionService#start()</code> 方法，初始化 Zookeeper 选举服务以实现 Elastic-Job-Cloud-Scheduler 主节点选举。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch leaderLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperElectionService</span><span class="params">(<span class="keyword">final</span> String identity, <span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> String electionPath, <span class="keyword">final</span> ElectionCandidate electionCandidate)</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 LeaderSelector</span></div><div class="line">   leaderSelector = <span class="keyword">new</span> LeaderSelector(client, electionPath, <span class="keyword">new</span> LeaderSelectorListenerAdapter() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(<span class="keyword">final</span> CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="comment">// ... 省略【暂时】无关代码</span></div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 设置重复参与选举主节点</span></div><div class="line">   leaderSelector.autoRequeue();</div><div class="line">   <span class="comment">// 设置参与节点的编号</span></div><div class="line">   leaderSelector.setId(identity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 开始选举.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elastic job: &#123;&#125; start to elect leadership"</span>, leaderSelector.getId());</div><div class="line">   leaderSelector.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>通过 <a href="https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator LeaderSelector</a> 实现分布式多节点选举。</p><blockquote><p>FROM <a href="https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html" rel="external nofollow noopener noreferrer" target="_blank">https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/leader/LeaderSelector.html</a><br>Abstraction to select a “leader” amongst multiple contenders in a group of JMVs connected to a Zookeeper cluster. If a group of N thread/processes contends for leadership, one will be assigned leader until it releases leadership at which time another one from the group will be chosen.<br>Note that this class uses an underlying InterProcessMutex and as a result leader election is “fair” - each user will become leader in the order originally requested (from ZK’s point of view).</p></blockquote></li><li><p>调用 <code>LeaderSelector#autoRequeue()</code> 方法，设置重复参与选举主节点。默认情况下，自己选举成为主节点后，不再参与下次选举。设置重复参与选举主节点后，每次选举都会参与。在 Elastic-Job-Cloud-Scheduler 里，我们显然要重复参与选举。</p></li><li>调用 <code>LeaderSelector#setId()</code> 方法，设置参与节点的编号。在 Elastic-Job-Cloud-Scheduler 里暂时没有实际用途。编号算法为 <code>BootstrapEnvironment.getInstance().getFrameworkHostPort()</code>，即：<code>HOST:PORT</code>。</li><li>调用 <code>#start()</code> 方法，开始选举。<strong>当自己选举主节点成功</strong>，回调 <code>LeaderSelector#takeLeadership()</code> 方法。</li></ul><p>回调 <code>LeaderSelector#takeLeadership()</code> 方法，Elastic-Job-Cloud-Scheduler <strong>主节点开始领导状态</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperElectionService.LeaderSelector 内部实现类</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(<span class="keyword">final</span> CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    log.info(<span class="string">"Elastic job: &#123;&#125; has leadership"</span>, identity);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 开始领导状态</span></div><div class="line">        electionCandidate.startLeadership();</div><div class="line">        <span class="comment">// 挂起 进程</span></div><div class="line">        leaderLatch.await();</div><div class="line">        log.warn(<span class="string">"Elastic job: &#123;&#125; lost leadership."</span>, identity);</div><div class="line">        <span class="comment">// 终止领导状态</span></div><div class="line">        electionCandidate.stopLeadership();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobSystemException exception) &#123;</div><div class="line">        <span class="comment">// 异常退出</span></div><div class="line">        log.error(<span class="string">"Elastic job: Starting error"</span>, exception);</div><div class="line">        System.exit(<span class="number">1</span>);  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>SchedulerElectionCandidate#startLeadership()</code> 方法，开始领导状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerElectionCandidate.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerElectionCandidate</span> <span class="keyword">implements</span> <span class="title">ElectionCandidate</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> SchedulerService schedulerService;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SchedulerElectionCandidate</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regCenter = regCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeadership</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            schedulerService = <span class="keyword">new</span> SchedulerService(regCenter);</div><div class="line">            schedulerService.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable throwable) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(throwable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 以守护进程方式启动.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   facadeService.start();</div><div class="line">   producerManager.startup();</div><div class="line">   statisticManager.startup();</div><div class="line">   cloudJobConfigurationListener.start();</div><div class="line">   taskLaunchScheduledService.startAsync();</div><div class="line">   restfulService.start();</div><div class="line">   schedulerDriver.start();</div><div class="line">   <span class="keyword">if</span> (env.getFrameworkConfiguration().isEnabledReconcile()) &#123;</div><div class="line">       reconcileService.startAsync();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>调用 <code>SchedulerService#start()</code> 方法后，各种服务初始化完成，特别是和 Mesos Master 的连接，可以愉快的进行作业调度等等服务。</li><li>Elastic-Job-Cloud-Scheduler <strong>从节点</strong>，因为无法回调 <code>LeaderSelector#takeLeadership()</code> 方法，处于”待命”状态。当主节点故障时，从节点会选举出新的主节点，触发 <code>LeaderSelector#takeLeadership()</code> 方法回调，继续提供服务。</li></ul></li><li><p>调用 <code>CountLatch#await()</code> 方法，挂起<strong>主节点</strong> <code>LeaderSelector#takeLeadership()</code> 方法继续向下执行。为什么要进行挂起？如果调用完该方法，<strong>主节点</strong>就会让出<strong>主节点</strong>身份，这样会导致 Elastic-Job-Cloud-Scheduler 集群不断不断不断更新主节点，无法正常提供服务。</p></li><li><p>当 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>关闭时，触发上文代码看到的 ShutdownHook ，关闭服务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Bootstrap.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"shutdown-hook"</span>) &#123;</div><div class="line">        </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// 停止选举</span></div><div class="line">                electionService.stop();</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>ElectionService#stop()</code> 方法，停止选举，从而终止领导状态，关闭各种服务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperElectionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"Elastic job: stop leadership election"</span>);</div><div class="line">    <span class="comment">// 结束 #takeLeadership() 方法的进程挂起</span></div><div class="line">    leaderLatch.countDown();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 关闭 LeaderSelector</span></div><div class="line">        leaderSelector.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ignored) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerElectionCandidate.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopLeadership</span><span class="params">()</span> </span>&#123;</div><div class="line">    schedulerService.stop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 停止运行.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">    restfulService.stop();</div><div class="line">    taskLaunchScheduledService.stopAsync();</div><div class="line">    cloudJobConfigurationListener.stop();</div><div class="line">    statisticManager.shutdown();</div><div class="line">    producerManager.shutdown();</div><div class="line">    schedulerDriver.stop(<span class="keyword">true</span>);</div><div class="line">    facadeService.stop();</div><div class="line">    <span class="keyword">if</span> (env.getFrameworkConfiguration().isEnabledReconcile()) &#123;</div><div class="line">        reconcileService.stopAsync();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>当发生 JobSystemException 异常时，即调用 <code>SchedulerElectionCandidate#startLeadership()</code> 方法发生异常( <code>SchedulerElectionCandidate#stopLeadership()</code> 实际不会抛出异常 )，调用 <code>System.exit(1)</code> 方法，Elastic-Job-Cloud-Scheduler 主节点<strong>异常崩溃</strong>。</p><ul><li>目前猜测<strong>可能</strong>有种情况会导致异常崩溃。（1）一个 Elastic-Job-Cloud-Scheduler 集群有两个节点 A / B，通过选举 A 成为主节点；（2）突然 Zookeeper 集群崩溃，恢复后，A 节点选举<strong>恰好</strong>又成为主节点，因为未调用 <code>SchedulerElectionCandidate#stopLeadership()</code> 关闭原来的各种服务，导致<strong>再次</strong>调用 <code>SchedulerElectionCandidate#startLeadership()</code> 会发生异常，例如说 RestfulService 服务，需要占用一个端口提供服务，重新初始化，会发生端口冲突抛出异常。笔者尝试模拟，通过一个 Elastic-Job-Cloud-Scheduler + Zookeeper 的情况，能够触发该情况，步骤如下：（1）Zookeeper 启动；（2）Elastic-Job-Cloud-Scheduler 启动，选举成为主节点，正常初始化；（3）重启 Zookeeper；（4）Elastic-Job-Cloud-Scheduler 再次选举成为主节点，因为 RestfulService 端口冲突异常初始化崩溃。<strong>如果真出现这种情况怎么办呢？</strong>在「3. Scheduler 部署」揭晓答案。</li></ul></li></ul><p>Elastic-Job-Lite 在主节点选举实现方式上略有不同，有兴趣的同学可以看下<a href="http://www.iocoder.cn/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》</a>的实现。</p><h1 id="3-Scheduler-部署"><a href="#3-Scheduler-部署" class="headerlink" title="3. Scheduler 部署"></a>3. Scheduler 部署</h1><p>比较容易想到的一种方式，选择多台主机部署 Elastic-Job-Cloud-Executor 多个节点。</p><p>But…… 我们要想下，Elastic-Job-Cloud-Executor 运行在 Mesos 之上，可以使用上 Mesos 的资源调度和部署服务。引入 Mesos 上著名的框架 <a href="https://mesosphere.github.io/marathon/" rel="external nofollow noopener noreferrer" target="_blank">Marathon</a>。它可以带来<strong>所有后台进程( 例如，Elastic-Job-Cloud-Executor )能够运行在任意机器上，Marathon 会在后台已有实例失败时，自动启动新实例</strong>的好处。是不是很赞 +1024 ？！</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P47<br>Mesos 集群里的常见方案是在 Marathon 上运行集群的 Mesos 框架。但是 Marathon 本身就是一种 Mesos 的框架！那么在 Marathon 上运行 Mesos 框架意味着什么呢？不用考虑如何将每种框架的调度器部署到特定的主机上并且处理这些主机的故障，Marathon 能够确保框架的调度器总是在集群里的某处运行着。这样大幅简化了在高可用配置里部署新框架的复杂度。</p></blockquote><p>嗯…… 当然，Marathon 我们也要做高可用。</p><p>😈 Marathon 原来中文是马拉松。哈哈哈，很适合的名字。</p><h1 id="4-Scheduler-故障转移"><a href="#4-Scheduler-故障转移" class="headerlink" title="4. Scheduler 故障转移"></a>4. Scheduler 故障转移</h1><p>当原有 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>崩溃时，<strong>从节点</strong>重新进行主节点选举，完成故障转移。那么此时会有一个问题，新<strong>主节点</strong>如何接管已经在执行中的 Elastic-Job-Cloud-Executer 们呢？</p><p>第一种方案，关闭原有的所有 Elastic-Job-Cloud-Executor 们，然后重新调度启动。显然，这个方式太过暴力。如果有些作业任务运行时间较长，直接中断不是很友好。再比如，Elastic-Job-Cloud-Scheduler 节点需要进行升级，也关闭 Elastic-Job-Cloud-Executor，也不合理，和使用高可用性集群操作系统的初衷是背离的。<strong>该方案，不推荐</strong>。</p><p>第二种方案，重用<strong>原主节点</strong>的 Mesos <strong>FrameworkID</strong>。原理如下：</p><blockquote><p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P72<br>在 Mesos 里，调度器由其 FrameworkID、FrameworkInfo 里的可选值唯一确定。FrameworkID 必须由 Mesos 分配，从而确保对于每个框架来说该值是唯一确定的。现在，需要在分配 FrameworkID 时存储该值，这样未来的主实例才可以重用该值。   </p></blockquote><p>在 Elastic-Job-Cloud-Scheduler 使用注册中心( Zookeeper ) 的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/ha/framework_id</code> 存储 FrameworkID，存储值为 <code>${FRAMEWORK_ID}</code>。使用 zkClient 查看如下：</p><blockquote><p>[zk: localhost:2181(CONNECTED) 1] get /elastic-job-cloud/ha/framework_id<br>d31e7faa-aa72-4d0a-8941-512984d5af49-0001</p></blockquote><p>调用 <code>SchedulerService#getSchedulerDriver()</code> 方法，初始化 Mesos Scheduler Driver 时，从 Zookeeper 获取是否已经存在 FrameworkID。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 FrameworkID</span></div><div class="line">   Optional&lt;String&gt; frameworkIDOptional = frameworkIDService.fetch();</div><div class="line">   Protos.FrameworkInfo.Builder builder = Protos.FrameworkInfo.newBuilder();</div><div class="line">   <span class="comment">// 如果存在，设置 FrameworkID</span></div><div class="line">   <span class="keyword">if</span> (frameworkIDOptional.isPresent()) &#123;</div><div class="line">       builder.setId(Protos.FrameworkID.newBuilder().setValue(frameworkIDOptional.get()).build());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   Protos.FrameworkInfo frameworkInfo = builder.setUser(mesosConfig.getUser()).setName(frameworkName)</div><div class="line">                .setHostname(mesosConfig.getHostname())</div><div class="line">                .setFailoverTimeout(FRAMEWORK_FAILOVER_TIMEOUT_SECONDS)</div><div class="line">                .setWebuiUrl(WEB_UI_PROTOCOL + env.getFrameworkHostPort()).setCheckpoint(<span class="keyword">true</span>).build();</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>FrameworkIDService#fetch()</code> 方法，从注册中心获取 FrameworkID 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">fetch</span><span class="params">()</span> </span>&#123;</div><div class="line">   String frameworkId = regCenter.getDirectly(HANode.FRAMEWORK_ID_NODE);</div><div class="line">   <span class="keyword">return</span> Strings.isNullOrEmpty(frameworkId) ? Optional.&lt;String&gt;absent() : Optional.of(frameworkId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>Protos.FrameworkInfo.Builder#setId(...)</code> 方法，当 FrameworkID 存在时，设置 FrameworkID。</p></li><li>调用 <code>Protos.FrameworkInfo.Builder#setFailoverTimeout(...)</code> 方法，设置 Scheduler 最大故障转移时间，即 FrameworkID 过期时间。Elastic-Job-Cloud-Scheduler 默认设置一周。</li></ul><p>当 Elastic-Job-Cloud-Scheduler 集群第一次初始化，上面的逻辑显然获取不到 FrameworkID，在向 Mesos Master 初始化成功后，回调 <code>SchedulerEngine#registered(...)</code> 方法进行保存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerEngine.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.FrameworkID frameworkID, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"call registered"</span>);</div><div class="line">        <span class="comment">// 保存FrameworkID</span></div><div class="line">        frameworkIDService.save(frameworkID.getValue());</div><div class="line">        <span class="comment">// 过期 TaskScheduler Lease</span></div><div class="line">        taskScheduler.expireAllLeases();</div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FrameworkIDService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(HANode.FRAMEWORK_ID_NODE)) &#123; <span class="comment">// 不存在才保存</span></div><div class="line">       regCenter.persist(HANode.FRAMEWORK_ID_NODE, id);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="5-Scheduler-数据存储"><a href="#5-Scheduler-数据存储" class="headerlink" title="5. Scheduler 数据存储"></a>5. Scheduler 数据存储</h1><p>新的 Elastic-Job-Cloud-Scheduler <strong>主节点</strong>在故障转移，不仅仅接管 Elastic-Job-Cloud-Executor，<strong>还需要接管数据存储</strong>。</p><p>Elastic-Job-Cloud-Executor 使用注册中心( Zookeeper )存储数据。数据存储分成两部分：</p><ul><li>config，云作业应用配置、云作业配置。</li><li>state，作业状态信息。</li></ul><p>整体如下图：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/02.png" alt=""></p><p>Elastic-Job-Cloud-Scheduler <strong>各个服务</strong>根据数据存储启动初始化。下面来看看依赖数据存储进行初始化的服务代码实现。</p><h2 id="5-1-RunningService"><a href="#5-1-RunningService" class="headerlink" title="5.1 RunningService"></a>5.1 RunningService</h2><p>RunningService，任务运行时服务。调用 <code>RunningService#start()</code> 方法，启动任务运行队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 运行中作业映射</span></div><div class="line"><span class="comment">     * key：作业名称</span></div><div class="line"><span class="comment">     * value：任务运行时上下文集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Set&lt;TaskContext&gt;&gt; RUNNING_TASKS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(TASK_INITIAL_SIZE);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        clear();</div><div class="line">        List&lt;String&gt; jobKeys = regCenter.getChildrenKeys(RunningNode.ROOT);</div><div class="line">        <span class="keyword">for</span> (String each : jobKeys) &#123;</div><div class="line">            <span class="comment">// 从运行中队列移除不存在配置的作业任务</span></div><div class="line">            <span class="keyword">if</span> (!configurationService.load(each).isPresent()) &#123;</div><div class="line">                remove(each);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 添加 运行中作业映射</span></div><div class="line">            RUNNING_TASKS.put(each, Sets.newCopyOnWriteArraySet(Lists.transform(regCenter.getChildrenKeys(RunningNode.getRunningJobNodePath(each)), <span class="keyword">new</span> Function&lt;String, TaskContext&gt;() &#123;</div><div class="line">                </div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> TaskContext <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> TaskContext.from(regCenter.get(RunningNode.getRunningTaskNodePath(TaskContext.MetaInfo.from(input).toString())));</div><div class="line">                &#125;</div><div class="line">            &#125;)));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>因为运行中作业映射( <code>RUNNING_TASKS</code> )使用的频次很多，Elastic-Job-Cloud-Scheduler 缓存在内存中。每次初始化时，使用从数据存储<strong>运行中作业队列</strong>加载到内存。</li><li><p>这里我们在看下<strong>运行中作业队列</strong>的添加( <code>#add()</code> )方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!configurationService.load(taskContext.getMetaInfo().getJobName()).isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).add(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemon(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中队列</span></div><div class="line">   String runningTaskNodePath = RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(runningTaskNodePath)) &#123;</div><div class="line">       regCenter.persist(runningTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>运行中作业队列只存储常驻作业的任务</strong>。所以<strong>瞬时</strong>作业，在故障转移时，可能存在相同作业相同分片任务<strong>同时</strong>调度执行。举个栗子🌰，Elastic-Job-Cloud-Scheduler 集群有两个节点 A( 主节点 ) / B( 从节点 )，（1）A 节点每 5 分钟调度一次瞬时作业任务 T ，T 每次执行消耗时间实际超过 5 分钟( 先不要考虑是否合理 )。（2）A 节点崩溃，B 节点成为主节点，5 分钟后调度 T 作业，因为<strong>运行中作业队列只存储常驻作业的任务</strong>，恢复后的 <code>RUNNING_TASKS</code> 不存在该作业任务，因此可以调度 T 作业，实际 T 作业正在 Elastic-Job-Cloud-Executor 执行中。</li></ul></li></ul><h2 id="5-2-ProducerManager"><a href="#5-2-ProducerManager" class="headerlink" title="5.2 ProducerManager"></a>5.2 ProducerManager</h2><p>ProducerManager，发布任务作业调度管理器。调用 <code>ProducerManager#startup()</code> 方法，启动作业调度器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"Start producer manager"</span>);</div><div class="line">        <span class="comment">// 发布瞬时作业任务的调度器</span></div><div class="line">        transientProducerScheduler.start();</div><div class="line">        <span class="comment">// 初始化调度作业</span></div><div class="line">        <span class="keyword">for</span> (CloudJobConfiguration each : configService.loadAll()) &#123;</div><div class="line">            schedule(each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ConfigService#loadAll()</code> 方法，从<strong>数据存储</strong>读取所有作业配置。</li><li>调用 <code>#schedule()</code> 方法，初始化调度作业。<ul><li><strong>瞬时</strong>作业，在 Elastic-Job-Cloud-Scheduler 计时调度，类似每 XX 秒 / 分 / 时 / 天之类的作业需要重新计时，这个请注意。</li><li><strong>常驻</strong>作业，在 Elastic-Job-Cloud-Executor 计时调度，暂无影响。</li><li>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「3. Producer 发布任务」</a>有详细解析。</li></ul></li></ul><h2 id="5-3-TaskScheduler"><a href="#5-3-TaskScheduler" class="headerlink" title="5.3 TaskScheduler"></a>5.3 TaskScheduler</h2><p>TaskScheduler，Fenzo 作业调度器，根据 Mesos Offer 和作业任务的优化分配。因为其分配是依赖当前实际 Mesos Offer 和 作业任务运行的情况，猜测<strong>可能</strong>对优化分配有影响，但不影响正确性。笔者对 TaskScheduler 了解不是很深入，仅仅作为猜测。</p><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.1」「4.2」「4.3」</a>有和 TaskScheduler 相关的内容解析。</p><h1 id="6-Mesos-Master-崩溃"><a href="#6-Mesos-Master-崩溃" class="headerlink" title="6. Mesos Master 崩溃"></a>6. Mesos Master 崩溃</h1><p>Mesos Master 集群，Mesos Master 主节点崩溃后，Mesos Master 集群重新选举后，Scheduler、Mesos Slave <strong>从 Zookeeper 获取到最新的 Mesos Master 主节点重新进行注册</strong>，不影响 Scheduler 、Mesos Slave 、任务执行。</p><p>调用 <code>SchedulerService#getSchedulerDriver(...)</code> 方法，设置 SchedulerDriver 从 Mesos Zookeeper Address 读取当前 Mesos Master 地址，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    MesosConfiguration mesosConfig = env.getMesosConfiguration();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MesosSchedulerDriver(<span class="keyword">new</span> SchedulerEngine(taskScheduler, facadeService, jobEventBus, frameworkIDService, statisticManager), frameworkInfo, mesosConfig.getUrl() <span class="comment">// Mesos Master URL</span></div><div class="line">    );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MesosSchedulerDriver.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MesosSchedulerDriver</span><span class="params">(Scheduler scheduler,</span></span></div><div class="line"><span class="function"><span class="params">                            FrameworkInfo framework,</span></span></div><div class="line"><span class="function"><span class="params">                            String master)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MesosSchedulerDriver 构造方法第三个参数 <code>master</code>，代表 Mesos 使用的 Zookeeper 地址，例如：<code>zk://127.0.0.1:2181/mesos</code>。生产环境请配置多 Zookeeper 节点，例如：<code>zk://host1:port1,host2:port2,.../path</code>。</li><li><p>使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 10] ls /mesos</div><div class="line">[log_replicas, json.info_0000000017]</div><div class="line">[zk: localhost:2181(CONNECTED) 11] get /mesos/json.info_0000000017</div><div class="line">&#123;"address":&#123;"hostname":"localhost","ip":"127.0.0.1","port":5050&#125;,"hostname":"localhost","id":"685fe32d-e30c-4df7-b891-3d96b06fee88","ip":16777343,"pid":"master@127.0.0.1:5050","port":5050,"version":"1.4.0"&#125;</div></pre></td></tr></table></figure></li></ul><p>Elastic-Job-Cloud-Scheduler 注册上、重新注册上、断开 Mesos Master 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.FrameworkID frameworkID, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"call registered"</span>);</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reregistered</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.MasterInfo masterInfo)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略无关代码</span></div><div class="line">        <span class="comment">// 注册 Mesos Master 信息</span></div><div class="line">        MesosStateService.register(masterInfo.getHostname(), masterInfo.getPort());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver)</span> </span>&#123;</div><div class="line">        log.warn(<span class="string">"call disconnected"</span>);</div><div class="line">        MesosStateService.deregister();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MesosStateService，Mesos状态服务，提供调用 Mesos Master API 服务，例如获取所有执行器。</li><li><p>调用 <code>MesosStateService#register(...)</code> 方法，注册 Mesos Master 信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MesosStateService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String stateUrl;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> String hostName, <span class="keyword">final</span> <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">        stateUrl = String.format(<span class="string">"http://%s:%d/state"</span>, hostName, port);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>MesosStateService#deregister(...)</code> 方法，注销 Mesos Master 信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deregister</span><span class="params">()</span> </span>&#123;</div><div class="line">    stateUrl = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P110 如何处理 master 的故障</a>，有兴趣的同学也可以<strong>仔细</strong>看看。</p><h1 id="7-Mesos-Slave-崩溃"><a href="#7-Mesos-Slave-崩溃" class="headerlink" title="7. Mesos Slave 崩溃"></a>7. Mesos Slave 崩溃</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>中，搜索关键字 <strong>“TASK_LOST”</strong>，有 Mesos Slave 崩溃后，对 Elastic-Job-Cloud-Scheduler 和 Elastic-Job-Cloud-Executor 的影响。</p><p><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P109 如何处理 slave 的故障</a>，有兴趣的同学也可以<strong>仔细</strong>看看。</p><h1 id="8-Scheduler-核对"><a href="#8-Scheduler-核对" class="headerlink" title="8. Scheduler 核对"></a>8. Scheduler 核对</h1><blockquote><p>FROM <a href="http://mesos.apache.org/documentation/latest/reconciliation/" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/documentation/latest/reconciliation/</a><br>Messages between framework schedulers and the Mesos master may be dropped due to failures and network partitions. This may cause a framework scheduler and the master to have <strong>different views of the current state of the cluster</strong>. For example, consider a launch task request sent by a framework. There are many ways that failures can prevent the task launch operation from succeeding, such as:</p><ul><li>Framework fails after persisting its intent to launch the task, but before the launch task message was sent.  </li><li>Master fails before receiving the message.  </li><li>Master fails after receiving the message but before sending it to the agent.  </li></ul></blockquote><p>通过<strong>核对</strong>特性解决这个问题。核对是协调器如何和 Mesos Master 一起检查调度器所认为的集群状态是否和 Mesos Master 所认为的集群状态完成匹配。</p><p>调用 <code>SchedulerDriver#reconcileTasks(...)</code> 方法，查询任务状态。代码接口如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SchedulerDriver</span> </span>&#123;</div><div class="line">    <span class="function">Status <span class="title">reconcileTasks</span><span class="params">(Collection&lt;TaskStatus&gt; statuses)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>只能</strong>查询<strong>非终止状态( non-terminal )</strong>的任务。核对的主要原因，确认任务是否还在运行，或者已经进入了中断状态。<ul><li>terminal：TASK_ERROR、TASK_FAILED、TASK_FINISHED、TASK_KILLED</li><li>non-terminal：TASK_DROPPED、TASK_GONE、TASK_GONE_BY_OPERATOR、TASK_KILLING、TASK_LOST、TASK_RUNNING、TASK_STAGING、TASK_STARTING、TASK_UNREACHABLE、TASK_UNKNOWN</li></ul></li><li>当 <code>statuses</code> 非空时，<strong>显示</strong>查询，通过回调 <code>Scheduler#statusUpdate(...)</code> 方法异步返回<strong>指定</strong>的任务的状态。</li><li>当 <code>statuses</code> 为空时，<strong>隐式</strong>查询，通过回调 <code>Scheduler#statusUpdate(...)</code> 方法异步返回<strong>全部</strong>的任务的状态。</li></ul><p>ReconcileService，核对 Mesos 与 Scheduler 之间的任务状态。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReconcileService</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            explicitReconcile();</div><div class="line">            implicitReconcile();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">        FrameworkConfiguration configuration = BootstrapEnvironment.getInstance().getFrameworkConfiguration();</div><div class="line">        <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(configuration.getReconcileIntervalMinutes(), configuration.getReconcileIntervalMinutes(), TimeUnit.MINUTES);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过配置 <code>FrameworkConfiguration#reconcileIntervalMinutes</code> 设置，每隔多少分钟执行一次核对。若配置时间大于 0 才开启任务状态核对功能。</li><li><p>调用 <code>#explicitReconcile()</code> 方法，查询运行中的任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">explicitReconcile</span><span class="params">()</span> </span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 获取运行中的作业任务上下文集合</span></div><div class="line">       Set&lt;TaskContext&gt; runningTask = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">       <span class="keyword">for</span> (Set&lt;TaskContext&gt; each : facadeService.getAllRunningTasks().values()) &#123;</div><div class="line">           runningTask.addAll(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (runningTask.isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       log.info(<span class="string">"Requesting &#123;&#125; tasks reconciliation with the Mesos master"</span>, runningTask.size());</div><div class="line">       <span class="comment">// 查询指定任务</span></div><div class="line">       schedulerDriver.reconcileTasks(Collections2.transform(runningTask, <span class="keyword">new</span> Function&lt;TaskContext, Protos.TaskStatus&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> Protos.<span class="function">TaskStatus <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TaskContext input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> Protos.TaskStatus.newBuilder()</div><div class="line">                       .setTaskId(Protos.TaskID.newBuilder().setValue(input.getId()).build())</div><div class="line">                       .setSlaveId(Protos.SlaveID.newBuilder().setValue(input.getSlaveId()).build())</div><div class="line">                       .setState(Protos.TaskState.TASK_RUNNING)</div><div class="line">                       .build();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#implicitReconcile()</code> 方法，查询所有任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">implicitReconcile</span><span class="params">()</span> </span>&#123;</div><div class="line">   lock.lock();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 查询全部任务</span></div><div class="line">       schedulerDriver.reconcileTasks(Collections.&lt;Protos.TaskStatus&gt;emptyList());</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       lock.unlock();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>为什么这里要使用 ReentrantLock 锁呢？Elastic-Job-Cloud-Scheduler 提供 CloudOperationRestfulApi，支持使用 HTTP Restful API 主动触发 <code>#explicitReconcile()</code> 和 <code>#implicitReconcile()</code> 方法，<strong>通过锁避免并发核对</strong>。对 CloudOperationRestfulApi 有兴趣的同学，直接点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/a52d4062bf1f1d729fa4dbf2d1225e0d97778cb9/elastic-job-cloud/elastic-job-cloud-scheduler/src/main/java/com/dangdang/ddframe/job/cloud/scheduler/restful/CloudOperationRestfulApi.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现。</p></li><li>虽然 <code>#implicitReconcile()</code> 方法，能查询到所有 Mesos 任务状的态，但是性能较差，而 <code>#explicitReconcile()</code> 方法显式查询运行中的 Mesos 任务的状态，性能更好，所以先进行调用。</li><li><p>优化点（目前暂未实现）：Elastic-Job-Cloud-Scheduler 注册到 Mesos 和 重注册到 Mesos，都执行一次核对。</p><blockquote><p>FROM <a href="http://www.iocoder.cn/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码分析 —— 自诊断修复》</a><br>This reconciliation algorithm must be run after each (re-)registration.</p></blockquote></li></ul><p>其他 Scheduler 核对资料，有兴趣的同学可以看看：</p><ul><li><a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》P76 添加核对 、P111 故障转移期间的核对</a></li><li><a href="http://mesos.apache.org/documentation/latest/reconciliation/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— reconciliation》</a></li></ul><p>Elastic-Job-Lite 也会存在作业节点 和 Zookeeper 数据不一致的情况，有兴趣的同学可以看下<a href="http://www.iocoder.cn/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码分析 —— 自诊断修复》</a>的实现。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>给英文和我一样半斤八两的同学一本葵花宝典+辟邪剑谱：</p><ul><li><a href="https://mesos-cn.gitbooks.io/mesos-cn/content/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos中文手册》</a>。</li><li><a href="http://www.jianshu.com/p/726e28ea488a" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 容错、故障》</a></li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/03.png" alt=""></p><p>整个 Elastic-Job-Cloud 完结，撒花！</p><p>收获蛮多的，学习的第一套基于云原生( CloudNative )实现的中间件，期待有基于云原生的服务化中间件。</p><p>一开始因为 Elastic-Job-Cloud 基于 Mesos 实现，内心还是有点恐惧感，后面硬啃 + 搭配<a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a>，比预想的时间快了一半完成这个系列。在这里强烈推荐这本书。另外，等时间相对空，会研究下另外一个沪江开源的基于 Mesos 实现的分布式调度系统 <a href="https://github.com/HujiangTechnology/Juice" rel="external nofollow noopener noreferrer" target="_blank">Juice</a>。不是很确定会不会出源码解析的文章，尽量输出噶。</p><p>后面会继续更新源码解析系列，下一个系列应该是<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 源码解析》</a>。在选择要研究的 tcc 中间件还是蛮纠结的，哈哈，这里听从 <a href="http://www.54tianzhisheng.cn/" rel="external nofollow noopener noreferrer" target="_blank">zhisheng</a> 的建议。如果不好，我保证会打死你的。</p><p>希望坚持不懈的分享源码解析会有更多的同行者阅读。确实，源码解析的受众略小。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_15/04.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. Scheduler 集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 作业失效转移</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-job-failover/</id>
    <published>2018-01-09T16:00:00.000Z</published>
    <updated>2017-09-16T04:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 记录作业失效转移</a></li><li><a href="#">3. 提交失效转移作业</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 作业失效转移</strong>。对应到 Elastic-Job-Lite 源码解析文章为<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 作业作业失效转移》</a>。</p><p>你需要对<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》</a>有一定的了解。</p><p>当作业任务在 Elastic-Job-Cloud-Executor 异常崩溃时，该任务在下次调度之前不会被重新执行。开启失效转移功能后，该作业任务会立即被 Elastic-Job-Cloud-Scheduler 重新调度，提交 Elastic-Job-Cloud-Executor <strong>立即</strong>执行。</p><p>在 Elastic-Job-Cloud 里，我们了解到作业分成<strong>瞬时</strong>作业和<strong>常驻</strong>作业。实际上面失效转移的定义暂时只适用于<strong>瞬时</strong>作业。对于<strong>常驻</strong>作业，作业任务异常崩溃后，无论你是否开启失效转移功能，Elastic-Job-Cloud-Scheduler 会立刻提交 Elastic-Job-Cloud-Executor <strong>重新调度</strong>执行。</p><p><strong>为什么此处使用的是“重新调度”，而不是“立即执行”呢</strong>？目前版本 Elasitc-Job-Cloud 暂时不支持<strong>常驻</strong>作业的失效转移，当作业任务异常崩溃，本次执行<strong>不会重新执行</strong>，但是为了作业任务后续能够调度执行，所以再次提交 Elastic-Job-Cloud-Scheduler。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>OK，下面我们来看看作业失效转移的实现方式和作业任务异常崩溃的多重场景。</p><h1 id="2-记录作业失效转移"><a href="#2-记录作业失效转移" class="headerlink" title="2. 记录作业失效转移"></a>2. 记录作业失效转移</h1><p>当作业任务异常崩溃时，Elastic-Job-Cloud-Scheduler 通过 Mesos 任务状态变更接口( <code>#statusUpdate()</code> )实现对任务状态的监听处理，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">        String taskId = taskStatus.getTaskId().getValue();</div><div class="line">        TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">        String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">        log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">        jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER, </div><div class="line">                taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">        <span class="keyword">switch</span> (taskStatus.getState()) &#123;</div><div class="line">            <span class="keyword">case</span> TASK_RUNNING:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_FINISHED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_KILLED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_LOST:</div><div class="line">            <span class="keyword">case</span> TASK_DROPPED:</div><div class="line">            <span class="keyword">case</span> TASK_GONE:</div><div class="line">            <span class="keyword">case</span> TASK_GONE_BY_OPERATOR:</div><div class="line">            <span class="keyword">case</span> TASK_FAILED: <span class="comment">// 执行作业任务被错误终止</span></div><div class="line">            <span class="keyword">case</span> TASK_ERROR: <span class="comment">// 任务错误</span></div><div class="line">                log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                <span class="comment">// 将任务从运行时队列删除</span></div><div class="line">                facadeService.removeRunning(taskContext);</div><div class="line">                <span class="comment">// 记录失效转移队列</span></div><div class="line">                facadeService.recordFailoverTask(taskContext);</div><div class="line">                <span class="comment">// 通知 TaskScheduler 任务不分配在对应主机上</span></div><div class="line">                unAssignTask(taskId);</div><div class="line">                <span class="comment">// 统计</span></div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_UNKNOWN:</div><div class="line">            <span class="keyword">case</span> TASK_UNREACHABLE:</div><div class="line">                log.error(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一共有 6 种状态判定为作业任务崩溃，我们来一个一个看看：</p><ul><li><p>TASK_DROPPED / TASK_GONE / TASK_GONE_BY_OPERATOR</p><p>  这三个状态，笔者暂时不太了解，这里先引用一些资料，欢迎有了解的同学指教一下。    </p><blockquote><p>FROM <a href="http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskState.html" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskState.html</a><br><strong>TASK_DROPPED</strong>：The task failed to launch because of a transient error.<br><strong>TASK_GONE</strong>：The task is no longer running.<br><strong>TASK_GONE_BY_OPERATOR</strong>：The task was running on an agent that the master cannot contact; the operator has asserted that the agent has been shutdown, but this has not been directly confirmed by the master.  </p><p>FROM <a href="http://mesos.apache.org/blog/mesos-1-1-0-released/" rel="external nofollow noopener noreferrer" target="_blank">http://mesos.apache.org/blog/mesos-1-1-0-released/</a><br>[MESOS-5344] - Experimental support for partition-aware Mesos frameworks. In previous Mesos releases, when an agent is partitioned from the master and then reregisters with the cluster, all tasks running on the agent are terminated and the agent is shutdown. In Mesos 1.1, partitioned agents will no longer be shutdown when they reregister with the master. By default, tasks running on such agents will still be killed (for backward compatibility); however, frameworks can opt-in to the new PARTITION_AWARE capability. If they do this, their tasks will not be killed when a partition is healed. This allows frameworks to define their own policies for how to handle partitioned tasks. Enabling the PARTITION_AWARE capability also introduces a new set of task states: TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN. <strong>These new states are intended to eventually replace the TASK_LOST state</strong>.</p></blockquote></li><li><p>TASK_FAILED</p><p>  执行作业任务被<strong>错误</strong>终止。例如，执行器( Elastic-Job-Cloud-Executor )异常崩溃，或者被杀死。</p></li><li><p>TASK_ERROR</p><p>  任务启动尝试失败错误。例如，执行器( Elastic-Job-Cloud-Executor ) 接收到的任务的作业配置不正确。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新 Mesos 任务状态，运行中。</span></div><div class="line">    executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build());</div><div class="line">    <span class="comment">//</span></div><div class="line">    Map&lt;String, Object&gt; data = SerializationUtils.deserialize(taskInfo.getData().toByteArray());</div><div class="line">    ShardingContexts shardingContexts = (ShardingContexts) data.get(<span class="string">"shardingContext"</span>);</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    JobConfigurationContext jobConfig = <span class="keyword">new</span> JobConfigurationContext((Map&lt;String, String&gt;) data.get(<span class="string">"jobConfigContext"</span>));</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获得 分布式作业</span></div><div class="line">        ElasticJob elasticJob = getElasticJobInstance(jobConfig);</div><div class="line">        <span class="comment">// 调度器提供内部服务的门面对象</span></div><div class="line">        <span class="keyword">final</span> CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(shardingContexts, jobConfig, jobEventBus);</div><div class="line">        <span class="comment">// 执行作业</span></div><div class="line">        <span class="keyword">if</span> (jobConfig.isTransient()) &#123;</div><div class="line">            <span class="comment">// 执行作业</span></div><div class="line">            JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">            <span class="comment">// 更新 Mesos 任务状态，已完成。</span></div><div class="line">            executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 初始化 常驻作业调度器</span></div><div class="line">            <span class="keyword">new</span> DaemonTaskScheduler(elasticJob, jobConfig, jobFacade, executorDriver, taskInfo.getTaskId()).init();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</div><div class="line">        <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">        log.error(<span class="string">"Elastic-Job-Cloud-Executor error"</span>, ex);</div><div class="line">        <span class="comment">// 更新 Mesos 任务状态，错误。</span></div><div class="line">        executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_ERROR).setMessage(ExceptionUtil.transform(ex)).build());</div><div class="line">        <span class="comment">// 停止自己</span></div><div class="line">        executorDriver.stop();</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#getElasticJobInstance()</code> 方法，因为任务的作业配置不正确抛出<strong>异常</strong>。例如，任务类不存在；Spring 的 配置文件不存在；Spring 容器初始化出错；Spring Bean 对象初始化或获取出错；以及等等。</li><li><p><strong>瞬时</strong>作业，调用 <code>AbstractElasticJobExecutor#execute(...)</code> 方法，发生<strong>异常</strong>，并且<strong>异常被抛出</strong>。默认情况下，AbstractElasticJobExecutor 内部使用 DefaultJobExceptionHandler 处理发生的异常，<strong>不会抛出异常</strong>，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li></li></ul></li><li><p><strong>常驻</strong>作业，调用 <code>DaemonTaskScheduler#(...)</code> 方法，初始化发生<strong>异常</strong>。</p></li><li>因为上述的种种异常，调用 <code>ExecutorDriver#sendStatusUpdate(...)</code>，更新 Mesos 任务状态为 TASK_ERROR。另外，调用 <code>ExecutorDriver#stop()</code> 方法，关闭自己。<strong>这意味着，一个执行器上如果存在一个作业任务发生 TASK_ERROR，其他作业任务即使是正常的，也会更新作业任务状态为 TASK_FAILED</strong>。这块千万要注意。</li></ul></li><li><p>TASK_LOST</p><p>  执行作业任务的 Elastic-Job-Cloud-Executor 所在的 Mesos Slave 与 Mesos Master 因为<strong>网络问题或 Mesos Slave 崩溃</strong>引起丢失连接，<strong>可能</strong>导致其上的所有作业任务状态变为 TASK_LOST。</p><p>  <strong>当 Slave 宕机后重启，导致 TASK_LOST 时，Mesos又是怎么来处理的呢？</strong></p><blockquote><p>FROM <a href="http://dockone.io/article/2513" rel="external nofollow noopener noreferrer" target="_blank">http://dockone.io/article/2513</a><br>在 Master 和 Slave 之间，一般都是由 Master 主动向每一个 Slave 发送Ping消息，如果在设定时间内（flag.slave_ping_timeout，默认15s）没有收到Slave 的回复，并且达到一定次数（flag.max_slave_ping_timeouts，默认次数为5），那么 Master 会操作以下几个步骤：  </p><ol><li>将该 Slave 从 Master 中删除，此时该 Slave 的资源将不会再分配给Scheduler。  </li><li>遍历该 Slave 上运行的所有任务，向对应的 Framework 发送任务的 Task_Lost 状态更新，同时把这些任务从Master中删除。  </li><li>遍历该 Slave 上的所有 Executor，并删除。  </li><li>触发 Rescind Offer，把这个 Slave 上已经分配给 Scheduler 的 Offer 撤销。  </li><li>把这个 Slave 从 Master 的 Replicated log 中删除（Mesos Master 依赖 Replicated log 中的部分持久化集群配置信息进行 failer over / recovery）。 </li></ol></blockquote><ul><li><p>必须 Slave 进行重启，因为对执行器的相关操作只能通过 Mesos Slave，即 <strong>Scheduler &lt;=&gt; Mesos Master &lt;=&gt; Mesos Slave &lt;=&gt; Executor</strong>。如果 Slave 一直不进行重启，执行器会一直运行，除非有另外的机制，<strong>通知</strong>到执行器。</p><p>But………………<br>笔者尝试如上流程，使用 <code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭，<strong>重启 Mesos Slave</strong>，结果执行器( Elastic-Job-Cloud-Executor )未关闭，调度器( Elastic-Job-Cloud-Scheduler )并未收到任务的 TASK_LOST。？？？什么情况？？？翻查如下文档：</p></li><li><p><a href="http://mesos.apache.org/documentation/latest/high-availability-framework-guide/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— high-availability-framework-guide》</a>搜索标题 “Dealing with Partitioned or Failed Agents”。</p></li><li><p><a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索关标题 “Agent Recovery”。</p><p>因为 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，开启了 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code>。开启 <code>checkpoint</code> 后，Mesos Slave 会将记录<strong>检查点</strong>信息， Mesos Slave 重启后，会读取检查点检查信息，<strong>重新连接上( 不会关闭 )</strong>运行在它上面的执行器( Elastic-Job-Cloud-Scheduler )。开启 <code>PARTITION_AWARE</code> 后，TASK_LOST 会被区分成 TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN。表现如下：</p><ul><li><code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭</li><li>调度器( Elastic-Job-Cloud-Scheduler ) 接收直接由 Mesos Master 发送的该 Mesos Slave 上的每个任务 TASK_UNREACHABLE。</li><li>Mesos Slave 重启完成。</li><li>执行器( Elastic-Job-Cloud-Executor ) 重新注册到重启好的 Mesos Slave ，并继续运行任务。</li></ul></li></ul><p>如果 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，关闭了 <code>PARTITION_AWARE</code> 和 <code>checkpoint</code>，表现同 <strong>TASK_LOST</strong> 描述的过程。</p><p>开启 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code> 实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">      Protos.FrameworkInfo.Builder builder = Protos.FrameworkInfo.newBuilder();</div><div class="line">      <span class="comment">// PARTITION_AWARE</span></div><div class="line">      builder.addCapabilitiesBuilder().setType(Protos.FrameworkInfo.Capability.Type.PARTITION_AWARE);</div><div class="line">      Protos.FrameworkInfo frameworkInfo = builder.setUser(mesosConfig.getUser()).setName(frameworkName)</div><div class="line">          .setHostname(mesosConfig.getHostname()).setFailoverTimeout(FRAMEWORK_FAILOVER_TIMEOUT_SECONDS)</div><div class="line">          .setWebuiUrl(WEB_UI_PROTOCOL + env.getFrameworkHostPort())</div><div class="line">          .setCheckpoint(<span class="keyword">true</span>) <span class="comment">// checkpoint</span></div><div class="line">          .build();</div><div class="line">      <span class="comment">// ... 省略无关代码</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></code></pre><p><strong>是不是开启了 <code>checkpoint</code>，Mesos Slave 重启不会关闭执行器？</strong></p><p> 答案当然是不是的。当 Mesos Slave 配置 <code>recover = cleanup</code> 或者 重启时间超过 <code>recovery_timeout</code> ( 默认，15 分钟 )时，重启完成后，Mesos Slave 关闭运行在它上面的执行器( Elastic-Job-Cloud-Executor )，调度器( Elastic-Job-Cloud-Scheduler ) 接收到的该 Mesos Slave 上的每个任务 TASK_FAILED。</p><ul><li>参考文档：<a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索标题 “Agent Configuration”。</li></ul></li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/01.png" alt=""></p><hr><p>调用 <code>FacadeService#recordFailoverTask(...)</code> 方法，记录失效转移队列，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordFailoverTask</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigOptional = jobConfigService.load(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isDisable(jobConfigOptional.get())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   CloudJobConfiguration jobConfig = jobConfigOptional.get();</div><div class="line">   <span class="keyword">if</span> (jobConfig.getTypeConfig().getCoreConfig().isFailover() <span class="comment">// 开启失效转移</span></div><div class="line">           || CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 常驻作业</span></div><div class="line">       failoverService.add(taskContext);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对于<strong>瞬时</strong>作业，必须开启 <code>JobCoreConfiguration.failover = true</code>，才能失效转移，这个比较好理解。</li><li>对于<strong>常驻</strong>作业，暂时不支持失效转移。因为常驻作业是在执行器( Elastic-Job-Executor ) 进行调度执行，如果不添加到失效转移作业队列，重新提交到执行器( Elastic-Job-Executor )，后续就不能调度执行该作业了。</li><li>调用 <code>FailoverService#add(...)</code> 方法，将任务放入失效转移队列，实现代码如下：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(FailoverNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   String failoverTaskNodePath = FailoverNode.getFailoverTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(failoverTaskNodePath) <span class="comment">// 判断不在失效转移队列</span></div><div class="line">           &amp;&amp; !runningService.isTaskRunning(taskContext.getMetaInfo())) &#123; <span class="comment">// 判断不在运行中</span></div><div class="line">       regCenter.persist(failoverTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FailoverNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;JOB_NAME&#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_TASK = FAILOVER_JOB + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;TASK_META_INFO&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>FailoverService，失效转移队列服务。</li><li><p><strong>失效转移队列</strong>存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/failover/${JOB_NAME}/${TASK_META_INFO}</code>，存储值为任务编号。使用 zkClient 查看如下：</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 2] ls /elastic-job-cloud/state/failover/test_job_simple</div><div class="line">[test_job_simple@-@0]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-cloud/state/failover/test_job_simple/test_job_simple@-@0</div><div class="line">test_job_simple@-@0@-@READY@-@4da72be3-43d5-4f02-9d7e-45feb30b8fcb-S2@-@8f2a5bb5-2941-4ece-b192-0f936e60faa7</div></pre></td></tr></table></figure></li><li><p>在运维平台，我们可以看到失效转移队列：</p><p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/02.png" alt=""> </p></li></ul><h1 id="3-提交失效转移作业"><a href="#3-提交失效转移作业" class="headerlink" title="3. 提交失效转移作业"></a>3. 提交失效转移作业</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.1 创建 Fenzo 任务请求」</a>里，调用 <code>FacadeService#getEligibleJobContext()</code> 方法，获取有资格运行的作业时。<code>FacadeService#getEligibleJobContext()</code> 不仅调用 <code>ReadyService#getAllEligibleJobContexts(...)</code> 方法，从<strong>待执行队列</strong>中获取所有有资格执行的作业上下文，也调用 <code>FailoverService#getAllEligibleJobContexts()</code> 方法，从<strong>失效转移队列</strong>中获取所有有资格执行的作业上下文。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getAllEligibleJobContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在 失效转移队列</span></div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(FailoverNode.ROOT)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 失效转移队列 的作业们</span></div><div class="line">   List&lt;String&gt; jobNames = regCenter.getChildrenKeys(FailoverNode.ROOT);</div><div class="line">   Collection&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobNames.size());</div><div class="line">   Set&lt;HashCode&gt; assignedTasks = <span class="keyword">new</span> HashSet&lt;&gt;(jobNames.size() * <span class="number">10</span>, <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">       <span class="comment">// 为空时，移除 失效转移队列 的作业</span></div><div class="line">       List&lt;String&gt; taskIdList = regCenter.getChildrenKeys(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">       <span class="keyword">if</span> (taskIdList.isEmpty()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 排除 作业配置 不存在的作业</span></div><div class="line">       Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(each);</div><div class="line">       <span class="keyword">if</span> (!jobConfig.isPresent()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得待执行的分片集合</span></div><div class="line">       List&lt;Integer&gt; assignedShardingItems = getAssignedShardingItems(each, taskIdList, assignedTasks);</div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!assignedShardingItems.isEmpty() &amp;&amp; jobConfig.isPresent()) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> JobContext(jobConfig.get(), assignedShardingItems, ExecutionType.FAILOVER));    </div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getAssignedShardingItems</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;String&gt; taskIdList, <span class="keyword">final</span> Set&lt;HashCode&gt; assignedTasks)</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(taskIdList.size());</div><div class="line">   <span class="keyword">for</span> (String each : taskIdList) &#123;</div><div class="line">       TaskContext.MetaInfo metaInfo = TaskContext.MetaInfo.from(each);</div><div class="line">       <span class="keyword">if</span> (assignedTasks.add(Hashing.md5().newHasher().putString(jobName, Charsets.UTF_8).putInt(metaInfo.getShardingItems().get(<span class="number">0</span>)).hash()) <span class="comment">// 排重</span></div><div class="line">               &amp;&amp; !runningService.isTaskRunning(metaInfo)) &#123; <span class="comment">// 排除正在运行中</span></div><div class="line">           result.add(metaInfo.getShardingItems().get(<span class="number">0</span>));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.4 创建 Mesos 任务信息」</a>里，调用 <code>LaunchingTasks#getIntegrityViolationJobs()</code> 方法，获得作业分片不完整的作业集合。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Collection&lt;String&gt; <span class="title">getIntegrityViolationJobs</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; assignedJobShardingTotalCountMap = getAssignedJobShardingTotalCountMap(vmAssignmentResults);</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(assignedJobShardingTotalCountMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : assignedJobShardingTotalCountMap.entrySet()) &#123;</div><div class="line">       JobContext jobContext = eligibleJobContextsMap.get(entry.getKey());</div><div class="line">       <span class="keyword">if</span> (ExecutionType.FAILOVER != jobContext.getType() <span class="comment">// 不包括 FAILOVER 执行类型的作业</span></div><div class="line">               &amp;&amp; !entry.getValue().equals(jobContext.getJobConfig().getTypeConfig().getCoreConfig().getShardingTotalCount())) &#123;</div><div class="line">           log.warn(<span class="string">"Job &#123;&#125; is not assigned at this time, because resources not enough to run all sharding instances."</span>, entry.getKey());</div><div class="line">           result.add(entry.getKey());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>一个作业可能存在部分分片需要失效转移，不需要考虑完整性。</li></ul><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.7 从队列中删除已运行的作业」</a>里，调用 <code>FailoverService#remove(...)</code> 方法，从失效转移队列中删除相关任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> Collection&lt;TaskContext.MetaInfo&gt; metaInfoList)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (TaskContext.MetaInfo each : metaInfoList) &#123;</div><div class="line">       regCenter.remove(FailoverNode.getFailoverTaskNodePath(each.toString()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>原本以为会是一篇水更，后面研究 TASK_LOST，发现收获大大的，干货妥妥的。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 记录作业失效转移&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Cloud 源码分析 —— 本地运行模式</title>
    <link href="http://www.iocoder.cn/Elastic-Job/cloud-local-executor/"/>
    <id>http://www.iocoder.cn/Elastic-Job/cloud-local-executor/</id>
    <published>2018-01-02T16:00:00.000Z</published>
    <updated>2017-09-06T10:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="#">1. 概述</a></li><li><a href="#">2. 配置</a></li><li><a href="#">3. 运行</a></li><li><a href="#">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 本地运行模式</strong>，对应<a href="http://elasticjob.io/docs/elastic-job-cloud/02-guide/local-executor/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 本地运行模式》</a>。</p><p><strong>有什么用呢</strong>？引用官方解答：</p><blockquote><p>在开发 Elastic-Job-Cloud 作业时，开发人员可以脱离 Mesos 环境，在本地运行和调试作业。可以利用本地运行模式充分的调试业务功能以及单元测试，完成之后再部署至 Mesos 集群。<br>本地运行作业无需安装 Mesos 环境。</p></blockquote><p>😈 是不是很赞 + 1024？！</p><p>本文涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/01.png" alt=""></p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>LocalCloudJobConfiguration，本地云作业配置，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-local-executor/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》「3.2 本地云作业配置」</a>有详细解析。</p><p>创建本地云作业配置示例代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LocalCloudJobConfiguration config = <span class="keyword">new</span> LocalCloudJobConfiguration(</div><div class="line">    <span class="keyword">new</span> SimpleJobConfiguration(</div><div class="line">    <span class="comment">// 配置作业类型和作业基本信息</span></div><div class="line">    JobCoreConfiguration.newBuilder(<span class="string">"FooJob"</span>, <span class="string">"*/2 * * * * ?"</span>, <span class="number">3</span>) </div><div class="line">        .shardingItemParameters(<span class="string">"0=Beijing,1=Shanghai,2=Guangzhou"</span>)</div><div class="line">        .jobParameter(<span class="string">"dbName=dangdang"</span>).build(), <span class="string">"com.dangdang.foo.FooJob"</span>),</div><div class="line">        <span class="comment">// 配置当前运行的作业是第几个分片 </span></div><div class="line">        <span class="number">1</span>,  </div><div class="line">        <span class="comment">// 配置Spring相关参数。如果不配置，代表不使用 Spring 配置。</span></div><div class="line">        <span class="string">"testSimpleJob"</span> , <span class="string">"applicationContext.xml"</span>);</div></pre></td></tr></table></figure><h1 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h1><p>LocalTaskExecutor，本地作业执行器。</p><p>创建本地作业执行器示例代码如下（来自官方）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> LocalTaskExecutor(localJobConfig).execute();</div></pre></td></tr></table></figure><p>可以看到，调用 <code>LocalTaskExecutor#execute()</code> 方法，执行作业逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LocalTaskExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   AbstractElasticJobExecutor jobExecutor;</div><div class="line">   CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(getShardingContexts(), getJobConfigurationContext(), <span class="keyword">new</span> JobEventBus());</div><div class="line">   <span class="comment">// 创建执行器</span></div><div class="line">   <span class="keyword">switch</span> (localCloudJobConfiguration.getTypeConfig().getJobType()) &#123;</div><div class="line">       <span class="keyword">case</span> SIMPLE:</div><div class="line">           jobExecutor = <span class="keyword">new</span> SimpleJobExecutor(getJobInstance(SimpleJob.class), jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> DATAFLOW:</div><div class="line">           jobExecutor = <span class="keyword">new</span> DataflowJobExecutor(getJobInstance(DataflowJob.class), jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> SCRIPT:</div><div class="line">           jobExecutor = <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(localCloudJobConfiguration.getTypeConfig().getJobType().name());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行作业</span></div><div class="line">   jobExecutor.execute();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getShardingContexts()</code> 方法，创建分片上下文集合( ShardingContexts )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   JobCoreConfiguration coreConfig = localCloudJobConfiguration.getTypeConfig().getCoreConfig();</div><div class="line">   Map&lt;Integer, String&gt; shardingItemMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">   shardingItemMap.put(localCloudJobConfiguration.getShardingItem(),</div><div class="line">           <span class="keyword">new</span> ShardingItemParameters(coreConfig.getShardingItemParameters()).getMap().get(localCloudJobConfiguration.getShardingItem()));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(</div><div class="line">           <span class="comment">// taskId 👇</span></div><div class="line">           Joiner.on(<span class="string">"@-@"</span>).join(localCloudJobConfiguration.getJobName(), localCloudJobConfiguration.getShardingItem(), <span class="string">"READY"</span>, <span class="string">"foo_slave_id"</span>, <span class="string">"foo_uuid"</span>),</div><div class="line">           localCloudJobConfiguration.getJobName(), coreConfig.getShardingTotalCount(), coreConfig.getJobParameter(), shardingItemMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#getJobConfigurationContext()</code> 方法，创建内部的作业配置上下文( JobConfigurationContext )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> JobConfigurationContext <span class="title">getJobConfigurationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; jobConfigurationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobClass"</span>, localCloudJobConfiguration.getTypeConfig().getJobClass());</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobType"</span>, localCloudJobConfiguration.getTypeConfig().getJobType().name());</div><div class="line">   jobConfigurationMap.put(<span class="string">"jobName"</span>, localCloudJobConfiguration.getJobName());</div><div class="line">   jobConfigurationMap.put(<span class="string">"beanName"</span>, localCloudJobConfiguration.getBeanName());</div><div class="line">   jobConfigurationMap.put(<span class="string">"applicationContext"</span>, localCloudJobConfiguration.getApplicationContext());</div><div class="line">   <span class="keyword">if</span> (JobType.DATAFLOW == localCloudJobConfiguration.getTypeConfig().getJobType()) &#123; <span class="comment">// 数据流作业</span></div><div class="line">       jobConfigurationMap.put(<span class="string">"streamingProcess"</span>, Boolean.toString(((DataflowJobConfiguration) localCloudJobConfiguration.getTypeConfig()).isStreamingProcess()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (JobType.SCRIPT == localCloudJobConfiguration.getTypeConfig().getJobType()) &#123; <span class="comment">// 脚本作业</span></div><div class="line">       jobConfigurationMap.put(<span class="string">"scriptCommandLine"</span>, ((ScriptJobConfiguration) localCloudJobConfiguration.getTypeConfig()).getScriptCommandLine());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JobConfigurationContext(jobConfigurationMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>#getJobInstance(...)</code> 方法， 获得分布式作业( ElasticJob )实现实例，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T extends ElasticJob&gt; <span class="function">T <span class="title">getJobInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; clazz)</span> </span>&#123;</div><div class="line">   Object result;</div><div class="line">   <span class="keyword">if</span> (Strings.isNullOrEmpty(localCloudJobConfiguration.getApplicationContext())) &#123; <span class="comment">// 直接创建 ElasticJob</span></div><div class="line">       String jobClass = localCloudJobConfiguration.getTypeConfig().getJobClass();</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           result = Class.forName(jobClass).newInstance();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' initialize failure, the error message is '%s'."</span>, jobClass, ex.getMessage());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// Spring 环境获得 ElasticJob</span></div><div class="line">       result = <span class="keyword">new</span> ClassPathXmlApplicationContext(localCloudJobConfiguration.getApplicationContext()).getBean(localCloudJobConfiguration.getBeanName());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> clazz.cast(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>AbstractElasticJobExecutor#execute()</code> 方法，执行作业逻辑。 Elastic-Job-Lite 和 Elastic-Job-Cloud 作业执行基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：可能有点水更，和大家实际开发太相关，想想还是更新下。<br>旁白君：哎哟哟，哎哟喂。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_03/02.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;3. 运
      
    
    </summary>
    
      <category term="Elastic-Job-Cloud" scheme="http://www.iocoder.cn/categories/Elastic-Job-Cloud/"/>
    
    
  </entry>
  
</feed>
