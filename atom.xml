<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋艿V的博客</title>
  <subtitle>愿编码半生，如老友相伴！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yunai.me/"/>
  <updated>2017-08-05T20:58:04.000Z</updated>
  <id>http://www.yunai.me/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-tcc/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2017-08-05T20:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>占坑文。关注公众号，第一时间获得更新通知。
ps：tcc 暂时未实现，目前在 RoadMap 中</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（一）之最大努力型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-bed/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-bed/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-11T10:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋艿的后端小屋】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>TODO 目录</p>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>数据库表<strong>分库</strong>后，业务场景下的<strong>单库本地事务</strong>可能变成<strong>跨库分布式事务</strong>。虽然我们可以通过合适的<strong>分库规则</strong>让操作的数据在同库下，继续保证<strong>单库本地事务</strong>，这也是非常推崇的，但不是所有场景下都能适用。如果这些场景对事务的一致性有要求，我们就不得不解决分布式事务的“麻烦”。</p>
<p><strong>分布式事务</strong>是个很大的话题，我们来看看 Sharding-JDBC 对她的解答：</p>
<blockquote>
<p>Sharding-JDBC由于性能方面的考量，决定不支持强一致性分布式事务。我们已明确规划线路图，未来会支持最终一致性的柔性事务。</p>
</blockquote>
<p>Sharding-JDBC 提供了两种 <strong>柔性事务</strong>：</p>
<ul>
<li>最大努力送达型 BED ：已经实现</li>
<li>事务补偿型 TCC ：计划中</li>
</ul>
<p><strong>本文分享 最大努力送达型 的实现</strong>。建议前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a>。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-最大努力送达型"><a href="#2-最大努力送达型" class="headerlink" title="2. 最大努力送达型"></a>2. 最大努力送达型</h1><p><strong>概念</strong></p>
<blockquote>
<p>在分布式数据库的场景下，相信对于该数据库的操作最终一定可以成功，所以通过最大努力反复尝试送达操作。</p>
</blockquote>
<p>从概念看，可能不是很直白的理解是什么意思，本文会<strong>最大努力</strong>让你干净理解。</p>
<p><strong>架构图</strong></p>
<blockquote>
<p><img src="../../../images/Sharding-JDBC/2017_08_20/01.jpeg" alt=""></p>
</blockquote>
<p>执行过程有 <strong>四种</strong> 情况：</p>
<ol>
<li>【红线】执行成功</li>
<li>【棕线】执行失败，同步重试成功</li>
<li>【粉线】执行失败，同步重试失败，异步重试成功</li>
<li>【绿线】执行失败，同步重试失败，异步重试失败，事务日志保留</li>
</ol>
<p>整体成漏斗倒三角，上一个阶段失败，交给下一个阶段重试：</p>
<p><img src="../../../images/Sharding-JDBC/2017_08_20/02.png" alt=""></p>
<p>整个过程通过如下 <strong>组件</strong> 完成：</p>
<ul>
<li>柔性事务管理器</li>
<li>最大努力送达型柔性事务</li>
<li>最大努力送达型事务监听器</li>
<li>事务日志存储器</li>
<li>最大努力送达型异步作业</li>
</ul>
<p>下面，我们逐节分享每个组件。</p>
<h1 id="3-柔性事务管理器"><a href="#3-柔性事务管理器" class="headerlink" title="3. 柔性事务管理器"></a>3. 柔性事务管理器</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>柔性事务管理器，SoftTransactionManager 实现，负责对柔性事务配置( SoftTransactionConfiguration ) 、柔性事务( AbstractSoftTransaction )的管理。</p>
<h2 id="3-2-柔性事务配置"><a href="#3-2-柔性事务配置" class="headerlink" title="3.2 柔性事务配置"></a>3.2 柔性事务配置</h2><p>调用 <code>#init()</code> 初始化柔性管理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 柔性事务配置对象</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SoftTransactionConfiguration transactionConfig;</div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 初始化事务管理器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// 初始化 最大努力送达型事务监听器</span></div><div class="line">   EventBusInstance.getInstance().register(<span class="keyword">new</span> BestEffortsDeliveryListener());</div><div class="line">   <span class="comment">// 初始化 事务日志数据库存储表</span></div><div class="line">   <span class="keyword">if</span> (TransactionLogDataSourceType.RDB == transactionConfig.getStorageType()) &#123;</div><div class="line">       Preconditions.checkNotNull(transactionConfig.getTransactionLogDataSource());</div><div class="line">       createTable();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 初始化 内嵌的最大努力送达型异步作业</span></div><div class="line">   <span class="keyword">if</span> (transactionConfig.getBestEffortsDeliveryJobConfiguration().isPresent()) &#123;</div><div class="line">       <span class="keyword">new</span> NestedBestEffortsDeliveryJobFactory(transactionConfig).init();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将最大努力送达型事务监听器( BestEffortsDeliveryListener )注册到事务总线 ( EventBus )。在『最大努力送达型事务监听器』小节会详细分享</li>
<li>当使用<strong>数据库</strong>存储事务日志( TransactionLog ) 时，若<strong>事务日志表( <code>transaction_log</code> )</strong>不存在则进行创建。在『事务日志存储器』小节会详细分享</li>
<li>当配置使用<strong>内嵌的</strong>最大努力送达型异步作业( NestedBestEffortsDeliveryJob ) 时，进行初始化。在『最大努力送达型异步作业』小节会详细分享</li>
</ul>
<p><strong>SoftTransactionConfiguration</strong></p>
<p>SoftTransactionConfiguration，柔性事务配置对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftTransactionConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务管理器管理的数据源.</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.NONE)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource targetDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步的事务送达的最大尝试次数.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> syncMaxDeliveryTryTimes = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务日志存储类型.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> TransactionLogDataSourceType storageType = RDB;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储事务日志的数据源.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> DataSource transactionLogDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内嵌的最大努力送达型异步作业配置对象.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;NestedBestEffortsDeliveryJobConfiguration&gt; bestEffortsDeliveryJobConfiguration = Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-柔性事务"><a href="#3-3-柔性事务" class="headerlink" title="3.3 柔性事务"></a>3.3 柔性事务</h2><p>在 Sharding-JDBC 里，目前柔性事务分成两种：</p>
<ul>
<li>BEDSoftTransaction ：最大努力送达型柔性事务</li>
<li>TCCSoftTransaction ：TCC型柔性事务</li>
</ul>
<p><strong>继承 AbstractSoftTransaction</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接原自动提交状态</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> previousAutoCommit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> ShardingConnection connection;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务类型</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> SoftTransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务编号</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> String transactionId;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AbstractSoftTransaction 实现了开启柔性事务、关闭柔性事务两个方法提供给子类调用：</p>
<ul>
<li><p><code>#beginInternal()</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 开启柔性</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> conn 分片连接</div><div class="line">* <span class="doctag">@param</span> type 事务类型</div><div class="line">* <span class="doctag">@throws</span> SQLException</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginInternal</span><span class="params">(<span class="keyword">final</span> Connection conn, <span class="keyword">final</span> SoftTransactionType type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// TODO 判断如果在传统事务中，则抛异常</span></div><div class="line">   Preconditions.checkArgument(conn <span class="keyword">instanceof</span> ShardingConnection, <span class="string">"Only ShardingConnection can support eventual consistency transaction."</span>);</div><div class="line">   <span class="comment">// 设置执行错误，不抛出异常</span></div><div class="line">   ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">false</span>);</div><div class="line">   connection = (ShardingConnection) conn;</div><div class="line">   transactionType = type;</div><div class="line">   <span class="comment">// 设置自动提交状态</span></div><div class="line">   previousAutoCommit = connection.getAutoCommit();</div><div class="line">   connection.setAutoCommit(<span class="keyword">true</span>);</div><div class="line">   <span class="comment">// 生成事务编号</span></div><div class="line">   <span class="comment">// TODO 替换UUID为更有效率的id生成器</span></div><div class="line">   transactionId = UUID.randomUUID().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>* 调用 `ExecutorExceptionHandler.setExceptionThrown(false)` 设置执行 SQL 错误时，也不抛出异常。
    * 对异常处理的代码：[ExecutorExceptionHandler#setExceptionThrown()](https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorExceptionHandler.java#L59) 
    * 对于其他 SQL，不会因为 SQL 错误不执行，会继续执行
    * 对于上层业务，不会因为 SQL 错误终止逻辑，会继续执行。这里有一点要注意下，上层业务不能对该 SQL 执行结果有强依赖，因为 SQL 错误需要重试达到数据最终一致性
    * 对于**最大努力型事务**( TCC暂未实现 )，会对执行错误的 SQL 进行重试
</code></pre><ul>
<li><p>调用 <code>connection.setAutoCommit(true);</code>，设置执行自动提交。<strong>使用最大努力型事务时，上层业务执行 SQL 会马上提交，即使调用  <code>Connection#rollback()</code> 也是无法回滚的，这点一定要注意。</strong></p>
<ul>
<li><code>#end()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 结束柔性事务.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">       ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">true</span>);</div><div class="line">       connection.setAutoCommit(previousAutoCommit);</div><div class="line">       SoftTransactionManager.closeCurrentTransactionManager();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 关闭当前的柔性事务管理器.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeCurrentTransactionManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    ExecutorDataMap.getDataMap().put(TRANSACTION, <span class="keyword">null</span>);</div><div class="line">    ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>* 事务结束后，一定要记得调用 `#end()` 清理线程变量。否则，下次请求使用到该线程，会继续在这个柔性事务内。
</code></pre><p><strong>BEDSoftTransaction</strong>    </p>
<p>BEDSoftTransaction，最大努力送达型柔性事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BEDSoftTransaction</span> <span class="keyword">extends</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开启柔性事务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connection 数据库连接对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        beginInternal(connection, SoftTransactionType.BestEffortsDelivery);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>TCCSoftTransaction</strong></p>
<p>TCCSoftTransaction，TCC 型柔性事务，暂未实现。实现后，会更新到 <a href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/?self">《Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型》</a>。</p>
<hr>
<h3 id="3-3-1-创建柔性事务"><a href="#3-3-1-创建柔性事务" class="headerlink" title="3.3.1 创建柔性事务"></a>3.3.1 创建柔性事务</h3><p>通过调用 <code>SoftTransactionManager#getTransaction()</code> 创建柔性事务对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务对象 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION = <span class="string">"transaction"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务配置 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_CONFIG = <span class="string">"transactionConfig"</span>;</div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> type 柔性事务类型</div><div class="line">* <span class="doctag">@return</span> 柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> AbstractSoftTransaction <span class="title">getTransaction</span><span class="params">(<span class="keyword">final</span> SoftTransactionType type)</span> </span>&#123;</div><div class="line">   AbstractSoftTransaction result;</div><div class="line">   <span class="keyword">switch</span> (type) &#123;</div><div class="line">       <span class="keyword">case</span> BestEffortsDelivery: </div><div class="line">           result = <span class="keyword">new</span> BEDSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TryConfirmCancel:</div><div class="line">           result = <span class="keyword">new</span> TCCSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>: </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(type.toString());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 目前使用不支持嵌套事务，以后这里需要可配置</span></div><div class="line">   <span class="keyword">if</span> (getCurrentTransaction().isPresent()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support nested transaction."</span>);</div><div class="line">   &#125;</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION, result);</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, transactionConfig);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>后续可以从 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorDataMap.java" rel="external nofollow noopener noreferrer" target="_blank">ExecutorDataMap</a> 中获取当前线程的柔性事务和柔性事务配置：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前线程的柔性事务配置.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前线程的柔性事务配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;SoftTransactionConfiguration&gt; <span class="title">getCurrentTransactionConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transactionConfig = ExecutorDataMap.getDataMap().get(TRANSACTION_CONFIG);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transactionConfig)</div><div class="line">           ? Optional.&lt;SoftTransactionConfiguration&gt;absent()</div><div class="line">           : Optional.of((SoftTransactionConfiguration) transactionConfig);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前的柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前的柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;AbstractSoftTransaction&gt; <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transaction = ExecutorDataMap.getDataMap().get(TRANSACTION);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transaction)</div><div class="line">           ? Optional.&lt;AbstractSoftTransaction&gt;absent()</div><div class="line">           : Optional.of((AbstractSoftTransaction) transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="4-事务日志存储器"><a href="#4-事务日志存储器" class="headerlink" title="4. 事务日志存储器"></a>4. 事务日志存储器</h1><p>柔性事务执行过程中，会通过事务日志( TransactionLog ) 记录每条 SQL 执行状态：</p>
<ul>
<li>SQL 执行前，记录一条事务日志</li>
<li>SQL 执行成功，移除对应的事务日志 </li>
</ul>
<p>通过实现事务日志存储器接口( TransactionLogStorage )，提供存储功能。目前有两种实现：</p>
<ul>
<li>MemoryTransactionLogStorage ：基于<strong>内存</strong>的事务日志存储器。主要用于开发测试，<strong>生产环境下不要使用</strong>。</li>
<li>RdbTransactionLogStorage ：基于<strong>数据库</strong>的事务日志存储器。</li>
</ul>
<p>本节只分析 RdbTransactionLogStorage。对 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-transaction-parent/sharding-jdbc-transaction-storage/src/main/java/com/dangdang/ddframe/rdb/transaction/soft/storage/impl/RdbTransactionLogStorage.java" rel="external nofollow noopener noreferrer" target="_blank">MemoryTransactionLogStorage</a> 感兴趣的同学可以点击链接传送到达。</p>
<p><strong>TransactionLogStorage 有五个接口方法，下文每个小标题都是一个方法。</strong></p>
<h2 id="4-1-add"><a href="#4-1-add" class="headerlink" title="4.1 #add()"></a>4.1 #add()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 存储事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TransactionLog transactionLog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TransactionLog transactionLog)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"INSERT INTO `transaction_log` (`id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`) VALUES (?, ?, ?, ?, ?, ?);"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">    <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TransactionLog (transaction_log) 数据库表结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>名字</th>
<th>数据库类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>事件编号</td>
<td>VARCHAR(40)</td>
<td>EventBus 事件编号，<strong>非事务编号</strong></td>
</tr>
<tr>
<td>transaction_type</td>
<td>柔性事务类型</td>
<td>VARCHAR(30)</td>
</tr>
<tr>
<td>data_source</td>
<td>数据源名</td>
<td>VARCHAR(255)</td>
<td></td>
</tr>
<tr>
<td>sql</td>
<td>SQL</td>
<td>TEXT</td>
</tr>
<tr>
<td>parameters</td>
<td>占位符参数</td>
<td>TEXT</td>
<td>JSON 字符串存储</td>
</tr>
<tr>
<td>creation_time</td>
<td>记录时间</td>
<td>LONG</td>
</tr>
<tr>
<td>async_delivery_try_times</td>
<td>已异步重试次数</td>
<td>INT</td>
</tr>
</tbody>
</table>
<p>// TODO 插入失败，是不是死循环了。</p>
<h2 id="4-2-remove"><a href="#4-2-remove" class="headerlink" title="4.2 #remove()"></a>4.2 #remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据主键删除事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务日志主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line"><span class="comment">// RdbTransactionLogStorage.java    </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"DELETE FROM `transaction_log` WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">          <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3-findEligibleTransactionLogs"><a href="#4-3-findEligibleTransactionLogs" class="headerlink" title="4.3 #findEligibleTransactionLogs()"></a>4.3 #findEligibleTransactionLogs()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 读取需要处理的事务日志.</div><div class="line">* </div><div class="line">* &lt;p&gt;需要处理的事务日志为: &lt;/p&gt;</div><div class="line">* &lt;p&gt;1. 异步处理次数小于最大处理次数.&lt;/p&gt;</div><div class="line">* &lt;p&gt;2. 异步处理的事务日志早于异步处理的间隔时间.&lt;/p&gt;</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> size 获取日志的数量</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryDelayMillis 执行送达事务的延迟毫秒数.</div><div class="line">*/</div><div class="line"><span class="function">List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">final</span> <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span> </span>&#123;</div><div class="line">   List&lt;TransactionLog&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</div><div class="line">   String sql = <span class="string">"SELECT `id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`, `async_delivery_try_times` "</span></div><div class="line">       + <span class="string">"FROM `transaction_log` WHERE `async_delivery_try_times`&lt;? AND `transaction_type`=? AND `creation_time`&lt;? LIMIT ?;"</span>;</div><div class="line">   <span class="keyword">try</span> (Connection conn = dataSource.getConnection()) &#123;</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-4-increaseAsyncDeliveryTryTimes"><a href="#4-4-increaseAsyncDeliveryTryTimes" class="headerlink" title="4.4 #increaseAsyncDeliveryTryTimes()"></a>4.4 #increaseAsyncDeliveryTryTimes()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 增加事务日志异步重试次数.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(String id)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"UPDATE `transaction_log` SET `async_delivery_try_times`=`async_delivery_try_times`+1 WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-5-processData"><a href="#4-5-processData" class="headerlink" title="4.5 #processData()"></a>4.5 #processData()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理事务数据.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> connection 业务数据库连接</div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(Connection connection, TransactionLog transactionLog, <span class="keyword">int</span> maxDeliveryTryTimes)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> Connection connection, <span class="keyword">final</span> TransactionLog transactionLog, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes)</span> </span>&#123;</div><div class="line">   <span class="comment">// 重试执行失败 SQL</span></div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       Connection conn = connection;</div><div class="line">       PreparedStatement preparedStatement = conn.prepareStatement(transactionLog.getSql())) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; transactionLog.getParameters().size(); parameterIndex++) &#123;</div><div class="line">           preparedStatement.setObject(parameterIndex + <span class="number">1</span>, transactionLog.getParameters().get(parameterIndex));</div><div class="line">       &#125;</div><div class="line">       preparedStatement.executeUpdate();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="comment">// 重试失败，更新事务日志，增加已异步重试次数</span></div><div class="line">       increaseAsyncDeliveryTryTimes(transactionLog.getId());</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionCompensationException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除重试执行成功 SQL 对应的事务日志</span></div><div class="line">   remove(transactionLog.getId());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不同于前四个<strong>增删改查</strong>接口方法的实现，<code>#processData()</code> 是带有一些逻辑的。根据事务日志( TransactionLog )重试执行失败的 SQL，若成功，移除事务日志；若失败，更新事务日志，增加已异步重试次数</li>
<li>该方法会被<strong>最大努力送达型异步作业</strong>调用到</li>
</ul>
<h1 id="5-最大努力送达型事务监听器"><a href="#5-最大努力送达型事务监听器" class="headerlink" title="5. 最大努力送达型事务监听器"></a>5. 最大努力送达型事务监听器</h1><h1 id="6-最大努力送达型异步作业"><a href="#6-最大努力送达型异步作业" class="headerlink" title="6. 最大努力送达型异步作业"></a>6. 最大努力送达型异步作业</h1><h1 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h1><h1 id="8-开发指南-amp-开发示例"><a href="#8-开发指南-amp-开发示例" class="headerlink" title="8. 开发指南 &amp; 开发示例"></a>8. 开发指南 &amp; 开发示例</h1><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋艿的后端小屋】&lt;/stron
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— JDBC实现与读写分离</title>
    <link href="http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/"/>
    <id>http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/</id>
    <published>2017-08-17T16:00:00.000Z</published>
    <updated>2017-08-10T17:26:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. unspported 包</a></li>
<li><a href="#">3. adapter 包</a>
<ul>
<li><a href="#">3.1 WrapperAdapter</a></li>
<li><a href="#">3.2 AbstractDataSourceAdapter</a></li>
<li><a href="#">3.3 AbstractConnectionAdapter</a></li>
<li><a href="#">3.4 AbstractStatementAdapter</a></li>
<li><a href="#">3.5 AbstractPreparedStatementAdapter</a></li>
<li><a href="#">3.6 AbstractResultSetAdapter</a></li>
</ul>
</li>
<li><a href="#">4. 插入流程</a></li>
<li><a href="#">5. 查询流程</a></li>
<li><a href="#">6. 读写分离</a></li>
<li><a href="#">666. <s>彩蛋</s></a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文主要分享 <strong>JDBC</strong> 与 <strong>读写分离</strong> 的实现。为什么会把这两个东西放在一起讲呢？客户端直连数据库的读写分离主要通过获取读库和写库的不同连接来实现，和 JDBC Connection 刚好放在一块。</p>
<p>OK，我们先来看一段 Sharding-JDBC 官方对自己的定义和定位</p>
<blockquote>
<p>Sharding-JDBC定位为轻量级java框架，使用客户端直连数据库，以jar包形式提供服务，未使用中间层，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式，可理解为<strong>增强版的JDBC驱动</strong>，旧代码迁移成本几乎为零。</p>
</blockquote>
<p>可以看出，Sharding-JDBC 通过实现 <strong>JDBC规范</strong>，对上层提供透明化数据库分库分表的访问。😈 黑科技？实际我们使用的<strong>数据库连接池</strong>也是通过这种方式实现对上层无感知的提供连接池。甚至还可以通过这种方式实现对 Lucene、<a href="http://www.yunai.me/MyCAT/connect-mongodb/?self">MongoDB</a> 等等的访问。</p>
<p>扯远了，下面来看看 Sharding-JDBC <code>jdbc</code> 包的结构：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/01.png" alt=""></p>
<ul>
<li><code>unsupported</code>：声明<strong>不支持</strong>的数据操作方法</li>
<li><code>adapter</code>：适配类，实现和分库分表<strong>无关</strong>的方法</li>
<li><code>core</code>：核心类，实现和分库分表<strong>相关</strong>的方法</li>
</ul>
<p>根据 <code>core</code> 包，可以看出分到四种我们<strong>超级熟悉</strong>的对象</p>
<ul>
<li>
<p>Datasource</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/02.png" alt="-w640"></p>
</li>
<li>
<p>Connection</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/03.png" alt="-w640"></p>
</li>
<li>
<p>Statement</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/04.png" alt="-w640"></p>
</li>
<li>
<p>ResultSet</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/05.png" alt="-w640"></p>
</li>
</ul>
<p><strong>实现</strong>层级如下：<strong>JDBC 接口</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>core</code>类</strong>。</p>
<hr>
<p><strong>本文内容顺序</strong></p>
<ol>
<li><code>unspported</code> 包</li>
<li><code>adapter</code> 包</li>
<li>插入流程，分析的类：
<ul>
<li>ShardingDataSource</li>
<li>ShardingConnection</li>
<li>ShardingPreparedStatement（ShardingStatement 类似，不重复分析）</li>
<li>GeneratedKeysResultSet、GeneratedKeysResultSetMetaData</li>
</ul>
</li>
<li>查询流程，分析的类：
<ul>
<li>ShardingPreparedStatement</li>
<li>ShardingResultSet</li>
</ul>
</li>
<li>读写分离，分析的类：
<ul>
<li>MasterSlaveDataSource</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. unspported 包</h1>
<p><code>unspported</code> 包内的<strong>抽象</strong>类，声明不支持操作的数据对象，所有方法都是 <code>throw new SQLFeatureNotSupportedException()</code> 方式。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedGeneratedKeysResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"getBoolean"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedOperationConnection</span> <span class="keyword">extends</span> <span class="title">WrapperAdapter</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> CallableStatement <span class="title">prepareCall</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"prepareCall"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. adapter 包</h1>
<p><code>adapter</code> 包内的<strong>抽象</strong>类，实现和分库分表<strong>无关</strong>的方法。</p>
<p><strong>考虑到第4、5两小节更容易理解，本小节贴的代码会相对多</strong></p>
<h2>3.1 WrapperAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/WrapperAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">WrapperAdapter</a>，JDBC Wrapper 适配类。</p>
<p><strong>对 Wrapper 接口实现如下两个方法</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isWrapperFor(iface)) &#123;</div><div class="line">       <span class="keyword">return</span> (T) <span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(String.format(<span class="string">"[%s] cannot be unwrapped as [%s]"</span>, getClass().getName(), iface.getName()));</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>提供子类 <code>#recordMethodInvocation()</code> 记录方法调用，<code>#replayMethodsInvocation()</code> 回放记录的方法调用</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;JdbcMethodInvocation&gt; jdbcMethodInvocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> targetClass 目标类</div><div class="line">* <span class="doctag">@param</span> methodName 方法名称</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recordMethodInvocation</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; targetClass, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;[] argumentTypes, <span class="keyword">final</span> Object[] arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jdbcMethodInvocations.add(<span class="keyword">new</span> JdbcMethodInvocation(targetClass.getMethod(methodName, argumentTypes), arguments));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> target 目标对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">replayMethodsInvocation</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (JdbcMethodInvocation each : jdbcMethodInvocations) &#123;</div><div class="line">       each.invoke(target);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>这两个方法有什么用途呢？例如下文会提到的 AbstractConnectionAdapter 的 <code>#setAutoCommit()</code>，当它无数据库连接时，先记录；等获得到数据连接后，再回放：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractConnectionAdapter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<ul>
<li>
<p>JdbcMethodInvocation，反射调用JDBC相关方法的工具类：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法参数</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object[] arguments;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line">    *  调用方法.</div><div class="line">    * </div><div class="line">    * <span class="doctag">@param</span> target 目标对象</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           method.invoke(target, arguments); <span class="comment">// 反射调用</span></div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalAccessException | InvocationTargetException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Invoke jdbc method exception"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<p><strong>提供子类 <code>#throwSQLExceptionIfNecessary()</code> 抛出异常链</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">throwSQLExceptionIfNecessary</span><span class="params">(<span class="keyword">final</span> Collection&lt;SQLException&gt; exceptions)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (exceptions.isEmpty()) &#123; <span class="comment">// 为空不抛出异常</span></div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLException ex = <span class="keyword">new</span> SQLException();</div><div class="line">   <span class="keyword">for</span> (SQLException each : exceptions) &#123;</div><div class="line">       ex.setNextException(each); <span class="comment">// 异常链</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> ex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 AbstractDataSourceAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractDataSourceAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractDataSourceAdapter</a>，数据源适配类。</p>
<p>直接点击链接查看源码。</p>
<h2>3.3 AbstractConnectionAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractConnectionAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractConnectionAdapter</a>，数据库连接适配类。</p>
<p>我们来瞅瞅大家最关心的<strong>事务</strong>相关方法的实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 是否自动提交</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得链接</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 链接</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;Connection&gt; <span class="title">getConnections</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAutoCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> autoCommit;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#setAutoCommit()</code> 调用时，实际会设置其所持有的 Connection 的 <code>autoCommit</code> 属性</li>
<li><code>#getConnections()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.commit();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;SQLException&gt; exceptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           each.rollback();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           exceptions.add(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   throwSQLExceptionIfNecessary(exceptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#commit()</code>、<code>#rollback()</code> 调用时，实际调用其所持有的 Connection 的方法</li>
<li>异常情况下，<code>#commit()</code> 和 <code>#rollback()</code> 处理方式不同，笔者暂时不知道答案，求证后会进行更新</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 只读</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readOnly = <span class="keyword">true</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 事务级别</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> transactionIsolation = TRANSACTION_READ_UNCOMMITTED;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.readOnly = readOnly;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setReadOnly"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;readOnly&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setReadOnly(readOnly);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   transactionIsolation = level;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setTransactionIsolation"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;level&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setTransactionIsolation(level);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 AbstractStatementAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractStatementAdapter</a>，静态语句对象适配类。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">boolean</span> hasResult = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">for</span> (Statement each : getRoutedStatements()) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getUpdateCount() &gt; -<span class="number">1</span>) &#123;</div><div class="line">           hasResult = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       result += each.getUpdateCount();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE) &#123;</div><div class="line">       result = Integer.MAX_VALUE;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> hasResult ? Long.valueOf(result).intValue() : -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取路由的静态语句对象集合.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 路由的静态语句对象集合</div><div class="line">*/</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;? extends Statement&gt; getRoutedStatements();</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getUpdateCount()</code> 调用持有的 Statement 计算更新数量</li>
<li><code>#getRoutedStatements()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<h2>3.5 AbstractPreparedStatementAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractPreparedStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractPreparedStatementAdapter</a>，预编译语句对象的适配类。</p>
<p><strong><code>#recordSetParameter()</code>实现对占位符参数的设置</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的设置参数方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetParameterMethodInvocation&gt; setParameterMethodInvocations = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 参数</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> <span class="keyword">int</span> x)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   setParameter(parameterIndex, x);</div><div class="line">   recordSetParameter(<span class="string">"setInt"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;, parameterIndex, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录占位符参数</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> parameterIndex 占位符参数位置</div><div class="line">* <span class="doctag">@param</span> value 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (parameters.size() == parameterIndex - <span class="number">1</span>) &#123;</div><div class="line">       parameters.add(value);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = parameters.size(); i &lt;= parameterIndex - <span class="number">1</span>; i++) &#123; <span class="comment">// 用 null 填充前面未设置的位置</span></div><div class="line">       parameters.add(<span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line">   parameters.set(parameterIndex - <span class="number">1</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> methodName 方法名，例如 setInt、setLong 等</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordSetParameter</span><span class="params">(<span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class[] argumentTypes, <span class="keyword">final</span> Object... arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       setParameterMethodInvocations.add(<span class="keyword">new</span> SetParameterMethodInvocation(PreparedStatement.class.getMethod(methodName, argumentTypes), arguments, arguments[<span class="number">1</span>]));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> preparedStatement 预编译语句对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">replaySetParameter</span><span class="params">(<span class="keyword">final</span> PreparedStatement preparedStatement)</span> </span>&#123;</div><div class="line">   addParameters();</div><div class="line">   <span class="keyword">for</span> (SetParameterMethodInvocation each : setParameterMethodInvocations) &#123;</div><div class="line">       updateParameterValues(each, parameters.get(each.getIndex() - <span class="number">1</span>)); <span class="comment">// 同一个位置多次设置，值可能不一样，需要更新下</span></div><div class="line">       each.invoke(preparedStatement);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当使用分布式主键时，生成后会添加到 parameters，此时 parameters 数量多于 setParameterMethodInvocations，需要生成该分布式主键的 SetParameterMethodInvocation</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addParameters</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = setParameterMethodInvocations.size(); i &lt; parameters.size(); i++) &#123;</div><div class="line">       recordSetParameter(<span class="string">"setObject"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, Object.class&#125;, i + <span class="number">1</span>, parameters.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParameterValues</span><span class="params">(<span class="keyword">final</span> SetParameterMethodInvocation setParameterMethodInvocation, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!Objects.equals(setParameterMethodInvocation.getValue(), value)) &#123;</div><div class="line">       setParameterMethodInvocation.changeValueArgument(value); <span class="comment">// 修改占位符参数</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>逻辑类似 <code>WrapperAdapter</code> 的 <code>#recordMethodInvocation()</code>，<code>#replayMethodsInvocation()</code>，请<strong>认真</strong>阅读代码注释</p>
</li>
<li>
<p>SetParameterMethodInvocation，继承 JdbcMethodInvocation，反射调用参数设置方法的工具类：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SetParameterMethodInvocation</span> <span class="keyword">extends</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 位置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数值</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置参数值.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 参数值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValueArgument</span><span class="params">(<span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">        getArguments()[<span class="number">1</span>] = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>3.6 AbstractResultSetAdapter</h2>
<p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractResultSetAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractResultSetAdapter</a>，代理结果集适配器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResultSetAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 结果集集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">// TODO should return sharding statement in future</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Statement <span class="title">getStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getStatement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getMetaData();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).findColumn(columnLabel);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>4. 插入流程</h1>
<p>插入使用<strong>分布式主键</strong>例子代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码仅仅是例子，生产环境下请注意异常处理和资源关闭</span></div><div class="line">String sql = <span class="string">"INSERT INTO t_order(uid, nickname, pid) VALUES (1, '2', ?)"</span>;</div><div class="line">DataSource dataSource = <span class="keyword">new</span> ShardingDataSource(shardingRule);</div><div class="line">Connection conn = dataSource.getConnection();</div><div class="line">PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); <span class="comment">// 返回主键需要  Statement.RETURN_GENERATED_KEYS</span></div><div class="line">ps.setLong(<span class="number">1</span>, <span class="number">100</span>);</div><div class="line">ps.executeUpdate();</div><div class="line">ResultSet rs = ps.getGeneratedKeys();</div><div class="line"><span class="keyword">if</span> (rs.next()) &#123;</div><div class="line">    System.out.println(<span class="string">"id:"</span> + rs.getLong(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>调用 <code>#executeUpdate()</code> 方法，内部过程如下</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/06.png" alt=""></p>
<p>是不是对上层<strong>完全透明</strong>？！我们来看看内部是怎么实现的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeUpdate();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#route()</code> 分库分表路由，获得预编译语句对象执行单元( PreparedStatementUnit )集合。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementUnit</span> <span class="keyword">implements</span> <span class="title">BaseStatementUnit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 执行单元</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 预编译语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>#executeUpdate()</code> 调用<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">执行引擎</a><strong>并行</strong>执行<strong>多个</strong>预编译语句对象。执行时，最终调用预编译语句对象( PreparedStatement )。我们来看一个例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatementExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executePreparedStatement(sqlType, preparedStatementUnits, parameters, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="comment">// 调用 PreparedStatement#executeUpdate()</span></div><div class="line">               <span class="keyword">return</span> ((PreparedStatement) baseStatementUnit.getStatement()).executeUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;PreparedStatementUnit&gt; <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;PreparedStatementUnit&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   setRouteResult(routingEngine.route(getParameters()));</div><div class="line">   <span class="comment">// 遍历 SQL 执行单元</span></div><div class="line">   <span class="keyword">for</span> (SQLExecutionUnit each : getRouteResult().getExecutionUnits()) &#123;</div><div class="line">       SQLType sqlType = getRouteResult().getSqlStatement().getType();</div><div class="line">       Collection&lt;PreparedStatement&gt; preparedStatements;</div><div class="line">       <span class="comment">// 创建实际的 PreparedStatement</span></div><div class="line">       <span class="keyword">if</span> (SQLType.DDL == sqlType) &#123;</div><div class="line">           preparedStatements = generatePreparedStatementForDDL(each);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           preparedStatements = Collections.singletonList(generatePreparedStatement(each));</div><div class="line">       &#125;</div><div class="line">       getRoutedStatements().addAll(preparedStatements);</div><div class="line">       <span class="comment">// 回放设置占位符参数到 PreparedStatement</span></div><div class="line">       <span class="keyword">for</span> (PreparedStatement preparedStatement : preparedStatements) &#123;</div><div class="line">           replaySetParameter(preparedStatement);</div><div class="line">           result.add(<span class="keyword">new</span> PreparedStatementUnit(each, preparedStatement));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建 PreparedStatement</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlExecutionUnit SQL 执行单元</div><div class="line">* <span class="doctag">@return</span> PreparedStatement</div><div class="line">* <span class="doctag">@throws</span> SQLException 当 JDBC 操作发生异常时</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">generatePreparedStatement</span><span class="params">(<span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">   <span class="comment">// 获得连接</span></div><div class="line">   Connection connection = getShardingConnection().getConnection(sqlExecutionUnit.getDataSource(), getRouteResult().getSqlStatement().getType());</div><div class="line">   <span class="comment">// 声明返回主键</span></div><div class="line">   <span class="keyword">if</span> (isReturnGeneratedKeys() || isReturnGeneratedKeys() &amp;&amp; generatedKey.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#generatePreparedStatement()</code> 创建 PreparedStatement，后调用 <code>#replaySetParameter()</code> 回放设置占位符参数到 PreparedStatement</p>
</li>
<li>
<p>当 <strong>声明返回主键</strong> 时，即 <code>#isReturnGeneratedKeys()</code> 返回 <code>true</code> 时，调用 <code>connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS)</code>。为什么该方法会返回 <code>true</code>？上文例子 <code>conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> String[] columnNames)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql, Statement.RETURN_GENERATED_KEYS);</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingPreparedStatement</span><span class="params">(<span class="keyword">final</span> ShardingConnection shardingConnection, <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> autoGeneratedKeys)</span> </span>&#123;</div><div class="line"> <span class="keyword">this</span>(shardingConnection, sql);</div><div class="line"> <span class="keyword">if</span> (RETURN_GENERATED_KEYS == autoGeneratedKeys) &#123;</div><div class="line">     markReturnGeneratedKeys();</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">markReturnGeneratedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line"> returnGeneratedKeys = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>声明返回主键</strong>后，插入执行完成，我们调用 <code>#getGeneratedKeys()</code> 可以获得主键 ：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">getGeneratedKeys</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">    <span class="comment">// 分布式主键</span></div><div class="line">    <span class="keyword">if</span> (generatedKey.isPresent() &amp;&amp; returnGeneratedKeys) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet(routeResult.getGeneratedKeys().iterator(), generatedKey.get().getColumn(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 数据库自增</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == getRoutedStatements().size()) &#123;</div><div class="line">        <span class="keyword">return</span> getRoutedStatements().iterator().next().getGeneratedKeys();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>ShardingConnection#getConnection()</code> 方法获得该 PreparedStatement 对应的<strong>真实</strong>数据库连接( Connection )：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据数据源名称获取相应的数据库连接.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> dataSourceName 数据源名称</div><div class="line"> * <span class="doctag">@param</span> sqlType SQL语句类型</div><div class="line"> * <span class="doctag">@return</span> 数据库连接</div><div class="line"> * <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 从连接缓存中获取连接</span></div><div class="line">    Optional&lt;Connection&gt; connection = getCachedConnection(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">if</span> (connection.isPresent()) &#123;</div><div class="line">        <span class="keyword">return</span> connection.get();</div><div class="line">    &#125;</div><div class="line">    Context metricsContext = MetricsContext.start(Joiner.on(<span class="string">"-"</span>).join(<span class="string">"ShardingConnection-getConnection"</span>, dataSourceName));</div><div class="line">    <span class="comment">//</span></div><div class="line">    DataSource dataSource = shardingContext.getShardingRule().getDataSourceRule().getDataSource(dataSourceName);</div><div class="line">    Preconditions.checkState(<span class="keyword">null</span> != dataSource, <span class="string">"Missing the rule of %s in DataSourceRule"</span>, dataSourceName);</div><div class="line">    String realDataSourceName;</div><div class="line">    <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123;</div><div class="line">        dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">        realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        realDataSourceName = dataSourceName;</div><div class="line">    &#125;</div><div class="line">    Connection result = dataSource.getConnection();</div><div class="line">    MetricsContext.stop(metricsContext);</div><div class="line">    <span class="comment">// 添加到连接缓存</span></div><div class="line">    connectionMap.put(realDataSourceName, result);</div><div class="line">    <span class="comment">// 回放 Connection 方法</span></div><div class="line">    replayMethodsInvocation(result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;Connection&gt; <span class="title">getCachedConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">    String key = connectionMap.containsKey(dataSourceName) ? dataSourceName : MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">return</span> Optional.fromNullable(connectionMap.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#getCachedConnection()</code> 尝试获得<strong>已缓存</strong>的数据库连接；如果缓存中不存在，获取到连接后会进行<strong>缓存</strong></li>
<li>从 ShardingRule 配置的 DataSourceRule 获取<strong>真实</strong>的数据源( DataSource )</li>
<li>MasterSlaveDataSource 实现<strong>主从</strong>数据源封装，我们在<em>下小节</em>分享</li>
<li>调用 <code>#replayMethodsInvocation()</code> 回放记录的 Connection 方法</li>
</ul>
</li>
</ul>
<p><em>插入实现的代码基本分享完了，因为是不断代码下钻的方式分析，可以反向向上在理理，会更加清晰</em>。</p>
<h1>5. 查询流程</h1>
<p>单纯从 <code>core</code> 包里的 JDBC 实现，查询流程 <code>#executeQuery()</code> 和 <code>#execute()</code> 基本一致，差别在于<strong>执行</strong>和<strong>多结果集归并</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSet result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 路由</span></div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="comment">// 执行</span></div><div class="line">       List&lt;ResultSet&gt; resultSets = <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeQuery();</div><div class="line">       <span class="comment">// 结果归并</span></div><div class="line">       result = <span class="keyword">new</span> ShardingResultSet(resultSets, <span class="keyword">new</span> MergeEngine(</div><div class="line">               getShardingConnection().getShardingContext().getDatabaseType(), resultSets, (SelectStatement) getRouteResult().getSqlStatement()).merge());</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置结果集</span></div><div class="line">   setCurrentResultSet(result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><strong>SQL执行</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a></p>
</li>
<li>
<p><strong>结果归并</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/result-merger/?self">《Sharding-JDBC 源码分析 —— 结果归并》</a></p>
</li>
<li>
<p>结果归并 <code>#merge()</code> 完后，创建分片结果集( ShardingResultSet )</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractResultSetAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 归并结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSetMerger mergeResultSet;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnIndex, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnLabel, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 隐藏其他类似 getXXXX() 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h1>6. 读写分离</h1>
<p>建议前置阅读：<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/master-slave/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 读写分离》</a></p>
<p>当你有读写分离的需求时，将 ShardingRule 配置<strong>对应的数据源</strong> 从 ShardingDataSource 替换成 MasterSlaveDataSource。我们来看看 MasterSlaveDataSource 的功能和实现。</p>
<p><strong>支持一主多从的读写分离配置，可配合分库分表使用</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MasterSlaveDataSourceFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSourceFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建读写分离数据源.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> name 读写分离数据源名称</div><div class="line">     * <span class="doctag">@param</span> masterDataSource 主节点数据源</div><div class="line">     * <span class="doctag">@param</span> slaveDataSource 从节点数据源</div><div class="line">     * <span class="doctag">@param</span> otherSlaveDataSources 其他从节点数据源</div><div class="line">     * <span class="doctag">@return</span> 读写分离数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">createDataSource</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> DataSource masterDataSource, <span class="keyword">final</span> DataSource slaveDataSource, <span class="keyword">final</span> DataSource... otherSlaveDataSources)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MasterSlaveDataSource(name, masterDataSource, Lists.asList(slaveDataSource, otherSlaveDataSources));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource masterDataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从数据源集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DataSource&gt; slaveDataSources;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性。</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   String realDataSourceName;</div><div class="line">   <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123; <span class="comment">// 读写分离</span></div><div class="line">       dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">       realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       realDataSourceName = dataSourceName;</div><div class="line">   &#125;</div><div class="line">   Connection result = dataSource.getConnection();</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当前线程是否是 DML 操作标识</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; DML_FLAG = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;() &#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Boolean <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 从库负载均衡策略</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SlaveLoadBalanceStrategy slaveLoadBalanceStrategy = <span class="keyword">new</span> RoundRobinSlaveLoadBalanceStrategy();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取主或从节点的数据源.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@return</span> 主或从节点的数据源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isMasterRoute(sqlType)) &#123;</div><div class="line">       DML_FLAG.set(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span> masterDataSource;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> slaveLoadBalanceStrategy.getDataSource(name, slaveDataSources);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMasterRoute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.DQL != sqlType || DML_FLAG.get() || HintManagerHolder.isMasterRouteOnly();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>ShardingConnection 获取到的数据源是 MasterSlaveDataSource 时，调用 <code>MasterSlaveDataSource#getConnection()</code> 方法获取<strong>真实</strong>的数据源</p>
</li>
<li>
<p>通过 <code>#isMasterRoute()</code> 判断是否读取<strong>主库</strong>，以下三种情况会访问主库：</p>
<ul>
<li>非查询语句 (DQL)</li>
<li><strong>该</strong>数据源在<strong>当前</strong>线程访问过主库：通过线程变量 <code>DML_FLAG</code> 实现</li>
<li>强制主库：程序里调用 <code>HintManager.getInstance().setMasterRouteOnly()</code> 实现</li>
</ul>
</li>
<li>
<p>访问从库时，会通过负载均衡策略( SlaveLoadBalanceStrategy ) 选择一个从库</p>
<pre><code class="language-Java">// SlaveLoadBalanceStrategy.java
public interface SlaveLoadBalanceStrategy {
    
    /**
     * 根据负载均衡策略获取从库数据源.
     * 
     * @param name 读写分离数据源名称
     * @param slaveDataSources 从库数据源列表
     * @return 选中的从库数据源
     */
    DataSource getDataSource(String name, List&lt;DataSource&gt; slaveDataSources);
}

// RoundRobinSlaveLoadBalanceStrategy.java
public final class RoundRobinSlaveLoadBalanceStrategy implements SlaveLoadBalanceStrategy {
    
    private static final ConcurrentHashMap&lt;String, AtomicInteger&gt; COUNT_MAP = new ConcurrentHashMap&lt;&gt;();
    
    @Override
    public DataSource getDataSource(final String name, final List&lt;DataSource&gt; slaveDataSources) {
        AtomicInteger count = COUNT_MAP.containsKey(name) ? COUNT_MAP.get(name) : new AtomicInteger(0);
        COUNT_MAP.putIfAbsent(name, count);
        count.compareAndSet(slaveDataSources.size(), 0);
        return slaveDataSources.get(count.getAndIncrement() % slaveDataSources.size());
    }
}
</code></pre>
<ul>
<li>MasterSlaveDataSource 默认使用 RoundRobinSlaveLoadBalanceStrategy，暂时不支持配置</li>
<li>RoundRobinSlaveLoadBalanceStrategy，轮询负载均衡策略，<strong>每个从节点访问次数均衡，暂不支持数据源故障移除</strong></li>
</ul>
</li>
</ul>
<h1>666. 彩蛋</h1>
<p>没有彩蛋<br>
没有彩<br>
没有<br>
没</p>
<p>下一篇，<a href="http://www.yunai.me/Sharding-JDBC/transaction-bed/?self">《分布式事务（一）之最大努力型》</a>走起。老司机，赶紧上车。</p>
<p>道友，分享一个朋友圈可好？不然交个道姑那<s>敏感词</s>你。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 结果归并</title>
    <link href="http://www.yunai.me/Sharding-JDBC/result-merger/"/>
    <id>http://www.yunai.me/Sharding-JDBC/result-merger/</id>
    <published>2017-08-15T16:00:00.000Z</published>
    <updated>2017-08-10T17:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. MergeEngine</a>
<ul>
<li><a href="#">2.1 SelectStatement#setIndexForItems()</a></li>
<li><a href="#">2.2 ResultSetMerger</a>
<ul>
<li><a href="#">2.2.1 AbstractStreamResultSetMerger</a></li>
<li><a href="#">2.2.2 AbstractMemoryResultSetMerger</a></li>
<li><a href="#">2.2.3 AbstractDecoratorResultSetMerger</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">3. OrderByStreamResultSetMerger</a>
<ul>
<li><a href="#">3.1 归并算法</a></li>
<li><a href="#">3.2 #next()</a></li>
</ul>
</li>
<li><a href="#">4. GroupByStreamResultSetMerger</a>
<ul>
<li><a href="#">4.1 AggregationUnit</a></li>
<li><a href="#">4.2 #next()</a></li>
</ul>
</li>
<li><a href="#">5. GroupByMemoryResultSetMerger</a>
<ul>
<li><a href="#">5.1 #next()</a></li>
</ul>
</li>
<li><a href="#">6. IteratorStreamResultSetMerger</a></li>
<li><a href="#">7. LimitDecoratorResultSetMerger</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享<strong>查询结果归并</strong>的源码实现。</p>
<p>正如前文<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《SQL 执行》</a>提到的**“分表分库，需要执行的 SQL 数量从单条变成了多条”<strong>，多个</strong>SQL执行**结果必然需要进行合并，例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_time</div></pre></td></tr></table></figure></p>
<p>在各分片排序完后，Sharding-JDBC 获取到结果后，仍然需要再进一步排序。目前有 <strong>分页</strong>、<strong>分组</strong>、<strong>排序</strong>、<strong>聚合列</strong>、<strong>迭代</strong> 五种场景需要做进一步处理。当然，如果单分片<strong>SQL执行</strong>结果是无需合并的。在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《SQL 执行》</a>不知不觉已经分享了插入、更新、删除操作的结果合并，所以下面我们一起看看<strong>查询结果归并</strong>的实现。</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. MergeEngine</h1>
<p>MergeEngine，分片结果集归并引擎。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MergeEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 数据库类型</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> DatabaseType databaseType;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 结果集集合</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Select SQL语句对象</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 查询列名与位置映射</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MergeEngine</span><span class="params">(<span class="keyword">final</span> DatabaseType databaseType, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.databaseType = databaseType;</div><div class="line">   <span class="keyword">this</span>.resultSets = resultSets;</div><div class="line">   <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">   <span class="comment">// 获得 查询列名与位置映射</span></div><div class="line">   columnLabelIndexMap = getColumnLabelIndexMap(resultSets.get(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 查询列名与位置映射</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> resultSet 结果集</div><div class="line">* <span class="doctag">@return</span> 查询列名与位置映射</div><div class="line">* <span class="doctag">@throws</span> SQLException 当结果集已经关闭</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">getColumnLabelIndexMap</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSetMetaData resultSetMetaData = resultSet.getMetaData(); <span class="comment">// 元数据（包含查询列信息）</span></div><div class="line">   Map&lt;String, Integer&gt; result = <span class="keyword">new</span> TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= resultSetMetaData.getColumnCount(); i++) &#123;</div><div class="line">       result.put(SQLUtil.getExactlyValue(resultSetMetaData.getColumnLabel(i)), i);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 MergeEngine 被创建时，会传入 <code>resultSets</code> 结果集集合，并根据其获得 <code>columnLabelIndexMap</code> 查询列名与位置映射。通过 <code>columnLabelIndexMap</code>，可以很方便的使用查询列名获得在返回结果记录列( header )的第几列。</li>
</ul>
<hr>
<p>MergeEngine 的 <code>#merge()</code> 方法作为入口提供<strong>查询结果归并</strong>功能。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 合并结果集.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 归并完毕后的结果集</div><div class="line">* <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> ResultSetMerger <span class="title">merge</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   selectStatement.setIndexForItems(columnLabelIndexMap);</div><div class="line">   <span class="keyword">return</span> decorate(build());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#merge()</code> 主体逻辑就两行代码，设置查询列位置信息，并返回<strong>合适</strong>的归并结果集接口( ResultSetMerger ) 实现。</li>
</ul>
<h2>2.1 SelectStatement#setIndexForItems()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SelectStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 为选择项设置索引.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> columnLabelIndexMap 列标签索引字典</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndexForItems</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap)</span> </span>&#123;</div><div class="line">   setIndexForAggregationItem(columnLabelIndexMap);</div><div class="line">   setIndexForOrderItem(columnLabelIndexMap, orderByItems);</div><div class="line">   setIndexForOrderItem(columnLabelIndexMap, groupByItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>部分<strong>查询列</strong>是经过<strong>推到</strong>出来，在 <strong>SQL解析</strong> 过程中，未获得到查询列位置，需要通过该方法进行初始化。对这块不了解的同学，回头可以看下<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之查询SQL》</a>。🙂 现在不用回头，皇冠会掉。</p>
</li>
<li>
<p><code>#setIndexForAggregationItem()</code> 处理 <strong>AVG聚合计算列</strong> 推导出其对应的 <strong>SUM/COUNT 聚合计算列</strong>的位置：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndexForAggregationItem</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (AggregationSelectItem each : getAggregationSelectItems()) &#123;</div><div class="line">       Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format(<span class="string">"Can't find index: %s, please add alias for aggregate selections"</span>, each));</div><div class="line">       each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));</div><div class="line">       <span class="keyword">for</span> (AggregationSelectItem derived : each.getDerivedAggregationSelectItems()) &#123;</div><div class="line">           Preconditions.checkState(columnLabelIndexMap.containsKey(derived.getColumnLabel()), String.format(<span class="string">"Can't find index: %s"</span>, derived));</div><div class="line">           derived.setIndex(columnLabelIndexMap.get(derived.getColumnLabel()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>#setIndexForOrderItem()</code> 处理 <strong>ORDER BY / GROUP BY 列不在查询列</strong> 推导出的<strong>查询列</strong>的位置：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndexForOrderItem</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">      <span class="keyword">if</span> (-<span class="number">1</span> != each.getIndex()) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      Preconditions.checkState(columnLabelIndexMap.containsKey(each.getColumnLabel()), String.format(<span class="string">"Can't find index: %s"</span>, each));</div><div class="line">      <span class="keyword">if</span> (columnLabelIndexMap.containsKey(each.getColumnLabel())) &#123;</div><div class="line">          each.setIndex(columnLabelIndexMap.get(each.getColumnLabel()));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h2>2.2 ResultSetMerger</h2>
<p>ResultSetMerger，归并结果集接口。</p>
<p>我们先来看看整体的类结构关系：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/04.png" alt=""></p>
<p>从 <strong>功能</strong> 上分成四种：</p>
<ul>
<li>分组：GroupByMemoryResultSetMerger、GroupByStreamResultSetMerger；包含<strong>聚合列</strong></li>
<li>排序：OrderByStreamResultSetMerger</li>
<li>迭代：IteratorStreamResultSetMerger</li>
<li>分页：LimitDecoratorResultSetMerger</li>
</ul>
<p>从 <strong>实现方式</strong> 上分成三种：</p>
<ul>
<li>Stream 流式：AbstractStreamResultSetMerger</li>
<li>Memory 内存：AbstractMemoryResultSetMerger</li>
<li>Decorator 装饰者：AbstractDecoratorResultSetMerger</li>
</ul>
<p><strong>什么时候该用什么实现方式？</strong></p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/06.png" alt=""></p>
<ul>
<li>Stream 流式：将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。看完下文<em>第三节</em> OrderByStreamResultSetMerger 可以形象的理解。</li>
<li>Memory 内存：需要将结果集的所有数据都遍历并存储在内存中，再通过内存归并后，将内存中的数据伪装成结果集返回。看完下文<em>第五节</em> GroupByMemoryResultSetMerger 可以形象的理解。</li>
<li>Decorator 装饰者：可以和前二者任意组合</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MergeEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 合并结果集.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 归并完毕后的结果集</div><div class="line">* <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> ResultSetMerger <span class="title">merge</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   selectStatement.setIndexForItems(columnLabelIndexMap);</div><div class="line">   <span class="keyword">return</span> decorate(build());</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> ResultSetMerger <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &#123; <span class="comment">// 分组 或 聚合列</span></div><div class="line">       <span class="keyword">if</span> (selectStatement.isSameGroupByAndOrderByItems()) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> GroupByStreamResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> GroupByMemoryResultSetMerger(columnLabelIndexMap, resultSets, selectStatement, getNullOrderType());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!selectStatement.getOrderByItems().isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> OrderByStreamResultSetMerger(resultSets, selectStatement.getOrderByItems(), getNullOrderType());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamResultSetMerger(resultSets);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> ResultSetMerger <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> ResultSetMerger resultSetMerger)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSetMerger result = resultSetMerger;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != selectStatement.getLimit()) &#123;</div><div class="line">       result = <span class="keyword">new</span> LimitDecoratorResultSetMerger(result, selectStatement.getLimit());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.1 AbstractStreamResultSetMerger</h3>
<p>AbstractStreamResultSetMerger，<strong>流式</strong>归并结果集抽象类，提供从<strong>当前结果集</strong>获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStreamResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ResultSet currentResultSet;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> ResultSet <span class="title">getCurrentResultSet</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == currentResultSet) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Current ResultSet is null, ResultSet perhaps end of next."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> currentResultSet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Object.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getObject(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">int</span>.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getInt(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (String.class == type) &#123;</div><div class="line">            <span class="keyword">return</span> getCurrentResultSet().getString(columnIndex);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// .... 省略其他数据类型读取类似代码</span></div><div class="line">        <span class="keyword">return</span> getCurrentResultSet().getObject(columnIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.2 AbstractMemoryResultSetMerger</h3>
<p>AbstractMemoryResultSetMerger，<strong>内存</strong>归并结果集抽象类，提供从<strong>内存数据行对象( MemoryResultSetRow )</strong> 获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMemoryResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内存数据行对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> MemoryResultSetRow currentResultSetRow;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Blob.class == type || Clob.class == type || Reader.class == type || InputStream.class == type || SQLXML.class == type) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> currentResultSetRow.getCell(columnIndex);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>和 AbstractStreamResultSetMerger 对比，貌似区别不大？！确实，从抽象父类上看，两种实现方式差不多。抽象父类提供给实现子类的是<strong>数据读取</strong>的功能，真正的流式归并、内存归并是在子类实现上体现。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryResultSetRow</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 行数据</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] data;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemoryResultSetRow</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        data = load(resultSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 加载 ResultSet 当前行数据到内存</div><div class="line">     * <span class="doctag">@param</span> resultSet 结果集</div><div class="line">     * <span class="doctag">@return</span> 行数据</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Object[] load(<span class="keyword">final</span> ResultSet resultSet) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">int</span> columnCount = resultSet.getMetaData().getColumnCount();</div><div class="line">        Object[] result = <span class="keyword">new</span> Object[columnCount];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) &#123;</div><div class="line">            result[i] = resultSet.getObject(i + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取数据.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> columnIndex 列索引</div><div class="line">     * <span class="doctag">@return</span> 数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCell</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(columnIndex &gt; <span class="number">0</span> &amp;&amp; columnIndex &lt; data.length + <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> data[columnIndex - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置数据.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> columnIndex 列索引</div><div class="line">     * <span class="doctag">@param</span> value 值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCell</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(columnIndex &gt; <span class="number">0</span> &amp;&amp; columnIndex &lt; data.length + <span class="number">1</span>);</div><div class="line">        data[columnIndex - <span class="number">1</span>] = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#load()</code> 方法，将当前结果集的一条行数据加载到内存。</li>
</ul>
<h3>2.2.3 AbstractDecoratorResultSetMerger</h3>
<p>AbstractDecoratorResultSetMerger，装饰结果集归并抽象类，通过调用<strong>其装饰的归并对象</strong> <code>#getValue()</code> 方法获得行数据。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecoratorResultSetMerger</span> <span class="keyword">implements</span> <span class="title">ResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 装饰的归并对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSetMerger resultSetMerger;</div><div class="line">        </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> resultSetMerger.getValue(columnIndex, type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. OrderByStreamResultSetMerger</h1>
<p>OrderByStreamResultSetMerger，基于 <strong>Stream</strong> 方式排序归并结果集实现。</p>
<h2>3.1 归并算法</h2>
<p>因为<strong>各个分片结果集已经排序完成</strong>，使用**<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">《归并算法》</a>**能够充分利用这个优势。</p>
<blockquote>
<p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<p>【迭代法】</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
</blockquote>
<p>从定义上看，是不是超级符合我们这个场景。😈 此时此刻，你是不是捂着胸口，感叹：“大学怎么没好好学数据结构与算法呢”？反正我是捂着了，都是眼泪。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/01.jpg" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.NONE)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序值对象队列</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;OrderByValue&gt; orderByValuesQueue;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否第一个 ResultSet 已经调用 #next()</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstNext;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderByStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems, <span class="keyword">final</span> OrderType nullOrderType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.orderByItems = orderByItems;</div><div class="line">        <span class="keyword">this</span>.orderByValuesQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(resultSets.size());</div><div class="line">        <span class="keyword">this</span>.nullOrderType = nullOrderType;</div><div class="line">        orderResultSetsToQueue(resultSets);</div><div class="line">        isFirstNext = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orderResultSetsToQueue</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</div><div class="line">            OrderByValue orderByValue = <span class="keyword">new</span> OrderByValue(each, orderByItems, nullOrderType);</div><div class="line">            <span class="keyword">if</span> (orderByValue.next()) &#123;</div><div class="line">                orderByValuesQueue.offer(orderByValue);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        setCurrentResultSet(orderByValuesQueue.isEmpty() ? resultSets.get(<span class="number">0</span>) : orderByValuesQueue.peek().getResultSet());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>属性 <code>orderByValuesQueue</code> 使用的队列实现是<strong>优先级</strong>队列( PriorityQueue )。有兴趣的同学可以看看<a href="http://wlh0706-163-com.iteye.com/blog/1850125" rel="external nofollow noopener noreferrer" target="_blank">《JDK源码研究PriorityQueue》</a>，本文不展开讲，不是主角戏份不多。我们记住几个方法的用途：</p>
<ul>
<li><code>#offer()</code>：增加元素。增加时，会将该元素和已有元素们按照<strong>优先级</strong>进行排序</li>
<li><code>#peek()</code>：获得优先级第一的元素</li>
<li><code>#pool()</code>：获得优先级第一的元素<strong>并移除</strong></li>
</ul>
</li>
<li>
<p>一个 ResultSet 构建一个 OrderByValue 用于排序，即上文<strong>归并算法</strong>提到的**“空间”**。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">OrderByValue</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 已排序结果集</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSet resultSet;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序列对应的值数组</div><div class="line">     * 因为一条记录可能有多个排序列，所以是数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; orderValues;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 遍历下一个结果集游标.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 是否有下一个结果集</div><div class="line">     * <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = resultSet.next();</div><div class="line">        orderValues = result ? getOrderValues() : Collections.&lt;Comparable&lt;?&gt;&gt;emptyList();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得 排序列对应的值数组</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 排序列对应的值数组</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭时</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; getOrderValues() <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        List&lt;Comparable&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(orderByItems.size());</div><div class="line">        <span class="keyword">for</span> (OrderItem each : orderByItems) &#123;</div><div class="line">            Object value = resultSet.getObject(each.getIndex());</div><div class="line">            Preconditions.checkState(<span class="keyword">null</span> == value || value <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">            result.add((Comparable&lt;?&gt;) value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 对比 &#123;<span class="doctag">@link</span> #orderValues&#125;，即两者的第一条记录</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> o 对比 OrderByValue</div><div class="line">     * <span class="doctag">@return</span> -1 0 1</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> OrderByValue o)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderByItems.size(); i++) &#123;</div><div class="line">            OrderItem thisOrderBy = orderByItems.get(i);</div><div class="line">            <span class="keyword">int</span> result = ResultSetUtil.compareTo(orderValues.get(i), o.orderValues.get(i), thisOrderBy.getType(), nullOrderType);</div><div class="line">            <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>OrderByValue#next()</code> 方法时，获得其对应结果集<strong>排在第一条</strong>的记录，通过 <code>#getOrderValues()</code> 计算该记录的排序字段值。这样<strong>两个OrderByValue</strong> 通过 <code>#compareTo()</code> 方法可以比较<strong>两个结果集</strong>的第一条记录。</li>
</ul>
</li>
<li>
<p><code>if (orderByValue.next()) {</code> 处，调用 <code>OrderByValue#next()</code> 后，添加到 PriorityQueue。因此，<code>orderByValuesQueue.peek().getResultSet()</code> 能够获得多个 ResultSet 中排在第一的。</p>
</li>
</ul>
<h2>3.2 #next()</h2>
<p>通过调用 <code>OrderByStreamResultSetMerger#next()</code> 不断获得当前排在第一的记录。<code>#next()</code> 每次调用后，实际做的是当前 ResultSet 的替换，以及当前的 ResultSet 的记录指向下一条。这样说起来可能比较绕，我们来看一张图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/02.png" alt=""></p>
<ul>
<li>白色向下箭头：OrderByStreamResultSetMerger 对 ResultSet 的指向。</li>
<li>黑色箭头：ResultSet 对当前记录的指向。</li>
<li>ps：这块如果分享的不清晰让您费劲，十分抱歉。欢迎加我微信（wangwenbin-server）交流下，这样我也可以优化表述。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OrderByStreamResultSetMerger.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isFirstNext) &#123;</div><div class="line">       isFirstNext = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除上一次获得的 ResultSet</span></div><div class="line">   OrderByValue firstOrderByValue = orderByValuesQueue.poll();</div><div class="line">   <span class="comment">// 如果上一次获得的 ResultSet还有下一条记录，继续添加到 排序值对象队列</span></div><div class="line">   <span class="keyword">if</span> (firstOrderByValue.next()) &#123;</div><div class="line">       orderByValuesQueue.offer(firstOrderByValue);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置当前 ResultSet</span></div><div class="line">   setCurrentResultSet(orderByValuesQueue.peek().getResultSet());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>orderByValuesQueue.poll()</code> 移除上一次获得的 ResultSet。为什么不能 <code>#setCurrentResultSet()</code> 就移除呢？如果该 ResultSet 里面还存在下一条记录，需要继续参加<strong>排序</strong>。而判断是否有下一条，需要调用 <code>ResultSet#next()</code> 方法，这会导致 ResultSet 指向了下一条记录。因而 <code>orderByValuesQueue.poll()</code> 调用是<strong>后置</strong>的。</p>
</li>
<li>
<p><code>isFirstNext</code> 变量那的判断看着是不是很“灵异”？因为 <code>#orderResultSetsToQueue()</code> 处设置了第一次的 ResultSet。如果不加这个标记，会导致第一条记录“不见”了。</p>
</li>
<li>
<p>通过不断的 <code>Queue#poll()</code>、<code>Queue#offset()</code> 实现排序。巧妙！仿佛 Get 新技能了：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 移除上一次获得的 ResultSet</span></div><div class="line">OrderByValue firstOrderByValue = orderByValuesQueue.poll();</div><div class="line"><span class="comment">// 如果上一次获得的 ResultSet还有下一条记录，继续添加到 排序值对象队列</span></div><div class="line"><span class="keyword">if</span> (firstOrderByValue.next()) &#123;</div><div class="line">  orderByValuesQueue.offer(firstOrderByValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<hr>
<p>在看下，我们上文 Stream 方式归并的定义：**将数据游标与结果集的游标保持一致，顺序的从结果集中一条条的获取正确的数据。**是不是能够清晰的对上了？！🙂</p>
<h1>4. GroupByStreamResultSetMerger</h1>
<p>GroupByStreamResultSetMerger，基于 <strong>Stream</strong> 方式分组归并结果集实现。 它继承自 OrderByStreamResultSetMerger，在<strong>排序</strong>的逻辑上，实现分组功能。实现原理也较为简单：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/03.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">OrderByStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询列名与位置映射</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Select SQL语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前结果记录</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; currentRow;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 下一条结果记录 GROUP BY 条件</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;?&gt; currentGroupByValues;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByStreamResultSetMerger</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> OrderType nullOrderType) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">super</span>(resultSets, selectStatement.getOrderByItems(), nullOrderType);</div><div class="line">        <span class="keyword">this</span>.labelAndIndexMap = labelAndIndexMap;</div><div class="line">        <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">        currentRow = <span class="keyword">new</span> ArrayList&lt;&gt;(labelAndIndexMap.size());</div><div class="line">        <span class="comment">// 初始化下一条结果记录 GROUP BY 条件</span></div><div class="line">        currentGroupByValues = getOrderByValuesQueue().isEmpty() ? Collections.emptyList() : <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> currentRow.get(columnIndex - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> String columnLabel, <span class="keyword">final</span> Class&lt;?&gt; type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Preconditions.checkState(labelAndIndexMap.containsKey(columnLabel), String.format(<span class="string">"Can't find columnLabel: %s"</span>, columnLabel));</div><div class="line">        <span class="keyword">return</span> currentRow.get(labelAndIndexMap.get(columnLabel) - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>currentRow</code> 为当前结果记录，使用 <code>#getValue()</code>、<code>#getCalendarValue()</code> 方法获得当前结果记录的查询列值。</p>
</li>
<li>
<p><code>currentGroupByValues</code> 为<strong>下一条</strong>结果记录 GROUP BY 条件，通过 GroupByValue 生成：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByValue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组条件值数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; groupValues;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByValue</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        groupValues = getGroupByValues(resultSet, groupByItems);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获得分组条件值数组</div><div class="line">     * 例如，`GROUP BY user_id, order_status` 返回的某条记录结果为 `userId = 1, order_status = 3`，对应的 `groupValues = [1, 3]`</div><div class="line">     * <span class="doctag">@param</span> resultSet 结果集（单分片）</div><div class="line">     * <span class="doctag">@param</span> groupByItems 分组列</div><div class="line">     * <span class="doctag">@return</span> 分组条件值数组</div><div class="line">     * <span class="doctag">@throws</span> SQLException 当结果集关闭</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> List&lt;?&gt; getGroupByValues(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        List&lt;Object&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(groupByItems.size());</div><div class="line">        <span class="keyword">for</span> (OrderItem each : groupByItems) &#123;</div><div class="line">            result.add(resultSet.getObject(each.getIndex())); <span class="comment">// 从结果集获得每个分组条件的值</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>GroupByStreamResultSetMerger 在创建时，当前结果记录<strong>实际未合并</strong>，需要先调用 <code>#next()</code>，在使用 <code>#getValue()</code> 等方法获取值，这个和 OrderByStreamResultSetMerger 不同，可能是个 BUG。</p>
</li>
</ul>
<h2>4.1 AggregationUnit</h2>
<p>AggregationUnit，归并计算单元接口，有两个接口方法：</p>
<ul>
<li><code>#merge()</code>：归并聚合值</li>
<li><code>#getResult()</code>：获取计算结果</li>
</ul>
<p>一共有三个实现类：</p>
<ul>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/AccumulationAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">AccumulationAggregationUnit</a>：累加聚合单元，解决 COUNT、SUM 聚合列</li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/ComparableAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">ComparableAggregationUnit</a>：比较聚合单元，解决 MAX、MIN 聚合列</li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/merger/groupby/aggregation/AverageAggregationUnit.java" rel="external nofollow noopener noreferrer" target="_blank">AverageAggregationUnit</a>：平均值聚合单元，解决 AVG 聚合列</li>
</ul>
<p>实现都比较易懂，直接点击链接查看源码，我们就不浪费篇幅贴代码啦。</p>
<h2>4.2 #next()</h2>
<p>我们先看看大体的调用流程：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/05.png" alt=""></p>
<p>😈 看起来代码比较多，逻辑其实比较清晰，对照着顺序图顺序往下读即可。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GroupByStreamResultSetMerger.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// 清除当前结果记录</span></div><div class="line">   currentRow.clear();</div><div class="line">   <span class="keyword">if</span> (getOrderByValuesQueue().isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (isFirstNext()) &#123;</div><div class="line">       <span class="keyword">super</span>.next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 顺序合并下面相同分组条件的记录</span></div><div class="line">   <span class="keyword">if</span> (aggregateCurrentGroupByRowAndNext()) &#123;</div><div class="line">       <span class="comment">// 生成下一条结果记录 GROUP BY 条件</span></div><div class="line">       currentGroupByValues = <span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">aggregateCurrentGroupByRowAndNext</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">   <span class="comment">// 生成计算单元</span></div><div class="line">   Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 循环顺序合并下面相同分组条件的记录</span></div><div class="line">   <span class="keyword">while</span> (currentGroupByValues.equals(<span class="keyword">new</span> GroupByValue(getCurrentResultSet(), selectStatement.getGroupByItems()).getGroupValues())) &#123;</div><div class="line">       <span class="comment">// 归并聚合值</span></div><div class="line">       aggregate(aggregationUnitMap);</div><div class="line">       <span class="comment">// 缓存当前记录到结果记录</span></div><div class="line">       cacheCurrentRow();</div><div class="line">       <span class="comment">// 获取下一条记录</span></div><div class="line">       result = <span class="keyword">super</span>.next();</div><div class="line">       <span class="keyword">if</span> (!result) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置当前记录的聚合字段结果</span></div><div class="line">   setAggregationValueToCurrentRow(aggregationUnitMap);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(<span class="keyword">final</span> Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;AggregationSelectItem, AggregationUnit&gt; entry : aggregationUnitMap.entrySet()) &#123;</div><div class="line">       List&lt;Comparable&lt;?&gt;&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</div><div class="line">       <span class="keyword">if</span> (entry.getKey().getDerivedAggregationSelectItems().isEmpty()) &#123; <span class="comment">// SUM/COUNT/MAX/MIN 聚合列</span></div><div class="line">           values.add(getAggregationValue(entry.getKey()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (AggregationSelectItem each : entry.getKey().getDerivedAggregationSelectItems()) &#123; <span class="comment">// AVG 聚合列</span></div><div class="line">               values.add(getAggregationValue(each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       entry.getValue().merge(values);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheCurrentRow</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getCurrentResultSet().getMetaData().getColumnCount(); i++) &#123;</div><div class="line">       currentRow.add(getCurrentResultSet().getObject(i + <span class="number">1</span>));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span> Comparable&lt;?&gt; getAggregationValue(<span class="keyword">final</span> AggregationSelectItem aggregationSelectItem) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   Object result = getCurrentResultSet().getObject(aggregationSelectItem.getIndex());</div><div class="line">   Preconditions.checkState(<span class="keyword">null</span> == result || result <span class="keyword">instanceof</span> Comparable, <span class="string">"Aggregation value must implements Comparable"</span>);</div><div class="line">   <span class="keyword">return</span> (Comparable&lt;?&gt;) result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAggregationValueToCurrentRow</span><span class="params">(<span class="keyword">final</span> Map&lt;AggregationSelectItem, AggregationUnit&gt; aggregationUnitMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;AggregationSelectItem, AggregationUnit&gt; entry : aggregationUnitMap.entrySet()) &#123;</div><div class="line">       currentRow.set(entry.getKey().getIndex() - <span class="number">1</span>, entry.getValue().getResult()); <span class="comment">// 获取计算结果</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>5. GroupByMemoryResultSetMerger</h1>
<p>GroupByMemoryResultSetMerger，基于 <strong>内存</strong> 分组归并结果集实现。</p>
<p>区别于 GroupByStreamResultSetMerger，其无法使用每个分片结果集的<strong>有序</strong>的特点，只能在内存中合并后，进行<strong>整个</strong>重新排序。因而，性能和内存都较 GroupByStreamResultSetMerger 会差。</p>
<p>主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_16/07.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupByMemoryResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractMemoryResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Select SQL语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SelectStatement selectStatement;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 默认排序类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType nullOrderType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内存结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;MemoryResultSetRow&gt; memoryResultSetRows;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupByMemoryResultSetMerger</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">final</span> Map&lt;String, Integer&gt; labelAndIndexMap, <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> OrderType nullOrderType) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="keyword">super</span>(labelAndIndexMap);</div><div class="line">        <span class="keyword">this</span>.selectStatement = selectStatement;</div><div class="line">        <span class="keyword">this</span>.nullOrderType = nullOrderType;</div><div class="line">        memoryResultSetRows = init(resultSets);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> Iterator&lt;MemoryResultSetRow&gt; <span class="title">init</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>); <span class="comment">// 分组条件值与内存记录映射</span></div><div class="line">        Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>); <span class="comment">// 分组条件值与聚合列映射</span></div><div class="line">        <span class="comment">// 遍历结果集</span></div><div class="line">        <span class="keyword">for</span> (ResultSet each : resultSets) &#123;</div><div class="line">            <span class="keyword">while</span> (each.next()) &#123;</div><div class="line">                <span class="comment">// 生成分组条件</span></div><div class="line">                GroupByValue groupByValue = <span class="keyword">new</span> GroupByValue(each, selectStatement.getGroupByItems());</div><div class="line">                <span class="comment">// 初始化分组条件到 dataMap、aggregationMap 映射</span></div><div class="line">                initForFirstGroupByValue(each, groupByValue, dataMap, aggregationMap);</div><div class="line">                <span class="comment">// 归并聚合值</span></div><div class="line">                aggregate(each, groupByValue, aggregationMap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置聚合列结果到内存记录</span></div><div class="line">        setAggregationValueToMemoryRow(dataMap, aggregationMap);</div><div class="line">        <span class="comment">// 内存排序</span></div><div class="line">        List&lt;MemoryResultSetRow&gt; result = getMemoryResultSetRows(dataMap);</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</div><div class="line">            setCurrentResultSetRow(result.get(<span class="number">0</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.iterator();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>#initForFirstGroupByValue()</code> 初始化<strong>分组条件</strong>到 <code>dataMap</code>，<code>aggregationMap</code> 映射中，这样可以调用 <code>#aggregate()</code> 将聚合值归并到 <code>aggregationMap</code> 里的该分组条件。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initForFirstGroupByValue</span><span class="params">(<span class="keyword">final</span> ResultSet resultSet, <span class="keyword">final</span> GroupByValue groupByValue, <span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap, </span></span></div><div class="line">                                          <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">        <span class="comment">// 初始化分组条件到 dataMap</span></div><div class="line">        <span class="keyword">if</span> (!dataMap.containsKey(groupByValue)) &#123;</div><div class="line">            dataMap.put(groupByValue, <span class="keyword">new</span> MemoryResultSetRow(resultSet));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 初始化分组条件到 aggregationMap</span></div><div class="line">        <span class="keyword">if</span> (!aggregationMap.containsKey(groupByValue)) &#123;</div><div class="line">            Map&lt;AggregationSelectItem, AggregationUnit&gt; map = Maps.toMap(selectStatement.getAggregationSelectItems(), <span class="keyword">new</span> Function&lt;AggregationSelectItem, AggregationUnit&gt;() &#123;</div><div class="line">                </div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> AggregationUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> AggregationSelectItem input)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> AggregationUnitFactory.create(input.getType());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            aggregationMap.put(groupByValue, map);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ``` </div><div class="line">* 聚合完每个分组条件后，将聚合列结果 `aggregationMap` 合并到 `dataMap`。</div><div class="line"></div><div class="line">    ```<span class="function">Java</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAggregationValueToMemoryRow</span><span class="params">(<span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap, <span class="keyword">final</span> Map&lt;GroupByValue, Map&lt;AggregationSelectItem, AggregationUnit&gt;&gt; aggregationMap)</span> &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;GroupByValue, MemoryResultSetRow&gt; entry : dataMap.entrySet()) &#123; <span class="comment">// 遍 历内存记录</span></div><div class="line">           <span class="keyword">for</span> (AggregationSelectItem each : selectStatement.getAggregationSelectItems()) &#123; <span class="comment">// 遍历 每个聚合列</span></div><div class="line">               entry.getValue().setCell(each.getIndex(), aggregationMap.get(entry.getKey()).get(each).getResult());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>#getMemoryResultSetRows()</code> 方法对内存记录进行<strong>内存排序</strong>。</p>
</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GroupByMemoryResultSetMerger.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;MemoryResultSetRow&gt; <span class="title">getMemoryResultSetRows</span><span class="params">(<span class="keyword">final</span> Map&lt;GroupByValue, MemoryResultSetRow&gt; dataMap)</span> </span>&#123;</div><div class="line">   List&lt;MemoryResultSetRow&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(dataMap.values());</div><div class="line">   Collections.sort(result, <span class="keyword">new</span> GroupByRowComparator(selectStatement, nullOrderType)); <span class="comment">// 内存排序</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GroupByRowComparator.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> MemoryResultSetRow o1, <span class="keyword">final</span> MemoryResultSetRow o2, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">       Object orderValue1 = o1.getCell(each.getIndex());</div><div class="line">       Preconditions.checkState(<span class="keyword">null</span> == orderValue1 || orderValue1 <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">       Object orderValue2 = o2.getCell(each.getIndex());</div><div class="line">       Preconditions.checkState(<span class="keyword">null</span> == orderValue2 || orderValue2 <span class="keyword">instanceof</span> Comparable, <span class="string">"Order by value must implements Comparable"</span>);</div><div class="line">       <span class="keyword">int</span> result = ResultSetUtil.compareTo((Comparable) orderValue1, (Comparable) orderValue2, each.getType(), nullOrderType);</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>总的来说，GROUP BY 内存归并和我们日常使用 Map 计算用户订单数是比较相似的。</li>
</ul>
<h2>5.1 #next()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (memoryResultSetRows.hasNext()) &#123;</div><div class="line">       setCurrentResultSetRow(memoryResultSetRows.next());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>内存归并完成后，使用 <code>memoryResultSetRows</code> 不断获得下一条记录。</li>
</ul>
<h1>6. IteratorStreamResultSetMerger</h1>
<p>IteratorStreamResultSetMerger，基于 <strong>Stream</strong> 迭代归并结果集实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorStreamResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractStreamResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ResultSet 数组迭代器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ResultSet&gt; resultSets;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IteratorStreamResultSetMerger</span><span class="params">(<span class="keyword">final</span> List&lt;ResultSet&gt; resultSets)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.resultSets = resultSets.iterator();</div><div class="line">        <span class="comment">// 设置当前 ResultSet，这样 #getValue() 能拿到记录</span></div><div class="line">        setCurrentResultSet(<span class="keyword">this</span>.resultSets.next());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="comment">// 当前 ResultSet 迭代下一条记录</span></div><div class="line">        <span class="keyword">if</span> (getCurrentResultSet().next()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!resultSets.hasNext()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获得下一个ResultSet， 设置当前 ResultSet</span></div><div class="line">        setCurrentResultSet(resultSets.next());</div><div class="line">        <span class="keyword">boolean</span> hasNext = getCurrentResultSet().next();</div><div class="line">        <span class="keyword">if</span> (hasNext) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!hasNext &amp;&amp; resultSets.hasNext()) &#123;</div><div class="line">            setCurrentResultSet(resultSets.next());</div><div class="line">            hasNext = getCurrentResultSet().next();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> hasNext;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>7. LimitDecoratorResultSetMerger</h1>
<p>LimitDecoratorResultSetMerger，基于 <strong>Decorator</strong> 分页结果集归并实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitDecoratorResultSetMerger</span> <span class="keyword">extends</span> <span class="title">AbstractDecoratorResultSetMerger</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页条件</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Limit limit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否全部记录都跳过了，即无符合条件记录</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> skipAll;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前已返回行数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rowNumber;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitDecoratorResultSetMerger</span><span class="params">(<span class="keyword">final</span> ResultSetMerger resultSetMerger, <span class="keyword">final</span> Limit limit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(resultSetMerger);</div><div class="line">        <span class="keyword">this</span>.limit = limit;</div><div class="line">        skipAll = skipOffset();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipOffset</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="comment">// 跳过 skip 记录</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit.getOffsetValue(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!getResultSetMerger().next()) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 行数</span></div><div class="line">        rowNumber = limit.isRowCountRewriteFlag() ? <span class="number">0</span> : limit.getOffsetValue();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (skipAll) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 获得下一条记录</span></div><div class="line">        <span class="keyword">if</span> (limit.getRowCountValue() &gt; -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> ++rowNumber &lt;= limit.getRowCountValue() &amp;&amp; getResultSetMerger().next();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 部分db 可以直 offset，不写 limit 行数，例如 oracle</span></div><div class="line">        <span class="keyword">return</span> getResultSetMerger().next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>LimitDecoratorResultSetMerger 可以对其他 ResultSetMerger 进行装饰，调用其他 ResultSetMerger 的 <code>#next()</code> 不断获得下一条记录。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>诶？应该是有蛮多地方解释的不是很清晰，如果让您阅读误解或是阻塞，非常抱歉。代码读起来比较易懂，使用文字来解释，对表述能力较差的自己，可能就绞尽脑汁，一脸懵逼。</p>
<p>恩，如果可以，还烦请把读起来不太爽的地方告诉我，谢谢。</p>
<p>厚着脸皮，道友，分享一波朋友圈可好？</p>
<p>如下是小礼包，嘿嘿</p>
<table>
<thead>
<tr>
<th>归并结果集接口</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>OrderByStreamResultSetMerger</td>
<td><code>SELECT * FROM t_order ORDER BY id</code></td>
</tr>
<tr>
<td>GroupByStreamResultSetMerger</td>
<td><code>SELECT uid, AVG(id) FROM t_order GROUP BY uid</code></td>
</tr>
<tr>
<td>GroupByMemoryResultSetMerger</td>
<td><code>SELECT uid FROM t_order GROUP BY id ORDER BY id DESC</code></td>
</tr>
<tr>
<td>IteratorStreamResultSetMerger</td>
<td><code>SELECT * FROM t_order</code></td>
</tr>
<tr>
<td>LimitDecoratorResultSetMerger</td>
<td><code>SELECT * FROM t_order ORDER BY id LIMIT 10</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 执行</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-execute/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-execute/</id>
    <published>2017-08-13T16:00:00.000Z</published>
    <updated>2017-08-10T17:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ExecutorEngine</a>
<ul>
<li><a href="#">2.1 ListeningExecutorService</a></li>
<li><a href="#">2.2 关闭</a></li>
<li><a href="#">2.3 执行 SQL 任务</a></li>
</ul>
</li>
<li><a href="#">3. Executor</a>
<ul>
<li><a href="#">3.1 StatementExecutor</a></li>
<li><a href="#">3.2 PreparedStatementExecutor</a></li>
<li><a href="#">3.3 BatchPreparedStatementExecutor</a></li>
</ul>
</li>
<li><a href="#">4. ExecutionEvent</a>
<ul>
<li><a href="#">4.1 EventBus</a></li>
<li><a href="#">4.2 BestEffortsDeliveryListener</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>越过千山万水（SQL 解析、SQL 路由、SQL 改写），我们终于来到了 <strong>SQL 执行</strong>。开森不开森？！</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/01.png" alt=""></p>
<p>本文主要分享<strong>SQL 执行</strong>的过程，不包括<strong>结果聚合</strong>。<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> <strong>东半球第二良心笔者</strong>会更新，关注微信公众号<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>完稿后<strong>第一时间</strong>通知您哟。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/06.png" alt=""></p>
<p><strong>绿框部分</strong> SQL 执行主流程。</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. ExecutorEngine</h1>
<p>ExecutorEngine，SQL执行引擎。</p>
<p>分表分库，需要执行的 SQL 数量从单条变成了多条，此时有两种方式执行：</p>
<ul>
<li><strong>串行</strong>执行 SQL</li>
<li><strong>并行</strong>执行 SQL</li>
</ul>
<p>前者，编码容易，性能较差，总耗时是多条 SQL 执行时间累加。<br>
后者，编码复杂，性能较好，总耗时约等于执行时间最长的 SQL。</p>
<p>👼 ExecutorEngine 当然采用的是<strong>后者</strong>，并行执行 SQL。</p>
<h2>2.1 ListeningExecutorService</h2>
<p><a href="http://www.yiibai.com/guava/" rel="external nofollow noopener noreferrer" target="_blank">Guava( Java 工具库 )</a> 提供的继承自  ExecutorService 的<strong>线程服务接口</strong>，提供创建 ListenableFuture 功能。ListenableFuture 接口，继承 Future 接口，有如下好处：</p>
<blockquote>
<p>我们强烈地建议你在代码中多使用ListenableFuture来代替JDK的 Future, 因为：</p>
</blockquote>
<ul>
<li>大多数Futures 方法中需要它。</li>
<li>转到ListenableFuture 编程比较容易。</li>
<li>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和ListenableFuture的扩展方法。</li>
</ul>
<blockquote>
<p>传统JDK中的Future通过异步的方式计算返回结果:在多线程运算中可能或者可能在没有结束返回结果，Future是运行中的多线程的一个引用句柄，确保在服务执行返回一个Result。</p>
</blockquote>
<blockquote>
<p>ListenableFuture可以允许你注册回调方法(callbacks)，在运算（多线程执行）完成的时候进行调用,  或者在运算（多线程执行）完成后立即执行。这样简单的改进，使得可以明显的支持更多的操作，这样的功能在JDK concurrent中的Future是不支持的。</p>
</blockquote>
<p>如上内容来自<a href="http://ifeve.com/google-guava-listenablefuture/" rel="external nofollow noopener noreferrer" target="_blank">《Google Guava包的ListenableFuture解析
》</a>，文章写的很棒。下文你会看到 Sharding-JDBC 是<strong>如何通过 ListenableFuture 简化并发编程的</strong>。</p>
<p>下面看看 ExecutorEngine 如何<strong>初始化</strong> ListeningExecutorService</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingDataSource</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> Properties props)</span> </span>&#123;</div><div class="line">    <span class="comment">// .... 省略部分代码</span></div><div class="line">   shardingProperties = <span class="keyword">new</span> ShardingProperties(props);</div><div class="line">   <span class="keyword">int</span> executorSize = shardingProperties.getValue(ShardingPropertiesConstant.EXECUTOR_SIZE);</div><div class="line">   executorEngine = <span class="keyword">new</span> ExecutorEngine(executorSize);</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorEngine</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> executorSize)</span> </span>&#123;</div><div class="line">   executorService = MoreExecutors.listeningDecorator(<span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           executorSize, executorSize, <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder().setDaemon(<span class="keyword">true</span>).setNameFormat(<span class="string">"ShardingJDBC-%d"</span>).build()));</div><div class="line">   MoreExecutors.addDelayedShutdownHook(executorService, <span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>一个分片数据源( ShardingDataSource ) <strong>独占</strong> 一个 SQL执行引擎( ExecutorEngine )。</li>
<li><code>MoreExecutors#listeningDecorator()</code> 创建 ListeningExecutorService，这样 <code>#submit()</code>，<code>#invokeAll()</code> 可以返回 ListenableFuture。</li>
<li>默认情况下，线程池大小为 <strong>8</strong>。可以根据实际业务需要，设置 ShardingProperties 进行调整。</li>
<li><code>#setNameFormat()</code> 并发编程时，一定要对线程名字做下定义，这样排查问题会方便很多。</li>
<li><code>MoreExecutors#addDelayedShutdownHook()</code>，<strong>应用关闭</strong>时，等待<strong>所有任务全部完成</strong>再关闭。默认配置等待时间为 60 秒，<strong>建议</strong>将等待时间做成可配的。</li>
</ul>
<h2>2.2 关闭</h2>
<p>数据源关闭时，会调用 ExecutorEngine 也进行关闭。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorEngine.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorService.shutdownNow();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       executorService.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!executorService.isTerminated()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"ExecutorEngine can not been terminated"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#shutdownNow()</code> 尝试使用 <code>Thread.interrupt()</code> 打断正在执行中的任务，未执行的任务不再执行。<strong>建议</strong>打印下哪些任务未执行，因为 SQL 未执行，可能数据未能持久化。</li>
<li><code>#awaitTermination()</code> 因为 <code>#shutdownNow()</code> 打断不是<strong>立即</strong>结束，需要一个过程，因此这里<strong>等待</strong>了 5 秒。</li>
<li><strong>等待</strong> 5 秒后，线程池不一定已经关闭，此时抛出异常给上层。<strong>建议</strong>打印下日志，记录出现这个情况。</li>
</ul>
<h2>2.3 执行 SQL 任务</h2>
<p>ExecutorEngine 对外暴露 <code>#executeStatement()</code>，<code>#executePreparedStatement()</code>，<code>#executeBatch()</code></p>
<p>三个方法分别提供给 StatementExecutor、PreparedStatementExecutor、BatchPreparedStatementExecutor 调用。而这三个方法，内部调用的都是 <code>#execute()</code> 私有方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Statement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> statementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeStatement</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;StatementUnit&gt; statementUnits, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, statementUnits, Collections.&lt;List&lt;Object&gt;&gt;emptyList(), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行PreparedStatement.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> preparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameters 参数列表</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executePreparedStatement</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, preparedStatementUnits, Collections.singletonList(parameters), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行Batch.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> batchPreparedStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; executeBatch(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BatchPreparedStatementUnit&gt; batchPreparedStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, batchPreparedStatementUnits, parameterSets, executeCallback);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>#execute()</code> 执行过程大体流程如下图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/02.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL 类型</div><div class="line">* <span class="doctag">@param</span> baseStatementUnits 语句对象执行单元集合</div><div class="line">* <span class="doctag">@param</span> parameterSets 参数列表集</div><div class="line">* <span class="doctag">@param</span> executeCallback 执行回调函数</div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">execute</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;? extends BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">if</span> (baseStatementUnits.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Iterator&lt;? extends BaseStatementUnit&gt; iterator = baseStatementUnits.iterator();</div><div class="line">   BaseStatementUnit firstInput = iterator.next();</div><div class="line">   <span class="comment">// 第二个任务开始所有 SQL任务 提交线程池【异步】执行任务</span></div><div class="line">   ListenableFuture&lt;List&lt;T&gt;&gt; restFutures = asyncExecute(sqlType, Lists.newArrayList(iterator), parameterSets, executeCallback);</div><div class="line">   T firstOutput;</div><div class="line">   List&lt;T&gt; restOutputs;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 第一个任务【同步】执行任务</span></div><div class="line">       firstOutput = syncExecute(sqlType, firstInput, parameterSets, executeCallback);</div><div class="line">       <span class="comment">// 等待第二个任务开始所有 SQL任务完成</span></div><div class="line">       restOutputs = restFutures.get();</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       ExecutorExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回结果</span></div><div class="line">   List&lt;T&gt; result = Lists.newLinkedList(restOutputs);</div><div class="line">   result.add(<span class="number">0</span>, firstOutput);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一个任务**【同步】**调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">syncExecute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="comment">// 【同步】执行任务</span></div><div class="line">   <span class="keyword">return</span> executeInternal(sqlType, baseStatementUnit, parameterSets, executeCallback, ExecutorExceptionHandler.isExceptionThrown(), ExecutorDataMap.getDataMap());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第二个开始的任务<strong>提交线程池异步</strong>调用 <code>#executeInternal()</code> 执行任务。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; ListenableFuture&lt;List&lt;T&gt;&gt; asyncExecute(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   List&lt;ListenableFuture&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(baseStatementUnits.size());</div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</div><div class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> BaseStatementUnit each : baseStatementUnits) &#123;</div><div class="line">       <span class="comment">// 提交线程池【异步】执行任务</span></div><div class="line">       result.add(executorService.submit(<span class="keyword">new</span> Callable&lt;T&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executeInternal(sqlType, each, parameterSets, executeCallback, isExceptionThrown, dataMap);</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回 ListenableFuture</span></div><div class="line">   <span class="keyword">return</span> Futures.allAsList(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们注意下 <code>Futures.allAsList(result);</code> 和 <code>restOutputs = restFutures.get();</code>。神器 Guava <strong>简化并发编程</strong> 的好处就提现出来了。<code>ListenableFuture#get()</code> 当<strong>所有任务都成功</strong>时，返回所有任务执行结果；当<strong>任何一个任务失败</strong>时，<strong>马上</strong>抛出异常，无需等待其他任务执行完成。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/03.gif" alt=""></p>
<p><em>😮 Guava 真她喵神器，公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>会更新 Guava 源码分享的一个系列哟！老司机还不赶紧上车？</em></p>
<ul>
<li>为什么会分同步执行和异步执行呢？猜测，当<strong>SQL 执行是单表时</strong>，只要进行第一个任务的同步调用，性能更加优秀。等跟张亮大神请教确认原因后，咱会进行更新。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">executeInternal</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback, </span></span></div><div class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown, <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap) <span class="keyword">throws</span> Exception &#123;</div><div class="line">   <span class="keyword">synchronized</span> (baseStatementUnit.getStatement().getConnection()) &#123;</div><div class="line">       T result;</div><div class="line">       ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);</div><div class="line">       ExecutorDataMap.setDataMap(dataMap);</div><div class="line">       List&lt;AbstractExecutionEvent&gt; events = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="comment">// 生成 Event</span></div><div class="line">       <span class="keyword">if</span> (parameterSets.isEmpty()) &#123;</div><div class="line">           events.add(getExecutionEvent(sqlType, baseStatementUnit, Collections.emptyList()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (List&lt;Object&gt; each : parameterSets) &#123;</div><div class="line">               events.add(getExecutionEvent(sqlType, baseStatementUnit, each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.BEFORE_EXECUTE</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent event : events) &#123;</div><div class="line">           EventBusInstance.getInstance().post(event);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 执行回调函数</span></div><div class="line">           result = executeCallback.execute(baseStatementUnit);</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_FAILURE</span></div><div class="line">           <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">               each.setEventExecutionType(EventExecutionType.EXECUTE_FAILURE);</div><div class="line">               each.setException(Optional.of(ex));</div><div class="line">               EventBusInstance.getInstance().post(each);</div><div class="line">               ExecutorExceptionHandler.handleException(ex);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_SUCCESS</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">           each.setEventExecutionType(EventExecutionType.EXECUTE_SUCCESS);</div><div class="line">           EventBusInstance.getInstance().post(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>result = executeCallback.execute(baseStatementUnit);</code> 执行回调函数。StatementExecutor，PreparedStatementExecutor，BatchPreparedStatementExecutor 通过传递<strong>执行回调函数</strong>( ExecuteCallback )实现给 ExecutorEngine 实现并行执行。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> baseStatementUnit 语句对象执行单元</div><div class="line">     * <span class="doctag">@return</span> 处理结果</div><div class="line">     * <span class="doctag">@throws</span> Exception 执行期异常</div><div class="line">     */</div><div class="line">    <span class="function">T <span class="title">execute</span><span class="params">(BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>synchronized (baseStatementUnit.getStatement().getConnection())</code> 原以为 Connection 非线程安全，因此需要用<strong>同步</strong>，后翻查资料<a href="http://blog.csdn.net/goldenfish1919/article/details/9089667" rel="external nofollow noopener noreferrer" target="_blank">《数据库连接池为什么要建立多个连接》</a>，Connection 是线程安全的。等跟张亮大神请教确认原因后，咱会进行更新。</li>
<li>ExecutionEvent 这里先不解释，在本文第四节【EventBus】分享。</li>
<li>ExecutorExceptionHandler、ExecutorDataMap 和 柔性事务 ( AbstractSoftTransaction )，放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>分享。</li>
</ul>
<h1>3. Executor</h1>
<p>Executor，执行器，目前一共有三个执行器。不同的执行器对应不同的执行单元 (BaseStatementUnit)。</p>
<table>
<thead>
<tr>
<th style="text-align:left">执行器类</th>
<th style="text-align:left">执行器名</th>
<th style="text-align:left">执行单元</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">StatementExecutor</td>
<td style="text-align:left">静态语句对象执行单元</td>
<td style="text-align:left">StatementUnit</td>
</tr>
<tr>
<td style="text-align:left">PreparedStatementExecutor</td>
<td style="text-align:left">预编译语句对象请求的执行器</td>
<td style="text-align:left">PreparedStatementUnit</td>
</tr>
<tr>
<td style="text-align:left">BatchPreparedStatementExecutor</td>
<td style="text-align:left">批量预编译语句对象请求的执行器</td>
<td style="text-align:left">BatchPreparedStatementUnit</td>
</tr>
</tbody>
</table>
<ul>
<li>执行器提供的方法不同，因此不存在公用接口或者抽象类。</li>
<li>执行单元继承自 BaseStatementUnit</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/04.png" alt=""></p>
<h2>3.1 StatementExecutor</h2>
<p>StatementExecutor，<strong>多线程</strong>执行静态语句对象请求的执行器，一共有三类方法：</p>
<ul>
<li><code>#executeQuery()</code></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL查询.</div><div class="line">* <span class="doctag">@return</span> 结果集列表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ResultSet&gt; <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeQuery"</span>);</div><div class="line">   List&lt;ResultSet&gt; result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;ResultSet&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> ResultSet <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeQuery(baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#executeUpdate()</code> 因为有四个不同情况的<code>#executeUpdate()</code>，所以抽象了 Updater 接口，从而达到逻辑重用。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL更新.</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executeUpdate(<span class="keyword">new</span> Updater() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.executeUpdate(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Updater updater)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> updater.executeUpdate(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算总的更新数量</div><div class="line">* <span class="doctag">@param</span> results 更新数量数组</div><div class="line">* <span class="doctag">@return</span> 更新数量</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; results)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Integer each : results) &#123;</div><div class="line">       result += <span class="keyword">null</span> == each ? <span class="number">0</span> : each;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#execute()</code> 因为有四个不同情况的<code>#execute()</code>，所以抽象了 Executor 接口，从而达到逻辑重用。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 执行SQL请求.</div><div class="line">* <span class="doctag">@return</span> true表示执行DQL语句, false表示执行的DML语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(<span class="keyword">new</span> Executor() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.execute(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Executor executor)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-execute"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Boolean&gt; result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Boolean&gt;() &#123; </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executor.execute(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty() || <span class="keyword">null</span> == result.get(<span class="number">0</span>)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result.get(<span class="number">0</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 PreparedStatementExecutor</h2>
<p>PreparedStatementExecutor，<strong>多线程</strong>执行预编译语句对象请求的执行器。比 StatementExecutor 多了 <code>parameters</code> 参数，方法逻辑上基本一致，就不重复分享啦。</p>
<h2>3.3 BatchPreparedStatementExecutor</h2>
<p>BatchPreparedStatementExecutor，<strong>多线程</strong>执行批量预编译语句对象请求的执行器。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BatchPreparedStatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行批量SQL.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 执行结果</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] executeBatch() &#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeBatch"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> accumulate(executorEngine.executeBatch(sqlType, batchPreparedStatementUnits, parameterSets, <span class="keyword">new</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> <span class="keyword">int</span>[] execute(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeBatch();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算每个语句的更新数量</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> results 每条 SQL 更新数量</div><div class="line">* <span class="doctag">@return</span> 每个语句的更新数量</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] accumulate(<span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; results) &#123;</div><div class="line">   <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[parameterSets.size()];</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 每个语句按照顺序，读取到其对应的每个分片SQL影响的行数进行累加</span></div><div class="line">   <span class="keyword">for</span> (BatchPreparedStatementUnit each : batchPreparedStatementUnits) &#123;</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : each.getJdbcAndActualAddBatchCallTimesMap().entrySet()) &#123;</div><div class="line">           result[entry.getKey()] += <span class="keyword">null</span> == results.get(count) ? <span class="number">0</span> : results.get(count)[entry.getValue()];</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>眼尖</strong>的同学会发现，为什么有 BatchPreparedStatementExecutor，而没有 BatchStatementExecutor 呢？目前 Sharding-JDBC 不支持 Statement 批量操作，只能进行 PreparedStatement 的批操作。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatement 批量操作，不会报错</span></div><div class="line">PreparedStatement ps = conn.prepareStatement(sql)</div><div class="line">ps.addBatch();</div><div class="line">ps.addBatch();</div><div class="line"></div><div class="line"><span class="comment">// Statement 批量操作，会报错</span></div><div class="line">ps.addBatch(sql); <span class="comment">// 报错：at com.dangdang.ddframe.rdb.sharding.jdbc.unsupported.AbstractUnsupportedOperationStatement.addBatch</span></div></pre></td></tr></table></figure></p>
<h1>4. ExecutionEvent</h1>
<p>AbstractExecutionEvent，SQL 执行事件抽象接口。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutionEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件编号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> EventExecutionType eventExecutionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异常</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;SQLException&gt; exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AbstractExecutionEvent 有两个实现子类：</p>
<ul>
<li>DMLExecutionEvent：DML类SQL执行时事件</li>
<li>DQLExecutionEvent：DQL类SQL执行时事件</li>
</ul>
<p>EventExecutionType，事件触发类型。</p>
<ul>
<li>BEFORE_EXECUTE：执行前</li>
<li>EXECUTE_SUCCESS：执行成功</li>
<li>EXECUTE_FAILURE：执行失败</li>
</ul>
<h2>4.1 EventBus</h2>
<p><strong>那究竟有什么用途呢？</strong> Sharding-JDBC 使用 Guava（<strong>没错，又是它</strong>）的 <strong>EventBus</strong> 实现了<strong>事件的发布和订阅</strong>。从上文 <code>ExecutorEngine#executeInternal()</code> 我们可以看到<strong>每个分片</strong> SQL 执行的过程中会发布相应事件：</p>
<ul>
<li>执行 SQL 前：发布类型类型为 BEFORE_EXECUTE 的事件</li>
<li>执行 SQL 成功：发布类型类型为 EXECUTE_SUCCESS 的事件</li>
<li>执行 SQL 失败：发布类型类型为 EXECUTE_FAILURE 的事件</li>
</ul>
<p>**怎么订阅事件呢？**非常简单，例子如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBusInstance.getInstance().register(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123; <span class="comment">// DMLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DMLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(<span class="keyword">final</span> DQLExecutionEvent event)</span> </span>&#123; <span class="comment">//DQLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DQLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#register()</code> 任何类都可以，并非一定需要使用 Runnable 类。此处例子单纯因为方便</li>
<li><code>@Subscribe</code> 注解在方法上，实现对事件的订阅</li>
<li><code>@AllowConcurrentEvents</code> 注解在方法上，表示线程安全，允许并发执行</li>
<li>方法上的<strong>参数对应的类</strong>即是订阅的事件。例如，<code>#listen()</code> 订阅了 DMLExecutionEvent 事件</li>
<li><code>EventBus#post()</code> 发布事件，<strong>同步</strong>调用订阅逻辑</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_14/05.png" alt=""></p>
<ul>
<li>推荐阅读文章：<a href="http://www.cnblogs.com/peida/p/EventBus.html" rel="external nofollow noopener noreferrer" target="_blank">《Guava学习笔记：EventBus》</a></li>
</ul>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h2>4.2 BestEffortsDeliveryListener</h2>
<p>BestEffortsDeliveryListener，最大努力送达型事务监听器。</p>
<p>本文暂时暂时不分析其实现，仅仅作为另外一个<strong>订阅者</strong>的例子。我们会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>进行分享。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">        TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">        BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">        <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">            <span class="keyword">case</span> BEFORE_EXECUTE:</div><div class="line">                <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">                transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                        event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_SUCCESS: </div><div class="line">                transactionLogStorage.remove(event.getId());</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_FAILURE: </div><div class="line">                <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">                    Connection conn = <span class="keyword">null</span>;</div><div class="line">                    PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                        <span class="keyword">if</span> (!isValidConnection(conn)) &#123;</div><div class="line">                            bedSoftTransaction.getConnection().release(conn);</div><div class="line">                            conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                            isNewConnection = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                        <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                            preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement.executeUpdate();</div><div class="line">                        deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                        transactionLogStorage.remove(event.getId());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                        log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        close(isNewConnection, conn, preparedStatement);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">default</span>: </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>本文完，但也未完。</p>
<p><strong>跨分片事务问题</strong>。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> t_order <span class="keyword">SET</span> nickname = ? <span class="keyword">WHERE</span> user_id = ?</div></pre></td></tr></table></figure></p>
<p>A 节点 <code>connection.commit()</code> 时，应用突然挂了！B节点 <code>connection.commit()</code> 还来不及执行。<br>
我们一起去<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>寻找答案。</p>
<p><strong>道友，分享一波朋友圈可好？</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式主键</title>
    <link href="http://www.yunai.me/Sharding-JDBC/distributed-id/"/>
    <id>http://www.yunai.me/Sharding-JDBC/distributed-id/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2017-08-10T17:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2.KeyGenerator</a>
<ul>
<li><a href="#">2.1 DefaultKeyGenerator</a></li>
<li><a href="#">2.2 HostNameKeyGenerator</a></li>
<li><a href="#">2.3 IPKeyGenerator</a></li>
<li><a href="#">2.4 IPSectionKeyGenerator</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享 Sharding-JDBC <strong>分布式主键</strong>实现。</p>
<p>官方文档<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/key-generator/" rel="external nofollow noopener noreferrer" target="_blank">《分布式主键》</a>对其介绍及使用方式介绍很完整，强烈先阅读。下面先引用下分布式主键的<strong>实现动机</strong>：</p>
<blockquote>
<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各大数据库对于该需求也提供了相应的支持，比如MySQL的自增键。对于MySQL而言，分库分表之后，不同表生成全局唯一的Id是非常棘手的问题。因为同一个逻辑表内的不同实际表之间的自增键是无法互相感知的，这样会造成重复Id的生成。我们当然可以通过约束表生成键的规则来达到数据的不重复，但是这需要引入额外的运维力量来解决重复性问题，并使框架缺乏扩展性。</p>
</blockquote>
<blockquote>
<p>目前有许多第三方解决方案可以完美解决这个问题，比如UUID等依靠特定算法自生成不重复键，或者通过引入Id生成服务等。 但也正因为这种多样性导致了Sharding-JDBC如果强依赖于任何一种方案就会限制其自身的发展。</p>
</blockquote>
<blockquote>
<p>基于以上的原因，最终采用了以JDBC接口来实现对于生成Id的访问，而将底层具体的Id生成实现分离出来。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. KeyGenerator</h1>
<p>KeyGenerator，主键生成器接口。实现类通过实现 <code>#generateKey()</code> 方法对外提供<strong>生成主键</strong>的功能。</p>
<h2>2.1 DefaultKeyGenerator</h2>
<p>DefaultKeyGenerator，默认的主键生成器。该生成器采用 Twitter Snowflake 算法实现，生成 <strong>64 Bits</strong> 的 <strong>Long</strong> 型编号。国内另外一款数据库中间件 MyCAT 分布式主键也是基于该算法实现。国内很多大型互联网公司<strong>发号器</strong>服务基于该算法加部分改造实现。所以 DefaultKeyGenerator 必须是<strong>根正苗红</strong>。如果你对<strong>分布式主键</strong>感兴趣，可以看看逗比笔者整理的<a href="http://www.yunai.me/Architecture/talk-about-global-id/?self">《谈谈 ID》</a>。</p>
<p>咳咳咳，有点跑题了。<strong>编号</strong>由四部分组成，从高位到低位（从左到右）分别是：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_12/01.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">Bits</th>
<th style="text-align:left">名字</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">符号位</td>
<td style="text-align:left">等于 0</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left">时间戳</td>
<td style="text-align:left">从 2016/11/01 零点开始的毫秒数，支持 2 ^41 /365/24/60/60/1000=69.7年</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">工作进程编号</td>
<td style="text-align:left">支持 1024 个进程</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">序列号</td>
<td style="text-align:left">每毫秒从 0 开始自增，支持 4096 个编号</td>
</tr>
</tbody>
</table>
<ul>
<li>每个工作进程每秒可以产生 4096000 个编号。是不是灰常牛比 💯</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间偏移量，从2016年11月1日零点开始</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EPOCH;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量占用比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_BITS = <span class="number">12L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID比特</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_BITS = <span class="number">10L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 自增量掩码（最大值）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEQUENCE_MASK = (<span class="number">1</span> &lt;&lt; SEQUENCE_BITS) - <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_LEFT_SHIFT_BITS = SEQUENCE_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间戳左移比特数（位数）</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMESTAMP_LEFT_SHIFT_BITS = WORKER_ID_LEFT_SHIFT_BITS + WORKER_ID_BITS;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID最大值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WORKER_ID_MAX_VALUE = <span class="number">1L</span> &lt;&lt; WORKER_ID_BITS;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TimeService timeService = <span class="keyword">new</span> TimeService();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 工作进程ID</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> workerId;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.set(<span class="number">2016</span>, Calendar.NOVEMBER, <span class="number">1</span>);</div><div class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MINUTE, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);</div><div class="line">        calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</div><div class="line">        EPOCH = calendar.getTimeInMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后自增量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后生成编号时间戳，单位：毫秒</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTime;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置工作进程Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> workerId 工作进程Id</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setWorkerId</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> workerId)</span> </span>&#123;</div><div class="line">        Preconditions.checkArgument(workerId &gt;= <span class="number">0L</span> &amp;&amp; workerId &lt; WORKER_ID_MAX_VALUE);</div><div class="line">        DefaultKeyGenerator.workerId = workerId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生成Id.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 返回@&#123;<span class="doctag">@link</span> Long&#125;类型的Id</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Number <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 保证当前时间大于最后时间。时间回退会导致产生重复id</span></div><div class="line">        <span class="keyword">long</span> currentMillis = timeService.getCurrentMillis();</div><div class="line">        Preconditions.checkState(lastTime &lt;= currentMillis, <span class="string">"Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds"</span>, lastTime, currentMillis);</div><div class="line">        <span class="comment">// 获取序列号</span></div><div class="line">        <span class="keyword">if</span> (lastTime == currentMillis) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="number">0L</span> == (sequence = ++sequence &amp; SEQUENCE_MASK)) &#123; <span class="comment">// 当获得序号超过最大值时，归0，并去获得新的时间</span></div><div class="line">                currentMillis = waitUntilNextTime(currentMillis);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sequence = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置最后时间戳</span></div><div class="line">        lastTime = currentMillis;</div><div class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">            log.debug(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date(lastTime)), workerId, sequence);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 生成编号</span></div><div class="line">        <span class="keyword">return</span> ((currentMillis - EPOCH) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (workerId &lt;&lt; WORKER_ID_LEFT_SHIFT_BITS) | sequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 不停获得时间，直到大于最后时间</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> lastTime 最后时间</div><div class="line">     * <span class="doctag">@return</span> 时间</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitUntilNextTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> time = timeService.getCurrentMillis();</div><div class="line">        <span class="keyword">while</span> (time &lt;= lastTime) &#123;</div><div class="line">            time = timeService.getCurrentMillis();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> time;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>EPOCH = calendar.getTimeInMillis();</code> 计算 2016/11/01 零点开始的毫秒数。</li>
<li><code>#generateKey()</code> 实现逻辑
<ol>
<li>校验当前时间<strong>小于等于</strong>最后生成编号时间戳，避免服务器时钟同步，可能产生时间回退，导致产生<strong>重复</strong>编号</li>
</ol>
<ul>
<li>获得序列号。当前时间戳可获得自增量到达最大值时，调用 <code>#waitUntilNextTime()</code> 获得下一毫秒</li>
<li>设置最后生成编号时间戳，用于校验时间回退情况</li>
<li>位操作生成<strong>编号</strong></li>
</ul>
</li>
</ul>
<p>总的来说，Twitter Snowflake 算法实现上是相对简单易懂的，较为麻烦的是<strong>怎么解决工作进程编号的分配</strong>？</p>
<ol>
<li>超过 1024 个怎么办？</li>
<li>怎么保证全局唯一？</li>
</ol>
<p>第一个问题，将分布式主键生成独立成一个<strong>发号器</strong>服务，提供生成分布式编号的功能。这个不在本文的范围内，有兴趣的同学可以 Google 下。</p>
<p>第二个问题，通过 Zookeeper、Consul、Etcd 等提供分布式配置功能的中间件。当然 Sharding-JDBC 也提供了不依赖这些服务的方式，我们一个一个往下看。</p>
<h2>2.2 HostNameKeyGenerator</h2>
<blockquote>
<p>根据<strong>机器名最后的数字编号</strong>获取工作进程编号。<br>
如果线上机器命名有统一规范,建议使用此种方式。<br>
例如，机器的 HostName 为: <code>dangdang-db-sharding-dev-01</code>(公司名-部门名-服务名-环境名-编号)，会截取 HostName 最后的编号 01 作为工作进程编号( workId )。</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HostNameKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   Long workerId;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   String hostName = address.getHostName();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       workerId = Long.valueOf(hostName.replace(hostName.replaceAll(<span class="string">"\\d+$"</span>, <span class="string">""</span>), <span class="string">""</span>));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"Wrong hostname:%s, hostname must be end with number!"</span>, hostName));</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.3 IPKeyGenerator</h2>
<blockquote>
<p>根据<strong>机器IP</strong>获取工作进程编号。<br>
如果线上机器的IP二进制表示的最后10位不重复,建议使用此种方式。<br>
例如，机器的IP为192.168.1.108，二进制表示:<code>11000000 10101000 00000001 01101100</code>，截取最后 10 位 <code>01 01101100</code>，转为十进制 364，设置工作进程编号为 364。</p>
</blockquote>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   DefaultKeyGenerator.setWorkerId((<span class="keyword">long</span>) (((ipAddressByteArray[ipAddressByteArray.length - <span class="number">2</span>] &amp; <span class="number">0B11</span>) &lt;&lt; Byte.SIZE)</div><div class="line">           + (ipAddressByteArray[ipAddressByteArray.length - <span class="number">1</span>] &amp; <span class="number">0xFF</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.4 IPSectionKeyGenerator</h2>
<p>来自 <strong>DogFc</strong> 贡献，对 IPKeyGenerator 进行改造。</p>
<blockquote>
<p>浏览 IPKeyGenerator 工作进程编号生成的规则后，感觉对服务器IP后10位（特别是IPV6）数值比较约束。<br>
有以下优化思路：<br>
因为工作进程编号最大限制是 2^10，我们生成的工程进程编号只要满足小于 1024 即可。<br>
1.针对IPV4:<br>
....IP最大 255.255.255.255。而（255+255+255+255) &lt; 1024。<br>
....因此采用IP段数值相加即可生成唯一的workerId，不受IP位限制。</p>
</blockquote>
<ol start="2">
<li>针对IPV6:<br>
....IP最大 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff<br>
....为了保证相加生成出的工程进程编号 &lt; 1024,思路是将每个 Bit 位的后6位相加。这样在一定程度上也可以满足workerId不重复的问题。<br>
使用这种 IP 生成工作进程编号的方法,必须保证IP段相加不能重复</li>
</ol>
<p>对于 IPV6 ：2^ 6 = 64。64 * 8 = 512 &lt; 1024。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// IPSectionKeyGenerator.java</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initWorkerId</span><span class="params">()</span> </span>&#123;</div><div class="line">   InetAddress address;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       address = InetAddress.getLocalHost();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> UnknownHostException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot get LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">byte</span>[] ipAddressByteArray = address.getAddress();</div><div class="line">   <span class="keyword">long</span> workerId = <span class="number">0L</span>;</div><div class="line">   <span class="comment">// IPV4</span></div><div class="line">   <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">4</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0xFF</span>;</div><div class="line">       &#125;</div><div class="line">   <span class="comment">// IPV6</span></div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipAddressByteArray.length == <span class="number">16</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">byte</span> byteNum : ipAddressByteArray) &#123;</div><div class="line">           workerId += byteNum &amp; <span class="number">0B111111</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bad LocalHost InetAddress, please check your network!"</span>);</div><div class="line">   &#125;</div><div class="line">   DefaultKeyGenerator.setWorkerId(workerId);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>没有彩蛋。HOHOHO</p>
<p>道友，分享一波朋友圈可好。</p>
<p>感谢你，技术如此只好，还关注我的公众号。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由改写</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-rewrite/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-rewrite/</id>
    <published>2017-08-09T16:00:00.000Z</published>
    <updated>2017-08-10T17:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLToken</a></li>
<li><a href="#">3.SQL 改写</a>
<ul>
<li><a href="#">3.1 TableToken</a></li>
<li><a href="#">3.2 ItemsToken</a></li>
<li><a href="#">3.3 OffsetToken</a></li>
<li><a href="#">3.4 RowCountToken</a>
<ul>
<li><a href="#">3.4.1 分页补充</a></li>
</ul>
</li>
<li><a href="#">3.5 OrderByToken</a></li>
<li><a href="#">3.6 GeneratedKeyToken</a></li>
</ul>
</li>
<li><a href="#">4. SQL 生成</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?mp">《SQL 解析（三）之查询SQL》</a></p>
<p>本文分享<strong>SQL 改写</strong>的源码实现。主要涉及两方面：</p>
<ol>
<li>SQL 改写：改写 SQL，解决分库分表后，查询结果需要聚合，需要对 SQL 进行调整，例如分页</li>
<li>SQL 生成：生成分表分库的执行 SQL</li>
</ol>
<p>SQLRewriteEngine，SQL重写引擎，实现 SQL 改写、生成功能。从 Sharding-JDBC 1.5.0 版本，SQL 改写进行了调整和大量优化。</p>
<blockquote>
<p>1.4.x及之前版本，SQL改写是在SQL路由之前完成的，在1.5.x中调整为SQL路由之后，因为SQL改写可以根据路由至单库表还是多库表而进行进一步优化。</p>
</blockquote>
<p>😆 很多同学看完<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a> 可能是一脸懵逼，特别对**“SQL 半理解”**。<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/01.png" alt="">希望本文能给你一些启发。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. SQLToken</h1>
<p>😁 SQLToken 在本文中很重要，所以即使在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a>已经分享过，我们也换个姿势，再来一次。</p>
<p>SQLToken，SQL标记对象<strong>接口</strong>。SQLRewriteEngine 基于 SQLToken 实现 <strong>SQL改写</strong>。SQL解析器在 SQL解析过程中，很重要的一个目的是<strong>标记需要SQL改写的部分</strong>，也就是 SQLToken。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/02.png" alt=""></p>
<p><strong>各 SQLToken 生成条件如下</strong>(<em>悲伤，做成表格形式排版是乱的</em>)：</p>
<ol>
<li>GeneratedKeyToken 自增主键标记对象
<ul>
<li>插入SQL自增列不存在：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>TableToken 表标记对象
<ul>
<li>查询列的表别名：<code>SELECT o.order_id</code> 的 <code>o</code></li>
<li>查询的表名：<code>SELECT * FROM t_order</code> 的 <code>t_order</code></li>
</ul>
</li>
<li>ItemsToken 选择项标记对象
<ul>
<li>AVG查询列：<code>SELECT AVG(price) FROM t_order</code> 的 <code>AVG(price)</code></li>
<li>ORDER BY 字段不在查询列：<code>SELECT order_id FROM t_order ORDER BY create_time</code> 的 <code>create_time</code></li>
<li>GROUP BY 字段不在查询列：<code>SELECT COUNT(order_id) FROM t_order GROUP BY user_id</code> 的 <code>user_id</code></li>
<li>自增主键未在插入列中：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li>
</ul>
</li>
<li>OffsetToken 分页偏移量标记对象
<ul>
<li>分页有偏移量，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>RowCountToken 分页长度标记对象
<ul>
<li>分页有长度，但<strong>不是</strong>占位符 <code>?</code></li>
</ul>
</li>
<li>OrderByToken 排序标记对象
<ul>
<li>有 GROUP BY 条件，无 ORDER BY 条件：<code>SELECT COUNT(*) FROM t_order GROUP BY order_id</code> 的 <code>order_id</code></li>
</ul>
</li>
</ol>
<h1>3.SQL 改写</h1>
<p><code>SQLRewriteEngine#rewrite()</code> 实现了 <strong>SQL改写</strong> 功能。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* SQL改写.</div><div class="line">* <span class="doctag">@param</span> isRewriteLimit 是否重写Limit</div><div class="line">* <span class="doctag">@return</span> SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewriteLimit)</span> </span>&#123;</div><div class="line">   SQLBuilder result = <span class="keyword">new</span> SQLBuilder();</div><div class="line">   <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</div><div class="line">       result.appendLiterals(originalSQL);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 排序SQLToken，按照 beginPosition 递增</span></div><div class="line">   sortByBeginPosition();</div><div class="line">   <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == count) &#123; <span class="comment">// 拼接第一个 SQLToken 前的字符串</span></div><div class="line">           result.appendLiterals(originalSQL.substring(<span class="number">0</span>, each.getBeginPosition()));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 拼接每个SQLToken</span></div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</div><div class="line">           appendTableToken(result, (TableToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</div><div class="line">           appendItemsToken(result, (ItemsToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</div><div class="line">           appendLimitRowCount(result, (RowCountToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</div><div class="line">           appendLimitOffsetToken(result, (OffsetToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</div><div class="line">           appendOrderByToken(result);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>SQL改写以 SQLToken 为<strong>间隔</strong>，<strong>顺序</strong>改写。
<ul>
<li>顺序：调用 <code>#sortByBeginPosition()</code> 将 SQLToken 按照 <code>beginPosition</code> <strong>升序</strong>。</li>
<li>间隔：遍历 SQLToken，逐个拼接。</li>
</ul>
</li>
</ul>
<p>例如：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/03.png" alt=""></p>
<hr>
<p>SQLBuilder，SQL构建器。下文会大量用到，我们看下实现代码。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 段集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; segments;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> StringBuilder currentSegment;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        segments = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加字面量.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> literals 字面量</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLiterals</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">        currentSegment.append(literals);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 追加表占位符.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> tableName 表名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTable</span><span class="params">(<span class="keyword">final</span> String tableName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 TableToken</span></div><div class="line">        segments.add(<span class="keyword">new</span> TableToken(tableName));</div><div class="line">        <span class="comment">// 新建当前段</span></div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略代码，【SQL生成】处分享</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@RequiredArgsConstructor</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 表名</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>现在我们来逐个分析每种 SQLToken 的<strong>拼接</strong>实现。</p>
<h2>3.1 TableToken</h2>
<p>调用 <code>#appendTableToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> tableToken tableToken</div><div class="line">* <span class="doctag">@param</span> count tableToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTableToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> TableToken tableToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 TableToken</span></div><div class="line">   String tableName = sqlStatement.getTables().getTableNames().contains(tableToken.getTableName()) ? tableToken.getTableName() : tableToken.getOriginalLiterals();</div><div class="line">   sqlBuilder.appendTable(tableName);</div><div class="line">   <span class="comment">// 拼接 SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = tableToken.getBeginPosition() + tableToken.getOriginalLiterals().length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>SQLBuilder#appendTable()</code> 拼接 TableToken。</li>
<li><code>sqlStatement.getTables().getTableNames().contains(tableToken.getTableName())</code> 目的是处理掉<strong>表名前后有的特殊字符</strong>，例如<code>SELECT * FROM 't_order'</code> 中 <code>t_order</code> 前后有 <code>'</code> 符号。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableToken.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLUtil.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExactlyValue</span><span class="params">(<span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == value ? <span class="keyword">null</span> : CharMatcher.anyOf(<span class="string">"[]`'\""</span>).removeFrom(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 SQL 为 <code>SELECT o.* FROM t_order o</code>
<ul>
<li>TableToken 为查询列前的表别名 <code>o</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/04.png" alt=""></li>
<li>TableToken 为表名 <code>t_order</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/05.png" alt=""></li>
</ul>
</li>
</ul>
<h2>3.2 ItemsToken</h2>
<p>调用 <code>#appendItemsToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> itemsToken itemsToken</div><div class="line">* <span class="doctag">@param</span> count itemsToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendItemsToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 ItemsToken</span></div><div class="line">   <span class="keyword">for</span> (String item : itemsToken.getItems()) &#123;</div><div class="line">       sqlBuilder.appendLiterals(<span class="string">", "</span>);</div><div class="line">       sqlBuilder.appendLiterals(item);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = itemsToken.getBeginPosition();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一种情况，<strong>AVG查询列</strong>，SQL 为 <code>SELECT AVG(order_id) FROM t_order o</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/06.png" alt=""></li>
<li>第二种情况，<strong>ORDER BY 字段不在查询列</strong>，SQL 为 <code>SELECT userId FROM t_order o ORDER BY order_id</code> 时返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/07.png" alt=""></li>
<li>第三种情况，<strong>GROUP BY 字段不在查询列</strong>，类似第二种情况，就不举例子列。</li>
</ul>
<h2>3.3 OffsetToken</h2>
<p>调用 <code>#appendLimitOffsetToken()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OffsetToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@param</span> offsetToken offsetToken</div><div class="line">* <span class="doctag">@param</span> count offsetToken 在 sqlTokens 的顺序</div><div class="line">* <span class="doctag">@param</span> sqlTokens sqlTokens</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写。当路由结果为单分片时无需重写</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 OffsetToken</span></div><div class="line">   sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当分页<strong>跨分片</strong>时，需要每个分片都查询后在<strong>内存</strong>中进行聚合。此时 <code>isRewrite = true</code>。为什么是 <code>&quot;0&quot;</code> 开始呢？每个分片在 [0, offset) 的记录<strong>可能</strong>属于实际分页结果，因而查询每个分片需要从 0 开始。</li>
<li>当分页<strong>单分片</strong>时，则无需重写，该分片执行的结果即是最终结果。<strong>SQL改写在SQL路由之后就有这个好处</strong>。如果先改写，因为没办法知道最终是单分片还是跨分片，考虑正确性，只能统一使用跨分片。</li>
</ul>
<h2>3.4 RowCountToken</h2>
<p>调用 <code>#appendLimitRowCount()</code> 方法拼接。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   Limit limit = selectStatement.getLimit();</div><div class="line">   <span class="keyword">if</span> (!isRewrite) &#123; <span class="comment">// 路由结果为单分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || <span class="comment">// [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">           !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123; <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 路由结果为多分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(limit.isRowCountRewriteFlag() ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>[1.1] <code>!selectStatement.getGroupByItems().isEmpty()</code> 跨分片<strong>分组</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.2] <code>!selectStatement.getAggregationSelectItems().isEmpty())</code> 跨分片<strong>聚合列</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li>
<li>[1.1][1.2]，<strong>可能</strong>变成必须的前提是 GROUP BY 和 ORDER BY 排序不一致。如果一致，各分片已经排序完成，无需内存中排序。</li>
</ul>
<h3>3.4.1 分页补充</h3>
<p>OffsetToken、RowCountToken 只有在分页对应位置非占位符 <code>?</code> 才存在。当对应位置是占位符时，会对<strong>分页条件对应的预编译 SQL 占位符参数</strong>进行重写，<strong>整体逻辑和 OffsetToken、RowCountToken 是一致的</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 👼 ParsingSQLRouter#route() 调用 #processLimit() </span></div><div class="line"></div><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理分页条件</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> SQLRewriteEngine#appendLimitRowCount(SQLBuilder, RowCountToken, int, List, boolean) </div><div class="line">* <span class="doctag">@param</span> parameters 占位符对应参数列表</div><div class="line">* <span class="doctag">@param</span> selectStatement Select SQL语句对象</div><div class="line">* <span class="doctag">@param</span> isSingleRouting 是否单表路由</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLimit</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() <span class="comment">// // [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">                               || !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">                           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems(); <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">   selectStatement.getLimit().processParameters(parameters, !isSingleRouting, isNeedFetchAll);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 填充改写分页参数.</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isRewrite 是否重写参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否获取所有数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   fill(parameters);</div><div class="line">   <span class="keyword">if</span> (isRewrite) &#123;</div><div class="line">       rewrite(parameters, isFetchAll);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 将占位符参数里是分页的参数赋值给 offset 、rowCount</div><div class="line">* 赋值的前提条件是 offset、rowCount 是 占位符</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> offset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.offset) &#123;</div><div class="line">       offset = -<span class="number">1</span> == <span class="keyword">this</span>.offset.getIndex() ? getOffsetValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.offset.getIndex()));</div><div class="line">       <span class="keyword">this</span>.offset.setValue(offset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> rowCount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.rowCount) &#123;</div><div class="line">       rowCount = -<span class="number">1</span> == <span class="keyword">this</span>.rowCount.getIndex() ? getRowCountValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.rowCount.getIndex()));</div><div class="line">       <span class="keyword">this</span>.rowCount.setValue(rowCount);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || rowCount &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingException(<span class="string">"LIMIT offset and row count can not be a negative value."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 重写分页条件对应的参数</div><div class="line">* <span class="doctag">@param</span> parameters 参数</div><div class="line">* <span class="doctag">@param</span> isFetchAll 是否拉取所有</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> rewriteOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> rewriteRowCount;</div><div class="line">   <span class="comment">// 重写</span></div><div class="line">   <span class="keyword">if</span> (isFetchAll) &#123;</div><div class="line">       rewriteRowCount = Integer.MAX_VALUE;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowCountRewriteFlag) &#123;</div><div class="line">       rewriteRowCount = <span class="keyword">null</span> == rowCount ? -<span class="number">1</span> : getOffsetValue() + rowCount.getValue();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       rewriteRowCount = rowCount.getValue();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 参数设置</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != offset &amp;&amp; offset.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(offset.getIndex(), rewriteOffset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != rowCount &amp;&amp; rowCount.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(rowCount.getIndex(), rewriteRowCount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.5 OrderByToken</h2>
<p>调用 <code>#appendOrderByToken()</code> 方法拼接。数据库里，当无 ORDER BY条件 而有 GROUP BY 条件时候，会使用 GROUP BY条件将结果升序排序：</p>
<ul>
<li><code>SELECT order_id FROM t_order GROUP BY order_id</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id ASC</code></li>
<li><code>SELECT order_id FROM t_order GROUP BY order_id DESC</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id DESC</code></li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 拼接 OrderByToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   <span class="comment">// 拼接 OrderByToken</span></div><div class="line">   StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder(<span class="string">" ORDER BY "</span>);</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">           orderByLiterals.append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           orderByLiterals.append(<span class="string">","</span>).append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   orderByLiterals.append(<span class="string">" "</span>);</div><div class="line">   sqlBuilder.appendLiterals(orderByLiterals.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当 SQL 为 <code>SELECT order_id FROM t_order o GROUP BY order_id</code> 返回结果：
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/08.png" alt=""></li>
</ul>
<h2>3.6 GeneratedKeyToken</h2>
<p>前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-4/?mp">《SQL 解析（四）之插入SQL》</a></p>
<p>GeneratedKeyToken，和其它 SQLToken 不同，在 <strong>SQL解析</strong> 完进行处理。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123; <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 追加自增主键标记对象.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingRule 分片规则</div><div class="line">* <span class="doctag">@param</span> parametersSize 参数个数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// SQL 里有主键列</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != generatedKey) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TableRule 存在</span></div><div class="line">   Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(getTables().getSingleTableName());</div><div class="line">   <span class="keyword">if</span> (!tableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// GeneratedKeyToken 存在</span></div><div class="line">   Optional&lt;GeneratedKeyToken&gt; generatedKeysToken = findGeneratedKeyToken();</div><div class="line">   <span class="keyword">if</span> (!generatedKeysToken.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">   ItemsToken valuesToken = <span class="keyword">new</span> ItemsToken(generatedKeysToken.get().getBeginPosition());</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == parametersSize) &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken, parametersSize);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 generatedKeysToken</span></div><div class="line">   getSqlTokens().remove(generatedKeysToken.get());</div><div class="line">   <span class="comment">// 新增 ItemsToken</span></div><div class="line">   getSqlTokens().add(valuesToken);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>根据<strong>占位符参数</strong>数量不同，调用的 <code>#appendGenerateKeyToken()</code> 是<strong>不同</strong>的：</li>
<li><strong>占位符参数数量 = 0</strong> 时，直接生成<strong>分布式主键</strong>，保持无占位符的做法。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成分布式主键</span></div><div class="line">   Number generatedKey = shardingRule.generateKey(tableRule.getLogicTable());</div><div class="line">   <span class="comment">// 添加到 ItemsToken</span></div><div class="line">   valuesToken.getItems().add(generatedKey.toString());</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLNumberExpression(generatedKey)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   <span class="keyword">this</span>.generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getLogicTable(), -<span class="number">1</span>, generatedKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>占位符参数数量 &gt; 0</strong> 时，生成自增列的占位符，保持有占位符的做法。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成占位符</span></div><div class="line">   valuesToken.getItems().add(<span class="string">"?"</span>);</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLPlaceholderExpression(parametersSize)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getGenerateKeyColumn(), parametersSize, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>因为 GenerateKeyToken 已经处理完，所以移除，避免 <code>SQLRewriteEngine#rewrite()</code> 二次改写。另外，通过 ItemsToken 补充自增列。</li>
<li>生成 GeneratedKey 会在 ParsingSQLRouter 进一步处理。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理 插入SQL 主键字段</div><div class="line">* 当 主键编号 未生成时，&#123;<span class="doctag">@link</span> ShardingRule#generateKey(String)&#125; 进行生成</div><div class="line">* <span class="doctag">@param</span> parameters 占位符参数</div><div class="line">* <span class="doctag">@param</span> insertStatement Insert SQL语句对象</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKey</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> InsertStatement insertStatement, <span class="keyword">final</span> SQLRouteResult sqlRouteResult)</span> </span>&#123;</div><div class="line">   GeneratedKey generatedKey = insertStatement.getGeneratedKey();</div><div class="line">   <span class="keyword">if</span> (parameters.isEmpty()) &#123; <span class="comment">// 已有主键，无占位符，INSERT INTO t_order(order_id, user_id) VALUES (1, 100);</span></div><div class="line">       sqlRouteResult.getGeneratedKeys().add(generatedKey.getValue());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.size() == generatedKey.getIndex()) &#123; <span class="comment">// 主键字段不存在存在，INSERT INTO t_order(user_id) VALUES(?);</span></div><div class="line">       Number key = shardingRule.generateKey(insertStatement.getTables().getSingleTableName()); <span class="comment">// 生成主键编号</span></div><div class="line">       parameters.add(key);</div><div class="line">       setGeneratedKeys(sqlRouteResult, key);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> != generatedKey.getIndex()) &#123; <span class="comment">// 主键字段存在，INSERT INTO t_order(order_id, user_id) VALUES(?, ?);</span></div><div class="line">       setGeneratedKeys(sqlRouteResult, (Number) parameters.get(generatedKey.getIndex()));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置 主键编号 到 SQL路由结果</div><div class="line">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</div><div class="line">* <span class="doctag">@param</span> generatedKey 主键编号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGeneratedKeys</span><span class="params">(<span class="keyword">final</span> SQLRouteResult sqlRouteResult, <span class="keyword">final</span> Number generatedKey)</span> </span>&#123;</div><div class="line">   generatedKeys.add(generatedKey);</div><div class="line">   sqlRouteResult.getGeneratedKeys().clear();</div><div class="line">   sqlRouteResult.getGeneratedKeys().addAll(generatedKeys);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>parameters.size() == generatedKey.getIndex()</code> 处对应 <code>#appendGenerateKeyToken()</code> 的 <strong>占位符参数数量 &gt; 0</strong> 情况，此时会生成<strong>分布式主键</strong>。😈 该处是不是可以考虑把生成<strong>分布式主键</strong>挪到 <code>#appendGenerateKeyToken()</code>，这样更加统一一些。</li>
</ul>
<h1>4. SQL 生成</h1>
<p><strong>SQL路由</strong>完后，会生成各数据分片的<strong>执行SQL</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 省略部分代码... 处理 插入SQL 主键字段</span></div><div class="line">   </div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   </div><div class="line">   <span class="comment">// 省略部分代码... SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 省略部分代码... 处理分页</span></div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               <span class="comment">// 👼 生成 SQL</span></div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           <span class="comment">// 👼 生成 SQL</span></div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>RewriteEngine#generateSQL()</code> 生成<strong>执行SQL</strong>。对于笛卡尔积路由结果和简单路由结果传递的参数略有不同：前者使用 CartesianDataSource ( CartesianTableReference )，后者使用路由表单元 ( TableUnit )。对路由结果不是很了解的同学，建议看下 <a href="http://www.yunai.me/Sharding-JDBC/sql-route-2/?mp">《SQL 路由（二）之分库分表路由》</a>。</li>
</ul>
<p><code>RewriteEngine#generateSQL()</code> 对于笛卡尔积路由结果和简单路由结果两种情况，处理上大体是一致的：1. 获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射，2. 根据映射改写 SQL 相关<strong>逻辑表</strong>为<strong>真实表</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(tableUnit));</div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积路由表单元</div><div class="line">* <span class="doctag">@param</span> sqlBuilder SQL构建器</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(cartesianTableReference));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">// SQLBuilder.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成SQL语句.</div><div class="line">* <span class="doctag">@param</span> tableTokens 占位符集合（逻辑表与真实表映射）</div><div class="line">* <span class="doctag">@return</span> SQL语句</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">for</span> (Object each : segments) &#123;</div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken &amp;&amp; tableTokens.containsKey(((TableToken) each).tableName)) &#123;</div><div class="line">           result.append(tableTokens.get(((TableToken) each).tableName));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.append(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#toSQL()</code> 结果如图： <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/09.png" alt="">
😜 对 <strong>SQL改写</strong> 是不是清晰很多了。</li>
</ul>
<hr>
<p>下面我们以<strong>笛卡尔积路由结果</strong>获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射为例子(<em>简单路由结果基本类似而且简单</em>)。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得（笛卡尔积表路由组里的路由表单元逻辑表 和 与其互为BindingTable关系的逻辑表）对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积表路由组</div><div class="line">* <span class="doctag">@return</span> 集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getTableTokens</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; tableTokens = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (TableUnit each : cartesianTableReference.getTableUnits()) &#123;</div><div class="line">       tableTokens.put(each.getLogicTableName(), each.getActualTableName());</div><div class="line">       <span class="comment">// 查找 BindingTableRule</span></div><div class="line">       Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each.getLogicTableName());</div><div class="line">       <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">           tableTokens.putAll(getBindingTableTokens(each, bindingTableRule.get()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> tableTokens;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 BindingTable 关系的逻辑表对应的真实表映射（逻辑表需要在 SQL 中存在）</div><div class="line">* <span class="doctag">@param</span> tableUnit 路由单元</div><div class="line">* <span class="doctag">@param</span> bindingTableRule Binding表规则配置对象</div><div class="line">* <span class="doctag">@return</span> 映射</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getBindingTableTokens</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> BindingTableRule bindingTableRule)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (String eachTable : sqlStatement.getTables().getTableNames()) &#123;</div><div class="line">       <span class="keyword">if</span> (!eachTable.equalsIgnoreCase(tableUnit.getLogicTableName()) &amp;&amp; bindingTableRule.hasLogicTable(eachTable)) &#123;</div><div class="line">           result.put(eachTable, bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>笛卡尔积表路由组( CartesianTableReference )包含<strong>多个</strong>路由表单元( TableUnit )。每个路由表单元需要遍历。</li>
<li>路由表单元本身包含逻辑表和真实表，直接添加到映射即可。</li>
<li>互为 BindingTable 关系的表只计算一次路由分片，因此<strong>未计算</strong>的真实表需要以其对应的<strong>已计算</strong>的真实表去查找，即 <code>bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName())</code> 处逻辑。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BindingTableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据其他Binding表真实表名称获取相应的真实Binding表名称.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> dataSource 数据源名称</div><div class="line">* <span class="doctag">@param</span> logicTable 逻辑表名称</div><div class="line">* <span class="doctag">@param</span> otherActualTable 其他真实Binding表名称</div><div class="line">* <span class="doctag">@return</span> 真实Binding表名称</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBindingActualTable</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String logicTable, <span class="keyword">final</span> String otherActualTable)</span> </span>&#123;</div><div class="line">   <span class="comment">// 计算 otherActualTable 在其 TableRule 的 actualTable 是第几个</span></div><div class="line">   <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.isDynamic()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Dynamic table cannot support Binding table."</span>);</div><div class="line">       &#125;</div><div class="line">       index = each.findActualTableIndex(dataSource, otherActualTable);</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(-<span class="number">1</span> != index, String.format(<span class="string">"Actual table [%s].[%s] is not in table config"</span>, dataSource, otherActualTable));</div><div class="line">   <span class="comment">// 计算 logicTable 在其 TableRule 的 第index 的 真实表</span></div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getLogicTable().equalsIgnoreCase(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> each.getActualTables().get(index).getTableName();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot find binding actual table, data source: %s, logic table: %s, other actual table: %s"</span>, dataSource, logicTable, otherActualTable));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能看起来有些绕，我们看张图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_10/10.png" alt=""></p>
<p><strong>友情提示</strong>：这里不嫌啰嗦在提一句，互为 BindingTable 的表，配置 TableRule 时，<code>actualTables</code> 数量一定要一致，否则多出来的表，可能会无法被路由到。</p>
<h1>666. 彩蛋</h1>
<p>哈哈哈，看完<strong>SQL改写</strong>后，<strong>SQL解析</strong>是不是清晰多了！嘿嘿嘿，反正我现在有点嗨。恩，蛮嗨的。</p>
<p>当然，如果<strong>SQL解析</strong>理解上有点疑惑的你，<strong>欢迎</strong>加我的微信，咱 <strong>1对1</strong> 搞基。关注我的微信公众号：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a> 即可获得。</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<p>道友，转发一波朋友圈可好？</p>
<p>Let's Go! <a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分布式主键》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> 继续。</p>
<p><em>感谢技术牛逼如你耐心的阅读本文。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-3/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-3/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>抱歉，站坑文。近期看情况更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-2/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-2/</id>
    <published>2017-08-05T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLRouteResult</a></li>
<li><a href="#">3. 路由策略 x 算法</a></li>
<li><a href="#">4. SQL 路由</a></li>
<li><a href="#">5. DatabaseHintSQLRouter</a></li>
<li><a href="#">6. ParsingSQLRouter</a>
<ul>
<li><a href="#">6.1 SimpleRoutingEngine</a></li>
<li><a href="#">6.2 ComplexRoutingEngine</a></li>
<li><a href="#">6.3 CartesianRoutingEngine</a></li>
<li><a href="#">6.3 ParsingSQLRouter 主#route()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文分享分表分库<strong>路由</strong>相关的实现。涉及内容如下：</p>
<ol>
<li>SQL 路由结果</li>
<li>路由策略 x 算法</li>
<li>SQL 路由器</li>
</ol>
<p>内容顺序如编号。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<p>SQL 路由大体流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<h1>2. SQLRouteResult</h1>
<p>经过 <strong>SQL解析</strong>、<strong>SQL路由</strong>后，产生<strong>SQL路由结果</strong>，即 SQLRouteResult。根据路由结果，<strong>生成SQL</strong>，<strong>执行SQL</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/01.png" alt=""></p>
<ul>
<li><code>sqlStatement</code> ：SQL语句对象，经过<strong>SQL解析</strong>的结果对象。</li>
<li><code>executionUnits</code> ：SQL最小执行单元集合。<strong>SQL执行</strong>时，执行每个单元。</li>
<li><code>generatedKeys</code> ：<strong>插入</strong>SQL语句生成的主键编号集合。目前不支持批量插入而使用集合的原因，猜测是为了未来支持批量插入做准备。</li>
</ul>
<h1>3. 路由策略 x 算法</h1>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<p>ShardingStrategy，分片策略。目前支持两种分片：</p>
<p><em>分片资源：在分库策略里指的是库，在分表策略里指的是表。</em></p>
<p>【1】 计算<strong>静态</strong>分片（常用）</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算静态分片.</div><div class="line">* <span class="doctag">@param</span> sqlType SQL语句的类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的数据源名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doStaticSharding</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">if</span> (shardingValues.isEmpty()) &#123;</div><div class="line">       Preconditions.checkState(!isInsertMultiple(sqlType, availableTargetNames), <span class="string">"INSERT statement should contain sharding value."</span>); <span class="comment">// 插入不能有多资源对象</span></div><div class="line">       result.addAll(availableTargetNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 插入SQL 是否插入多个分片</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInsertMultiple</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.INSERT == sqlType &amp;&amp; availableTargetNames.size() &gt; <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>插入SQL 需要有片键值，否则无法判断单个分片资源。<em>（Sharding-JDBC 目前仅支持单条记录插入）</em></li>
</ul>
<p>【2】计算<strong>动态</strong>分片</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算动态分片.</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doDynamicSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Preconditions.checkState(!shardingValues.isEmpty(), <span class="string">"Dynamic table should contain sharding value."</span>); <span class="comment">// 动态分片必须有分片值</span></div><div class="line">   Collection&lt;String&gt; availableTargetNames = Collections.emptyList();</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>动态分片对应 <code>TableRule.dynamic=true</code></li>
<li>动态分片必须有分片值</li>
</ul>
<p>😈 闷了，看起来两者没啥区别？答案在<strong>分片算法</strong>上。我们先看 <code>#doSharding()</code> 方法的实现。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算分片</div><div class="line">* <span class="doctag">@param</span> shardingValues 分片值集合</div><div class="line">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</div><div class="line">* <span class="doctag">@return</span> 分库后指向的分片资源集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> NoneKeyShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.singletonList(((NoneKeyShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues.iterator().next()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 单片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> SingleKeyShardingAlgorithm) &#123;</div><div class="line">       SingleKeyShardingAlgorithm&lt;?&gt; singleKeyShardingAlgorithm = (SingleKeyShardingAlgorithm&lt;?&gt;) shardingAlgorithm;</div><div class="line">       ShardingValue shardingValue = shardingValues.iterator().next();</div><div class="line">       <span class="keyword">switch</span> (shardingValue.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> SINGLE:</div><div class="line">               <span class="keyword">return</span> Collections.singletonList(singleKeyShardingAlgorithm.doEqualSharding(availableTargetNames, shardingValue));</div><div class="line">           <span class="keyword">case</span> LIST:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doInSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">case</span> RANGE:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doBetweenSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingValue.getType().getClass().getName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> MultipleKeysShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> ((MultipleKeysShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingAlgorithm.getClass().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>无分片键算法：对应 NoneKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NoneKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>单片键算法：对应 SingleKeyShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingleKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doEqualSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">ShardingValueType</th>
<th style="text-align:left">SQL 操作符</th>
<th style="text-align:left">接口方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SINGLE</td>
<td style="text-align:left">=</td>
<td style="text-align:left"><code>#doEqualSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">LIST</td>
<td style="text-align:left">IN</td>
<td style="text-align:left"><code>#doInSharding()</code></td>
</tr>
<tr>
<td style="text-align:left">RANGE</td>
<td style="text-align:left">BETWEEN</td>
<td style="text-align:left"><code>#doBetweenSharding()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>多片键算法：对应 MultipleKeysShardingAlgorithm 分片算法接口。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipleKeysShardingAlgorithm</span> <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分片算法类结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/02.png" alt=""></p>
<p>来看看 Sharding-JDBC 实现的无需分库的分片算法 NoneDatabaseShardingAlgorithm (NoneTableShardingAlgorithm 基本一模一样)：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneDatabaseShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyDatabaseShardingAlgorithm</span>&lt;<span class="title">String</span>&gt;, <span class="title">MultipleKeysDatabaseShardingAlgorithm</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames.isEmpty() ? <span class="keyword">null</span> : availableTargetNames.iterator().next();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>**一定要注意，NoneXXXXShardingAlgorithm 只适用于无分库/表的需求，否则会是错误的路由结果。**例如，<code>#doEqualSharding()</code> 返回的是第一个分片资源。</li>
</ul>
<hr>
<p>再来看测试目录下实现的<strong>余数基偶分表算法</strong> ModuloTableShardingAlgorithm 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.ModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">            <span class="keyword">if</span> (each.endsWith(shardingValue.getValue() % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> each;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            <span class="keyword">for</span> (String tableName : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (tableName.endsWith(value % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(tableName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (each.endsWith(i % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(each);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>我们可以参考这个例子编写自己的分片算哟 👼。</li>
<li>多片键分库算法接口实现例子：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/test/java/com/dangdang/ddframe/rdb/integrate/fixture/MultipleKeysModuloDatabaseShardingAlgorithm.java" rel="external nofollow noopener noreferrer" target="_blank">MultipleKeysModuloDatabaseShardingAlgorithm.java</a></li>
</ul>
<hr>
<p>😈 来看看<strong>动态计算分片</strong>需要怎么实现分片算法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.SingleKeyDynamicModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleKeyDynamicModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 表前缀</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tablePrefix;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tablePrefix + shardingValue.getValue() % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(shardingValue.getValues().size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            result.add(tablePrefix + value % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            result.add(tablePrefix + i % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>骚年，是不是明白了一些？<strong>动态表</strong>无需把真实表配置到 TableRule，而是通过<strong>分片算法</strong>计算出<strong>真实表</strong>。</li>
</ul>
<h1>4. SQL 路由</h1>
<p>SQLRouter，SQL 路由器接口，共有两种实现：</p>
<ul>
<li>DatabaseHintSQLRouter：通过提示且仅路由至数据库的SQL路由器</li>
<li>ParsingSQLRouter：需要解析的SQL路由器</li>
</ul>
<p>它们实现 <code>#parse()</code>进行<strong>SQL解析</strong>，<code>#route()</code>进行<strong>SQL路由</strong>。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/03.png" alt=""></p>
<hr>
<p>RoutingEngine，路由引擎接口，共有四种实现：</p>
<ul>
<li>DatabaseHintRoutingEngine：基于数据库提示的路由引擎</li>
<li>SimpleRoutingEngine：简单路由引擎</li>
<li>CartesianRoutingEngine：笛卡尔积的库表路由</li>
<li>ComplexRoutingEngine：混合多库表路由引擎</li>
</ul>
<p><strong>ComplexRoutingEngine 根据路由结果会转化成 SimpleRoutingEngine 或 ComplexRoutingEngine</strong>。下文会看相应源码。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/04.png" alt=""></p>
<hr>
<p>路由结果有两种：</p>
<ul>
<li>RoutingResult：简单路由结果</li>
<li>CartesianRoutingResult：笛卡尔积路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/05.png" alt=""></p>
<p>从图中，我们已经能大概看到两者有什么区别，更具体的下文随源码一起分享。</p>
<p>😈 SQLRouteResult 和 RoutingResult 有什么区别？</p>
<ul>
<li>SQLRouteResult：<strong>整个SQL路由</strong>返回的路由结果</li>
<li>RoutingResult：<strong>RoutingEngine</strong>返回路由结果</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p>
<hr>
<p>一下子看到这么多**&quot;对象&quot;<strong>，可能有点</strong>紧张**。不要紧张，我们一起在整理下。</p>
<table>
<thead>
<tr>
<th style="text-align:left">路由器</th>
<th style="text-align:left">路由引擎</th>
<th style="text-align:left">路由结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DatabaseHintSQLRouter</td>
<td style="text-align:left">DatabaseHintRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">SimpleRoutingEngine</td>
<td style="text-align:left">RoutingResult</td>
</tr>
<tr>
<td style="text-align:left">ParsingSQLRouter</td>
<td style="text-align:left">CartesianRoutingEngine</td>
<td style="text-align:left">CartesianRoutingResult</td>
</tr>
</tbody>
</table>
<p>😈 逗比博主给大家解决了**&quot;对象&quot;<strong>，是不是应该</strong>分享朋友圈**。</p>
<h1>5. DatabaseHintSQLRouter</h1>
<p>DatabaseHintSQLRouter，基于数据库提示的路由引擎。路由器工厂 SQLRouterFactory 创建路由器时，判断到使用数据库提示( Hint ) 时，创建 DatabaseHintSQLRouter。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLRouter <span class="title">createSQLRouter</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> HintManagerHolder.isDatabaseShardingOnly() ? <span class="keyword">new</span> DatabaseHintSQLRouter(shardingContext) : <span class="keyword">new</span> ParsingSQLRouter(shardingContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看下 HintManagerHolder、HintManager <strong>部分相关</strong>的代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HintManagerHolder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManagerHolder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * HintManager 线程变量</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HintManager&gt; HINT_MANAGER_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断是否当前只分库.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 是否当前只分库.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDatabaseShardingOnly</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != HINT_MANAGER_HOLDER.get() &amp;&amp; HINT_MANAGER_HOLDER.get().isDatabaseShardingOnly();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 清理线索分片管理器的本地线程持有者.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        HINT_MANAGER_HOLDER.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HintManager.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 库分片值集合</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ShardingKey, ShardingValue&lt;?&gt;&gt; databaseShardingValues = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 只做库分片</div><div class="line">     * &#123;<span class="doctag">@link</span> DatabaseHintRoutingEngine&#125;</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseShardingOnly;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线索分片管理器实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线索分片管理器实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HintManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        HintManager result = <span class="keyword">new</span> HintManager();</div><div class="line">        HintManagerHolder.setHintManager(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置分库分片值.</div><div class="line">     * </div><div class="line">     * &lt;p&gt;分片操作符为等号.该方法适用于只分库的场景&lt;/p&gt;</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 分片值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseShardingValue</span><span class="params">(<span class="keyword">final</span> Comparable&lt;?&gt; value)</span> </span>&#123;</div><div class="line">        databaseShardingOnly = <span class="keyword">true</span>;</div><div class="line">        addDatabaseShardingValue(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么如果要使用 DatabaseHintSQLRouter，我们只需要 <code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 即可。这里有两点要注意下：</p>
<ul>
<li><code>HintManager#getInstance()</code>，每次获取到的都是<strong>新</strong>的 HintManager，多次赋值需要小心。</li>
<li><code>HintManager#close()</code>，使用完需要去清理，避免下个请求读到遗漏的线程变量。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLJudgeEngine(logicSQL).judge(); <span class="comment">// 只解析 SQL 类型</span></div><div class="line">&#125;  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// TODO insert的SQL仍然需要解析自增主键</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = <span class="keyword">new</span> DatabaseHintRoutingEngine(shardingRule.getDataSourceRule(), shardingRule.getDatabaseShardingStrategy(), sqlStatement.getType())</div><div class="line">           .route();</div><div class="line">   <span class="comment">// SQL最小执行单元</span></div><div class="line">   <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">       result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), logicSQL));</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#parse()</code> 只解析了 SQL 类型，即 SELECT / UPDATE / DELETE / INSERT 。</li>
<li><strong>使用的分库策略来自 ShardingRule，不是 TableRule，这个一定要留心。<strong>❓因为 SQL 未解析</strong>表名</strong>。因此，即使在 TableRule 设置了 <code>actualTables</code> 属性也是没有效果的。</li>
<li>目前不支持 Sharding-JDBC 的主键自增。❓因为 SQL 未解析<strong>自增主键</strong>。从代码上的<code>TODO</code>应该会支持。</li>
<li><code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 设置的库分片值使用的是  EQUALS，因而分库策略计算出来的只有<strong>一个库分片</strong>，即 TableUnit 只有一个，SQLExecutionUnit 只有一个。</li>
</ul>
<hr>
<p>看看 DatabaseHintSQLRouter 的实现：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Hint 获得 分片键值</span></div><div class="line">   Optional&lt;ShardingValue&lt;?&gt;&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(<span class="keyword">new</span> ShardingKey(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME));</div><div class="line">   Preconditions.checkState(shardingValue.isPresent());</div><div class="line">   log.debug(<span class="string">"Before database sharding only db:&#123;&#125; sharding values: &#123;&#125;"</span>, dataSourceRule.getDataSourceNames(), shardingValue.get());</div><div class="line">   <span class="comment">// 路由。表分片规则使用的是 ShardingRule 里的。因为没 SQL 解析。</span></div><div class="line">   Collection&lt;String&gt; routingDataSources = databaseShardingStrategy.doStaticSharding(sqlType, dataSourceRule.getDataSourceNames(), Collections.&lt;ShardingValue&lt;?&gt;&gt;singleton(shardingValue.get()));</div><div class="line">   Preconditions.checkState(!routingDataSources.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   log.debug(<span class="string">"After database sharding only result: &#123;&#125;"</span>, routingDataSources);</div><div class="line">   <span class="comment">// 路由结果</span></div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (String each : routingDataSources) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each, <span class="string">""</span>, <span class="string">""</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>只</strong>调用 <code>databaseShardingStrategy.doStaticSharding()</code> 方法计算<strong>库</strong>分片。</li>
<li><code>new TableUnit(each, &quot;&quot;, &quot;&quot;)</code> 的 <code>logicTableName</code>，<code>actualTableName</code> 都是空串，相信原因你已经知道。</li>
</ul>
<h1>6. ParsingSQLRouter</h1>
<p>ParsingSQLRouter，需要解析的SQL路由器。</p>
<p>ParsingSQLRouter 使用 SQLParsingEngine <strong>解析SQL</strong>。对<strong>SQL解析</strong>有兴趣的同学可以看看拙作<a href="http://www.yunai.me/categories/Sharding-JDBC/?mp">《Sharding-JDBC 源码分析 —— SQL 解析》</a>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123;</div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#appendGenerateKeyToken()</code> 会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>分享</li>
</ul>
<hr>
<p>ParsingSQLRouter 在路由时，会根据<strong>表情况</strong>使用 SimpleRoutingEngine 或 CartesianRoutingEngine 进行路由。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; tableNames = sqlStatement.getTables().getTableNames();</div><div class="line">   RoutingEngine routingEngine;</div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == tableNames.size() || shardingRule.isAllBindingTables(tableNames)) &#123;</div><div class="line">       routingEngine = <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableNames.iterator().next(), sqlStatement);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// TODO 可配置是否执行笛卡尔积</span></div><div class="line">       routingEngine = <span class="keyword">new</span> ComplexRoutingEngine(shardingRule, parameters, tableNames, sqlStatement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> routingEngine.route();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当只进行<strong>一张表</strong>或者<strong>多表互为BindingTable关系</strong>时，使用 SimpleRoutingEngine 简单路由引擎。<strong>多表互为BindingTable关系</strong>时，每张表的路由结果是相同的，所以只要计算第一张表的分片即可。</li>
<li><code>tableNames.iterator().next()</code> 注意下，<code>tableNames</code> 变量是 <code>new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER)</code>。所以 <code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code> 即使 <code>t_order_item</code> 排在 <code>t_order</code> 前面，<code>tableNames.iterator().next()</code> 返回的是 <code>t_order</code>。当 <code>t_order</code> 和 <code>t_order_item</code> 为 <strong>BindingTable关系</strong> 时，计算的是 <code>t_order</code> 路由分片。</li>
<li>BindingTable关系在 ShardingRule 的 <code>tableRules</code> 配置。配置该关系 TableRule 有如下需要遵守的规则：
<ul>
<li>分片策略与算法相同</li>
<li>数据源配置对象相同</li>
<li>真实表<strong>数量</strong>相同</li>
</ul>
</li>
</ul>
<p><strong>举个例子</strong>：</p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li>
<li>分库分表情况：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div></pre></td></tr></table></figure></p>
<p>最终执行的SQL如下：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div></pre></td></tr></table></figure></p>
<ul>
<li><code>t_order_item_03</code>、<code>t_order_item_04</code> 无法被查询到。</li>
</ul>
<p>下面我们看看 <code>#isAllBindingTables()</code> 如何实现<strong>多表互为BindingTable关系</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="comment">// 调用顺序 #isAllBindingTables()=&gt;#filterAllBindingTables()=&gt;#findBindingTableRule()=&gt;#findBindingTableRule()</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断逻辑表名称集合是否全部属于Binding表.</div><div class="line">* <span class="doctag">@param</span> logicTables 逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; bindingTables = filterAllBindingTables(logicTables);</div><div class="line">   <span class="keyword">return</span> !bindingTables.isEmpty() &amp;&amp; bindingTables.containsAll(logicTables);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 过滤出所有的Binding表名称.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">filterAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logicTables.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Optional&lt;BindingTableRule&gt; bindingTableRule = findBindingTableRule(logicTables);</div><div class="line">   <span class="keyword">if</span> (!bindingTableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交集</span></div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(bindingTableRule.get().getAllLogicTables());</div><div class="line">   result.retainAll(logicTables);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得包含&lt;strong&gt;任一&lt;/strong&gt;在逻辑表名称集合的binding表配置的逻辑表名称集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;BindingTableRule&gt; result = findBindingTableRule(each);</div><div class="line">       <span class="keyword">if</span> (result.isPresent()) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据逻辑表名称获取binding表配置的逻辑表名称集合.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> String logicTable)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (BindingTableRule each : bindingTableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.hasLogicTable(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>逻辑看起来比较长，目的是找到一条 BindingTableRule 包含<strong>所有</strong>逻辑表集合</li>
<li>不支持<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB" rel="external nofollow noopener noreferrer" target="_blank">《传递关系》</a>：配置 BindingTableRule 时，<strong>相同绑定关系一定要配置在一条</strong>，必须是 <code>[a, b, c]</code>，而不能是 <code>[a, b], [b, c]</code>。</li>
</ul>
<h2>6.1 SimpleRoutingEngine</h2>
<p>SimpleRoutingEngine，简单路由引擎。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_06/07.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</div><div class="line">   DatabaseShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getDatabaseShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualDatasourceNames(), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;ShardingValue&lt;?&gt;&gt; getShardingValues(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns) &#123;</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</div><div class="line">   <span class="keyword">for</span> (String each : shardingColumns) &#123;</div><div class="line">       Optional&lt;Condition&gt; condition = sqlStatement.getConditions().find(<span class="keyword">new</span> Column(each, logicTableName));</div><div class="line">       <span class="keyword">if</span> (condition.isPresent()) &#123;</div><div class="line">           result.add(condition.get().getShardingValue(parameters));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>可以使用 HintManager 设置<strong>库</strong>分片值进行<strong>强制路由</strong>。</li>
<li><code>#getShardingValues()</code> 我们看到了<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/">《SQL 解析（二）之SQL解析》</a>分享的 Condition 对象。之前我们提到过<strong>Parser 半理解SQL的目的之一是：提炼分片上下文</strong>，此处即是该目的的体现。Condition 里只放<strong>明确</strong>影响路由的条件，例如：<code>order_id = 1</code>, <code>order_id IN (1, 2)</code>, <code>order_id BETWEEN (1, 3)</code>，不放<strong>无法计算</strong>的条件，例如：<code>o.order_id = i.order_id</code>。该方法里，使用<strong>分片键</strong>从 Condition 查找 <strong>分片值</strong>。🙂 是不是对 Condition 的认识更加清晰一丢丢落。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources)</span> </span>&#123;</div><div class="line">   TableShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getTableShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = tableRule.isDynamic() ? strategy.doDynamicSharding(shardingValues)</div><div class="line">           : strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualTableNames(routedDataSources), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no table route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>可以使用 HintManager 设置<strong>表</strong>分片值进行<strong>强制路由</strong>。</li>
<li>根据 <code>dynamic</code> 属性来判断调用 <code>#doDynamicSharding()</code> 还是 <code>#doStaticSharding()</code> 计算分片。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources, <span class="keyword">final</span> Collection&lt;String&gt; routedTables)</span> </span>&#123;</div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (DataNode each : tableRule.getActualDataNodes(routedDataSources, routedTables)) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each.getDataSourceName(), logicTableName, each.getTableName()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据数据源名称过滤获取真实数据单元.</div><div class="line">* <span class="doctag">@param</span> targetDataSources 数据源名称集合</div><div class="line">* <span class="doctag">@param</span> targetTables 真实表名称集合</div><div class="line">* <span class="doctag">@return</span> 真实数据单元</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;DataNode&gt; <span class="title">getActualDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dynamic ? getDynamicDataNodes(targetDataSources, targetTables) : getStaticDataNodes(targetDataSources, targetTables);</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDynamicDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(targetDataSources.size() * targetTables.size());</div><div class="line">   <span class="keyword">for</span> (String targetDataSource : targetDataSources) &#123;</div><div class="line">       <span class="keyword">for</span> (String targetTable : targetTables) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> DataNode(targetDataSource, targetTable));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getStaticDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(actualTables.size());</div><div class="line">   <span class="keyword">for</span> (DataNode each : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (targetDataSources.contains(each.getDataSourceName()) &amp;&amp; targetTables.contains(each.getTableName())) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在 SimpleRoutingEngine 只生成了当前表的 TableUnits。如果存在<strong>与其互为BindingTable关系</strong>的表的 TableUnits 怎么获得？你可以想想噢，当然在后文<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>也会给出答案，看看和你想的是否一样。</li>
</ul>
<h2>6.2 ComplexRoutingEngine</h2>
<p>ComplexRoutingEngine，混合多库表路由引擎。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ComplexRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;RoutingResult&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   Collection&lt;String&gt; bindingTableNames = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="comment">// 计算每个逻辑表的简单路由分片</span></div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(each);</div><div class="line">       <span class="keyword">if</span> (tableRule.isPresent()) &#123;</div><div class="line">           <span class="keyword">if</span> (!bindingTableNames.contains(each)) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableRule.get().getLogicTable(), sqlStatement).route());</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 互为 BindingTable 关系的表加到 bindingTableNames 里，不重复计算分片</span></div><div class="line">           Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each);</div><div class="line">           <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">               bindingTableNames.addAll(Lists.transform(bindingTableRule.get().getTableRules(), <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</div><div class="line">                   </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> input.getLogicTable();</div><div class="line">                   &#125;</div><div class="line">               &#125;));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"mixed tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Cannot find table rule and default data source with logic tables: '%s'"</span>, logicTables);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 防御性编程。shardingRule#isAllBindingTables() 已经过滤了这个情况。</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == result.size()) &#123;</div><div class="line">       <span class="keyword">return</span> result.iterator().next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交给 CartesianRoutingEngine 形成笛卡尔积结果</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CartesianRoutingEngine(result).route();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>ComplexRoutingEngine 计算每个逻辑表的简单路由分片，路由结果交给 CartesianRoutingEngine <strong>继续</strong>路由形成笛卡尔积结果。</li>
</ul>
<p><img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/08.png" alt=""></p>
<ul>
<li>由于目前 ComplexRoutingEngine 路由前已经判断<strong>全部表互为 BindingTable 关系</strong>，因而不会出现 <code>result.size == 1</code>，属于防御性编程。</li>
<li><strong>部分表互为 BindingTable 关系</strong>时，ComplexRoutingEngine 不重复计算分片。</li>
</ul>
<h2>6.3 CartesianRoutingEngine</h2>
<p>CartesianRoutingEngine，笛卡尔积的库表路由。</p>
<p>实现逻辑上<strong>相对</strong>复杂，请保持耐心哟，😈 其实目的就是实现<strong>连连看</strong>的效果：</p>
<ul>
<li>RoutingResult[0] <code>x</code> RoutingResult[1] …… <code>x</code> RoutingResult[n- 1] <code>x</code> RoutingResult[n]</li>
<li><strong>同库</strong> 才可以进行笛卡尔积</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CartesianRoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   CartesianRoutingResult result = <span class="keyword">new</span> CartesianRoutingResult();</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : getDataSourceLogicTablesMap().entrySet()) &#123; <span class="comment">// Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</span></div><div class="line">       <span class="comment">// 获得当前数据源（库）的 路由表单元分组</span></div><div class="line">       List&lt;Set&lt;String&gt;&gt; actualTableGroups = getActualTableGroups(entry.getKey(), entry.getValue()); <span class="comment">// List&lt;Set&lt;真实表&gt;&gt;</span></div><div class="line">       List&lt;Set&lt;TableUnit&gt;&gt; tableUnitGroups = toTableUnitGroups(entry.getKey(), actualTableGroups);</div><div class="line">       <span class="comment">// 笛卡尔积，并合并结果</span></div><div class="line">       result.merge(entry.getKey(), getCartesianTableReferences(Sets.cartesianProduct(tableUnitGroups)));</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"cartesian tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一步，获得<strong>同库</strong>对应的<strong>逻辑表</strong>集合，即 <strong>Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</strong>。</li>
<li>第二步，遍历<strong>数据源（库）</strong>，获得当前<strong>数据源（库）<strong>的</strong>路由表单元分组</strong>。</li>
<li>第三步，对<strong>路由表单元分组</strong>进行<strong>笛卡尔积</strong>，并合并到路由结果。</li>
</ul>
<p>下面，我们一起逐步看看代码实现。</p>
<ul>
<li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li>
<li>分库分表情况：</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得同库对应的逻辑表集合</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; getDataSourceLogicTablesMap() &#123;</div><div class="line">   Collection&lt;String&gt; intersectionDataSources = getIntersectionDataSources();</div><div class="line">   Map&lt;String, Set&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(routingResults.size());</div><div class="line">   <span class="comment">// 获得同库对应的逻辑表集合</span></div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : each.getTableUnits().getDataSourceLogicTablesMap(intersectionDataSources).entrySet()) &#123; <span class="comment">// 过滤掉不在数据源（库）交集的逻辑表</span></div><div class="line">           <span class="keyword">if</span> (result.containsKey(entry.getKey())) &#123;</div><div class="line">               result.get(entry.getKey()).addAll(entry.getValue());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(entry.getKey(), entry.getValue());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得所有路由结果里的数据源（库）交集</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getIntersectionDataSources</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">           result.addAll(each.getTableUnits().getDataSourceNames());</div><div class="line">       &#125;</div><div class="line">       result.retainAll(each.getTableUnits().getDataSourceNames()); <span class="comment">// 交集</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getDataSourceLogicTablesMap()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/09.png" alt=""></li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第二步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;String&gt;&gt; getActualTableGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Set&lt;String&gt; logicTables) &#123;</div><div class="line">   List&lt;Set&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       result.addAll(each.getTableUnits().getActualTableNameGroups(dataSource, logicTables));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;TableUnit&gt;&gt; toTableUnitGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> List&lt;Set&lt;String&gt;&gt; actualTableGroups) &#123;</div><div class="line">   List&lt;Set&lt;TableUnit&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTableGroups.size());</div><div class="line">   <span class="keyword">for</span> (Set&lt;String&gt; each : actualTableGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> HashSet&lt;&gt;(Lists.transform(<span class="keyword">new</span> ArrayList&lt;&gt;(each), <span class="keyword">new</span> Function&lt;String, TableUnit&gt;() &#123;</div><div class="line">    </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> TableUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> findTableUnit(dataSource, input);</div><div class="line">           &#125;</div><div class="line">       &#125;)));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#getActualTableGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/10.png" alt=""></li>
<li><code>#toTableUnitGroups()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/11.png" alt=""></li>
</ul>
<hr>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;CartesianTableReference&gt; <span class="title">getCartesianTableReferences</span><span class="params">(<span class="keyword">final</span> Set&lt;List&lt;TableUnit&gt;&gt; cartesianTableUnitGroups)</span> </span>&#123;</div><div class="line">   List&lt;CartesianTableReference&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(cartesianTableUnitGroups.size());</div><div class="line">   <span class="keyword">for</span> (List&lt;TableUnit&gt; each : cartesianTableUnitGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> CartesianTableReference(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CartesianRoutingResult.java</span></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CartesianDataSource&gt; routingDataSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Collection&lt;CartesianTableReference&gt; routingTableReferences)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianTableReference each : routingTableReferences) &#123;</div><div class="line">       merge(dataSource, each);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> CartesianTableReference routingTableReference)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianDataSource each : routingDataSources) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getDataSource().equalsIgnoreCase(dataSource)) &#123;</div><div class="line">           each.getRoutingTableReferences().add(routingTableReference);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   routingDataSources.add(<span class="keyword">new</span> CartesianDataSource(dataSource, routingTableReference));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p><code>Sets.cartesianProduct(tableUnitGroups)</code> 返回如图（Guava 工具库真强大）：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/12.png" alt=""></p>
</li>
<li>
<p><code>#getCartesianTableReferences()</code> 返回如图：<img src="http://www.yunai.me//images/Sharding-JDBC/2017_08_06/13.png" alt=""></p>
<p>CartesianTableReference，笛卡尔积表<strong>路由组</strong>，包含<strong>多条</strong> TableUnit，即 TableUnit[0] <code>x</code> TableUnit[1] …… <code>x</code> TableUnit[n]。例如图中：<code>t_order_01 x t_order_item_02</code>，最终转换成 SQL 为 <code>SELECT * FROM t_order_01 o join t_order_item_02 i ON o.order_id = i.order_id</code>。</p>
</li>
<li>
<p><code>#merge()</code> 合并笛卡尔积路由结果。CartesianRoutingResult 包含多个 CartesianDataSource，因此需要将 CartesianTableReference 合并（添加）到对应的 CartesianDataSource。当然，目前在实现时已经是按照**数据源（库）**生成对应的 CartesianTableReference。</p>
</li>
</ul>
<h2>6.4 ParsingSQLRouter 主#route()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 🐒🐒🐒 路由 🐒🐒🐒</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   <span class="comment">// SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 处理分页</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</div><div class="line">       processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="comment">// 打印 SQL</span></div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>RoutingResult routingResult = route(parameters, sqlStatement);</code> <strong>调用</strong>的就是上文分析的 SimpleRoutingEngine、ComplexRoutingEngine、CartesianRoutingEngine 的 <code>#route()</code> 方法。</li>
<li><code>#processGeneratedKey()</code>、<code>#processLimit()</code>、<code>#rewrite()</code>、<code>#generateSQL()</code> 等会放在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 分享。</li>
</ul>
<h1>666. 彩蛋</h1>
<p>篇幅有些长，希望能让大家对<strong>路由</strong>有比较完整的认识。<br>
如果内容有错误，烦请您指正，我会<strong>认真</strong>修改。<br>
如果表述不清晰，不太理解的，欢迎加我微信（wangwenbin-server）一起探讨。</p>
<p>谢谢你技术这么好，还<strong>耐心</strong>看完了本文。</p>
<p>强制路由 HintManager 讲的相对略过，可以看如下内容进一步了解：</p>
<ol>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/hint-sharding-value/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档-强制路由》</a></li>
<li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/api/HintManager.java#L41" rel="external nofollow noopener noreferrer" target="_blank">HintManager.java 源码</a></li>
</ol>
<p>厚着脸皮，道友，辛苦<strong>分享朋友圈</strong>可好？！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 路由（一）之分库分表配置</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-route-1/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-route-1/</id>
    <published>2017-08-03T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. TableRule</a>
<ul>
<li><a href="#">2.1 logicTable</a></li>
<li><a href="#">2.2 数据单元</a>
<ul>
<li><a href="#">2.2.1 DataNode</a></li>
<li><a href="#">2.2.2 DynamicDataNode</a></li>
</ul>
</li>
<li><a href="#">2.3 分库/分表策略</a></li>
<li><a href="#">2.4 主键生成</a></li>
</ul>
</li>
<li><a href="#">3. ShardingRule</a>
<ul>
<li><a href="#">3.1 dataSourceRule</a></li>
<li><a href="#">3.2 tableRules</a></li>
<li><a href="#">3.3 bindingTableRules</a></li>
</ul>
</li>
<li><a href="#">4. ShardingStrategy</a></li>
<li><a href="#">5. ShardingAlgorithm</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>😆<a href="http://www.yunai.me/categories/Sharding-JDBC/?self">《SQL 解析》</a> 已经告于段落，我们要开始新的旅程：<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 路由》</a>。相比<strong>SQL解析</strong>，路由会容易理解很多，骗人是小🐷。整个系列预计会拆分成<strong>三小篇</strong>文章：</p>
<ol>
<li>《分库分表配置》</li>
<li>《分表分库路由》</li>
<li>《Spring与YAML配置》</li>
</ol>
<p>第一、二篇会在<strong>近期</strong>更新。第三篇会在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>、<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>完成后进行更新。😈改写和执行相对有趣。</p>
<p>👼道友，您看，逗比博主**“很有规划”**，是关注公众号一波<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>还是分享朋友圈。</p>
<hr>
<p>阅读本文之前，建议已经读过<strong>官方</strong>相关文章：</p>
<ul>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/concepts/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 核心概念》</a></li>
<li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/sharding/" rel="external nofollow noopener noreferrer" target="_blank">《Sharding-JDBC 分表分库》</a></li>
</ul>
<p>分表分库配置会涉及如下类：</p>
<ul>
<li>TableRule 表规则配置对象</li>
<li>ShardingRule 分库分表规则配置对象</li>
<li>ShardingStrategy 分片策略</li>
<li>ShardingAlgorithm 分片算法</li>
</ul>
<p>我们来一起逐个类往下看。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. TableRule</h1>
<p>TableRule，表规则配置对象，内嵌 TableRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/01.png" alt=""></p>
<h2>2.1 logicTable</h2>
<blockquote>
<p>数据分片的<strong>逻辑表</strong>，对于水平拆分的数据库(表)，同一类表的总称。<br>
例：订单数据根据主键尾数拆分为10张表,分别是t_order_0到t_order_9，他们的逻辑表名为t_order。</p>
</blockquote>
<h2>2.2 数据单元</h2>
<p>Sharding-JDBC 有两种类型<strong>数据单元</strong>：</p>
<ul>
<li>DataNode ：<strong>静态</strong>分库分表数据单元</li>
</ul>
<blockquote>
<p>数据分片的最小单元，由数据源名称和数据表组成。<br>
例：ds_1.t_order_0。配置时默认各个分片数据库的表结构均相同，直接配置逻辑表和真实表对应关系即可。<br>
如果各数据库的表结果不同，可使用ds.actual_table配置。</p>
</blockquote>
<ul>
<li>DynamicDataNode ：<strong>动态</strong>表的分库分表数据单元</li>
</ul>
<blockquote>
<p>逻辑表和真实表不一定需要在配置规则中静态配置。<br>
比如按照日期分片的场景，真实表的名称随着时间的推移会产生变化。<br>
此类需求Sharding-JDBC是支持的，不过目前配置并不友好，会在新版本中提升。</p>
</blockquote>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/02.png" alt=""></p>
<p>TableRuleBuilder 调用 <code>#build()</code> 方法创建 TableRule。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRuleBuilder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TableRuleBuilder</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> TableRule <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">       KeyGenerator keyGenerator = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != generateKeyColumn &amp;&amp; <span class="keyword">null</span> != keyGeneratorClass) &#123;</div><div class="line">           keyGenerator = KeyGeneratorFactory.createKeyGenerator(keyGeneratorClass);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> TableRule(logicTable, dynamic, actualTables, dataSourceRule, dataSourceNames, databaseShardingStrategy, tableShardingStrategy, generateKeyColumn, keyGenerator);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TableRule</span><span class="params">(<span class="keyword">final</span> String logicTable, <span class="keyword">final</span> <span class="keyword">boolean</span> dynamic, <span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; dataSourceNames,</span></span></div><div class="line">                <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy,</div><div class="line">                <span class="keyword">final</span> String generateKeyColumn, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   Preconditions.checkNotNull(logicTable);</div><div class="line">   <span class="keyword">this</span>.logicTable = logicTable;</div><div class="line">   <span class="keyword">this</span>.dynamic = dynamic;</div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = tableShardingStrategy;</div><div class="line">   <span class="keyword">if</span> (dynamic) &#123; <span class="comment">// 动态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(dataSourceRule);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == actualTables || actualTables.isEmpty()) &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       Preconditions.checkNotNull(dataSourceRule);</div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(Collections.singletonList(logicTable), dataSourceRule, dataSourceNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 静态表的分库分表数据单元</span></div><div class="line">       <span class="keyword">this</span>.actualTables = generateDataNodes(actualTables, dataSourceRule, dataSourceNames);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">this</span>.generateKeyColumn = generateKeyColumn;</div><div class="line">   <span class="keyword">this</span>.keyGenerator = keyGenerator;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>2.2.1 DataNode</h3>
<p>大多数业务场景下，我们使用<strong>静态</strong>分库分表数据单元，即 DataNode。如上文注释处 <code>静态表的分库分表数据单元</code> 处所见，分成<strong>两</strong>种判断，实质上第一种是将 <code>logicTable</code> 作为 <code>actualTable</code>，即在<strong>库</strong>里不进行分表，是第二种的一种特例。</p>
<p>我们来看看 <code>#generateDataNodes()</code> 方法：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 生成静态数据分片节点</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> actualTables 真实表</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 静态数据分片节点</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> List&lt;String&gt; actualTables, <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = getDataSourceNames(dataSourceRule, actualDataSourceNames);</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTables.size() * (dataSourceNames.isEmpty() ? <span class="number">1</span> : dataSourceNames.size()));</div><div class="line">   <span class="keyword">for</span> (String actualTable : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (DataNode.isValidDataNode(actualTable)) &#123; <span class="comment">// 当 actualTable 为 $&#123;dataSourceName&#125;.$&#123;tableName&#125; 时</span></div><div class="line">           result.add(<span class="keyword">new</span> DataNode(actualTable));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (String dataSourceName : dataSourceNames) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> DataNode(dataSourceName, actualTable));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据 数据源配置对象 和 数据源名集合 获得 最终的数据源名集合</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> dataSourceRule 数据源配置对象</div><div class="line">* <span class="doctag">@param</span> actualDataSourceNames 数据源名集合</div><div class="line">* <span class="doctag">@return</span> 最终的数据源名集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getDataSourceNames</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;String&gt; actualDataSourceNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == dataSourceRule) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == actualDataSourceNames || actualDataSourceNames.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> dataSourceRule.getDataSourceNames();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> actualDataSourceNames;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>第一种情况，<strong>自定义分布</strong>。<code>actualTable</code> 为 <code>${dataSourceName}.${tableName}</code> 时，即已经明确真实表所在数据源。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"db0.t_order_0"</span>, <span class="string">"db1.t_order_1"</span>, <span class="string">"db1.t_order_2"</span>))</div></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  └── t_order_0 </div><div class="line">db1</div><div class="line">  ├── t_order_1</div><div class="line">  └── t_order_2</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种情况，<strong>均匀分布</strong>。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TableRule.builder(<span class="string">"t_order"</span>).actualTables(Arrays.asList(<span class="string">"t_order_0"</span>, <span class="string">"t_order_1"</span>))</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">db0</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1 </div><div class="line">db1</div><div class="line">  ├── t_order_0 </div><div class="line">  └── t_order_1</div></pre></td></tr></table></figure></p>
<p><code>#getDataSourceNames()</code> 使用 <code>dataSourceRule</code> 和 <code>actualDataSourceNames</code> 获取数据源的逻辑看起来有种“诡异”。<strong>实际 TableRuleBuilder 创建 TableRule 时，使用 <code>dataSourceRule</code> 而不要使用 <code>actualDataSourceNames</code></strong>。</p>
<h3>2.2.2 DynamicDataNode</h3>
<p>少数业务场景下，我们使用<strong>动态</strong>分库分表数据单元，即 DynamicDataNode。
<strong>通过 <code>dynamic=true</code> 属性配置</strong>。生成代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;DataNode&gt; <span class="title">generateDataNodes</span><span class="params">(<span class="keyword">final</span> DataSourceRule dataSourceRule)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; dataSourceNames = dataSourceRule.getDataSourceNames();</div><div class="line">   List&lt;DataNode&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(dataSourceNames.size());</div><div class="line">   <span class="keyword">for</span> (String each : dataSourceNames) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> DynamicDataNode(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>😂 从代码上看，貌似和<strong>动态</strong>分库分表数据单元没一毛钱关系？！别捉鸡，答案在<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 上。</p>
<h2>2.3 分库/分表策略</h2>
<ul>
<li><code>databaseShardingStrategy</code> ：分库策略</li>
<li><code>tableShardingStrategy</code> ：分表策略</li>
</ul>
<p>当分库/分表策略不配置时，使用 ShardingRule 配置的分库/分表策略。</p>
<h2>2.4 主键生成</h2>
<ul>
<li><code>generateKeyColumn</code> ：主键字段</li>
<li><code>keyGenerator</code> ：主键生成器</li>
</ul>
<p>当主键生成器不配置时，使用 ShardingRule 配置的主键生成器。</p>
<h1>3. ShardingRule</h1>
<p>ShardingRule，分库分表规则配置对象，内嵌 ShardingRuleBuilder 对象进行创建。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/03.png" alt=""></p>
<p>其中 databaseShardingStrategy、tableShardingStrategy、keyGenerator、defaultGenerator 和 TableRule 属性重复，用于当 TableRule 未配置对应属性，使用 ShardingRule 提供的该属性。</p>
<h2>3.1 dataSourceRule</h2>
<p><code>dataSourceRule</code>，数据源配置对象。ShardingRule 需要数据源配置正确。这点和 TableRule 是不同的。TableRule 对 <code>dataSourceRule</code> <strong>只使用数据源名字，最终执行SQL 使用数据源名字从 ShardingRule 获取数据源连接</strong>。大家可以回到本文【2.2.1 DataNode】细看下 DataNode 的生成过程。</p>
<h2>3.2 tableRules</h2>
<p><code>tableRules</code>，表规则配置对象<strong>集合</strong>。</p>
<h2>3.3 bindingTableRules</h2>
<blockquote>
<p>指在任何场景下分片规则均一致的主表和子表。<br>
例：订单表和订单项表，均按照订单ID分片，则此两张表互为BindingTable关系。<br>
BindingTable关系的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。</p>
</blockquote>
<p>😈 这么说，可能不太容易理解。<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>，我们在源码的基础上，好好理解下。<strong>非常重要，特别是性能优化上面</strong>。</p>
<h1>4. ShardingStrategy</h1>
<p>ShardingStrategy，分片策略。</p>
<ul>
<li>针对分库、分表有两个子类。</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p>
<ul>
<li>DatabaseShardingStrategy，使用<strong>分库</strong>算法进行分片</li>
<li>TableShardingStrategy，使用<strong>分表</strong>算法进行分片</li>
</ul>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1>5. ShardingAlgorithm</h1>
<p>ShardingAlgorithm，分片算法。</p>
<ul>
<li>针对分库、分表有两个子<strong>接口</strong>。</li>
<li>针对<strong>分片键</strong>数量分成：无分片键算法、单片键算法、多片键算法。</li>
</ul>
<p><strong>其中 NoneKeyDatabaseShardingAlgorithm、NoneTableShardingAlgorithm 为 ShardingRule 在未设置分库、分表算法的默认值</strong>。代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingRule</span><span class="params">(</span></span></div><div class="line">       <span class="keyword">final</span> DataSourceRule dataSourceRule, <span class="keyword">final</span> Collection&lt;TableRule&gt; tableRules, <span class="keyword">final</span> Collection&lt;BindingTableRule&gt; bindingTableRules,</div><div class="line">       <span class="keyword">final</span> DatabaseShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> TableShardingStrategy tableShardingStrategy, <span class="keyword">final</span> KeyGenerator keyGenerator) &#123;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">   <span class="keyword">this</span>.databaseShardingStrategy = <span class="keyword">null</span> == databaseShardingStrategy ? <span class="keyword">new</span> DatabaseShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneDatabaseShardingAlgorithm()) : databaseShardingStrategy;</div><div class="line">   <span class="keyword">this</span>.tableShardingStrategy = <span class="keyword">null</span> == tableShardingStrategy ? <span class="keyword">new</span> TableShardingStrategy(</div><div class="line">           Collections.&lt;String&gt;emptyList(), <span class="keyword">new</span> NoneTableShardingAlgorithm()) : tableShardingStrategy;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a> 会进一步说明。</p>
<h1>666. 彩蛋</h1>
<p>本文看似在水更，实是为<a href="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《分表分库路由》</a>做铺垫（一阵脸红😳）。</p>
<p>But，无论怎么说，道友，我做了新的关注二维码（感谢猫🐱先生），是不是可以推荐一波公众号给基佬。</p>
<p>恩，继续更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（六）之删除SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-6/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-6/</id>
    <published>2017-08-01T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. DeleteStatement</a></li>
<li><a href="#">3. #parse()</a>
<ul>
<li><a href="#">3.1 #skipBetweenDeleteAndTable()</a></li>
<li><a href="#">3.2 #parseSingleTable()</a></li>
<li><a href="#">3.3 #parseWhere()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>删除SQL解析</strong>的源码实现。</p>
<p>🙂 如果你已经理解<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之查询SQL》</a>，那本文会是一篇水文，当成一种放松吧。还是跟前文一样，以 MySQL 举例子。我们来一起看看 MySQLDeleteParser。</p>
<p>MySQL DELETE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>] <span class="keyword">FROM</span> tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</div><div class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    tbl_name[.*] [, tbl_name[.*]] ...</div><div class="line">    <span class="keyword">FROM</span> table_references</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    </div><div class="line">【<span class="keyword">OR</span>】</div><div class="line"></div><div class="line"><span class="keyword">DELETE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">QUICK</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    <span class="keyword">FROM</span> tbl_name[.*] [, tbl_name[.*]] ...</div><div class="line">    <span class="keyword">USING</span> table_references</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div></pre></td></tr></table></figure></p>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<p>Sharding-JDBC 更新SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_02/01.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> DeleteStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 DELETE</span></div><div class="line">   skipBetweenDeleteAndTable(); <span class="comment">// // 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE 和 FROM</span></div><div class="line">   sqlParser.parseSingleTable(deleteStatement); <span class="comment">// 解析表</span></div><div class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE); <span class="comment">// 跳到 WHERE</span></div><div class="line">   sqlParser.parseWhere(deleteStatement); <span class="comment">// 解析 WHERE</span></div><div class="line">   <span class="keyword">return</span> deleteStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. DeleteStatement</h1>
<p>删除SQL 解析结果。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>😈 对，没有其他属性。</p>
<p>我们来看下 <code>DELETE IGNORE FROM t_user WHERE user_id = ?</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_02/02.png" alt=""></p>
<h1>3. #parse()</h1>
<h2>3.1 #skipBetweenDeleteAndTable()</h2>
<p>在 <code>DELETE</code> 和 表名 之间有些词法，对 SQL 路由和改写无影响，进行跳过。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenDeleteAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipAll(MySQLKeyword.LOW_PRIORITY, MySQLKeyword.QUICK, MySQLKeyword.IGNORE);</div><div class="line">   getSqlParser().skipIfEqual(DefaultKeyword.FROM);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OracleDeleteParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenDeleteAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipIfEqual(DefaultKeyword.FROM);</div><div class="line">   getSqlParser().skipIfEqual(OracleKeyword.ONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 #parseSingleTable()</h2>
<p>解析<strong>表</strong>，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2>3.3 #parseWhere()</h2>
<p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h1>666. 彩蛋</h1>
<p>道友，帮我分享一波怎么样？</p>
<p><strong>后面 SQL 路由和改写会更加有趣哟！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（五）之更新SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-5/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-5/</id>
    <published>2017-07-30T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. UpdateStatement</a></li>
<li><a href="#">3. #parse()</a>
<ul>
<li><a href="#">3.1 #skipBetweenUpdateAndTable()</a></li>
<li><a href="#">3.2 #parseSingleTable()</a></li>
<li><a href="#">3.3 #parseSetItems()</a></li>
<li><a href="#">3.4 #parseWhere()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>更新SQL解析</strong>的源码实现。</p>
<p>更新SQL解析比查询SQL解析复杂度低的多的多。不同数据库在插入SQL语法上也统一的多。<strong>本文分享 MySQL 更新SQL解析器 MySQLUpdateParser</strong>。</p>
<p>MySQL UPDATE 语法一共有 2 种 ：</p>
<ul>
<li>第一种：<strong>Single-table syntax</strong></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_reference</div><div class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</div><div class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种：<strong>Multiple-table syntax</strong></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_references</div><div class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div></pre></td></tr></table></figure></p>
<p>Sharding-JDBC 目前仅支持第一种。业务场景上使用第二种的很少很少。</p>
<p>Sharding-JDBC 更新SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_31/01.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> UpdateStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 UPDATE</span></div><div class="line">   skipBetweenUpdateAndTable(); <span class="comment">// 跳过关键字，例如：MYSQL 里的 LOW_PRIORITY、IGNORE</span></div><div class="line">   sqlParser.parseSingleTable(updateStatement); <span class="comment">// 解析表</span></div><div class="line">   parseSetItems(); <span class="comment">// 解析 SET</span></div><div class="line">   sqlParser.skipUntil(DefaultKeyword.WHERE);</div><div class="line">   sqlParser.setParametersIndex(parametersIndex);</div><div class="line">   sqlParser.parseWhere(updateStatement);</div><div class="line">   <span class="keyword">return</span> updateStatement; <span class="comment">// 解析 WHERE</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. UpdateStatement</h1>
<p>更新SQL 解析结果。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>😈 对，没有其他属性。</p>
<p>我们来看下 <code>UPDATE t_user SET nickname = ?, age = ? WHERE user_id = ?</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_31/02.png" alt=""></p>
<h1>3. #parse()</h1>
<h2>3.1 #skipBetweenUpdateAndTable()</h2>
<p>在 <code>UPDATE</code> 和 表名 之间有些词法，对 SQL 路由和改写无影响，进行跳过。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenUpdateAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipAll(MySQLKeyword.LOW_PRIORITY, MySQLKeyword.IGNORE);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// OracleUpdateParser.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">skipBetweenUpdateAndTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   getSqlParser().skipIfEqual(OracleKeyword.ONLY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.2 #parseSingleTable()</h2>
<p>解析<strong>表</strong>，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2>3.3 #parseSetItems()</h2>
<p>解析<code>SET</code>后语句。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractUpdateParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析多个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.accept(DefaultKeyword.SET);</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       parseSetItem();</div><div class="line">   &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA)); <span class="comment">// 以 "," 分隔</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetItem</span><span class="params">()</span> </span>&#123;</div><div class="line">   parseSetColumn();</div><div class="line">   sqlParser.skipIfEqual(Symbol.EQ, Symbol.COLON_EQ);</div><div class="line">   parseSetValue();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetColumn</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       sqlParser.skipParentheses();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> beginPosition = sqlParser.getLexer().getCurrentToken().getEndPosition();</div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// 字段有别名</span></div><div class="line">       <span class="comment">// TableToken</span></div><div class="line">       <span class="keyword">if</span> (updateStatement.getTables().getSingleTableName().equalsIgnoreCase(SQLUtil.getExactlyValue(literals))) &#123;</div><div class="line">           updateStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition - literals.length(), literals));</div><div class="line">       &#125;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个 SET 值</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSetValue</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.parseExpression(updateStatement);</div><div class="line">   parametersIndex = sqlParser.getParametersIndex();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 #parseWhere()</h2>
<p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h1>666. 彩蛋</h1>
<p>😝 比更新SQL解析是不是简单，更不用对比查询SQL解析。😳有一种在水更的感觉。嘿嘿，下一篇（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a>）会更加容易。</p>
<p>道友，帮我分享一波怎么样？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（四）之插入SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-4/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-4/</id>
    <published>2017-07-28T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. InsertStatement</a></li>
<li><a href="#">3. #parse()</a>
<ul>
<li><a href="#">3.1 #parseInfo()</a></li>
<li><a href="#">3.2 #parseColumns()</a></li>
<li><a href="#">3.3 #parseValues()</a></li>
<li><a href="#">3.4 #parseCustomizedInsert()</a></li>
<li><a href="#">3.5 #appendGenerateKey()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>插入SQL解析</strong>的源码实现。</p>
<p>不考虑 INSERT SELECT 情况下，插入SQL解析比查询SQL解析复杂度低的多的多。不同数据库在插入SQL语法上也统一的多。<strong>本文分享 MySQL 插入SQL解析器 MySQLInsertParser</strong>。</p>
<p>MySQL INSERT 语法一共有 3 种 ：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [(col_name,...)]</div><div class="line">    &#123;<span class="keyword">VALUES</span> | <span class="keyword">VALUE</span>&#125; (&#123;expr | <span class="keyword">DEFAULT</span>&#125;,...),(...),...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">DELAYED</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    <span class="keyword">SET</span> col_name=&#123;expr | <span class="keyword">DEFAULT</span>&#125;, ...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure></p>
<ul>
<li>第三种：<code>INSERT SELECT</code></li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> [<span class="keyword">LOW_PRIORITY</span> | <span class="keyword">HIGH_PRIORITY</span>] [<span class="keyword">IGNORE</span>]</div><div class="line">    [<span class="keyword">INTO</span>] tbl_name</div><div class="line">    [<span class="keyword">PARTITION</span> (partition_name,...)]</div><div class="line">    [(col_name,...)]</div><div class="line">    <span class="keyword">SELECT</span> ...</div><div class="line">    [ <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span></div><div class="line">      col_name=expr</div><div class="line">        [, col_name=expr] ... ]</div></pre></td></tr></table></figure></p>
<p>Sharding-JDBC 目前支持：</p>
<ul>
<li>第一种：<code>INSERT {VALUES | VALUES}</code> <strong>单条记录</strong></li>
<li>第二种：<code>INSERT SET</code></li>
</ul>
<p>Sharding-JDBC 插入SQL解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_29/01.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InsertStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   sqlParser.getLexer().nextToken(); <span class="comment">// 跳过 INSERT 关键字</span></div><div class="line">   parseInto(); <span class="comment">// 解析INTO</span></div><div class="line">   parseColumns(); <span class="comment">// 解析表</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT, Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (getValuesKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第一种插入SQL情况</span></div><div class="line">       parseValues();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getCustomizedInsertKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123; <span class="comment">// 第二种插入SQL情况</span></div><div class="line">       parseCustomizedInsert();</div><div class="line">   &#125;</div><div class="line">   appendGenerateKey(); <span class="comment">// 自增主键</span></div><div class="line">   <span class="keyword">return</span> insertStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. InsertStatement</h1>
<p>插入SQL 解析结果。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 插入字段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Column&gt; columns = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> GeneratedKey generatedKey;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 插入字段 下一个Token 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> columnsListLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值字段 下一个Token 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> valuesListLastPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看下 <code>INSERT INTO t_order (uid, nickname) VALUES (?, ?)</code> 的<strong>解析结果</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_29/02.png" alt=""></p>
<h1>3. #parse()</h1>
<h2>3.1 #parseInto()</h2>
<p>解析<strong>表</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInto</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 例如，Oracle，INSERT FIRST/ALL 目前不支持</span></div><div class="line">   <span class="keyword">if</span> (getUnsupportedKeywords().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">   sqlParser.skipUntil(DefaultKeyword.INTO);</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="comment">// 解析表</span></div><div class="line">   sqlParser.parseSingleTable(insertStatement);</div><div class="line">   skipBetweenTableAndValues();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过 表 和 插入字段 中间的 Token</div><div class="line">* 例如 MySQL ：[PARTITION (partition_name,...)]</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipBetweenTableAndValues</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (getSkippedKeywordsBetweenTableAndValues().contains(sqlParser.getLexer().getCurrentToken().getType())) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>#parseSingleTable()</code> 请看<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的 <code>#parseSingleTable()</code> 小节</a>。</p>
<h2>3.2 #parseColumns()</h2>
<p>解析<strong>插入字段</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInsertParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseColumns</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;Column&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       String tableName = insertStatement.getTables().getSingleTableName();</div><div class="line">       Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName); <span class="comment">// 自动生成键信息</span></div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">do</span> &#123;</div><div class="line">           <span class="comment">// Column 插入字段</span></div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           String columnName = SQLUtil.getExactlyValue(sqlParser.getLexer().getCurrentToken().getLiterals());</div><div class="line">           result.add(<span class="keyword">new</span> Column(columnName, tableName));</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           <span class="comment">// 自动生成键</span></div><div class="line">           <span class="keyword">if</span> (generateKeyColumn.isPresent() &amp;&amp; generateKeyColumn.get().equalsIgnoreCase(columnName)) &#123;</div><div class="line">               generateKeyColumnIndex = count;</div><div class="line">           &#125;</div><div class="line">           count++;</div><div class="line">       &#125; <span class="keyword">while</span> (!sqlParser.equalAny(Symbol.RIGHT_PAREN) &amp;&amp; !sqlParser.equalAny(Assist.END));</div><div class="line">       <span class="comment">//</span></div><div class="line">       insertStatement.setColumnsListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">       <span class="comment">//</span></div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">   insertStatement.getColumns().addAll(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.3 #parseValues()</h2>
<p>解析<strong>值字段</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析值字段</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseValues</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> parsed = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       <span class="keyword">if</span> (parsed) &#123; <span class="comment">// 只允许INSERT INTO 一条</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support multiple insert"</span>);</div><div class="line">       &#125;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       sqlParser.accept(Symbol.LEFT_PAREN);</div><div class="line">       <span class="comment">// 解析表达式</span></div><div class="line">       List&lt;SQLExpression&gt; sqlExpressions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="keyword">do</span> &#123;</div><div class="line">           sqlExpressions.add(sqlParser.parseExpression());</div><div class="line">       &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA));</div><div class="line">       <span class="comment">//</span></div><div class="line">       insertStatement.setValuesListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">       <span class="comment">// 解析值字段</span></div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Column each : insertStatement.getColumns()) &#123;</div><div class="line">           SQLExpression sqlExpression = sqlExpressions.get(count);</div><div class="line">           insertStatement.getConditions().add(<span class="keyword">new</span> Condition(each, sqlExpression), shardingRule);</div><div class="line">           <span class="keyword">if</span> (generateKeyColumnIndex == count) &#123; <span class="comment">// 自动生成键</span></div><div class="line">               insertStatement.setGeneratedKey(createGeneratedKey(each, sqlExpression));</div><div class="line">           &#125;</div><div class="line">           count++;</div><div class="line">       &#125;</div><div class="line">       sqlParser.accept(Symbol.RIGHT_PAREN);</div><div class="line">       parsed = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (sqlParser.equalAny(Symbol.COMMA)); <span class="comment">// 字段以 "," 分隔</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建 自动生成键</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> column 字段</div><div class="line">* <span class="doctag">@param</span> sqlExpression 表达式</div><div class="line">* <span class="doctag">@return</span> 自动生成键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> GeneratedKey <span class="title">createGeneratedKey</span><span class="params">(<span class="keyword">final</span> Column column, <span class="keyword">final</span> SQLExpression sqlExpression)</span> </span>&#123;</div><div class="line">   GeneratedKey result;</div><div class="line">   <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLPlaceholderExpression) &#123; <span class="comment">// 占位符</span></div><div class="line">       result = <span class="keyword">new</span> GeneratedKey(column.getName(), ((SQLPlaceholderExpression) sqlExpression).getIndex(), <span class="keyword">null</span>);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLNumberExpression) &#123; <span class="comment">// 数字</span></div><div class="line">       result = <span class="keyword">new</span> GeneratedKey(column.getName(), -<span class="number">1</span>, ((SQLNumberExpression) sqlExpression).getNumber());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Generated key only support number."</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.4.1 GeneratedKey</h3>
<p>自动生成键，<strong>属于分片上下文信息</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedKey</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String column;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第几个占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Number value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.4.2 Condition</h3>
<p>条件对象，<strong>属于分片上下文信息</strong>。在<strong>插入SQL解析</strong>里存储<strong>影响分片的值字段</strong>。后续<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 路由》</a> 会专门分享这块。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Column column;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略其它属性</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Column</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 列名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 #parseCustomizedInsert()</h2>
<p>解析<strong>第二种插入SQL</strong>：<code>INSERT SET</code>。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">id</span> = <span class="number">4</span>  <span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> <span class="keyword">UPDATE</span> <span class="keyword">name</span> = <span class="string">'doubi'</span>, <span class="keyword">name</span> = <span class="string">'hehe'</span>;</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">SET</span> <span class="keyword">id</span> = <span class="number">4</span>, <span class="keyword">name</span> = <span class="string">'hehe'</span>;</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseInsertSet</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// 插入字段</span></div><div class="line">       Column column = <span class="keyword">new</span> Column(SQLUtil.getExactlyValue(getSqlParser().getLexer().getCurrentToken().getLiterals()), getInsertStatement().getTables().getSingleTableName());</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// 等号</span></div><div class="line">       getSqlParser().accept(Symbol.EQ);</div><div class="line">       <span class="comment">// 【值】表达式</span></div><div class="line">       SQLExpression sqlExpression;</div><div class="line">       <span class="keyword">if</span> (getSqlParser().equalAny(Literals.INT)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(getSqlParser().getLexer().getCurrentToken().getLiterals()));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Literals.FLOAT)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLNumberExpression(Double.parseDouble(getSqlParser().getLexer().getCurrentToken().getLiterals()));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Literals.CHARS)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLTextExpression(getSqlParser().getLexer().getCurrentToken().getLiterals());</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.NULL)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getSqlParser().equalAny(Symbol.QUESTION)) &#123;</div><div class="line">           sqlExpression = <span class="keyword">new</span> SQLPlaceholderExpression(getSqlParser().getParametersIndex());</div><div class="line">           getSqlParser().increaseParametersIndex();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">""</span>);</div><div class="line">       &#125;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       <span class="comment">// Condition</span></div><div class="line">       <span class="keyword">if</span> (getSqlParser().equalAny(Symbol.COMMA, DefaultKeyword.ON, Assist.END)) &#123;</div><div class="line">           getInsertStatement().getConditions().add(<span class="keyword">new</span> Condition(column, sqlExpression), getShardingRule());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           getSqlParser().skipUntil(Symbol.COMMA, DefaultKeyword.ON);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">while</span> (getSqlParser().equalAny(Symbol.COMMA)); <span class="comment">// 字段以 "," 分隔</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.5 #appendGenerateKey()</h2>
<p>当表设置<strong>自动生成键</strong>，并且插入SQL<strong>没</strong>写自增字段，增加该字段。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// 主键为user_id</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(nickname, age) <span class="keyword">VALUES</span> (?, ?)</div></pre></td></tr></table></figure></p>
<p>后续 SQL 改写会生成该自增编号，并改写该 SQL。后续<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 会专门分享这块。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKey</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 当表设置自动生成键，并且插入SQL没写自增字段</span></div><div class="line">   String tableName = insertStatement.getTables().getSingleTableName();</div><div class="line">   Optional&lt;String&gt; generateKeyColumn = shardingRule.getGenerateKeyColumn(tableName);</div><div class="line">   <span class="keyword">if</span> (!generateKeyColumn.isPresent() || <span class="keyword">null</span> != insertStatement.getGeneratedKey()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ItemsToken</span></div><div class="line">   ItemsToken columnsToken = <span class="keyword">new</span> ItemsToken(insertStatement.getColumnsListLastPosition());</div><div class="line">   columnsToken.getItems().add(generateKeyColumn.get());</div><div class="line">   insertStatement.getSqlTokens().add(columnsToken);</div><div class="line">   <span class="comment">// GeneratedKeyToken</span></div><div class="line">   insertStatement.getSqlTokens().add(<span class="keyword">new</span> GeneratedKeyToken(insertStatement.getValuesListLastPosition()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.5.1 GeneratedKeyToken</h3>
<p>自增主键标记对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedKeyToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>😈 是不是比<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/?self">《SQL 解析（三）之插入SQL》</a>简单很多。</p>
<p><strong>道友，可否分享一波【本文】到朋友圈</strong>。</p>
<p><strong>继续加油更新！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-3/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-3/</id>
    <published>2017-07-26T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SelectStatement</a>
<ul>
<li><a href="#">2.1 AbstractSQLStatement</a></li>
<li><a href="#">2.2 SQLToken</a></li>
</ul>
</li>
<li><a href="#">3. #query()</a>
<ul>
<li><a href="#">3.1 #parseDistinct()</a></li>
<li><a href="#">3.2 #parseSelectList()</a></li>
<li><a href="#">3.3 #skipToFrom()</a></li>
<li><a href="#">3.4 #parseFrom()</a></li>
<li><a href="#">3.5 #parseWhere()</a></li>
<li><a href="#">3.6 #parseGroupBy()</a></li>
<li><a href="#">3.7 #parseOrderBy()</a></li>
<li><a href="#">3.8 #parseLimit()</a></li>
<li><a href="#">3.9 #queryRest()</a></li>
</ul>
</li>
<li><a href="#">4. appendDerived等方法</a>
<ul>
<li><a href="#">4.1 appendAvgDerivedColumns</a></li>
<li><a href="#">4.2 appendDerivedOrderColumns</a></li>
<li><a href="#">4.3 ItemsToken</a></li>
<li><a href="#">4.4 appendDerivedOrderBy()</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>本文前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li>
<li><a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li>
</ul>
<p>本文分享<strong>插入SQL解析</strong>的源码实现。</p>
<p>由于每个数据库在遵守 SQL 语法规范的同时，又有各自独特的语法。因此，在 Sharding-JDBC 里每个数据库都有自己的 SELECT 语句的解析器实现方式，当然绝大部分逻辑是相同的。<strong>本文主要分享笔者最常用的 MySQL 查询</strong>。</p>
<p>查询 SQL 解析主流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/03.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   query();</div><div class="line">   parseOrderBy();</div><div class="line">   customizedSelect();</div><div class="line">   appendDerivedColumns();</div><div class="line">   appendDerivedOrderBy();</div><div class="line">   <span class="keyword">return</span> selectStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>#parseOrderBy()</code> ：对于 MySQL 查询语句解析器无效果，因为已经在 <code>#query()</code> 方法里面已经调用 <code>#parseOrderBy()</code>，因此图中省略该方法。</li>
<li><code>#customizedSelect()</code> ：Oracle、SQLServer 查询语句解析器重写了该方法，对于 MySQL 查询解析器是个空方法，进行省略。有兴趣的同学可以单独去研究研究。</li>
</ul>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<p>👼 查询语句解析是增删改查里面<strong>最灵活也是最复杂的</strong>，希望大家有耐心看完本文。理解查询语句解析，另外三种语句理解起来简直是 SO EASY。骗人是小狗🐶。<br>
🙂如果对本文有不理解的地方，可以给我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）<strong>留言，我会</strong>逐条认真耐心**回复。骗人是小猪🐷。</p>
<p>OK，不废话啦，开始我们这段痛并快乐的旅途。</p>
<h1>2. SelectStatement</h1>
<p>🙂 <strong>本节只介绍这些类，方便本文下节分析源码实现大家能知道认识它们</strong> 🙂</p>
<p>SelectStatement，查询语句解析结果对象。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SelectStatement.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否行 DISTINCT / DISTINCTROW / UNION</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> distinct;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否查询所有字段，即 SELECT *</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> containStar;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后一个查询项下一个 Token 的开始位置</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #items</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectListLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最后一个分组项下一个 Token 的开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groupByLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查询项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectItem&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 排序项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分页</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Limit limit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们对属性按照类型进行归类：</p>
<ul>
<li>特殊
<ul>
<li>distinct</li>
</ul>
</li>
<li>查询字段
<ul>
<li>containStar</li>
<li>items</li>
<li>selectListLastPosition</li>
</ul>
</li>
<li>分组条件
<ul>
<li>groupByItems</li>
<li>groupByLastPosition</li>
</ul>
</li>
<li>排序条件
<ul>
<li>orderByItems</li>
</ul>
</li>
<li>分页条件
<ul>
<li>limit</li>
</ul>
</li>
</ul>
<h2>2.1 AbstractSQLStatement</h2>
<p>增删改查解析结果对象的<strong>抽象父类</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSQLStatement</span> <span class="keyword">implements</span> <span class="title">SQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tables tables = <span class="keyword">new</span> Tables();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 过滤条件。</div><div class="line">     * 只有对路由结果有影响的条件，才添加进数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Conditions conditions = <span class="keyword">new</span> Conditions();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL标记对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>2.2 SQLToken</h2>
<p>SQLToken，SQL标记对象接口，SQL 改写时使用到。下面都是它的实现类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GeneratedKeyToken</td>
<td style="text-align:left">自增主键标记对象</td>
</tr>
<tr>
<td style="text-align:left">TableToken</td>
<td style="text-align:left">表标记对象</td>
</tr>
<tr>
<td style="text-align:left">ItemsToken</td>
<td style="text-align:left">选择项标记对象</td>
</tr>
<tr>
<td style="text-align:left">OffsetToken</td>
<td style="text-align:left">分页偏移量标记对象</td>
</tr>
<tr>
<td style="text-align:left">OrderByToken</td>
<td style="text-align:left">排序标记对象</td>
</tr>
<tr>
<td style="text-align:left">RowCountToken</td>
<td style="text-align:left">分页长度标记对象</td>
</tr>
</tbody>
</table>
<h1>3. #query()</h1>
<p><code>#query()</code>，查询 SQL 解析。</p>
<p><strong>MySQL SELECT Syntax</strong>：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/select.html</div><div class="line"><span class="keyword">SELECT</span></div><div class="line">    [ALL | <span class="keyword">DISTINCT</span> | <span class="keyword">DISTINCTROW</span> ]</div><div class="line">      [<span class="keyword">HIGH_PRIORITY</span>]</div><div class="line">      [<span class="keyword">STRAIGHT_JOIN</span>]</div><div class="line">      [<span class="keyword">SQL_SMALL_RESULT</span>] [<span class="keyword">SQL_BIG_RESULT</span>] [<span class="keyword">SQL_BUFFER_RESULT</span>]</div><div class="line">      [<span class="keyword">SQL_CACHE</span> | SQL_NO_CACHE] [<span class="keyword">SQL_CALC_FOUND_ROWS</span>]</div><div class="line">    select_expr [, select_expr ...]</div><div class="line">    [<span class="keyword">FROM</span> table_references</div><div class="line">      [<span class="keyword">PARTITION</span> partition_list]</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</div><div class="line">    [<span class="keyword">HAVING</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</div><div class="line">    [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</div><div class="line">    [<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</div><div class="line">    [<span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'file_name'</span></div><div class="line">        [<span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</div><div class="line">        export_options</div><div class="line">      | <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> <span class="string">'file_name'</span></div><div class="line">      | <span class="keyword">INTO</span> var_name [, var_name]]</div><div class="line">    [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> | <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>]]</div></pre></td></tr></table></figure></p>
<p>大体流程如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/04.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       parseDistinct();</div><div class="line">       getSqlParser().skipAll(MySQLKeyword.HIGH_PRIORITY, DefaultKeyword.STRAIGHT_JOIN, MySQLKeyword.SQL_SMALL_RESULT, MySQLKeyword.SQL_BIG_RESULT, MySQLKeyword.SQL_BUFFER_RESULT,</div><div class="line">               MySQLKeyword.SQL_CACHE, MySQLKeyword.SQL_NO_CACHE, MySQLKeyword.SQL_CALC_FOUND_ROWS);</div><div class="line">       parseSelectList(); <span class="comment">// 解析 查询字段</span></div><div class="line">       skipToFrom(); <span class="comment">// 跳到 FROM 处</span></div><div class="line">   &#125;</div><div class="line">   parseFrom();<span class="comment">// 解析 表（JOIN ON / FROM 单&amp;多表）</span></div><div class="line">   parseWhere(); <span class="comment">// 解析 WHERE 条件</span></div><div class="line">   parseGroupBy(); <span class="comment">// 解析 Group By 和 Having（目前不支持）条件</span></div><div class="line">   parseOrderBy(); <span class="comment">// 解析 Order By 条件</span></div><div class="line">   parseLimit(); <span class="comment">// 解析 分页 Limit 条件</span></div><div class="line">   <span class="comment">// [PROCEDURE] 暂不支持</span></div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.PROCEDURE)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getSqlParser().getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">   queryRest();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.1 #parseDistinct()</h2>
<p>解析 DISTINCT、DISTINCTROW、UNION 谓语。</p>
<p>核心代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseDistinct</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DISTINCT, DefaultKeyword.DISTINCTROW, DefaultKeyword.UNION)) &#123;</div><div class="line">       selectStatement.setDistinct(<span class="keyword">true</span>);</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (hasDistinctOn() &amp;&amp; sqlParser.equalAny(DefaultKeyword.ON)) &#123; <span class="comment">// PostgreSQL 独有语法： DISTINCT ON</span></div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ALL)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此处 DISTINCT 和 DISTINCT(字段) 不同，它是针对查询结果做去重，即整行重复。举个例子：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT item_id, order_id FROM t_order_item;</div><div class="line">+---------+----------+</div><div class="line">| item_id | order_id |</div><div class="line">+---------+----------+</div><div class="line">| 1       | 1        |</div><div class="line">| 1       | 1        |</div><div class="line">+---------+----------+</div><div class="line">2 rows in set (0.03 sec)</div><div class="line"></div><div class="line">mysql&gt; SELECT DISTINCT item_id, order_id FROM t_order_item;</div><div class="line">+---------+----------+</div><div class="line">| item_id | order_id |</div><div class="line">+---------+----------+</div><div class="line">| 1       | 1        |</div><div class="line">+---------+----------+</div><div class="line">1 rows in set (0.02 sec)</div></pre></td></tr></table></figure></p>
<h2>3.2 #parseSelectList()</h2>
<table>
<thead>
<tr>
<th>SELECT</th>
<th>o.user_id</th>
<th>COUNT(DISTINCT i.item_id) AS item_count</th>
<th>MAX(i.item_id)</th>
<th>FROM</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>SelectItem</td>
<td>SelectItem</td>
<td>SelectItem</td>
<td></td>
</tr>
</tbody>
</table>
<p>将 SQL <strong>查询字段</strong> 按照<strong>逗号( , )<strong>切割成</strong>多个</strong>选择项( SelectItem)。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSelectList</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       <span class="comment">// 解析单个选择项</span></div><div class="line">       parseSelectItem();</div><div class="line">   &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA));</div><div class="line">   <span class="comment">// 设置 最后一个查询项下一个 Token 的开始位置</span></div><div class="line">   selectStatement.setSelectListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.1 SelectItem 选择项</h3>
<p>SelectItem 接口，<strong>属于分片上下文信息</strong>，有 2 个实现类：</p>
<ul>
<li>CommonSelectItem ：通用选择项</li>
<li>AggregationSelectItem ：聚合选择项</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/01.png" alt=""></p>
<p>解析单个 SelectItem 核心代码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectItem</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 第四种情况，SQL Server 独有</span></div><div class="line">   <span class="keyword">if</span> (isRowNumberSelectItem()) &#123;</div><div class="line">       selectStatement.getItems().add(parseRowNumberSelectItem());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   sqlParser.skipIfEqual(DefaultKeyword.CONNECT_BY_ROOT); <span class="comment">// Oracle 独有：https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators004.htm</span></div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   <span class="comment">// 第一种情况，* 通用选择项，SELECT *</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.STAR) || Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(Symbol.STAR.getLiterals(), sqlParser.parseAlias()));</div><div class="line">       selectStatement.setContainStar(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第二种情况，聚合选择项</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.MAX, DefaultKeyword.MIN, DefaultKeyword.SUM, DefaultKeyword.AVG, DefaultKeyword.COUNT)) &#123;</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> AggregationSelectItem(AggregationType.valueOf(literals.toUpperCase()), sqlParser.skipParentheses(), sqlParser.parseAlias()));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第三种情况，非 * 通用选择项</span></div><div class="line">   StringBuilder expression = <span class="keyword">new</span> StringBuilder();</div><div class="line">   Token lastToken = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">while</span> (!sqlParser.equalAny(DefaultKeyword.AS) &amp;&amp; !sqlParser.equalAny(Symbol.COMMA) &amp;&amp; !sqlParser.equalAny(DefaultKeyword.FROM) &amp;&amp; !sqlParser.equalAny(Assist.END)) &#123;</div><div class="line">       String value = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">       <span class="keyword">int</span> position = sqlParser.getLexer().getCurrentToken().getEndPosition() - value.length();</div><div class="line">       expression.append(value);</div><div class="line">       lastToken = sqlParser.getLexer().getCurrentToken();</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (sqlParser.equalAny(Symbol.DOT)) &#123;</div><div class="line">           selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(position, value));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 不带 AS，并且有别名，并且别名不等于自己（tips：这里重点看。判断这么复杂的原因：防止substring操作截取结果错误）</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != lastToken &amp;&amp; Literals.IDENTIFIER == lastToken.getType()</div><div class="line">           &amp;&amp; !isSQLPropertyExpression(expression, lastToken) <span class="comment">// 过滤掉，别名是自己的情况【1】（例如，SELECT u.user_id u.user_id FROM t_user）</span></div><div class="line">           &amp;&amp; !expression.toString().equals(lastToken.getLiterals())) &#123; <span class="comment">// 过滤掉，无别名的情况【2】（例如，SELECT user_id FROM t_user）</span></div><div class="line">       selectStatement.getItems().add(</div><div class="line">               <span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.substring(<span class="number">0</span>, expression.lastIndexOf(lastToken.getLiterals()))), Optional.of(lastToken.getLiterals())));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 带 AS（例如，SELECT user_id AS userId） 或者 无别名（例如，SELECT user_id）</span></div><div class="line">   selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.toString()), sqlParser.parseAlias()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一共分成 4 种大的情况，我们来逐条梳理：</p>
<ul>
<li>第一种：<strong><code>*</code> 通用选择项</strong>：<br>
例如，<code>SELECT * FROM t_user</code> 的 <code>*</code>。<br>
为什么要加   <code>Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))</code> 判断呢？</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">`*`</span> <span class="keyword">FROM</span> t_user; // 也能达到查询所有字段的效果</div></pre></td></tr></table></figure></p>
<ul>
<li>第二种：<strong>聚合选择项</strong>：<br>
例如，<code>SELECT COUNT(user_id) FROM t_user</code> 的 <code>COUNT(user_id)</code>。</li>
</ul>
<p>解析结果 AggregationSelectItem：<br>
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/05.png" alt=""></p>
<p><code>sqlParser.skipParentheses()</code> 解析见<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的AbstractParser小节</a>。</p>
<ul>
<li>第三种：<strong>非 <code>*</code> 通用选择项</strong>：</li>
</ul>
<p>例如，<code>SELECT user_id FROM t_user</code>。</p>
<p>从实现上，逻辑会复杂很多。相比第一种，可以根据 <code>*</code> 做字段判断；相比第二种，可以使用 <code>(</code> 和 <code>)</code> 做字段判断。能够判断一个<strong>包含别名的</strong> SelectItem 结束有 4 种 Token，根据结束方式我们分成 2 种：</p>
<ul>
<li>DefaultKeyword.AS ：能够接触出 SelectItem 字段，<strong>即不包含别名</strong>。例如，<code>SELECT user_id AS uid FROM t_user</code>，能够直接解析出 <code>user_id</code>。</li>
<li>Symbol.COMMA / DefaultKeyword.FROM / Assist.END ：<strong>包含别名</strong>。例如，<code>SELECT user_id uid FROM t_user</code>，解析结果为 <code>user_id uid</code>。</li>
</ul>
<p>基于这个在配合上面的代码注释，大家再重新理解下第三种情况的实现。</p>
<ul>
<li>第四种：SQLServer ROW_NUMBER：</li>
</ul>
<p>ROW_NUMBER 是 SQLServer 独有的。由于本文大部分的读者使用的 MySQL / Oracle，就跳过了。有兴趣的同学可以看 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/dialect/sqlserver/SQLServerSelectParser.java" rel="external nofollow noopener noreferrer" target="_blank">SQLServerSelectParser#parseRowNumberSelectItem()</a> 方法。</p>
<h3>3.2.2 #parseAlias() 解析别名</h3>
<p>解析别名，分成是否带 <code>AS</code> 两种情况。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseAlias()小节</a>。</p>
<h3>3.2.3 TableToken 表标记对象</h3>
<p>TableToken，记录表名在 SQL 里出现的<strong>位置</strong>和<strong>名字</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表达式</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String originalLiterals;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取表名称.</div><div class="line">     * <span class="doctag">@return</span> 表名称</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例如上文第三种情况。
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/06.png" alt=""></p>
<h2>3.3 #skipToFrom()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 跳到 FROM 处</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipToFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (!getSqlParser().equalAny(DefaultKeyword.FROM) &amp;&amp; !getSqlParser().equalAny(Assist.END)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 #parseFrom()</h2>
<p>解析表以及表连接关系。<strong>这块相对比较复杂，请大家耐心+耐心+耐心。</strong></p>
<p><strong>MySQL JOIN Syntax</strong>：</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/join.html</div><div class="line">table_references:</div><div class="line">    escaped_table_reference [, escaped_table_reference] ...</div><div class="line"></div><div class="line">escaped_table_reference:</div><div class="line">    table_reference</div><div class="line">  | &#123; OJ table_reference &#125;</div><div class="line"></div><div class="line">table_reference:</div><div class="line">    table_factor</div><div class="line">  | join_table</div><div class="line"></div><div class="line">table_factor:</div><div class="line">    tbl_name [PARTITION (partition_names)]</div><div class="line">        [[AS] alias] [index_hint_list]</div><div class="line">  | table_subquery [AS] alias</div><div class="line">  | ( table_references )</div><div class="line"></div><div class="line">join_table:</div><div class="line">    table_reference [INNER | CROSS] JOIN table_factor [join_condition]</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor ON conditional_expr</div><div class="line">  | table_reference &#123;LEFT|RIGHT&#125; [OUTER] JOIN table_reference join_condition</div><div class="line">  | table_reference NATURAL [&#123;LEFT|RIGHT&#125; [OUTER]] JOIN table_factor</div><div class="line"></div><div class="line">join_condition:</div><div class="line">    ON conditional_expr</div><div class="line">  | USING (column_list)</div><div class="line"></div><div class="line">index_hint_list:</div><div class="line">    index_hint [, index_hint] ...</div><div class="line"></div><div class="line">index_hint:</div><div class="line">    USE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] ([index_list])</div><div class="line">  | IGNORE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</div><div class="line">  | FORCE &#123;INDEX|KEY&#125;</div><div class="line">      [FOR &#123;JOIN|ORDER BY|GROUP BY&#125;] (index_list)</div><div class="line"></div><div class="line">index_list:</div><div class="line">    index_name [, index_name] ...</div></pre></td></tr></table></figure></p>
<h3>3.4.1 JOIN ON / FROM TABLE</h3>
<p>先抛开<strong>子查询</strong>的情况，只考虑如下两种 SQL 情况。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// JOIN ON ： 实际可以继续 JOIN ON 更多表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id = i.order_id; </div><div class="line">// FROM 多表 ：实际可以继续 FROM 多更表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o, t_order_item i</div></pre></td></tr></table></figure></p>
<p>在看实现代码之前，先一起看下调用顺序图：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_27/02.png" alt=""></p>
<p>看懂上图后，来继续看下实现代码（🙂<strong>代码有点多，不要方！</strong>）：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.FROM)) &#123;</div><div class="line">       parseTable();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析子查询</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery for nested tables."</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setContainStar(<span class="keyword">false</span>);</div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询左括号</span></div><div class="line">       parse(); <span class="comment">// 解析子查询 SQL</span></div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询右括号</span></div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   parseTableFactor(); <span class="comment">// 解析当前表</span></div><div class="line">   parseJoinTable(); <span class="comment">// 解析下一个表</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个表名和表别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseTableFactor</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> beginPosition = sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length();</div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="comment">// TODO 包含Schema解析</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// https://dev.mysql.com/doc/refman/5.7/en/information-schema.html ：SELECT table_name, table_type, engine FROM information_schema.tables</span></div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       sqlParser.parseAlias();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// FIXME 根据shardingRule过滤table</span></div><div class="line">   selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</div><div class="line">   <span class="comment">// 表 以及 表别名</span></div><div class="line">   selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Join Table 或者 FROM 下一张 Table</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseJoinTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipJoin()) &#123;</div><div class="line">       <span class="comment">// 这里调用 parseJoinTable() 而不是 parseTableFactor() ：下一个 Table 可能是子查询</span></div><div class="line">       <span class="comment">// 例如：SELECT * FROM t_order JOIN (SELECT * FROM t_order_item JOIN t_order_other ON ) .....</span></div><div class="line">       parseTable();</div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.ON)) &#123; <span class="comment">// JOIN 表时 ON 条件</span></div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">               sqlParser.accept(Symbol.EQ);</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">           &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(DefaultKeyword.AND));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.USING)) &#123; <span class="comment">// JOIN 表时 USING 为使用两表相同字段相同时对 ON 的简化。例如以下两条 SQL 等价：</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i USING (order_id);</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id</span></div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">       parseJoinTable(); <span class="comment">// 继续递归</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 ON 条件里的 TableToken</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> startPosition 开始位置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseTableCondition</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> startPosition)</span> </span>&#123;</div><div class="line">   SQLExpression sqlExpression = sqlParser.parseExpression();</div><div class="line">   <span class="keyword">if</span> (!(sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression)) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">   <span class="keyword">if</span> (selectStatement.getTables().getTableNames().contains(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()))) &#123;</div><div class="line">       selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(startPosition, sqlPropertyExpression.getOwner().getName()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，递归因为平时日常中写的比较少，可能理解起来可能会困难一些，努力看懂！🙂<strong>如果真的看不懂，可以加微信公众号（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>），我来帮你一起理解。</strong></p>
<h3>3.4.2 子查询</h3>
<p>Sharding-JDBC 目前支持<strong>第一个</strong>包含多层级的数据子查询。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3;</div><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o3.order_id = i.order_id;</div></pre></td></tr></table></figure></p>
<p>不支持<strong>第二个开始</strong>包含多层级的数据子查询。例如：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> t_order_item i <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">ON</span> o3.order_id = i.order_id; // 此条 SQL 是上面第二条 SQL 左右量表颠倒</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">WHERE</span> o.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">status</span> = ?)) // <span class="keyword">FROM</span> 官方不支持 <span class="keyword">SQL</span> 举例</div></pre></td></tr></table></figure></p>
<p>使用<strong>第二个开始</strong>的子查询会抛出异常，代码如下：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// AbstractSelectParser.java#parseTable()片段</div><div class="line">if (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">    throw new UnsupportedOperationException(&quot;Cannot support subquery for nested tables.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用子查询，建议认真阅读官方<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/subquery/" rel="external nofollow noopener noreferrer" target="_blank">《分页及子查询》</a>文档。</p>
<h3>3.4.3 #parseJoinTable()</h3>
<p>MySQLSelectParser 重写了 <code>#parseJoinTable()</code> 方法用于解析 USE / IGNORE / FORCE index_hint。具体语法见上文 <strong>JOIN Syntax</strong>。这里就跳过，有兴趣的同学可以去看看。</p>
<h3>3.4.4 Tables 表集合对象</h3>
<p><strong>属于分片上下文信息</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Tables.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tables</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Table&gt; tables = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Table.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 表</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 别名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractSelectParser.java#parseTableFactor()片段</span></div><div class="line">selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div></pre></td></tr></table></figure></p>
<h2>3.5 #parseWhere()</h2>
<p>解析 WHERE 条件。解析代码：<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p>
<h2>3.6 #parseGroupBy()</h2>
<p>解析分组条件，实现上比较类似 <code>#parseSelectList</code>，会更加简单一些。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Group By 和 Having（暂时不支持）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseGroupBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.GROUP)) &#123;</div><div class="line">       sqlParser.accept(DefaultKeyword.BY);</div><div class="line">       <span class="comment">// 解析 Group By 每个字段</span></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           addGroupByItem(sqlParser.parseExpression(selectStatement));</div><div class="line">           <span class="keyword">if</span> (!sqlParser.equalAny(Symbol.COMMA)) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (sqlParser.equalAny(DefaultKeyword.WITH) || sqlParser.getLexer().getCurrentToken().getLiterals().equalsIgnoreCase(<span class="string">"ROLLUP"</span>)) &#123;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Having（暂时不支持）</span></div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setGroupByLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 Group By 单个字段</div><div class="line">* Group By 条件是带有排序功能，默认ASC</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlExpression 表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGroupByItem</span><span class="params">(<span class="keyword">final</span> SQLExpression sqlExpression)</span> </span>&#123;</div><div class="line">   <span class="comment">// Group By 字段 DESC / ASC / ;默认是 ASC。</span></div><div class="line">   OrderType orderByType = OrderType.ASC;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ASC)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.DESC)) &#123;</div><div class="line">       orderByType = OrderType.DESC;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析 OrderItem</span></div><div class="line">   OrderItem orderItem;</div><div class="line">   <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression) &#123;</div><div class="line">       SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()), SQLUtil.getExactlyValue(sqlPropertyExpression.getName()), orderByType,</div><div class="line">               getAlias(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner() + <span class="string">"."</span> + SQLUtil.getExactlyValue(sqlPropertyExpression.getName()))));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLIdentifierExpression) &#123;</div><div class="line">       SQLIdentifierExpression sqlIdentifierExpression = (SQLIdentifierExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName()), orderByType, getAlias(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName())));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   selectStatement.getGroupByItems().add(orderItem);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 字段在查询项里的别名</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> name 字段</div><div class="line">* <span class="doctag">@return</span> 别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;String&gt; <span class="title">getAlias</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123;</div><div class="line">       <span class="keyword">return</span> Optional.absent();</div><div class="line">   &#125;</div><div class="line">   String rawName = SQLUtil.getExactlyValue(name);</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(SQLUtil.getExactlyValue(each.getExpression()))) &#123;</div><div class="line">           <span class="keyword">return</span> each.getAlias();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(each.getAlias().orNull())) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(rawName);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.6.1 OrderItem 排序项</h3>
<p><strong>属于分片上下文信息</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 所属表别名</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; owner;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 排序字段</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 排序类型</div><div class="line">    */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 按照第几个查询字段排序</div><div class="line">    * ORDER BY 数字 的 数字代表的是第几个字段</div><div class="line">    */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 字段在查询项(&#123;<span class="doctag">@link</span> com.dangdang.ddframe.rdb.sharding.parsing.parser.context.selectitem.SelectItem&#125; 的别名</div><div class="line">    */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.7 #parseOrderBy()</h2>
<p>解析排序条件。实现逻辑类似 <code>#parseGroupBy()</code>，这里就跳过，有兴趣的同学可以去看看。</p>
<h2>3.8 #parseLimit()</h2>
<p>解析分页 Limit 条件。相对简单，这里就跳过，有兴趣的同学可以去看看。注意下，分成 3 种情况：</p>
<ul>
<li>LIMIT row_count</li>
<li>LIMIT offset, row_count</li>
<li>LIMIT row_count OFFSET offset</li>
</ul>
<h3>3.8.1 Limit</h3>
<p>分页对象。<strong>属于分片上下文信息</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Limit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否重写rowCount</div><div class="line">     * TODO 待补充：预计和内存分页合并有关</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> rowCountRewriteFlag;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * offset</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LimitValue offset;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * row</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> LimitValue rowCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LimitValue.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitValue</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 值</div><div class="line">     * 当 value == -1 时，为占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 第几个占位符</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.8.2 OffsetToken RowCountToken</h3>
<ul>
<li>OffsetToken：分页偏移量标记对象</li>
<li>RowCountToken：分页长度标记对象</li>
</ul>
<p><strong>只有在对应位置非占位符才有该 SQLToken</strong>。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OffsetToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 偏移值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RowCountToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RowCountToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 行数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.9 #queryRest()</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">queryRest</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UNION, DefaultKeyword.EXCEPT, DefaultKeyword.INTERSECT, DefaultKeyword.MINUS)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不支持 UNION / EXCEPT / INTERSECT / MINUS ，调用会抛出异常。</p>
<h1>4. appendDerived等方法</h1>
<p>因为 Sharding-JDBC 对表做了分片，在 AVG , GROUP BY , ORDER BY 需要对 SQL 进行一些改写，<strong>以达到能在内存里对结果做进一步处理</strong>，例如求平均值、分组、排序等。</p>
<p>😈：打起精神，此块是非常有趣的。</p>
<h2>4.1 appendAvgDerivedColumns</h2>
<p>解决 AVG 查询。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 针对 AVG 聚合字段，增加推导字段</div><div class="line">* AVG 改写成 SUM + COUNT 查询，内存计算出 AVG 结果。</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> itemsToken 选择项标记对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAvgDerivedColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (!(each <span class="keyword">instanceof</span> AggregationSelectItem) || AggregationType.AVG != ((AggregationSelectItem) each).getType()) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       AggregationSelectItem avgItem = (AggregationSelectItem) each;</div><div class="line">       <span class="comment">// COUNT 字段</span></div><div class="line">       String countAlias = String.format(DERIVED_COUNT_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem countItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.COUNT, avgItem.getInnerExpression(), Optional.of(countAlias));</div><div class="line">       <span class="comment">// SUM 字段</span></div><div class="line">       String sumAlias = String.format(DERIVED_SUM_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem sumItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.SUM, avgItem.getInnerExpression(), Optional.of(sumAlias));</div><div class="line">       <span class="comment">// AggregationSelectItem 设置</span></div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(countItem);</div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(sumItem);</div><div class="line">       <span class="comment">// TODO 将AVG列替换成常数，避免数据库再计算无用的AVG函数</span></div><div class="line">       <span class="comment">// ItemsToken</span></div><div class="line">       itemsToken.getItems().add(countItem.getExpression() + <span class="string">" AS "</span> + countAlias + <span class="string">" "</span>);</div><div class="line">       itemsToken.getItems().add(sumItem.getExpression() + <span class="string">" AS "</span> + sumAlias + <span class="string">" "</span>);</div><div class="line">       <span class="comment">//</span></div><div class="line">       derivedColumnOffset++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.2 appendDerivedOrderColumns</h2>
<p>解决 GROUP BY , ORDER BY。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 针对 GROUP BY 或 ORDER BY 字段，增加推导字段</div><div class="line">* 如果该字段不在查询字段里，需要额外查询该字段，这样才能在内存里 GROUP BY 或 ORDER BY</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> itemsToken 选择项标记对象</div><div class="line">* <span class="doctag">@param</span> orderItems 排序字段</div><div class="line">* <span class="doctag">@param</span> aliasPattern 别名模式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems, <span class="keyword">final</span> String aliasPattern)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">       <span class="keyword">if</span> (!isContainsItem(each)) &#123;</div><div class="line">           String alias = String.format(aliasPattern, derivedColumnOffset++);</div><div class="line">           each.setAlias(Optional.of(alias));</div><div class="line">           itemsToken.getItems().add(each.getQualifiedName().get() + <span class="string">" AS "</span> + alias + <span class="string">" "</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 查询字段是否包含排序字段</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> orderItem 排序字段</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContainsItem</span><span class="params">(<span class="keyword">final</span> OrderItem orderItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123; <span class="comment">// SELECT *</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != orderItem.getIndex()) &#123; <span class="comment">// ORDER BY 使用数字</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (each.getAlias().isPresent() &amp;&amp; orderItem.getAlias().isPresent() &amp;&amp; each.getAlias().get().equalsIgnoreCase(orderItem.getAlias().get())) &#123; <span class="comment">// 字段别名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!each.getAlias().isPresent() &amp;&amp; orderItem.getQualifiedName().isPresent() &amp;&amp; each.getExpression().equalsIgnoreCase(orderItem.getQualifiedName().get())) &#123; <span class="comment">// 字段原名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.3 ItemsToken</h2>
<p>选择项标记对象，<strong>属于分片上下文信息</strong>，目前有 3 个情况会创建：</p>
<ol>
<li><code>AVG</code> 查询额外 COUNT 和 SUM：<code>#appendAvgDerivedColumns()</code></li>
<li><code>GROUP BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li>
<li><code>ORDER BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li>
</ol>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字段名数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>4.4 appendDerivedOrderBy()</h2>
<p>当 SQL 有聚合条件而无排序条件，根据聚合条件进行排序。这是数据库自己的执行规则。</p>
<p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT order_id FROM t_order GROUP BY order_id;</div><div class="line">+----------+</div><div class="line">| order_id |</div><div class="line">+----------+</div><div class="line">| 1        |</div><div class="line">| 2        |</div><div class="line">| 3        |</div><div class="line">+----------+</div><div class="line">3 rows in set (0.05 sec)</div><div class="line"></div><div class="line">mysql&gt; SELECT order_id FROM t_order GROUP BY order_id DESC;</div><div class="line">+----------+</div><div class="line">| order_id |</div><div class="line">+----------+</div><div class="line">| 3        |</div><div class="line">| 2        |</div><div class="line">| 1        |</div><div class="line">+----------+</div><div class="line">3 rows in set (0.02 sec)</div></pre></td></tr></table></figure></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!getSelectStatement().getGroupByItems().isEmpty() &amp;&amp; getSelectStatement().getOrderByItems().isEmpty()) &#123;</div><div class="line">       getSelectStatement().getOrderByItems().addAll(getSelectStatement().getGroupByItems());</div><div class="line">       getSelectStatement().getSqlTokens().add(<span class="keyword">new</span> OrderByToken(getSelectStatement().getGroupByLastPosition()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>4.3.1 OrderByToken</h3>
<p>排序标记对象。当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OrderByToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 所在开始位置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>666. 彩蛋</h1>
<p>咳咳咳，确实有一些略长。但请相信，INSERT / UPDATE / DELETE 会简单很多很多。考试考的 SQL 最多的是什么？SELECT 语句呀！为啥，难呗。恩，我相信看到此处的你，一定是能看懂的，加油！</p>
<p>🙂如果对本文有不理解的地方，可以关注我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）<strong>获得</strong>微信号**，我们来一场，1 对 1 的搞基吧，不不不，是交流交流。</p>
<p>道友，帮我分享一波怎么样？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;o
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（二）之SQL解析</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-2/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-2/</id>
    <published>2017-07-25T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">【芋艿的后端小屋】</a>**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. SQLParsingEngine</a></li>
<li><a href="#">3. SQLParser SQL解析器</a>
<ul>
<li><a href="#">3.1 AbstractParser</a></li>
<li><a href="#">3.2 SQLParser</a>
<ul>
<li><a href="#">3.2.1 #parseExpression() 和 SQLExpression</a></li>
<li><a href="#">3.2.2 #parseAlias()</a></li>
<li><a href="#">3.2.3 #parseSingleTable()</a></li>
<li><a href="#">3.2.4 #skipJoin()</a></li>
<li><a href="#">3.2.5 #parseWhere()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">4. StatementParser SQL语句解析器</a>
<ul>
<li><a href="#">4.1 StatementParser</a></li>
<li><a href="#">4.2 Statement</a></li>
</ul>
</li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>上篇文章<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/">《词法解析》</a>分享了<strong>词法解析器Lexer</strong>是如何解析 SQL 里的词法。本文分享<strong>SQL解析引擎</strong>是如何解析与理解 SQL的。因为本文建立在<a href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/">《词法解析》</a>之上，你需要阅读它后在开始这段旅程。🙂如果对词法解析不完全理解，请给我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）<strong>留言，我会</strong>逐条认真耐心**回复。</p>
<p>区别于 Lexer，Parser <strong>理解SQL</strong>：</p>
<ul>
<li><strong>提炼分片上下文</strong></li>
<li><strong>标记需要SQL改写的部分</strong></li>
</ul>
<p>Parser 有三个组件：</p>
<ul>
<li>SQLParsingEngine ：SQL 解析引擎</li>
<li>SQLParser ：SQL 解析器</li>
<li>StatementParser ：SQL语句解析器</li>
</ul>
<p>SQLParsingEngine 调用 StatementParser 解析 SQL。<br>
StatementParser 调用 SQLParser 解析 SQL 表达式。<br>
SQLParser 调用 Lexer 解析 SQL 词法。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/01.png" alt=""></p>
<p>😜 是不是觉得 SQLParser 和 StatementParser 看起来很接近？下文为你揭开这个答案。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>
🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>
登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1>2. SQLParsingEngine</h1>
<p>SQLParsingEngine，SQL 解析引擎。其 <code>#parse()</code> 方法作为 SQL 解析入口，本身不带复杂逻辑，通过调用 SQL 对应的 StatementParser 进行 SQL 解析。</p>
<p>核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParsingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 SQL解析器</span></div><div class="line">   SQLParser sqlParser = getSQLParser();</div><div class="line">   <span class="comment">//</span></div><div class="line">   sqlParser.skipIfEqual(Symbol.SEMI); <span class="comment">// 跳过 ";"</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.WITH)) &#123; <span class="comment">// WITH Syntax</span></div><div class="line">       skipWith(sqlParser);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取对应 SQL语句解析器 解析SQL</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">       <span class="keyword">return</span> SelectParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.INSERT)) &#123;</div><div class="line">       <span class="keyword">return</span> InsertParserFactory.newInstance(shardingRule, sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UPDATE)) &#123;</div><div class="line">       <span class="keyword">return</span> UpdateParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DELETE)) &#123;</div><div class="line">       <span class="keyword">return</span> DeleteParserFactory.newInstance(sqlParser).parse();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>3. SQLParser SQL解析器</h1>
<p>SQLParser，SQL 解析器。和词法解析器 Lexer 一样，不同数据库有不同的实现。</p>
<p>类图如下（<strong>包含所有属性和方法</strong>）（<strong><a href="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/02.png">放大图片</a></strong>）：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/02.png" alt=""></p>
<h2>3.1 AbstractParser</h2>
<p>AbstractParser，SQLParser 的抽象父类，对 Lexer 简单封装。例如：</p>
<ul>
<li><code>#skipIfEqual()</code>：判断当前词法标记类型是否与其中一个传入值相等</li>
<li><code>#equalAny()</code>：判断当前词法标记类型是否与其中一个传入值相等</li>
</ul>
<p><em><strong>这里有一点我们需要注意，SQLParser 并不是等 Lexer 解析完词法( Token )，再根据词法去理解 SQL。而是，在理解 SQL 的过程中，调用 Lexer 进行分词。</strong></em></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParsingEngine.java#parse()片段</span></div><div class="line"><span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">    <span class="keyword">return</span> SelectParserFactory.newInstance(sqlParser).parse();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equalAny</span><span class="params">(<span class="keyword">final</span> TokenType... tokenTypes)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (TokenType each : tokenTypes) &#123;</div><div class="line">       <span class="keyword">if</span> (each == lexer.getCurrentToken().getType()) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>↑↑↑ 判断当前<strong>词法</strong>是否为 SELECT。实际 AbstractParser 只知道当前词法，并<strong>不知道</strong>后面还有哪些词法，也<strong>不知道</strong>之前有哪些词法。</li>
</ul>
<p>我们来看 AbstractParser 里比较复杂的方法 <code>#skipParentheses()</code> 帮助大家再理解下。请认真看代码注释噢。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过小括号内所有的词法标记.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 小括号内所有的词法标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">skipParentheses</span><span class="params">()</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (Symbol.LEFT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> beginPosition = getLexer().getCurrentToken().getEndPosition();</div><div class="line">       result.append(Symbol.LEFT_PAREN.getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">               increaseParametersIndex();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 到达结尾 或者 匹配合适数的)右括号</span></div><div class="line">           <span class="keyword">if</span> (Assist.END == getLexer().getCurrentToken().getType() || (Symbol.RIGHT_PAREN == getLexer().getCurrentToken().getType() &amp;&amp; <span class="number">0</span> == count)) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 处理里面有多个括号的情况，例如：SELECT COUNT(DISTINCT(order_id) FROM t_order</span></div><div class="line">           <span class="keyword">if</span> (Symbol.LEFT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">               count++;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Symbol.RIGHT_PAREN == getLexer().getCurrentToken().getType()) &#123;</div><div class="line">               count--;</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 下一个词法</span></div><div class="line">           getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得括号内的内容</span></div><div class="line">       result.append(getLexer().getInput().substring(beginPosition, getLexer().getCurrentToken().getEndPosition()));</div><div class="line">       <span class="comment">// 下一个词法</span></div><div class="line">       getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类其它方法很重要，逻辑相对简单，我们就不占用篇幅了。大家一定要看哟，后面调用非常非常多。<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/master/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/AbstractParser.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractParser.java 传送门</a>。👼也可以关注我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）<strong>发送关键字【sjdbc】获取</strong>增加方法内注释的项目地址**。</p>
<h2>3.2 SQLParser</h2>
<p>SQLParser，SQL 解析器，<strong>主要提供只考虑 SQL 块的解析方法，<em>不考虑 SQL 上下文</em></strong>。下文即将提到的 StatementParser 将 SQL 拆成对应的<strong>块</strong>，调用 SQLParser 进行解析。🤓 这么说，可能会有些抽象，我们下面来一起看。</p>
<p>SQLParser 看起来方法特别多，合并下一共 5 种：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">#parseExpression()</td>
<td style="text-align:left">解析表达式</td>
</tr>
<tr>
<td style="text-align:left">#parseAlias()</td>
<td style="text-align:left">解析别名</td>
</tr>
<tr>
<td style="text-align:left">#parseSingleTable()</td>
<td style="text-align:left">解析单表</td>
</tr>
<tr>
<td style="text-align:left">#skipJoin()</td>
<td style="text-align:left">跳过表关联词法</td>
</tr>
<tr>
<td style="text-align:left">#parseWhere()</td>
<td style="text-align:left">解析查询条件</td>
</tr>
</tbody>
</table>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/03.png" alt=""></p>
<p>看了这 5 个方法是否有点理解了？SQLParser 不考虑 SQL 是 SELECT / INSERT / UPDATE / DELETE ，它考虑的是，<strong>给我的是 WHERE 处解析查询条件，或是 INSERT INTO 解析单表 等</strong>，提供 SELECT / INSERT / UPDATE / DELETE 需要的 SQL 块公用解析。</p>
<h3>3.2.1 #parseExpression() 和 SQLExpression</h3>
<p>SQLExpression，SQL表达式接口。目前 6 种实现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">对应Token</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SQLIdentifierExpression</td>
<td style="text-align:left">标识表达式</td>
<td style="text-align:left">Literals.IDENTIFIER</td>
</tr>
<tr>
<td style="text-align:left">SQLPropertyExpression</td>
<td style="text-align:left">属性表达式</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">SQLNumberExpression</td>
<td style="text-align:left">数字表达式</td>
<td style="text-align:left">Literals.INT, Literals.HEX</td>
</tr>
<tr>
<td style="text-align:left">SQLPlaceholderExpression</td>
<td style="text-align:left">占位符表达式</td>
<td style="text-align:left">Symbol.QUESTION</td>
</tr>
<tr>
<td style="text-align:left">SQLTextExpression</td>
<td style="text-align:left">字符表达式</td>
<td style="text-align:left">Literals.CHARS</td>
</tr>
<tr>
<td style="text-align:left">SQLIgnoreExpression</td>
<td style="text-align:left">分片中无需关注的SQL表达式</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/04.png" alt=""></p>
<ul>
<li>SQLPropertyExpression 例如：<code>SELECT * FROM t_order o ORDER BY o.order_id</code> 中的 <code>o.order_id</code>。<strong>SQLPropertyExpression 从 SQLIdentifierExpression 进一步判断解析而来。</strong>
<img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/05.png" alt=""></li>
<li>SQLIgnoreExpression 例如：<code>SELECT * FROM t_order o ORDER BY o.order_id % 2</code> 中的<code>o.order_id % 2</code>。<strong>复合表达式都会解析成 SQLIgnoreExpression。</strong></li>
</ul>
<p>解析 SQLExpression 核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析表达式.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 表达式</div><div class="line">*/</div><div class="line"><span class="comment">// TODO 完善Expression解析的各种场景</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SQLExpression <span class="title">parseExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析表达式</span></div><div class="line">   String literals = getLexer().getCurrentToken().getLiterals();</div><div class="line">   <span class="keyword">final</span> SQLExpression expression = getExpression(literals);</div><div class="line">   <span class="comment">// SQLIdentifierExpression 需要特殊处理。考虑自定义函数，表名.属性情况。</span></div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Literals.IDENTIFIER)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// 例如，ORDER BY o.uid 中的 "o.uid"</span></div><div class="line">           String property = getLexer().getCurrentToken().getLiterals();</div><div class="line">           getLexer().nextToken();</div><div class="line">           <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : <span class="keyword">new</span> SQLPropertyExpression(<span class="keyword">new</span> SQLIdentifierExpression(literals), property);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.LEFT_PAREN)) &#123; <span class="comment">// 例如，GROUP BY DATE(create_time) 中的 "DATE(create_time)"</span></div><div class="line">           skipParentheses();</div><div class="line">           skipRestCompositeExpression();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</div><div class="line">   &#125;</div><div class="line">   getLexer().nextToken();</div><div class="line">   <span class="keyword">return</span> skipIfCompositeExpression() ? <span class="keyword">new</span> SQLIgnoreExpression() : expression;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得 词法Token 对应的 SQLExpression</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> literals 词法字面量标记</div><div class="line">* <span class="doctag">@return</span> SQLExpression</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> SQLExpression <span class="title">getExpression</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">       increaseParametersIndex();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLPlaceholderExpression(getParametersIndex() - <span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.CHARS)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLTextExpression(literals);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 考虑long的情况</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.INT)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.FLOAT)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Double.parseDouble(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 考虑long的情况</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.HEX)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLNumberExpression(Integer.parseInt(literals, <span class="number">16</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SQLIdentifierExpression(SQLUtil.getExactlyValue(literals));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLIgnoreExpression();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 如果是 复合表达式，跳过。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否跳过</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">skipIfCompositeExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT, Symbol.LEFT_PAREN)) &#123;</div><div class="line">       skipParentheses();</div><div class="line">       skipRestCompositeExpression();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过剩余复合表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipRestCompositeExpression</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (skipIfEqual(Symbol.PLUS, Symbol.SUB, Symbol.STAR, Symbol.SLASH, Symbol.PERCENT, Symbol.AMP, Symbol.BAR, Symbol.DOUBLE_AMP, Symbol.DOUBLE_BAR, Symbol.CARET, Symbol.DOT)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.QUESTION)) &#123;</div><div class="line">           increaseParametersIndex();</div><div class="line">       &#125;</div><div class="line">       getLexer().nextToken();</div><div class="line">       skipParentheses();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析了 SQLExpression 有什么用呢？我们会在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《插入SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《更新SQL解析》</a>、<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a>。留个悬念😈，关注我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）**，<strong>实时收到新文更新通知</strong>。</p>
<h3>3.2.2 #parseAlias()</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析别名.不仅仅是字段的别名，也可以是表的别名。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 别名</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">parseAlias</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析带 AS 情况</span></div><div class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.AS)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(Symbol.values())) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.absent();</div><div class="line">       &#125;</div><div class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">return</span> Optional.of(result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析别名</span></div><div class="line">   <span class="comment">// TODO 增加哪些数据库识别哪些关键字作为别名的配置</span></div><div class="line">   <span class="keyword">if</span> (equalAny(Literals.IDENTIFIER, Literals.CHARS, DefaultKeyword.USER, DefaultKeyword.END, DefaultKeyword.CASE, DefaultKeyword.KEY, DefaultKeyword.INTERVAL, DefaultKeyword.CONSTRAINT)) &#123;</div><div class="line">       String result = SQLUtil.getExactlyValue(getLexer().getCurrentToken().getLiterals());</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">return</span> Optional.of(result);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.3 #parseSingleTable()</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单表.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL语句对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSingleTable</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> hasParentheses = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">if</span> (equalAny(DefaultKeyword.SELECT)) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery"</span>);</div><div class="line">       &#125;</div><div class="line">       hasParentheses = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   Table table;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> beginPosition = getLexer().getCurrentToken().getEndPosition() - getLexer().getCurrentToken().getLiterals().length();</div><div class="line">   String literals = getLexer().getCurrentToken().getLiterals();</div><div class="line">   getLexer().nextToken();</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(Symbol.DOT)) &#123;</div><div class="line">       getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</div><div class="line">           accept(Symbol.RIGHT_PAREN);</div><div class="line">       &#125;</div><div class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">if</span> (hasParentheses) &#123;</div><div class="line">           accept(Symbol.RIGHT_PAREN);</div><div class="line">       &#125;</div><div class="line">       table = <span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), parseAlias());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (skipJoin()) &#123; <span class="comment">// multiple-update 或者 multiple-delete</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Multiple-Table."</span>);</div><div class="line">   &#125;</div><div class="line">   sqlStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</div><div class="line">   sqlStatement.getTables().add(table);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.4 #skipJoin()</h3>
<p>跳过表关联词法，支持 <code>SELECT * FROM t_user, t_order WHERE ...</code>, <code>SELECT * FROM t_user JOIN t_order ON ...</code>。下篇<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a><strong>解析表</strong>会用到这个方法。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 跳过表关联词法.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否表关联.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">skipJoin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.LEFT, DefaultKeyword.RIGHT, DefaultKeyword.FULL)) &#123;</div><div class="line">       skipIfEqual(DefaultKeyword.OUTER);</div><div class="line">       accept(DefaultKeyword.JOIN);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.INNER)) &#123;</div><div class="line">       accept(DefaultKeyword.JOIN);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, Symbol.COMMA, DefaultKeyword.STRAIGHT_JOIN)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.CROSS)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.JOIN, DefaultKeyword.APPLY)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.OUTER)) &#123;</div><div class="line">       <span class="keyword">if</span> (skipIfEqual(DefaultKeyword.APPLY)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.5 #parseWhere()</h3>
<p>解析 WHERE 查询条件。目前支持 AND 条件，不支持 OR 条件。近期 OR 条件支持的可能性比较低。另外条件这块对括号解析需要继续优化，实际使用请勿写冗余的括号。例如：<code>SELECT * FROM tbl_name1 WHERE ((val1=?) AND (val2=?)) AND val3 =?</code>。</p>
<p>根据不同的运算操作符，分成如下情况：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>附加条件</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td></td>
<td>#parseEqualCondition()</td>
</tr>
<tr>
<td>IN</td>
<td></td>
<td>#parseInCondition()</td>
</tr>
<tr>
<td>BETWEEN</td>
<td></td>
<td>#parseBetweenCondition()</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>Oracle 或 SQLServer 分页</td>
<td>#parseRowNumberCondition()</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td></td>
<td>#parseOtherCondition()</td>
</tr>
<tr>
<td>LIKE</td>
<td></td>
<td>parseOtherCondition</td>
</tr>
</tbody>
</table>
<p>代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析所有查询条件。</div><div class="line">* 目前不支持 OR 条件。</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConditions</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="comment">// AND 查询</span></div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       parseComparisonCondition(sqlStatement);</div><div class="line">   &#125; <span class="keyword">while</span> (skipIfEqual(DefaultKeyword.AND));</div><div class="line">   <span class="comment">// 目前不支持 OR 条件</span></div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.OR)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">&#125; </div><div class="line"><span class="comment">// TODO 解析组合expr</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析单个查询条件</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseComparisonCondition</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   skipIfEqual(Symbol.LEFT_PAREN);</div><div class="line">   SQLExpression left = parseExpression(sqlStatement);</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.EQ)) &#123;</div><div class="line">       parseEqualCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.IN)) &#123;</div><div class="line">       parseInCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(DefaultKeyword.BETWEEN)) &#123;</div><div class="line">       parseBetweenCondition(sqlStatement, left);</div><div class="line">       skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (equalAny(Symbol.LT, Symbol.GT, Symbol.LT_EQ, Symbol.GT_EQ)) &#123;</div><div class="line">       <span class="keyword">if</span> (left <span class="keyword">instanceof</span> SQLIdentifierExpression &amp;&amp; sqlStatement <span class="keyword">instanceof</span> SelectStatement</div><div class="line">               &amp;&amp; isRowNumberCondition((SelectStatement) sqlStatement, ((SQLIdentifierExpression) left).getName())) &#123;</div><div class="line">           parseRowNumberCondition((SelectStatement) sqlStatement);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left <span class="keyword">instanceof</span> SQLPropertyExpression &amp;&amp; sqlStatement <span class="keyword">instanceof</span> SelectStatement</div><div class="line">               &amp;&amp; isRowNumberCondition((SelectStatement) sqlStatement, ((SQLPropertyExpression) left).getName())) &#123;</div><div class="line">           parseRowNumberCondition((SelectStatement) sqlStatement);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           parseOtherCondition(sqlStatement);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (equalAny(DefaultKeyword.LIKE)) &#123;</div><div class="line">       parseOtherCondition(sqlStatement);</div><div class="line">   &#125;</div><div class="line">   skipIfEqual(Symbol.RIGHT_PAREN);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>#parseComparisonCondition()</code> 解析到 <code>左SQL表达式(left)</code> 和 运算符，调用相应方法进一步处理。我们选择 <code>#parseEqualCondition()</code> 看下，其他方法有兴趣跳转 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/master/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/SQLParser.java" rel="external nofollow noopener noreferrer" target="_blank">SQLParser</a> 查看。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 解析 = 条件</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlStatement SQL</div><div class="line">* <span class="doctag">@param</span> left 左SQLExpression</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseEqualCondition</span><span class="params">(<span class="keyword">final</span> SQLStatement sqlStatement, <span class="keyword">final</span> SQLExpression left)</span> </span>&#123;</div><div class="line">   getLexer().nextToken();</div><div class="line">   SQLExpression right = parseExpression(sqlStatement);</div><div class="line">   <span class="comment">// 添加列</span></div><div class="line">   <span class="comment">// TODO 如果有多表,且找不到column是哪个表的,则不加入condition,以后需要解析binding table</span></div><div class="line">   <span class="keyword">if</span> ((sqlStatement.getTables().isSingleTable() || left <span class="keyword">instanceof</span> SQLPropertyExpression)</div><div class="line">           <span class="comment">// 只有对路由结果有影响的才会添加到 conditions。SQLPropertyExpression 和 SQLIdentifierExpression 无法判断，所以未加入 conditions</span></div><div class="line">           &amp;&amp; (right <span class="keyword">instanceof</span> SQLNumberExpression || right <span class="keyword">instanceof</span> SQLTextExpression || right <span class="keyword">instanceof</span> SQLPlaceholderExpression)) &#123;</div><div class="line">       Optional&lt;Column&gt; column = find(sqlStatement.getTables(), left);</div><div class="line">       <span class="keyword">if</span> (column.isPresent()) &#123;</div><div class="line">           sqlStatement.getConditions().add(<span class="keyword">new</span> Condition(column.get(), right), shardingRule);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>#parseEqualCondition()</code> 解析到 <code>右SQL表达式(right)</code>，并判断 <code>左右SQL表达式</code> 与路由逻辑是否有影响，如果有，则加入到 Condition。<strong>这个就是 <code>#parseWhere()</code> 的目的：解析 WHERE 查询条件对路由有影响的条件。</strong><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《路由》</a>相关的逻辑，会单独开文章介绍。这里，我们先留有映像。</p>
<h1>4. StatementParser SQL语句解析器</h1>
<h2>4.1 StatementParser</h2>
<p>StatementParser，SQL语句解析器。每种 SQL，都有相应的 SQL语句解析器实现。不同数据库，继承这些 SQL语句解析器，实现各自 SQL 上的差异。大体结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/06.png" alt=""></p>
<p>SQLParsingEngine 根据不同 SQL 调用对应工厂创建 StatementParser。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectParserFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建Select语句解析器.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> sqlParser SQL解析器</div><div class="line">     * <span class="doctag">@return</span> Select语句解析器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractSelectParser <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> SQLParser sqlParser)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> MySQLParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MySQLSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> OracleParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> OracleSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> SQLServerParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SQLServerSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sqlParser <span class="keyword">instanceof</span> PostgreSQLParser) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PostgreSQLSelectParser(sqlParser);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(String.format(<span class="string">"Cannot support sqlParser class [%s]."</span>, sqlParser.getClass()));</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用 <code>StatementParser#parse()</code> 实现方法，对 SQL 进行解析。具体解析过程，另开文章分享。</p>
<h2>4.2 Statement</h2>
<p>不同 SQL 解析后，返回对应的 SQL 结果,即 Statement。大体结构如下：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/07.png" alt=""></p>
<p>Statement 包含两部分信息：</p>
<ul>
<li>
<p>分片上下文：用于 SQL 路由。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/08.png" alt=""></p>
</li>
<li>
<p>SQL 标记对象：用于 SQL 改写。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_26/09.png" alt=""></p>
</li>
</ul>
<p>我们会在后文增删改查SQL解析的过程中分享到它们。</p>
<h2>4.3 预告</h2>
<table>
<thead>
<tr>
<th>Parser</th>
<th>Statement</th>
<th>分享文章</th>
</tr>
</thead>
<tbody>
<tr>
<td>SelectStatementParser</td>
<td>SelectStatement + AbstractSQLStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a></td>
</tr>
<tr>
<td>InsertStatementParser</td>
<td>InsertStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《插入SQL解析》</a></td>
</tr>
<tr>
<td>UpdateStatementParser</td>
<td>UpdateStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《更新SQL解析》</a></td>
</tr>
<tr>
<td>DeleteStatementParser</td>
<td>DeleteStatement</td>
<td><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《删除SQL解析》</a></td>
</tr>
</tbody>
</table>
<h1>5. 彩蛋</h1>
<p>老铁，是不是有丢丢长？<br>
如果有地方错误，烦请指出🙂。<br>
如果有地方不是很理解，可以加我的公众号**（<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋艿的后端小屋</a>）<strong>留言，我会</strong>逐条认真耐心**回复。<br>
如果觉得还凑合，劳驾分享朋友圈或者基佬。</p>
<p><a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">《查询SQL解析》</a>已经写了一半，预计很快...</p>
<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：&lt;a href=&quot;http://www.yu
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— SQL 解析（一）之词法解析</title>
    <link href="http://www.yunai.me/Sharding-JDBC/sql-parse-1/"/>
    <id>http://www.yunai.me/Sharding-JDBC/sql-parse-1/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-08-10T17:25:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. Lexer 词法解析器</a></li>
<li><a href="#">3. Token 词法标记</a>
<ul>
<li><a href="#">3.1 DefaultKeyword 词法关键词</a></li>
<li><a href="#">3.2 Literals 词法字面量标记</a>
<ul>
<li><a href="#">3.2.1 Literals.IDENTIFIER 词法关键词</a></li>
<li><a href="#">3.2.2 Literals.VARIABLE 变量</a></li>
<li><a href="#">3.2.3 Literals.CHARS 字符串</a></li>
<li><a href="#">3.2.4 Literals.HEX 十六进制</a></li>
<li><a href="#">3.2.5 Literals.INT 整数</a></li>
<li><a href="#">3.2.6 Literals.FLOAT 浮点数</a></li>
</ul>
</li>
<li><a href="#">3.3 Symbol 词法符号标记</a></li>
<li><a href="#">3.4 Assist 词法辅助标记</a></li>
</ul>
</li>
<li><a href="#">4. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p><strong>SQL 解析引擎</strong>，数据库中间件必备的功能和流程。Sharding-JDBC 在 <code>1.5.0.M1</code> 正式发布时，将 SQL 解析引擎从 Druid 替换成了自研的。<strong>新引擎仅解析分片上下文，对于 SQL 采用&quot;半理解&quot;理念，进一步提升性能和兼容性，同时降低了代码复杂度</strong>（不理解没关系，我们后续会更新文章解释该优点）。 国内另一款数据库中间件 MyCAT SQL 解析引擎也是 Druid，目前也在开发属于自己的 SQL 解析引擎。</p>
<p>可能有同学看到<strong>SQL 解析</strong>会被吓到，请淡定，耐心往下看。《SQL 解析》内容我们会分成 5 篇相对简短的文章，让大家能够相对轻松愉快的去理解：</p>
<ol>
<li>词法解析</li>
<li>插入 SQL 解析</li>
<li>查询 SQL 解析</li>
<li>更新 SQL 解析</li>
<li>删除 SQL 解析</li>
</ol>
<hr>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/01.png" alt=""></p>
<p><strong>SQL 解析引擎</strong>在 <code>parsing</code> 包下，如上图所见包含两大组件：</p>
<ol>
<li>Lexer：<strong>词法</strong>解析器。</li>
<li>Parser：<strong>SQL</strong>解析器。</li>
</ol>
<p>两者都是解析器，区别在于 Lexer 只做词法的解析，不关注上下文，将字符串拆解成 N 个词法。而 Parser 在 Lexer 的基础上，还需要理解 SQL 。打个比方：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">SQL ：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user  </div><div class="line">Lexer ：[<span class="keyword">SELECT</span>] [ * ] [<span class="keyword">FROM</span>] [t_user]  </div><div class="line">Parser ：这是一条 [<span class="keyword">SELECT</span>] 查询表为 [t_user] ，并且返回 [ * ] 所有字段的 <span class="keyword">SQL</span>。</div></pre></td></tr></table></figure></p>
<p>🙂不完全懂？没关系，本文的主角是 Lexer，我们通过源码一点一点理解。一共 1400 行左右代码左右，还包含注释等等，实际更少噢。</p>
<h1>2. Lexer 词法解析器</h1>
<p><strong>Lexer 原理</strong>：<strong>顺序顺序顺序</strong> 解析 SQL，将字符串拆解成 N 个词法。</p>
<p>核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lexer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出字符串</div><div class="line">     * 比如：SQL</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String input;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 词法标记字典</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解析到 SQL 的 offset</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前 词法标记</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> Token currentToken;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分析下一个词法标记.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #currentToken</div><div class="line">     * <span class="doctag">@see</span> #offset</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">nextToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        skipIgnoredToken();</div><div class="line">        <span class="keyword">if</span> (isVariableBegin()) &#123; <span class="comment">// 变量</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanVariable();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNCharBegin()) &#123; <span class="comment">// N\</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, ++offset).scanChars();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isIdentifierBegin()) &#123; <span class="comment">// Keyword + Literals.IDENTIFIER</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanIdentifier();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isHexDecimalBegin()) &#123; <span class="comment">// 十六进制</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanHexDecimal();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNumberBegin()) &#123; <span class="comment">// 数字（整数+浮点数）</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanNumber();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSymbolBegin()) &#123; <span class="comment">// 符号</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanSymbol();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isCharsBegin()) &#123; <span class="comment">// 字符串，例如："abc"</span></div><div class="line">            currentToken = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).scanChars();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isEnd()) &#123; <span class="comment">// 结束</span></div><div class="line">            currentToken = <span class="keyword">new</span> Token(Assist.END, <span class="string">""</span>, offset);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 分析错误，无符合条件的词法标记</span></div><div class="line">            currentToken = <span class="keyword">new</span> Token(Assist.ERROR, <span class="string">""</span>, offset);</div><div class="line">        &#125;</div><div class="line">        offset = currentToken.getEndPosition();</div><div class="line">        <span class="comment">// System.out.println("| " + currentToken.getLiterals() + " | " + currentToken.getType() + " | " + currentToken.getEndPosition() + " |");</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 跳过忽略的词法标记</div><div class="line">     * 1. 空格</div><div class="line">     * 2. SQL Hint</div><div class="line">     * 3. SQL 注释</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipIgnoredToken</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 空格</span></div><div class="line">        offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        <span class="comment">// SQL Hint</span></div><div class="line">        <span class="keyword">while</span> (isHintBegin()) &#123;</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipHint();</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SQL 注释</span></div><div class="line">        <span class="keyword">while</span> (isCommentBegin()) &#123;</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipComment();</div><div class="line">            offset = <span class="keyword">new</span> Tokenizer(input, dictionary, offset).skipWhitespace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过 <code>#nextToken()</code> 方法，不断解析出 Token(<em>词法标记</em>)。我们来执行一次，看看 SQL 会被拆解成哪些 Token。</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">SQL ：<span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.user_id=? <span class="keyword">AND</span> o.order_id=?</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>literals</th>
<th>TokenType类</th>
<th>TokenType值</th>
<th>endPosition</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>DefaultKeyword</td>
<td>SELECT</td>
<td>6</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>8</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>9</td>
</tr>
<tr>
<td>*</td>
<td>Symbol</td>
<td>STAR</td>
<td>10</td>
</tr>
<tr>
<td>FROM</td>
<td>DefaultKeyword</td>
<td>FROM</td>
<td>15</td>
</tr>
<tr>
<td>t_order</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>23</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>25</td>
</tr>
<tr>
<td>JOIN</td>
<td>DefaultKeyword</td>
<td>JOIN</td>
<td>30</td>
</tr>
<tr>
<td>t_order_item</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>43</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>45</td>
</tr>
<tr>
<td>ON</td>
<td>DefaultKeyword</td>
<td>ON</td>
<td>48</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>50</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>51</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>59</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>60</td>
</tr>
<tr>
<td>i</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>61</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>62</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>70</td>
</tr>
<tr>
<td>WHERE</td>
<td>DefaultKeyword</td>
<td>WHERE</td>
<td>76</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>78</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>79</td>
</tr>
<tr>
<td>user_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>86</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>87</td>
</tr>
<tr>
<td>?</td>
<td>Symbol</td>
<td>QUESTION</td>
<td>88</td>
</tr>
<tr>
<td>AND</td>
<td>DefaultKeyword</td>
<td>AND</td>
<td>92</td>
</tr>
<tr>
<td>o</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>94</td>
</tr>
<tr>
<td>.</td>
<td>Symbol</td>
<td>DOT</td>
<td>95</td>
</tr>
<tr>
<td>order_id</td>
<td>Literals</td>
<td>IDENTIFIER</td>
<td>103</td>
</tr>
<tr>
<td>=</td>
<td>Symbol</td>
<td>EQ</td>
<td>104</td>
</tr>
<tr>
<td>?</td>
<td>Symbol</td>
<td>QUESTION</td>
<td>105</td>
</tr>
<tr>
<td></td>
<td>Assist</td>
<td>END</td>
<td>105</td>
</tr>
</tbody>
</table>
<p>眼尖的同学可能看到了 Tokenizer。对的，它是 Lexer 的好基佬，负责<strong>分词</strong>。</p>
<p><em>我们来总结下，<code>Lexer#nextToken()</code> 方法里，使用 <code>#skipIgnoredToken()</code> 方法跳过忽略的 Token，通过 <code>#isXXXX()</code> 方法判断好下一个 Token 的类型后，<strong>交给 Tokenizer 进行分词返回 Token</strong>。‼️此处可以考虑做个优化，不需要每次都 <code>new Tokenizer(...)</code> 出来，一个 Lexer 搭配一个 Tokenizer。</em></p>
<hr>
<p>由于不同数据库遵守 SQL 规范略有不同，所以不同的数据库对应不同的 Lexer。</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/02.png" alt=""></p>
<p>子 Lexer 通过重写方法实现自己独有的 SQL 语法。</p>
<h1>3. Token 词法标记</h1>
<p>上文我们已经看过 Token 的例子，一共有 3 个属性：</p>
<ul>
<li>TokenType type ：词法标记类型</li>
<li>String literals ：词法字面量标记</li>
<li>int endPosition ：<code>literals</code> 在 SQL 里的结束位置</li>
</ul>
<p>TokenType 词法标记类型，一共分成 4 个大类：</p>
<ul>
<li>DefaultKeyword ：词法关键词</li>
<li>Literals ：词法字面量标记</li>
<li>Symbol ：词法符号标记</li>
<li>Assist ：词法辅助标记</li>
</ul>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/03.png" alt=""></p>
<h2>3.1 DefaultKeyword 词法关键词</h2>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_07_23/04.png" alt=""></p>
<p><strong>不同数据库有自己独有的_词法关键词_，例如 MySQL 熟知的分页 Limit。</strong></p>
<p>我们以 MySQL 举个例子，当创建 MySQLLexer 时，会加载 DefaultKeyword 和 MySQLKeyword（ <em>OracleLexer、PostgreSQLLexer、SQLServerLexer 同 MySQLLexer</em> ）。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLLexer.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLLexer</span> <span class="keyword">extends</span> <span class="title">Lexer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 字典</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary(MySQLKeyword.values());</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySQLLexer</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(input, dictionary);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Dictionary.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 词法关键词Map</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Keyword&gt; tokens = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1024</span>);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span><span class="params">(<span class="keyword">final</span> Keyword... dialectKeywords)</span> </span>&#123;</div><div class="line">        fill(dialectKeywords);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 装上默认词法关键词 + 方言词法关键词</div><div class="line">     * 不同的数据库有相同的默认词法关键词，有有不同的方言关键词</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> dialectKeywords 方言词法关键词</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> Keyword... dialectKeywords)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (DefaultKeyword each : DefaultKeyword.values()) &#123;</div><div class="line">            tokens.put(each.name(), each);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (Keyword each : dialectKeywords) &#123;</div><div class="line">            tokens.put(each.toString(), each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Keyword 与 Literals.IDENTIFIER 是一起解析的，我们放在 Literals.IDENTIFIER 处一起分析。</p>
<h2>3.2 Literals 词法字面量标记</h2>
<p>Literals 词法字面量标记，一共分成 6 种：</p>
<ul>
<li>IDENTIFIER ：词法关键词</li>
<li>VARIABLE ：变量</li>
<li>CHARS ：字符串</li>
<li>HEX ：十六进制</li>
<li>INT ：整数</li>
<li>FLOAT ：浮点数</li>
</ul>
<h3>3.2.1 Literals.IDENTIFIER 词法关键词</h3>
<p>词法关键词。例如：表名，查询字段 等等。</p>
<p>解析 Literals.IDENTIFIER 与 Keyword 核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isIdentifierBegin(getCurrentChar(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierBegin</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isAlphabet(ch) || <span class="string">'`'</span> == ch || <span class="string">'_'</span> == ch || <span class="string">'$'</span> == ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描标识符.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 标识符标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanIdentifier</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// `字段`，例如：SELECT `id` FROM t_user 中的 `id`</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'`'</span> == charAt(offset)) &#123;</div><div class="line">       <span class="keyword">int</span> length = getLengthUntilTerminatedChar(<span class="string">'`'</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.IDENTIFIER, input.substring(offset, offset + length), offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (isIdentifierChar(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   String literals = input.substring(offset, offset + length);</div><div class="line">   <span class="comment">// 处理 order / group 作为表名</span></div><div class="line">   <span class="keyword">if</span> (isAmbiguousIdentifier(literals)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Token(processAmbiguousIdentifier(offset + length, literals), literals, offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 从 词法关键词 查找是否是 Keyword，如果是，则返回 Keyword，否则返回 Literals.IDENTIFIER</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(dictionary.findTokenType(literals, Literals.IDENTIFIER), literals, offset + length);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 计算到结束字符的长度</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> #hasEscapeChar(char, int) 处理类似 SELECT a AS `b``c` FROM table。此处连续的 "``" 不是结尾，如果传递的是 "`" 会产生误判，所以加了这个判断</div><div class="line">* <span class="doctag">@param</span> terminatedChar 结束字符</div><div class="line">* <span class="doctag">@return</span> 长度</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLengthUntilTerminatedChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> terminatedChar)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">   <span class="keyword">while</span> (terminatedChar != charAt(offset + length) || hasEscapeChar(terminatedChar, offset + length)) &#123;</div><div class="line">       <span class="keyword">if</span> (offset + length &gt;= input.length()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnterminatedCharException(terminatedChar);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (hasEscapeChar(terminatedChar, offset + length)) &#123;</div><div class="line">           length++;</div><div class="line">       &#125;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> length + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 Escape 字符</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> charIdentifier 字符</div><div class="line">* <span class="doctag">@param</span> offset 位置</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEscapeChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> charIdentifier, <span class="keyword">final</span> <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> charIdentifier == charAt(offset) &amp;&amp; charIdentifier == charAt(offset + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isIdentifierChar</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isAlphabet(ch) || CharType.isDigital(ch) || <span class="string">'_'</span> == ch || <span class="string">'$'</span> == ch || <span class="string">'#'</span> == ch;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是引起歧义的标识符</div><div class="line">* 例如 "SELECT * FROM group"，此时 "group" 代表的是表名，而非词法关键词</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> literals 标识符</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAmbiguousIdentifier</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> DefaultKeyword.ORDER.name().equalsIgnoreCase(literals) || DefaultKeyword.GROUP.name().equalsIgnoreCase(literals);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取引起歧义的标识符对应的词法标记类型</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> offset 位置</div><div class="line">* <span class="doctag">@param</span> literals 标识符</div><div class="line">* <span class="doctag">@return</span> 词法标记类型</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> TokenType <span class="title">processAmbiguousIdentifier</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (CharType.isWhitespace(charAt(offset + i))) &#123;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (DefaultKeyword.BY.name().equalsIgnoreCase(String.valueOf(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123;charAt(offset + i), charAt(offset + i + <span class="number">1</span>)&#125;))) &#123;</div><div class="line">       <span class="keyword">return</span> dictionary.findTokenType(literals);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Literals.IDENTIFIER;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.2 Literals.VARIABLE 变量</h3>
<p>变量。例如：<code>SELECT @@VERSION</code> 。</p>
<p>解析核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 变量</div><div class="line">* MySQL 与 SQL Server 支持</div><div class="line">* </div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanVariable()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isVariableBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描变量.</div><div class="line">* 在 MySQL 里，@代表用户变量；@@代表系统变量。</div><div class="line">* 在 SQLServer 里，有 @@。</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 变量标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanVariable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="string">'@'</span> == charAt(offset + <span class="number">1</span>)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (isVariableChar(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.VARIABLE, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.3 Literals.CHARS 字符串</h3>
<p>字符串。例如：<code>SELECT &quot;123&quot;</code> 。</p>
<p>解析核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否 N\</div><div class="line">* 目前 SQLServer 独有：在 SQL Server 中處理 Unicode 字串常數時，必需為所有的 Unicode 字串加上前置詞 N</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanChars()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNCharBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isSupportNChars() &amp;&amp; <span class="string">'N'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; <span class="string">'\''</span> == getCurrentChar(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCharsBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'\''</span> == getCurrentChar(<span class="number">0</span>) || <span class="string">'\"'</span> == getCurrentChar(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描字符串.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 字符串标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanChars</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> scanChars(charAt(offset));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> Token <span class="title">scanChars</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> terminatedChar)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = getLengthUntilTerminatedChar(terminatedChar);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.CHARS, input.substring(offset + <span class="number">1</span>, offset + length - <span class="number">1</span>), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.4 Literals.HEX 十六进制</h3>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 十六进制</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanHexDecimal()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHexDecimalBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'0'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; <span class="string">'x'</span> == getCurrentChar(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描十六进制数.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 十六进制数标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanHexDecimal</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = HEX_BEGIN_SYMBOL_LENGTH;</div><div class="line">   <span class="comment">// 负数</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">while</span> (isHex(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(Literals.HEX, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3>3.2.5 Literals.INT 整数</h3>
<p>整数。例如：<code>SELECT * FROM t_user WHERE id = 1</code>。</p>
<p>Literals.INT 与 Literals.FLOAT 是一起解析的，我们放在 Literals.FLOAT 处一起分析。</p>
<h3>3.2.6 Literals.FLOAT 浮点数</h3>
<p>浮点数。例如：<code>SELECT * FROM t_user WHERE id = 1.0</code>。
浮点数包含几种：&quot;1.0&quot;，&quot;1.0F&quot;，&quot;7.823E5&quot;（科学计数法）。</p>
<p>解析核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 数字</div><div class="line">* '-' 需要特殊处理。".2" 被处理成省略0的小数，"-.2" 不能被处理成省略的小数，否则会出问题。</div><div class="line">* 例如说，"SELECT a-.2" 处理的结果是 "SELECT" / "a" / "-" / ".2"</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNumberBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isDigital(getCurrentChar(<span class="number">0</span>)) <span class="comment">// 数字</span></div><div class="line">           || (<span class="string">'.'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; CharType.isDigital(getCurrentChar(<span class="number">1</span>)) &amp;&amp; !isIdentifierBegin(getCurrentChar(-<span class="number">1</span>)) <span class="comment">// 浮点数</span></div><div class="line">           || (<span class="string">'-'</span> == getCurrentChar(<span class="number">0</span>) &amp;&amp; (<span class="string">'.'</span> == getCurrentChar(<span class="number">0</span>) || CharType.isDigital(getCurrentChar(<span class="number">1</span>))))); <span class="comment">// 负数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描数字.</div><div class="line">* 解析数字的结果会有两种：整数 和 浮点数.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 数字标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanNumber</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 负数</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 浮点数</span></div><div class="line">   length += getDigitalLength(offset + length);</div><div class="line">   <span class="keyword">boolean</span> isFloat = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="string">'.'</span> == charAt(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">       length += getDigitalLength(offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 科学计数表示，例如：SELECT 7.823E5</span></div><div class="line">   <span class="keyword">if</span> (isScientificNotation(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">       <span class="keyword">if</span> (<span class="string">'+'</span> == charAt(offset + length) || <span class="string">'-'</span> == charAt(offset + length)) &#123;</div><div class="line">           length++;</div><div class="line">       &#125;</div><div class="line">       length += getDigitalLength(offset + length);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 浮点数，例如：SELECT 1.333F</span></div><div class="line">   <span class="keyword">if</span> (isBinaryNumber(offset + length)) &#123;</div><div class="line">       isFloat = <span class="keyword">true</span>;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(isFloat ? Literals.FLOAT : Literals.INT, input.substring(offset, offset + length), offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里要特别注意下：<strong>&quot;-&quot;</strong>。在数字表达实例，可以判定为 负号 和 减号（不考虑科学计数法）。</p>
<ul>
<li>&quot;.2&quot;  解析结果是 &quot;.2&quot;</li>
<li>&quot;-.2&quot; 解析结果不能是 &quot;-.2&quot;，而是 &quot;-&quot; 和 &quot;.2&quot;。</li>
</ul>
<h2>3.3 Symbol 词法符号标记</h2>
<p>词法符号标记。例如：&quot;{&quot;, &quot;}&quot;, &quot;&gt;=&quot; 等等。</p>
<p>解析核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lexer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 是否是 符号</div><div class="line">*</div><div class="line">* <span class="doctag">@see</span> Tokenizer#scanSymbol()</div><div class="line">* <span class="doctag">@return</span> 是否</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbolBegin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> CharType.isSymbol(getCurrentChar(<span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CharType.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断是否为符号.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> ch 待判断的字符</div><div class="line">* <span class="doctag">@return</span> 是否为符号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'('</span> == ch || <span class="string">')'</span> == ch || <span class="string">'['</span> == ch || <span class="string">']'</span> == ch || <span class="string">'&#123;'</span> == ch || <span class="string">'&#125;'</span> == ch || <span class="string">'+'</span> == ch || <span class="string">'-'</span> == ch || <span class="string">'*'</span> == ch || <span class="string">'/'</span> == ch || <span class="string">'%'</span> == ch || <span class="string">'^'</span> == ch || <span class="string">'='</span> == ch</div><div class="line">           || <span class="string">'&gt;'</span> == ch || <span class="string">'&lt;'</span> == ch || <span class="string">'~'</span> == ch || <span class="string">'!'</span> == ch || <span class="string">'?'</span> == ch || <span class="string">'&amp;'</span> == ch || <span class="string">'|'</span> == ch || <span class="string">'.'</span> == ch || <span class="string">':'</span> == ch || <span class="string">'#'</span> == ch || <span class="string">','</span> == ch || <span class="string">';'</span> == ch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Tokenizer.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 扫描符号.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 符号标记</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> Token <span class="title">scanSymbol</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (CharType.isSymbol(charAt(offset + length))) &#123;</div><div class="line">       length++;</div><div class="line">   &#125;</div><div class="line">   String literals = input.substring(offset, offset + length);</div><div class="line">   <span class="comment">// 倒序遍历，查询符合条件的 符号。例如 literals = ";;"，会是拆分成两个 ";"。如果基于正序，literals = "&lt;="，会被解析成 "&lt;" + "="。</span></div><div class="line">   Symbol symbol;</div><div class="line">   <span class="keyword">while</span> (<span class="keyword">null</span> == (symbol = Symbol.literalsOf(literals))) &#123;</div><div class="line">       literals = input.substring(offset, offset + --length);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Token(symbol, literals, offset + length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.4 Assist 词法辅助标记</h2>
<p>Assist 词法辅助标记，一共分成 2 种：</p>
<ul>
<li>END ：分析结束</li>
<li>ERROR ：分析错误。</li>
</ul>
<h1>4. 彩蛋</h1>
<p>老铁，是不是比想象中简单一些？！继续加油写 Parser 相关的文章！来一波微信公众号关注吧。</p>
<hr>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。Sharding-JDBC 也会因此，能够覆盖更广的场景。登记吧，少年！</strong></p>
<hr>
<p><strong>我创建了一个微信群【源码圈】，希望和大家分享交流读源码的经验。<br>
读源码先难后易，掌握方法后，可以做更有深度的学习。<br>
而且掌握方法并不难噢。<br>
加群方式：微信公众号发送关键字【qun】。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;ol
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— SQL ON MongoDB</title>
    <link href="http://www.yunai.me/MyCAT/connect-mongodb/"/>
    <id>http://www.yunai.me/MyCAT/connect-mongodb/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 主流程</a></li>
<li><a href="#">3. 查询操作</a></li>
<li><a href="#">4. 插入操作</a></li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>可能你在看到这个标题会小小的吃惊，MyCAT 能使用 MongoDB 做数据节点。是的，没错，确实可以。<br>
吼吼吼，让我们开启这段神奇的“旅途”。</p>
<p>本文主要分成四部分：</p>
<ol>
<li>总体流程，让你有个整体的认识</li>
<li>查询操作</li>
<li>插入操作</li>
<li>彩蛋，😈彩蛋，🙂彩蛋</li>
</ol>
<p>建议你看过这两篇文章（<em>非必须</em>）：</p>
<ol>
<li><a href="http://www.yunai.me/MyCAT/single-db-single-table-insert/?self">《MyCAT 源码分析 —— 【单库单表】插入》</a></li>
<li><a href="http://www.yunai.me/MyCAT/single-db-single-table-select/?self">《MyCAT 源码分析 —— 【单库单表】查询》</a></li>
</ol>
<h1>2. 主流程</h1>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/01.png" alt=""></p>
<ol>
<li><code>MyCAT Server</code> 接收 <code>MySQL Client</code> 基于 <strong>MySQL协议</strong> 的请求，翻译 <strong>SQL</strong> 成 <strong>MongoDB操作</strong> 发送给 <code>MongoDB Server</code>。</li>
<li><code>MyCAT Server</code> 接收 <code>MongoDB Server</code> 返回的 <strong>MongoDB数据</strong>，翻译成 <code>MySQL数据结果</code> 返回给 <code>MySQL Client</code>。</li>
</ol>
<p>这样一看，MyCAT 连接 MongoDB 是不是少神奇一点列。</p>
<hr>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/02.png" alt=""></p>
<blockquote>
<p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。JDBC是面向关系型数据库的。</p>
</blockquote>
<p>MyCAT 使用 JDBC 规范，抽象了对 MongoDB 的访问。通过这样的方式，MyCAT 也抽象了 SequoiaDB 的访问。可能这样说法有些抽象，看个类图压压惊。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/03.png" alt=""></p>
<p>是不是熟悉的味道。<strong>不得不说 JDBC 规范的精妙。</strong></p>
<h1>3. 查询操作</h1>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">''</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> _id <span class="keyword">DESC</span>;</div></pre></td></tr></table></figure></p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/04.png" alt=""></p>
<p>看顺序图已经很方便的理解整体逻辑，我就不多废话啦。我们来看几个核心的代码逻辑。</p>
<p><strong>1、查询 MongoDB</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> MongoData <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> MongoSQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!(statement <span class="keyword">instanceof</span> SQLSelectStatement)) &#123;</div><div class="line">       <span class="comment">//return null;</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"not a query sql statement"</span>);</div><div class="line">   &#125;</div><div class="line">   MongoData mongo = <span class="keyword">new</span> MongoData();</div><div class="line">   DBCursor c = <span class="keyword">null</span>;</div><div class="line">   SQLSelectStatement selectStmt = (SQLSelectStatement) statement;</div><div class="line">   SQLSelectQuery sqlSelectQuery = selectStmt.getSelect().getQuery();</div><div class="line">   <span class="keyword">int</span> icount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (sqlSelectQuery <span class="keyword">instanceof</span> MySqlSelectQueryBlock) &#123;</div><div class="line">       MySqlSelectQueryBlock mysqlSelectQuery = (MySqlSelectQueryBlock) selectStmt.getSelect().getQuery();</div><div class="line"></div><div class="line">       BasicDBObject fields = <span class="keyword">new</span> BasicDBObject();</div><div class="line"></div><div class="line">       <span class="comment">// 显示（返回）的字段</span></div><div class="line">       <span class="keyword">for</span> (SQLSelectItem item : mysqlSelectQuery.getSelectList()) &#123;</div><div class="line">           <span class="comment">//System.out.println(item.toString());</span></div><div class="line">           <span class="keyword">if</span> (!(item.getExpr() <span class="keyword">instanceof</span> SQLAllColumnExpr)) &#123;</div><div class="line">               <span class="keyword">if</span> (item.getExpr() <span class="keyword">instanceof</span> SQLAggregateExpr) &#123;</div><div class="line">                   SQLAggregateExpr expr = (SQLAggregateExpr) item.getExpr();</div><div class="line">                   <span class="keyword">if</span> (expr.getMethodName().equals(<span class="string">"COUNT"</span>)) &#123; <span class="comment">// TODO 待读：count（*）</span></div><div class="line">                       icount = <span class="number">1</span>;</div><div class="line">                       mongo.setField(getExprFieldName(expr), Types.BIGINT);</div><div class="line">                   &#125;</div><div class="line">                   fields.put(getExprFieldName(expr), <span class="number">1</span>);</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   fields.put(getFieldName(item), <span class="number">1</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 表名</span></div><div class="line">       SQLTableSource table = mysqlSelectQuery.getFrom();</div><div class="line">       DBCollection coll = <span class="keyword">this</span>._db.getCollection(table.toString());</div><div class="line">       mongo.setTable(table.toString());</div><div class="line"></div><div class="line">       <span class="comment">// WHERE</span></div><div class="line">       SQLExpr expr = mysqlSelectQuery.getWhere();</div><div class="line">       DBObject query = parserWhere(expr);</div><div class="line"></div><div class="line">       <span class="comment">// GROUP BY</span></div><div class="line">       SQLSelectGroupByClause groupby = mysqlSelectQuery.getGroupBy();</div><div class="line">       BasicDBObject gbkey = <span class="keyword">new</span> BasicDBObject();</div><div class="line">       <span class="keyword">if</span> (groupby != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">for</span> (SQLExpr gbexpr : groupby.getItems()) &#123;</div><div class="line">               <span class="keyword">if</span> (gbexpr <span class="keyword">instanceof</span> SQLIdentifierExpr) &#123;</div><div class="line">                   String name = ((SQLIdentifierExpr) gbexpr).getName();</div><div class="line">                   gbkey.put(name, Integer.valueOf(<span class="number">1</span>));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           icount = <span class="number">2</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// SKIP / LIMIT</span></div><div class="line">       <span class="keyword">int</span> limitoff = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> limitnum = <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (mysqlSelectQuery.getLimit() != <span class="keyword">null</span>) &#123;</div><div class="line">           limitoff = getSQLExprToInt(mysqlSelectQuery.getLimit().getOffset());</div><div class="line">           limitnum = getSQLExprToInt(mysqlSelectQuery.getLimit().getRowCount());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (icount == <span class="number">1</span>) &#123; <span class="comment">// COUNT（*）</span></div><div class="line">           mongo.setCount(coll.count(query));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (icount == <span class="number">2</span>) &#123; <span class="comment">// MapReduce</span></div><div class="line">           BasicDBObject initial = <span class="keyword">new</span> BasicDBObject();</div><div class="line">           initial.put(<span class="string">"num"</span>, <span class="number">0</span>);</div><div class="line">           String reduce = <span class="string">"function (obj, prev) &#123; "</span> + <span class="string">"  prev.num++&#125;"</span>;</div><div class="line">           mongo.setGrouyBy(coll.group(gbkey, query, initial, reduce));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> ((limitoff &gt; <span class="number">0</span>) || (limitnum &gt; <span class="number">0</span>)) &#123;</div><div class="line">               c = coll.find(query, fields).skip(limitoff).limit(limitnum);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               c = coll.find(query, fields);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="comment">// order by</span></div><div class="line">           SQLOrderBy orderby = mysqlSelectQuery.getOrderBy();</div><div class="line">           <span class="keyword">if</span> (orderby != <span class="keyword">null</span>) &#123;</div><div class="line">               BasicDBObject order = <span class="keyword">new</span> BasicDBObject();</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orderby.getItems().size(); i++) &#123;</div><div class="line">                   SQLSelectOrderByItem orderitem = orderby.getItems().get(i);</div><div class="line">                   order.put(orderitem.getExpr().toString(), getSQLExprToAsc(orderitem.getType()));</div><div class="line">               &#125;</div><div class="line">               c.sort(order);</div><div class="line">               <span class="comment">// System.out.println(order);</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       mongo.setCursor(c);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> mongo;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2、查询条件</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parserWhere</span><span class="params">(SQLExpr aexpr, BasicDBObject o)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (aexpr <span class="keyword">instanceof</span> SQLBinaryOpExpr) &#123;</div><div class="line">       SQLBinaryOpExpr expr = (SQLBinaryOpExpr) aexpr;</div><div class="line">       SQLExpr exprL = expr.getLeft();</div><div class="line">       <span class="keyword">if</span> (!(exprL <span class="keyword">instanceof</span> SQLBinaryOpExpr)) &#123;</div><div class="line">           <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"="</span>)) &#123;</div><div class="line">               o.put(exprL.toString(), getExpValue(expr.getRight()));</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               String op = <span class="string">""</span>;</div><div class="line">               <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$lt"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$lte"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&gt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$gt"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&gt;="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$gte"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"!="</span>)) &#123;</div><div class="line">                   op = <span class="string">"$ne"</span>;</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"&lt;&gt;"</span>)) &#123;</div><div class="line">                   op = <span class="string">"$ne"</span>;</div><div class="line">               &#125;</div><div class="line">               parserDBObject(o, exprL.toString(), op, getExpValue(expr.getRight()));</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"AND"</span>)) &#123;</div><div class="line">               parserWhere(exprL, o);</div><div class="line">               parserWhere(expr.getRight(), o);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expr.getOperator().getName().equals(<span class="string">"OR"</span>)) &#123;</div><div class="line">               orWhere(exprL, expr.getRight(), o);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't identify the operation of  of where"</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orWhere</span><span class="params">(SQLExpr exprL, SQLExpr exprR, BasicDBObject ob)</span> </span>&#123;</div><div class="line">   BasicDBObject xo = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   BasicDBObject yo = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   parserWhere(exprL, xo);</div><div class="line">   parserWhere(exprR, yo);</div><div class="line">   ob.put(<span class="string">"$or"</span>, <span class="keyword">new</span> Object[]&#123;xo, yo&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3、解析 MongoDB 数据</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoResultSet.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MongoResultSet</span><span class="params">(MongoData mongo, String schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>._cursor = mongo.getCursor();</div><div class="line">   <span class="keyword">this</span>._schema = schema;</div><div class="line">   <span class="keyword">this</span>._table = mongo.getTable();</div><div class="line">   <span class="keyword">this</span>.isSum = mongo.getCount() &gt; <span class="number">0</span>;</div><div class="line">   <span class="keyword">this</span>._sum = mongo.getCount();</div><div class="line">   <span class="keyword">this</span>.isGroupBy = mongo.getType();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.isGroupBy) &#123;</div><div class="line">       dblist = mongo.getGrouyBys();</div><div class="line">       <span class="keyword">this</span>.isSum = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>._cursor != <span class="keyword">null</span>) &#123;</div><div class="line">       select = _cursor.getKeysWanted().keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</div><div class="line">       <span class="comment">// 解析 fields</span></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>._cursor.hasNext()) &#123;</div><div class="line">           _cur = _cursor.next();</div><div class="line">           <span class="keyword">if</span> (_cur != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (select.length == <span class="number">0</span>) &#123;</div><div class="line">                   SetFields(_cur.keySet());</div><div class="line">               &#125;</div><div class="line">               _row = <span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 设置 fields 类型</span></div><div class="line">       <span class="keyword">if</span> (select.length == <span class="number">0</span>) &#123;</div><div class="line">           select = <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>&#125;;</div><div class="line">           SetFieldType(<span class="keyword">true</span>);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           SetFieldType(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       SetFields(mongo.getFields().keySet());<span class="comment">//new String[]&#123;"COUNT(*)"&#125;;</span></div><div class="line">       SetFieldType(mongo.getFields());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当使用 <code>SELECT *</code> 查询字段时，fields 使用第一条数据返回的 fields。即使，后面的数据有其他 fields，也不返回。</li>
</ul>
<p><strong>4、返回数据给 MySQL Client</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JDBCConnection.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ouputResultSet</span><span class="params">(ServerConnection sc, String sql)</span></span></div><div class="line">       <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   ResultSet rs = <span class="keyword">null</span>;</div><div class="line">   Statement stmt = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       stmt = con.createStatement();</div><div class="line">       rs = stmt.executeQuery(sql);</div><div class="line"></div><div class="line">       <span class="comment">// header</span></div><div class="line">       List&lt;FieldPacket&gt; fieldPks = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       ResultSetUtil.resultSetToFieldPacket(sc.getCharset(), fieldPks, rs, <span class="keyword">this</span>.isSpark);</div><div class="line">       <span class="keyword">int</span> colunmCount = fieldPks.size();</div><div class="line">       ByteBuffer byteBuf = sc.allocate();</div><div class="line">       ResultSetHeaderPacket headerPkg = <span class="keyword">new</span> ResultSetHeaderPacket();</div><div class="line">       headerPkg.fieldCount = fieldPks.size();</div><div class="line">       headerPkg.packetId = ++packetId;</div><div class="line">       byteBuf = headerPkg.write(byteBuf, sc, <span class="keyword">true</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(header);</div><div class="line">       byteBuf.clear();</div><div class="line">       List&lt;<span class="keyword">byte</span>[]&gt; fields = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(fieldPks.size());</div><div class="line">       <span class="keyword">for</span> (FieldPacket curField : fieldPks) &#123;</div><div class="line">           curField.packetId = ++packetId;</div><div class="line">           byteBuf = curField.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">           byteBuf.flip();</div><div class="line">           <span class="keyword">byte</span>[] field = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">           byteBuf.get(field);</div><div class="line">           byteBuf.clear();</div><div class="line">           fields.add(field);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// header eof</span></div><div class="line">       EOFPacket eofPckg = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eofPckg.packetId = ++packetId;</div><div class="line">       byteBuf = eofPckg.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       <span class="keyword">byte</span>[] eof = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(eof);</div><div class="line">       byteBuf.clear();</div><div class="line">       <span class="keyword">this</span>.respHandler.fieldEofResponse(header, fields, eof, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">       <span class="comment">// row</span></div><div class="line">       <span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">           RowDataPacket curRow = <span class="keyword">new</span> RowDataPacket(colunmCount);</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; colunmCount; i++) &#123;</div><div class="line">               <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">               <span class="keyword">if</span> (MysqlDefs.isBianry((<span class="keyword">byte</span>) fieldPks.get(i).type)) &#123;</div><div class="line">                   curRow.add(rs.getBytes(j));</div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fieldPks.get(i).type == MysqlDefs.FIELD_TYPE_DECIMAL ||</div><div class="line">                       fieldPks.get(i).type == (MysqlDefs.FIELD_TYPE_NEW_DECIMAL - <span class="number">256</span>)) &#123; <span class="comment">// field type is unsigned byte</span></div><div class="line">                   <span class="comment">// ensure that do not use scientific notation format</span></div><div class="line">                   BigDecimal val = rs.getBigDecimal(j);</div><div class="line">                   curRow.add(StringUtil.encode(val != <span class="keyword">null</span> ? val.toPlainString() : <span class="keyword">null</span>, sc.getCharset()));</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   curRow.add(StringUtil.encode(rs.getString(j), sc.getCharset()));</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           curRow.packetId = ++packetId;</div><div class="line">           byteBuf = curRow.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">           byteBuf.flip();</div><div class="line">           <span class="keyword">byte</span>[] row = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">           byteBuf.get(row);</div><div class="line">           byteBuf.clear();</div><div class="line">           <span class="keyword">this</span>.respHandler.rowResponse(row, <span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line">       fieldPks.clear();</div><div class="line">       <span class="comment">// row eof</span></div><div class="line">       eofPckg = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eofPckg.packetId = ++packetId;</div><div class="line">       byteBuf = eofPckg.write(byteBuf, sc, <span class="keyword">false</span>);</div><div class="line">       byteBuf.flip();</div><div class="line">       eof = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuf.limit()];</div><div class="line">       byteBuf.get(eof);</div><div class="line">       sc.recycle(byteBuf);</div><div class="line">       <span class="keyword">this</span>.respHandler.rowEofResponse(eof, <span class="keyword">this</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               rs.close();</div><div class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               stmt.close();</div><div class="line">           &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MongoResultSet.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Object x = getObject(columnLabel);</div><div class="line">   <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> x.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当返回字段值是 Object 时，返回该对象.toString()。例如：</li>
</ul>
<p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">mysql&gt; select * from user order by _id asc;</div><div class="line">+--------------------------+------+-------------------------------+</div><div class="line">| _id                      | name | profile                       |</div><div class="line">+--------------------------+------+-------------------------------+</div><div class="line">| 1                        | 123  | &#123; "age" : 1 , "height" : 100&#125; |</div></pre></td></tr></table></figure></p>
<h1>4. 插入操作</h1>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_19/05.png" alt=""></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MongoSQLParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> <span class="keyword">throws</span> MongoSQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLInsertStatement) &#123;</div><div class="line">       <span class="keyword">return</span> InsertData((SQLInsertStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLUpdateStatement) &#123;</div><div class="line">       <span class="keyword">return</span> UpData((SQLUpdateStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLDropTableStatement) &#123;</div><div class="line">       <span class="keyword">return</span> dropTable((SQLDropTableStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLDeleteStatement) &#123;</div><div class="line">       <span class="keyword">return</span> DeleteDate((SQLDeleteStatement) statement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (statement <span class="keyword">instanceof</span> SQLCreateTableStatement) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">InsertData</span><span class="params">(SQLInsertStatement state)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (state.getValues().getValues().size() == <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"number of  columns error"</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (state.getValues().getValues().size() != state.getColumns().size()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"number of values and columns have to match"</span>);</div><div class="line">   &#125;</div><div class="line">   SQLTableSource table = state.getTableSource();</div><div class="line">   BasicDBObject o = <span class="keyword">new</span> BasicDBObject();</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (SQLExpr col : state.getColumns()) &#123;</div><div class="line">       o.put(getFieldName2(col), getExpValue(state.getValues().getValues().get(i)));</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   DBCollection coll = <span class="keyword">this</span>._db.getCollection(table.toString());</div><div class="line">   coll.insert(o);</div><div class="line">   <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>5. 彩蛋</h1>
<p>老铁，看到这里，来一波微信公众号关注吧？！</p>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p>
<p><strong>1、支持多 MongoDB ，并使用 MyCAT 进行分片。</strong></p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/multi_mongodb" rel="external nofollow noopener noreferrer" target="_blank">multi_mongodb</a></p>
<p><strong>2、支持 MongoDB + MySQL 作为同一个 MyCAT Table 的数据节点。查询时，可以合并数据结果。</strong></p>
<p>查询时，返回 MySQL 数据记录字段要比 MongoDB 数据记录字段全，否则，合并结果时会报错。</p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/single_mongodb_mysql" rel="external nofollow noopener noreferrer" target="_blank">single_mongodb_mysql</a></p>
<p><strong>3、MongoDB 作为数据节点时，可以使用 MyCAT 提供的数据库主键字段功能。</strong></p>
<p>MyCAT 配置：<a href="https://github.com/YunaiV/Mycat-Server/tree/1.6/src/test/resources/single_mongodb" rel="external nofollow noopener noreferrer" target="_blank">single_mongodb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;ol
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— PreparedStatement 重新入门</title>
    <link href="http://www.yunai.me/MyCAT/what-is-PreparedStatement/"/>
    <id>http://www.yunai.me/MyCAT/what-is-PreparedStatement/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. JDBC Client 实现</a></li>
<li><a href="#">3. MyCAT Server 实现</a>
<ul>
<li><a href="#">3.1 创建 PreparedStatement</a></li>
<li><a href="#">3.2 执行 SQL</a></li>
</ul>
</li>
<li><a href="#">4. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>相信很多同学在学习 JDBC 时，都碰到 <code>PreparedStatement</code> 和 <code>Statement</code>。究竟该使用哪个呢？最终很可能是<strong>懵里懵懂</strong>的看了各种总结，使用 <code>PreparedStatement</code>。那么本文，通过 MyCAT 对 <code>PreparedStatement</code> 的实现对大家能够重新理解下。</p>
<p>本文主要分成两部分：</p>
<ol>
<li>JDBC Client 如何实现 <code>PreparedStatement</code>。</li>
<li>MyCAT Server 如何处理 <code>PreparedStatement</code>。</li>
</ol>
<p>😈 Let's Go。</p>
<h1>2. JDBC Client 实现</h1>
<p>首先，我们来看一段大家最喜欢复制粘贴之一的代码，JDBC PreparedStatement 查询 MySQL 数据库：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</div><div class="line">        <span class="comment">// 1. 获得数据库连接</span></div><div class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:8066/dbtest?useServerPrepStmts=true"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// PreparedStatement</span></div><div class="line">        PreparedStatement ps = conn.prepareStatement(<span class="string">"SELECT id, username, password FROM t_user WHERE id = ?"</span>);</div><div class="line">        ps.setLong(<span class="number">1</span>, Math.abs(<span class="keyword">new</span> Random().nextLong()));</div><div class="line"></div><div class="line">        <span class="comment">// execute</span></div><div class="line">        ps.executeQuery();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>获取 MySQL 连接时，<code>useServerPrepStmts=true</code>  是<strong>非常非常非常重要</strong>的参数。如果不配置，<code>PreparedStatement</code> 实际是个<strong>假</strong>的 <code>PreparedStatement</code>（新版本默认为 FALSE，据说部分老版本默认为 TRUE），未开启服务端级别的 SQL 预编译。</p>
<p>WHY ？来看下 JDBC 里面是怎么实现的。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.mysql.jdbc.ConnectionImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (getConnectionMutex()) &#123;</div><div class="line">       checkClosed();</div><div class="line">       </div><div class="line">       PreparedStatement pStmt = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">boolean</span> canServerPrepare = <span class="keyword">true</span>;</div><div class="line">       String nativeSql = getProcessEscapeCodesForPrepStmts() ? nativeSQL(sql) : sql;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; getEmulateUnsupportedPstmts()) &#123;</div><div class="line">           canServerPrepare = canHandleAsServerPreparedStatement(nativeSql);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; canServerPrepare) &#123;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.getCachePreparedStatements()) &#123; <span class="comment">// 从缓存中获取 pStmt</span></div><div class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>.serverSideStatementCache) &#123;</div><div class="line">                   pStmt = (com.mysql.jdbc.ServerPreparedStatement) <span class="keyword">this</span>.serverSideStatementCache</div><div class="line">                           .remove(makePreparedStatementCacheKey(<span class="keyword">this</span>.database, sql));</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (pStmt != <span class="keyword">null</span>) &#123;</div><div class="line">                       ((com.mysql.jdbc.ServerPreparedStatement) pStmt).setClosed(<span class="keyword">false</span>);</div><div class="line">                       pStmt.clearParameters(); <span class="comment">// 清理上次留下的参数</span></div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   <span class="keyword">if</span> (pStmt == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// .... 省略代码 ：向 Server 提交 SQL 预编译。</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 向 Server 提交 SQL 预编译。</span></div><div class="line">                   pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, <span class="keyword">this</span>.database, resultSetType, resultSetConcurrency);</div><div class="line"></div><div class="line">                   pStmt.setResultSetType(resultSetType);</div><div class="line">                   pStmt.setResultSetConcurrency(resultSetConcurrency);</div><div class="line">               &#125; <span class="keyword">catch</span> (SQLException sqlEx) &#123;</div><div class="line">                   <span class="comment">// Punt, if necessary</span></div><div class="line">                   <span class="keyword">if</span> (getEmulateUnsupportedPstmts()) &#123;</div><div class="line">                       pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       <span class="keyword">throw</span> sqlEx;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> pStmt;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>【前者】当 Client 开启 <code>useServerPreparedStmts</code> 并且 Server 支持 <code>ServerPrepare</code>，<strong>Client 会向 Server 提交 SQL 预编译请求</strong>。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.useServerPreparedStmts &amp;&amp; canServerPrepare) &#123;</div><div class="line">    pStmt = ServerPreparedStatement.getInstance(getMultiHostSafeProxy(), nativeSql, <span class="keyword">this</span>.database, resultSetType, resultSetConcurrency);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>【后者】当 Client 未开启 <code>useServerPreparedStmts</code> 或者 Server 不支持 <code>ServerPrepare</code>，Client 创建 <code>PreparedStatement</code>，<strong>_不会_向 Server 提交 SQL 预编译请求</strong>。</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">pStmt = (PreparedStatement) clientPrepareStatement(nativeSql, resultSetType, resultSetConcurrency, <span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p><strong>即使这样，究竟为什么性能会更好呢？</strong></p>
<ul>
<li>【前者】返回的 <code>PreparedStatement</code> 对象类是 <code>JDBC42ServerPreparedStatement.java</code>，后续每次执行 SQL 只需将对应占位符?对应的值提交给 Server即可，减少网络传输和 SQL 解析开销。</li>
<li>【后者】返回的 <code>PreparedStatement</code> 对象类是 <code>JDBC42PreparedStatement.java</code>，后续每次执行 SQL 需要将<strong>完整</strong>的 SQL 提交给 Server，增加了网络传输和 SQL 解析开销。</li>
</ul>
<p><em>🌚：【前者】性能一定比【后者】好吗？相信你已经有了正确的答案。</em></p>
<h1>3. MyCAT Server 实现</h1>
<h2>3.1 创建 PreparedStatement</h2>
<p>该操作对应 Client <code>conn.prepareStatement(....)</code>。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_17/01.png" alt=""></p>
<p>MyCAT 接收到请求后，创建 <code>PreparedStatement</code>，并返回 <code>statementId</code> 等信息。Client 发起 SQL 执行时，需要将 <code>statementId</code> 带给 MyCAT。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPrepareHandler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(String sql)</span> </span>&#123;</div><div class="line">LOGGER.debug(<span class="string">"use server prepare, sql: "</span> + sql);</div><div class="line"></div><div class="line">   PreparedStatement pstmt = pstmtForSql.get(sql);</div><div class="line">   <span class="keyword">if</span> (pstmt == <span class="keyword">null</span>) &#123; <span class="comment">// 缓存中获取</span></div><div class="line">   	<span class="comment">// 解析获取字段个数和参数个数</span></div><div class="line">   	<span class="keyword">int</span> columnCount = getColumnCount(sql);</div><div class="line">   	<span class="keyword">int</span> paramCount = getParamCount(sql);</div><div class="line">       pstmt = <span class="keyword">new</span> PreparedStatement(++pstmtId, sql, columnCount, paramCount);</div><div class="line">       pstmtForSql.put(pstmt.getStatement(), pstmt);</div><div class="line">       pstmtForId.put(pstmt.getId(), pstmt);</div><div class="line">   &#125;</div><div class="line">   PreparedStmtResponse.response(pstmt, source);</div><div class="line">&#125;</div><div class="line"><span class="comment">// PreparedStmtResponse.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(PreparedStatement pstmt, FrontendConnection c)</span> </span>&#123;</div><div class="line">   <span class="keyword">byte</span> packetId = <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="comment">// write preparedOk packet</span></div><div class="line">   PreparedOkPacket preparedOk = <span class="keyword">new</span> PreparedOkPacket();</div><div class="line">   preparedOk.packetId = ++packetId;</div><div class="line">   preparedOk.statementId = pstmt.getId();</div><div class="line">   preparedOk.columnsNumber = pstmt.getColumnsNumber();</div><div class="line">   preparedOk.parametersNumber = pstmt.getParametersNumber();</div><div class="line">   ByteBuffer buffer = preparedOk.write(c.allocate(), c,<span class="keyword">true</span>);</div><div class="line"></div><div class="line">   <span class="comment">// write parameter field packet</span></div><div class="line">   <span class="keyword">int</span> parametersNumber = preparedOk.parametersNumber;</div><div class="line">   <span class="keyword">if</span> (parametersNumber &gt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parametersNumber; i++) &#123;</div><div class="line">           FieldPacket field = <span class="keyword">new</span> FieldPacket();</div><div class="line">           field.packetId = ++packetId;</div><div class="line">           buffer = field.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       EOFPacket eof = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eof.packetId = ++packetId;</div><div class="line">       buffer = eof.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// write column field packet</span></div><div class="line">   <span class="keyword">int</span> columnsNumber = preparedOk.columnsNumber;</div><div class="line">   <span class="keyword">if</span> (columnsNumber &gt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnsNumber; i++) &#123;</div><div class="line">           FieldPacket field = <span class="keyword">new</span> FieldPacket();</div><div class="line">           field.packetId = ++packetId;</div><div class="line">           buffer = field.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       EOFPacket eof = <span class="keyword">new</span> EOFPacket();</div><div class="line">       eof.packetId = ++packetId;</div><div class="line">       buffer = eof.write(buffer, c,<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// send buffer</span></div><div class="line">   c.write(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>每个连接之间，PreparedStatement 不共享，即不同连接，即使 SQL相同，对应的 PreparedStatement 不同。</strong></p>
<h2>3.2 执行 SQL</h2>
<p>该操作对应 Client <code>conn.execute(....)</code>。</p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_17/02.png" alt=""></p>
<p>MyCAT 接收到请求后，将 PreparedStatement 使用请求的参数格式化成可执行的 SQL 进行执行。伪代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String sql = pstmt.sql.format(request.params);</div><div class="line">execute(sql);</div></pre></td></tr></table></figure></p>
<p>核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPrepareHandler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> pstmtId = ByteUtil.readUB4(data, <span class="number">5</span>);</div><div class="line">   PreparedStatement pstmt = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">if</span> ((pstmt = pstmtForId.get(pstmtId)) == <span class="keyword">null</span>) &#123;</div><div class="line">       source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, <span class="string">"Unknown pstmtId when executing."</span>);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 参数读取</span></div><div class="line">       ExecutePacket packet = <span class="keyword">new</span> ExecutePacket(pstmt);</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           packet.read(data, source.getCharset());</div><div class="line">       &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</div><div class="line">           source.writeErrMessage(ErrorCode.ER_ERROR_WHEN_EXECUTING_COMMAND, e.getMessage());</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       BindValue[] bindValues = packet.values;</div><div class="line">       <span class="comment">// 还原sql中的动态参数为实际参数值</span></div><div class="line">       String sql = prepareStmtBindValue(pstmt, bindValues);</div><div class="line">       <span class="comment">// 执行sql</span></div><div class="line">       source.getSession2().setPrepared(<span class="keyword">true</span>);</div><div class="line">       source.query(sql);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">prepareStmtBindValue</span><span class="params">(PreparedStatement pstmt, BindValue[] bindValues)</span> </span>&#123;</div><div class="line">   String sql = pstmt.getStatement();</div><div class="line">   <span class="keyword">int</span>[] paramTypes = pstmt.getParametersType();</div><div class="line"></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = sql.length(); i &lt; len; i++) &#123;</div><div class="line">       <span class="keyword">char</span> c = sql.charAt(i);</div><div class="line">       <span class="keyword">if</span> (c != <span class="string">'?'</span>) &#123;</div><div class="line">           sb.append(c);</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 处理占位符?</span></div><div class="line">       <span class="keyword">int</span> paramType = paramTypes[idx];</div><div class="line">       BindValue bindValue = bindValues[idx];</div><div class="line">       idx++;</div><div class="line">       <span class="comment">// 处理字段为空的情况</span></div><div class="line">       <span class="keyword">if</span> (bindValue.isNull) &#123;</div><div class="line">           sb.append(<span class="string">"NULL"</span>);</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 非空情况, 根据字段类型获取值</span></div><div class="line">       <span class="keyword">switch</span> (paramType &amp; <span class="number">0xff</span>) &#123;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_TINY:</div><div class="line">               sb.append(String.valueOf(bindValue.byteBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_SHORT:</div><div class="line">               sb.append(String.valueOf(bindValue.shortBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Fields.FIELD_TYPE_LONG:</div><div class="line">               sb.append(String.valueOf(bindValue.intBinding));</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="comment">// .... 省略非核心代码</span></div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> sb.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>4. 彩蛋</h1>
<p>💯 看到此处是不是真爱？！反正我信了。<br>
给老铁们额外加个🍗。</p>
<p>细心的同学们可能已经注意到 JDBC Client 是支持缓存 <code>PreparedStatement</code>，无需每次都让 Server 进行创建。</p>
<p>当配置 MySQL 数据连接 <code>cachePrepStmts=true</code> 时开启 Client 级别的缓存。But，<strong>此处的缓存又和一般的缓存不一样</strong>，是使用 <code>remove</code> 的方式获得的，并且创建好 <code>PreparedStatement</code> 时也不添加到缓存。那什么时候添加缓存呢？在 <code>pstmt.close()</code> 时，并且**<code>pstmt</code> 是通过缓存获取时**，添加到缓存。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   MySQLConnection locallyScopedConn = <span class="keyword">this</span>.connection;</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (locallyScopedConn == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span>; <span class="comment">// already closed</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">synchronized</span> (locallyScopedConn.getConnectionMutex()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.isCached &amp;&amp; isPoolable() &amp;&amp; !<span class="keyword">this</span>.isClosed) &#123;</div><div class="line">           clearParameters();</div><div class="line">           <span class="keyword">this</span>.isClosed = <span class="keyword">true</span>;</div><div class="line">           <span class="keyword">this</span>.connection.recachePreparedStatement(<span class="keyword">this</span>);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       realClose(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ConnectionImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recachePreparedStatement</span><span class="params">(ServerPreparedStatement pstmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (getConnectionMutex()) &#123;</div><div class="line">       <span class="keyword">if</span> (getCachePreparedStatements() &amp;&amp; pstmt.isPoolable()) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.serverSideStatementCache) &#123;</div><div class="line">               <span class="keyword">this</span>.serverSideStatementCache.put(makePreparedStatementCacheKey(pstmt.currentCatalog, pstmt.originalSql), pstmt);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么要这么实现？<code>PreparedStatement</code> 是有状态的变量，我们会去 <code>setXXX(pos, value)</code>，一旦多线程共享，会导致错乱。</p>
<p>🗿 这个“彩蛋”还满意么？<strong>请关注我的公众号：芋艿的后端小屋</strong>。下一篇更新：《MyCAT源码解析 —— MongoDB》，极大可能就在本周噢。</p>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p>
<p>另外推荐一篇文章：<a href="https://www.zybuluo.com/stefanlu/note/254899" rel="external nofollow noopener noreferrer" target="_blank">《JDBC PreparedStatement》</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;ol
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 为什么阅读 Sharding-JDBC 源码？</title>
    <link href="http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/"/>
    <id>http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/</id>
    <published>2017-07-15T16:00:00.000Z</published>
    <updated>2017-08-10T04:03:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h2>为什么阅读 Sharding-JDBC 源码？</h2>
<ol>
<li>看完大部分的 MyCAT 源码，有惊喜的地方，也有失望的地方，因而想看看 Sharding-JDBC 进行下对比。尽管，Sharding-JDBC 是 Client 端级别，MyCAT 是 Server 级别。</li>
<li>Sharding-JDBC 经历过当当本身业务的考验，从可靠性上来说会更让人有信赖感。</li>
<li>文档更加完善，开发体系更加健全。</li>
<li>Sharding-JDBC 1.5.0.M3 发布。</li>
<li><strong>最大努力送达型</strong>事务支持，想要进一步了解分布式事务的解决方案。Last But Very Importment。</li>
</ol>
<h2>使用公司</h2>
<ol>
<li>京东 ( FROM 民间 )</li>
<li>唯品会 ( FROM 民间 )</li>
<li>转转 ( FROM https://github.com/dangdangdotcom/sharding-jdbc/issues/234 )</li>
<li>足记 ( FROM https://github.com/dangdangdotcom/sharding-jdbc/issues/234 )</li>
<li><strong>不定义更新</strong> ( FROM https://github.com/dangdangdotcom/sharding-jdbc/issues/234 )</li>
</ol>
<h2>步骤</h2>
<ul>
<li>
<p>FROM MyCAT</p>
<p><strong>从 MyCAT 阅读计划复制，用于对比。</strong></p>
</li>
<li>
<p>[x] <s>NIO</s></p>
</li>
<li>
<p>[x] <s>分布式事务</s></p>
</li>
<li>
<p>[x] <s>MyCAT 主从</s></p>
</li>
<li>
<p>[x] <s>支持prepare预编译指令</s></p>
</li>
<li>
<p>[x] 自增序列</p>
</li>
<li>
<p>[x] 单库任意 Join</p>
</li>
<li>
<p>[x] <s>跨库2表 Join</s></p>
</li>
<li>
<p>[x] <s>跨库多表 Join</s></p>
</li>
<li>
<p>[x] SQL 解析</p>
</li>
<li>
<p>[ ] 读写分离</p>
</li>
<li>
<p>[x] <s>MySQL 主从</s></p>
</li>
<li>
<p>[x] <s>自动故障切换</s></p>
</li>
<li>
<p>[x] <s>Galera Cluster 集群</s></p>
</li>
<li>
<p>[x] <s>MHA 集群</s></p>
</li>
<li>
<p>[x] <s>Percona 集群</s></p>
</li>
<li>
<p>[x] <s>服务降级</s></p>
</li>
<li>
<p>[x] <s>多租户</s></p>
</li>
<li>
<p>[x] 路由</p>
</li>
<li>
<p>[x] <s>MyCAT 集群</s></p>
</li>
<li>
<p>[x] <s>注解</s></p>
</li>
<li>
<p>[x] <s>缓存</s></p>
</li>
<li>
<p>[x] <s>监控</s></p>
</li>
<li>
<p>[x] <s>Mongodb</s></p>
</li>
<li>
<p>[ ] 内存管理</p>
</li>
<li>
<p>[ ] 数据聚合</p>
</li>
<li>
<p>[ ] 数据排序</p>
</li>
<li>
<p>[x] 分表</p>
</li>
<li>
<p>[x] 分库</p>
</li>
<li>
<p>[x] <s>全局表</s></p>
</li>
<li>
<p>[x] <s>E/R关系</s></p>
</li>
<li>
<p>[x] <s>服务降级</s></p>
</li>
<li>
<p>[x] <s>SQL 注入攻击拦截</s></p>
</li>
<li>
<p>[x] <s>MySQL 协议</s></p>
</li>
<li>
<p>[x] <s>PostgreSQL 协议</s></p>
</li>
<li>
<p>[ ] 存储过程</p>
</li>
<li>
<p>FROM Sharding-JDBC</p>
<p><strong>从 官网 介绍获取。</strong></p>
</li>
<li>
<p>[ ] 分布式事务 ：最大努力送达型事务</p>
</li>
<li>
<p>[ ] 分布式事务 ：TCC型事务(TBD)</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;ol
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>MyCAT 源码分析  —— XA分布式事务</title>
    <link href="http://www.yunai.me/MyCAT/xa-distributed-transaction/"/>
    <id>http://www.yunai.me/MyCAT/xa-distributed-transaction/</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2017-07-31T12:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. XA 概念</a></li>
<li><a href="#">3. MyCAT 代码实现</a>
<ul>
<li><a href="#">3.1 JDBC Demo 代码</a></li>
<li><a href="#">3.2 MyCAT 开启 XA 事务</a></li>
<li><a href="#">3.3 MyCAT 接收 SQL</a></li>
<li><a href="#">3.4 MySQL 接收 COMMIT</a>
<ul>
<li><a href="#">3.4.1 单节点事务 or 多节点事务</a></li>
<li><a href="#">3.4.2 协调日志</a></li>
<li><a href="#">3.4.3 MultiNodeCoordinator</a></li>
</ul>
</li>
<li><a href="#">3.5 MyCAT 启动回滚 XA事务</a></li>
</ul>
</li>
<li><a href="#">4. MyCAT 实现缺陷</a>
<ul>
<li><a href="#">4.1 协调日志写入性能</a></li>
<li><a href="#">4.2 数据节点未全部 PREPARE 就进行 COMMIT</a></li>
<li><a href="#">4.3 MyCAT 启动回滚 PREPARE 的 XA事务</a></li>
<li><a href="#">4.4 单节点事务未记录协调日志</a></li>
<li><a href="#">4.5 XA COMMIT 部分节点挂了重新恢复后，未进一步处理</a></li>
</ul>
</li>
<li><a href="#">5. 彩蛋</a></li>
</ul>
<hr>
<h1>1. 概述</h1>
<p>数据库拆分后，业务上会碰到需要分布式事务的场景。MyCAT 基于 XA 实现分布式事务。国内目前另外一款很火的数据库中间件 Sharding-JDBC 准备基于 TCC 实现分布式事务。</p>
<p>本文内容分成三部分：</p>
<ol>
<li>XA 概念简述</li>
<li>MyCAT 代码如何实现 XA</li>
<li>MyCAT 在实现 XA 存在的一些缺陷</li>
</ol>
<h1>2. XA 概念</h1>
<blockquote></blockquote>
<p>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括：</p>
<ol>
<li>应用程序（ <strong>AP</strong> ）</li>
<li>事务管理器（ <strong>TM</strong> ）</li>
<li>资源管理器（ <strong>RM</strong> ）</li>
<li>通信资源管理器（ <strong>CRM</strong> ）<br>
一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ <strong>RM</strong> ）是数据库，常见的通信资源管理器（ <strong>CRM</strong> ）是消息中间件，下图是X/Open DTP模型：</li>
</ol>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/01.png" alt=""></p>
<blockquote>
<p>一般的编程方式是这样的：</p>
</blockquote>
<ol>
<li>配置 <strong>TM</strong> ，通过 <strong>TM</strong> 或者 <strong>RM</strong> 提供的方式，把 <strong>RM</strong> 注册到 <strong>TM</strong>。可以理解为给 <strong>TM</strong> 注册 <strong>RM</strong> 作为数据源。一个 <strong>TM</strong> 可以注册多个 <strong>RM</strong>。</li>
<li><strong>AP</strong> 从 <strong>TM</strong> 获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）<br>
<strong>AP</strong> 向 <strong>TM</strong> 发起一个全局事务。这时，<strong>TM</strong> 会通知各个 <strong>RM</strong>。<strong>XID</strong>（全局事务ID）会通知到各个RM。</li>
<li><strong>AP</strong> 通过 <strong>TM</strong> 中获取的连接，<strong>间接</strong>操作 <strong>RM</strong> 进行业务操作。这时，<strong>TM</strong> 在每次 <strong>AP</strong> 操作时把 <strong>XID</strong>(包括所属分支的信息)传递给 <strong>RM</strong>，<strong>RM</strong> 正是通过这个 <strong>XID</strong> 关联来操作和事务的关系的。</li>
<li><strong>AP</strong> 结束全局事务时，<strong>TM</strong> 会通知 <strong>RM</strong> 全局事务结束。开始二段提交，也就是prepare - commit的过程。</li>
</ol>
<hr>
<blockquote>
<p>XA协议指的是TM（事务管理器）和RM（资源管理器）之间的接口。目前主流的关系型数据库产品都是实现了XA接口的。JTA(Java Transaction API)是符合X/Open DTP模型的，事务管理器和资源管理器之间也使用了XA协议。 本质上也是借助两阶段提交协议来实现分布式事务的，下面分别来看看XA事务成功和失败的模型图：</p>
</blockquote>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/02.png" alt="成功"></p>
<p><img src="http://www.yunai.me/images/MyCAT/2017_07_15/03.png" alt="失败"></p>
<hr>
<p>😈 看到这里是不是有种黑人问号的感觉？淡定！我们接下来看 MyCAT 代码层面是如何实现 XA 的。另外，有兴趣对概念了解更多的，可以参看如下文章：</p>
<ol>
<li><a href="http://www.infoq.com/cn/articles/xa-transactions-handle" rel="external nofollow noopener noreferrer" target="_blank">《XA事务处理》</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/xa-statements.html" rel="external nofollow noopener noreferrer" target="_blank">《XA Transaction SQL Syntax》</a></li>
<li><a href="http://www.voidcn.com/blog/gao1738/article/p-4554083.html" rel="external nofollow noopener noreferrer" target="_blank">《MySQL XA 事务支持调研》</a></li>
</ol>
<h1>3. MyCAT 代码实现</h1>
<ul>
<li>MyCAT ：TM，协调者。</li>
<li>数据节点 ：RM，参与者。</li>
</ul>
<h2>3.1 JDBC Demo 代码</h2>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCATXAClientDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</div><div class="line">        <span class="comment">// 1. 获得数据库连接</span></div><div class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:8066/dbtest"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</div><div class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 2. 开启 MyCAT XA 事务</span></div><div class="line">        conn.prepareStatement(<span class="string">"set xa=on"</span>).execute();</div><div class="line"></div><div class="line">        <span class="comment">// 3. 插入 SQL</span></div><div class="line">        <span class="comment">// 3.1 SQL1 A库</span></div><div class="line">        <span class="keyword">long</span> uid = Math.abs(<span class="keyword">new</span> Random().nextLong());</div><div class="line">        String username = UUID.randomUUID().toString();</div><div class="line">        String password = UUID.randomUUID().toString();</div><div class="line">        String sql1 = String.format(<span class="string">"insert into t_user(id, username, password) VALUES (%d, '%s', '%s')"</span>,</div><div class="line">                uid, username, password);</div><div class="line">        conn.prepareStatement(sql1).execute();</div><div class="line">        <span class="comment">// 3.2 SQL2 B库</span></div><div class="line">        <span class="keyword">long</span> orderId = Math.abs(<span class="keyword">new</span> Random().nextLong());</div><div class="line">        String nickname = UUID.randomUUID().toString();</div><div class="line">        String sql2 = String.format(<span class="string">"insert into t_order(id, uid, nickname) VALUES(%d, %s, '%s')"</span>, orderId, uid, nickname);</div><div class="line">        conn.prepareStatement(sql2).execute();</div><div class="line"></div><div class="line">        <span class="comment">// 4. 提交 XA 事务</span></div><div class="line">        conn.commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>set xa=on</code> MyCAT 开启 XA 事务。</li>
<li><code>conn.commit</code> 提交 XA 事务。</li>
</ul>
<h2>3.2 MyCAT 开启 XA 事务</h2>
<p>当 MyCAT 接收到 <code>set xa = on</code> 命令时，开启 XA 事务，并生成 XA 事务编号。XA 事务编号生成算法为 UUID。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SetHandler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String stmt, ServerConnection c, <span class="keyword">int</span> offset)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> rs = ServerParseSet.parse(stmt, offset);</div><div class="line">		<span class="keyword">switch</span> (rs &amp; <span class="number">0xff</span>) &#123;</div><div class="line">		<span class="comment">// ... 省略代码</span></div><div class="line">		<span class="keyword">case</span> XA_FLAG_ON: &#123;</div><div class="line">			<span class="keyword">if</span> (c.isAutocommit()) &#123;</div><div class="line">				c.writeErrMessage(ErrorCode.ERR_WRONG_USED, <span class="string">"set xa cmd on can't used in autocommit connection "</span>);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			c.getSession2().setXATXEnabled(<span class="keyword">true</span>);</div><div class="line">			c.write(c.writeToBuffer(OkPacket.OK, c.allocate()));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">case</span> XA_FLAG_OFF: &#123;</div><div class="line">			c.writeErrMessage(ErrorCode.ERR_WRONG_USED,</div><div class="line">					<span class="string">"set xa cmd off not for external use "</span>);</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// ... 省略代码</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// NonBlockingSession.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXATXEnabled</span><span class="params">(<span class="keyword">boolean</span> xaTXEnabled)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (xaTXEnabled) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.xaTXID == <span class="keyword">null</span>) &#123;</div><div class="line">           xaTXID = genXATXID(); <span class="comment">// 😈😈😈获得 XA 事务编号</span></div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">this</span>.xaTXID = <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">genXATXID</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> MycatServer.getInstance().getXATXIDGLOBAL();</div><div class="line">&#125;</div><div class="line"><span class="comment">// MycatServer.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getXATXIDGLOBAL</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"'"</span> + getUUID() + <span class="string">"'"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUUID</span><span class="params">()</span> </span>&#123; <span class="comment">// 😈😈😈</span></div><div class="line">   String s = UUID.randomUUID().toString();</div><div class="line">   <span class="keyword">return</span> s.substring(<span class="number">0</span>, <span class="number">8</span>) + s.substring(<span class="number">9</span>, <span class="number">13</span>) + s.substring(<span class="number">14</span>, <span class="number">18</span>) + s.substring(<span class="number">19</span>, <span class="number">23</span>) + s.substring(<span class="number">24</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2>3.3 MyCAT 接收 SQL</h2>
<p>此处 SQL 指的是 <code>insert</code>、<code>update</code>、<code>delete</code> 操作。</p>
<p>当向某个数据节点<strong>第一次</strong>发起 SQL 时，会在 SQL 前面附加 <code>XA START 'xaTranId'</code>，并设置该数据节点<strong>连接</strong>事务状态为 <code>TxState.TX_STARTED_STATE</code>（<em>分布式事务状态，下文会专门整理</em>）。核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLConnection.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">synAndDoExecute</span><span class="params">(String xaTxID, RouteResultsetNode rrn,</span></span></div><div class="line">                                 <span class="keyword">int</span> clientCharSetIndex, <span class="keyword">int</span> clientTxIsoLation,</div><div class="line">                                 <span class="keyword">boolean</span> clientAutoCommit) &#123;</div><div class="line">   String xaCmd = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">boolean</span> conAutoComit = <span class="keyword">this</span>.autocommit;</div><div class="line">   String conSchema = <span class="keyword">this</span>.schema;</div><div class="line">   <span class="comment">// never executed modify sql,so auto commit</span></div><div class="line">   <span class="keyword">boolean</span> expectAutocommit = !modifiedSQLExecuted || isFromSlaveDB() || clientAutoCommit;</div><div class="line">   <span class="keyword">if</span> (expectAutocommit == <span class="keyword">false</span> &amp;&amp; xaTxID != <span class="keyword">null</span> &amp;&amp; xaStatus == TxState.TX_INITIALIZE_STATE) &#123; <span class="comment">// 😈😈😈</span></div><div class="line">       xaCmd = <span class="string">"XA START "</span> + xaTxID + <span class="string">';'</span>;</div><div class="line">       <span class="keyword">this</span>.xaStatus = TxState.TX_STARTED_STATE;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略代码</span></div><div class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="comment">// .... 省略代码</span></div><div class="line">   <span class="keyword">if</span> (xaCmd != <span class="keyword">null</span>) &#123;</div><div class="line">       sb.append(xaCmd);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// and our query sql to multi command at last</span></div><div class="line">   sb.append(rrn.getStatement() + <span class="string">";"</span>);</div><div class="line">   <span class="comment">// syn and execute others</span></div><div class="line">   <span class="keyword">this</span>.sendQueryCmd(sb.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>举个 变量<code>sb</code> 的例子：</p>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SET</span> <span class="keyword">names</span> utf8;<span class="keyword">SET</span> autocommit=<span class="number">0</span>;XA <span class="keyword">START</span> <span class="string">'1f2da7353e8846e5833b8d8dd041cfb1'</span>,<span class="string">'db2'</span>;<span class="keyword">insert</span> <span class="keyword">into</span> t_user(<span class="keyword">id</span>, username, <span class="keyword">password</span>) <span class="keyword">VALUES</span> (<span class="number">3400</span>, <span class="string">'b7c5ec1f-11cc-4599-851c-06ad617fec42'</span>, <span class="string">'d2694679-f6a2-4623-a339-48d4a868be90'</span>);</div></pre></td></tr></table></figure></p>
<h2>3.4 MySQL 接收 COMMIT</h2>
<h3>3.4.1 单节点事务 or 多节点事务</h3>
<p><code>COMMIT</code> 执行时，MyCAT 会判断 XA 事务里，涉及到的数据库节点数量。</p>
<ul>
<li>如果节点数量为 1，单节点事务，使用 <code>CommitNodeHandler</code> 处理。</li>
<li>如果节点数量 &gt; 1，多节点事务，使用 <code>MultiNodeCoordinator</code> 处理。</li>
</ul>
<p><code>CommitNodeHandler</code> 相比 <code>MultiNodeCoordinator</code> 来说，只有一个数据节点，不需要进行多节点协调，逻辑会相对简单，有兴趣的同学可以另外看。我们主要分析 <code>MultiNodeCoordinator</code>。</p>
<h3>3.4.2 协调日志</h3>
<p><strong>协调日志</strong>，记录协调过程中各数据节点 XA 事务状态，处理<strong>MyCAT异常奔溃</strong>或者<strong>数据节点部分XA COMMIT，另外部分 XA PREPARE</strong>下的状态恢复。</p>
<p><strong>XA 事务共有种</strong>：</p>
<ol>
<li>TX_INITIALIZE_STATE ：事务初始化</li>
<li>TX_STARTED_STATE ：事务开始完成</li>
<li>TX_PREPARED_STATE ：事务准备完成</li>
<li>TX_COMMITED_STATE ：事务提交完成</li>
<li>TX_ROLLBACKED_STATE ：事务回滚完成</li>
</ol>
<p><strong>状态变更流</strong> ：TX_INITIALIZE_STATE =&gt; TX_STARTED_STATE =&gt; TX_PREPARED_STATE =&gt; TX_COMMITED_STATE / TX_ROLLBACKED_STATE 。</p>
<p><strong>协调日志包含两个部分</strong>：</p>
<ol>
<li>CoordinatorLogEntry ：协调者日志</li>
<li>ParticipantLogEntry ：参与者日志。<strong>此处，数据节点扮演参与者的角色。下文中，可能会出现参与者与数据节点混用的情况，望见谅。</strong></li>
</ol>
<p><em>一次 XA 事务，对应一条 <code>CoordinatorLogEntry</code>。一条<code>CoordinatorLogEntry</code> 包含 N条<code>ParticipantLogEntry</code></em>。 核心代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CoordinatorLogEntry ：协调者日志</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLogEntry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务编号</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参与者日志数组</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ParticipantLogEntry[] participants;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ParticipantLogEntry ：参与者日志</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticipantLogEntry</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务编号</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String coordinatorId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据库 uri</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String uri;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 过期描述</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">long</span> expires;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * XA 事务状态</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> txState;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参与者名字</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> String resourceName;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>MyCAT 记录协调日志以 JSON格式 到文件</strong>。<strong>每行</strong>包含一条<code>CoordinatorLogEntry</code>。举个例子：</p>
<p><figure class="highlight json"><table><tr><td class="code"><pre><div class="line">&#123;<span class="attr">"id"</span>:<span class="string">"'e827b3fe666c4d968961350d19adda31'"</span>,<span class="attr">"participants"</span>:[&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db3"</span>&#125;,&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db1"</span>&#125;]&#125;</div><div class="line">&#123;<span class="attr">"id"</span>:<span class="string">"'f00b61fa17cb4ec5b8264a6d82f847d0'"</span>,<span class="attr">"participants"</span>:[&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db2"</span>&#125;,&#123;<span class="attr">"uri"</span>:<span class="string">"127.0.0.1"</span>,<span class="attr">"state"</span>:<span class="string">"3"</span>,<span class="attr">"expires"</span>:<span class="number">0</span>,<span class="attr">"resourceName"</span>:<span class="string">"db1"</span>&#125;]&#125;</div></pre></td></tr></table></figure></p>
<p>实现类为：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// XA 协调者日志 存储接口：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/Repository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Repository</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// XA 协调者日志 文件存储：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/impl/FileSystemRepository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// XA 协调者日志 文件存储：https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/xa/recovery/impl/InMemoryRepository.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>目前日志文件写入的方式性能较差，这里我们不做分析，在【4. MyCAT 实现缺陷】里一起讲。</p>
<h3>3.4.3 MultiNodeCoordinator</h3>
<p>敲敲敲，这里是本文的重点之一噢。😈</p>
<p><strong>第一阶段：发起 PREPARE。</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeBatchNodeCmd</span><span class="params">(SQLCtrlCommand cmdHandler)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.cmdHandler = cmdHandler;</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> initCount = session.getTargetCount();</div><div class="line">   runningCount.set(initCount);</div><div class="line">   nodeCount = initCount;</div><div class="line">   failed.set(<span class="keyword">false</span>);</div><div class="line">   faileCount.set(<span class="number">0</span>);</div><div class="line">   <span class="comment">//recovery nodes log</span></div><div class="line">   ParticipantLogEntry[] participantLogEntry = <span class="keyword">new</span> ParticipantLogEntry[initCount];</div><div class="line">   <span class="comment">// 执行</span></div><div class="line">   <span class="keyword">int</span> started = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (RouteResultsetNode rrn : session.getTargetKeys()) &#123;</div><div class="line">       <span class="keyword">if</span> (rrn == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">final</span> BackendConnection conn = session.getTarget(rrn);</div><div class="line">       <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</div><div class="line">           conn.setResponseHandler(<span class="keyword">this</span>);</div><div class="line">           <span class="comment">//process the XA_END XA_PREPARE Command</span></div><div class="line">           MySQLConnection mysqlCon = (MySQLConnection) conn;</div><div class="line">           String xaTxId = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">               xaTxId = session.getXaTXID() + <span class="string">",'"</span> + mysqlCon.getSchema() + <span class="string">"'"</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (mysqlCon.getXaStatus() == TxState.TX_STARTED_STATE) &#123; <span class="comment">// XA 事务</span></div><div class="line">               <span class="comment">//recovery Log</span></div><div class="line">               participantLogEntry[started] = <span class="keyword">new</span> ParticipantLogEntry(xaTxId, conn.getHost(), <span class="number">0</span>, conn.getSchema(), ((MySQLConnection) conn).getXaStatus());</div><div class="line">               String[] cmds = <span class="keyword">new</span> String[]&#123;<span class="string">"XA END "</span> + xaTxId, <span class="comment">// XA END 命令</span></div><div class="line">                       <span class="string">"XA PREPARE "</span> + xaTxId&#125;; <span class="comment">// XA PREPARE 命令</span></div><div class="line">               mysqlCon.execBatchCmd(cmds);</div><div class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非 XA 事务</span></div><div class="line">               <span class="comment">// recovery Log</span></div><div class="line">               participantLogEntry[started] = <span class="keyword">new</span> ParticipantLogEntry(xaTxId, conn.getHost(), <span class="number">0</span>, conn.getSchema(), ((MySQLConnection) conn).getXaStatus());</div><div class="line">               cmdHandler.sendCommand(session, conn);</div><div class="line">           &#125;</div><div class="line">           ++started;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// xa recovery log</span></div><div class="line">   <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">       CoordinatorLogEntry coordinatorLogEntry = <span class="keyword">new</span> CoordinatorLogEntry(session.getXaTXID(), <span class="keyword">false</span>, participantLogEntry);</div><div class="line">       inMemoryRepository.put(session.getXaTXID(), coordinatorLogEntry);</div><div class="line">       fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (started &lt; nodeCount) &#123; <span class="comment">// TODO 疑问：如何触发</span></div><div class="line">       runningCount.set(started);</div><div class="line">       LOGGER.warn(<span class="string">"some connection failed to execute "</span> + (nodeCount - started));</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * assumption: only caused by front-end connection close. &lt;br/&gt;</div><div class="line">        * Otherwise, packet must be returned to front-end</div><div class="line">        */</div><div class="line">       failed.set(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>向各数据节点发送 <code>XA END</code> + <code>XA PREPARE</code> 指令。举个 变量<code>cmds</code> 例子：</li>
</ul>
<p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">XA <span class="keyword">END</span> <span class="string">'4cbb18214d0b47adbdb0658598666677'</span>,<span class="string">'db3'</span>;XA <span class="keyword">PREPARE</span> <span class="string">'4cbb18214d0b47adbdb0658598666677'</span>,<span class="string">'db3'</span>;</div></pre></td></tr></table></figure></p>
<ul>
<li>记录协调日志。每条参与者日志状态为 <code>TxState.TX_STARTED_STATE</code>。</li>
</ul>
<hr>
<p><strong>第二阶段：发起 COMMIT。</strong></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">okResponse</span><span class="params">(<span class="keyword">byte</span>[] ok, BackendConnection conn)</span> </span>&#123;</div><div class="line">   <span class="comment">// process the XA Transatcion 2pc commit</span></div><div class="line">   <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> MySQLConnection) &#123;</div><div class="line">       MySQLConnection mysqlCon = (MySQLConnection) conn;</div><div class="line">       <span class="keyword">switch</span> (mysqlCon.getXaStatus()) &#123;</div><div class="line">           <span class="keyword">case</span> TxState.TX_STARTED_STATE:</div><div class="line">               <span class="comment">//if there have many SQL execute wait the okResponse,will come to here one by one</span></div><div class="line">               <span class="comment">//should be wait all nodes ready ,then send xa commit to all nodes.</span></div><div class="line">               <span class="keyword">if</span> (mysqlCon.batchCmdFinished()) &#123;</div><div class="line">                   String xaTxId = session.getXaTXID();</div><div class="line">                   String cmd = <span class="string">"XA COMMIT "</span> + xaTxId + <span class="string">",'"</span> + mysqlCon.getSchema() + <span class="string">"'"</span>;</div><div class="line">                   <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class="line">                       LOGGER.debug(<span class="string">"Start execute the cmd :"</span> + cmd + <span class="string">",current host:"</span> + mysqlCon.getHost() + <span class="string">":"</span> + mysqlCon.getPort());</div><div class="line">                   &#125;</div><div class="line">                   <span class="comment">// recovery log</span></div><div class="line">                   CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);</div><div class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntry.participants.length; i++) &#123;</div><div class="line">                       LOGGER.debug(<span class="string">"[In Memory CoordinatorLogEntry]"</span> + coordinatorLogEntry.participants[i]);</div><div class="line">                       <span class="keyword">if</span> (coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())) &#123;</div><div class="line">                           coordinatorLogEntry.participants[i].txState = TxState.TX_PREPARED_STATE;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">                   inMemoryRepository.put(xaTxId, coordinatorLogEntry);</div><div class="line">                   fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">                   <span class="comment">// send commit</span></div><div class="line">                   mysqlCon.setXaStatus(TxState.TX_PREPARED_STATE);</div><div class="line">                   mysqlCon.execCmd(cmd);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           <span class="keyword">case</span> TxState.TX_PREPARED_STATE: &#123;</div><div class="line">               <span class="comment">// recovery log</span></div><div class="line">               String xaTxId = session.getXaTXID();</div><div class="line">               CoordinatorLogEntry coordinatorLogEntry = inMemoryRepository.get(xaTxId);</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntry.participants.length; i++) &#123;</div><div class="line">                   <span class="keyword">if</span> (coordinatorLogEntry.participants[i].resourceName.equals(conn.getSchema())) &#123;</div><div class="line">                       coordinatorLogEntry.participants[i].txState = TxState.TX_COMMITED_STATE;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               inMemoryRepository.put(xaTxId, coordinatorLogEntry);</div><div class="line">               fileRepository.writeCheckpoint(inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">               <span class="comment">// XA reset status now</span></div><div class="line">               mysqlCon.setXaStatus(TxState.TX_INITIALIZE_STATE);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 释放连接</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cmdHandler.relaseConOnOK()) &#123;</div><div class="line">       session.releaseConnection(conn);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       session.releaseConnectionIfSafe(conn, LOGGER.isDebugEnabled(), <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 是否所有节点都完成commit，如果是，则返回Client 成功</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.finished()) &#123;</div><div class="line">       cmdHandler.okResponse(session, ok);</div><div class="line">       <span class="keyword">if</span> (cmdHandler.isAutoClearSessionCons()) &#123;</div><div class="line">           session.clearResources(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">/* 1.  事务提交后,xa 事务结束   */</span></div><div class="line">       <span class="keyword">if</span> (session.getXaTXID() != <span class="keyword">null</span>) &#123;</div><div class="line">           session.setXATXEnabled(<span class="keyword">false</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">/* 2. preAcStates 为true,事务结束后,需要设置为true。preAcStates 为ac上一个状态    */</span></div><div class="line">       <span class="keyword">if</span> (session.getSource().isPreAcStates()) &#123;</div><div class="line">           session.getSource().setAutocommit(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>mysqlCon.batchCmdFinished()</code> 每个数据节点，第一次返回的是 <code>XA END</code> 成功，第二次返回的是 <code>XA PREPARE</code>。在 <code>XA PREPARE</code> 成功后，记录该数据节点的<strong>参与者日志</strong>状态为 <code>TxState.TX_PREPARED_STATE</code>。之后，向该数据节点发起 <code>XA COMMIT</code> 命令。</li>
<li><code>XA COMMIT</code> 返回成功后，记录该数据节点的<strong>事务参与者日志</strong>状态为 <code>TxState.TX_COMMITED_STATE</code>。</li>
<li>当所有数据节点（参与者）都执行完成 <code>XA COMMIT</code> 返回，即 <code>this.finished() == true</code>，返回 MySQL Client XA 事务提交成功。</li>
</ul>
<p>[x] <code>XA PREPARE</code> 和 <code>XA COMMIT</code>，数据节点可能返回失败，目前暂时没模拟出来，对应方法为 <code>#errorResponse(....)</code>。</p>
<h2>3.5 MyCAT 启动回滚 XA事务</h2>
<p>MyCAT 启动时，会<strong>回滚处于TxState.TX_PREPARED_STATE</strong>的 <code>ParticipantLogEntry</code> 对应的数据节点的 XA 事务。代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MycatServer.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performXARecoveryLog</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// fetch the recovery log</span></div><div class="line">   CoordinatorLogEntry[] coordinatorLogEntries = getCoordinatorLogEntries();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntries.length; i++) &#123;</div><div class="line">       CoordinatorLogEntry coordinatorLogEntry = coordinatorLogEntries[i];</div><div class="line">       <span class="keyword">boolean</span> needRollback = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coordinatorLogEntry.participants.length; j++) &#123;</div><div class="line">           ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];</div><div class="line">           <span class="keyword">if</span> (participantLogEntry.txState == TxState.TX_PREPARED_STATE) &#123;</div><div class="line">               needRollback = <span class="keyword">true</span>;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (needRollback) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coordinatorLogEntry.participants.length; j++) &#123;</div><div class="line">               ParticipantLogEntry participantLogEntry = coordinatorLogEntry.participants[j];</div><div class="line">               <span class="comment">//XA rollback</span></div><div class="line">               String xacmd = <span class="string">"XA ROLLBACK "</span> + coordinatorLogEntry.id + <span class="string">';'</span>;</div><div class="line">               OneRawSQLQueryResultHandler resultHandler = <span class="keyword">new</span> OneRawSQLQueryResultHandler(<span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> XARollbackCallback());</div><div class="line">               outloop:</div><div class="line">               <span class="keyword">for</span> (SchemaConfig schema : MycatServer.getInstance().getConfig().getSchemas().values()) &#123;</div><div class="line">                   <span class="keyword">for</span> (TableConfig table : schema.getTables().values()) &#123;</div><div class="line">                       <span class="keyword">for</span> (String dataNode : table.getDataNodes()) &#123;</div><div class="line">                           PhysicalDBNode dn = MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);</div><div class="line">                           <span class="keyword">if</span> (dn.getDbPool().getSource().getConfig().getIp().equals(participantLogEntry.uri)</div><div class="line">                                   &amp;&amp; dn.getDatabase().equals(participantLogEntry.resourceName)) &#123;</div><div class="line">                               <span class="comment">//XA STATE ROLLBACK</span></div><div class="line">                               participantLogEntry.txState = TxState.TX_ROLLBACKED_STATE;</div><div class="line">                               SQLJob sqlJob = <span class="keyword">new</span> SQLJob(xacmd, dn.getDatabase(), resultHandler, dn.getDbPool().getSource());</div><div class="line">                               sqlJob.run();</div><div class="line">                               <span class="keyword">break</span> outloop;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// init into in memory cached</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coordinatorLogEntries.length; i++) &#123;</div><div class="line">  MultiNodeCoordinator.inMemoryRepository.put(coordinatorLogEntries[i].id, coordinatorLogEntries[i]);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// discard the recovery log</span></div><div class="line">    MultiNodeCoordinator.fileRepository.writeCheckpoint(MultiNodeCoordinator.inMemoryRepository.getAllCoordinatorLogEntries());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1>4. MyCAT 实现缺陷</h1>
<p>MyCAT 1.6.5 版本实现弱XA事务，相对来说，笔者认为距离实际生产使用存在一些差距。下面罗列可能存在的缺陷，如有错误，麻烦指出。🙂希望 MyCAT 在分布式事务的实现上，能够越来越给力。</p>
<h2>4.1 协调日志写入性能</h2>
<p>1、<code>CoordinatorLogEntry</code>、<code>ParticipantLogEntry</code> 在每次写入文件时，是将内存中所有的日志<strong>全部重新</strong>写入，导致写入性能随着 XA 事务次数的增加，性能会越来越糟糕，导致 XA 事务整体性能会非常差。另外，该方法是<strong>同步</strong>的，也加大了写入的延迟。</p>
<p>建议：先获得可写入文件的 OFFSET，写入协调日志到文件，内存维护好 XA事务编号 与 OFFSET 的映射关系，从而实现<strong>顺序写入</strong> + <strong>并行写入</strong>。</p>
<p>2、内存里维护了所有的协调日志，占用内存会越来越大，并且无释放机制。即使重启，协调日志也会重新加载到内存。</p>
<p>建议：已完全回滚或者提交的协调日志不放入内存。另外有文件存储好 XA事务编号 与 OFFSET 的映射关系。</p>
<p>3、协调日志只写入单个文件。</p>
<p>建议：分拆协调日志文件。</p>
<p>PS：有兴趣的同学可以看下 <code>RocketMQ</code> 对 <code>CommitLog</code> 的存储，性能上很赞！</p>
<h2>4.2 数据节点未全部 PREPARE 就进行 COMMIT</h2>
<p>XA 事务定义，需要等待所有参与者<strong>全部</strong> <code>XA PREPARE</code> 成功完成后发起 <code>XA COMMIT</code>。目前 MyCAT 是某个数据节点 <code>XA PREPARE</code> 完成后<strong>立即</strong>进行 <code>XA COMMIT</code>。比如说：第一个数据节点提交了 <code>XA END;XA PREPARE</code> 时，第二个数据节在进行 <code>XA END;XA PREAPRE;</code> 前挂了，第一个节点依然会 <code>XA COMMIT</code> 成功。</p>
<p>建议：按照严格的 XA 事务定义。</p>
<h2>4.3 MyCAT 启动回滚 PREPARE 的 XA事务</h2>
<p>1、MyCAT 启动时，回滚所有的 <code>PREPARE</code> 的 XA 事务，可能某个 XA 事务，部分 <code>COMMIT</code>，部分 <code>PREPARE</code>。此时直接回滚，会导致数据不一致。</p>
<p>建议：当判断到某个 XA 事务存在 <code>PREPARE</code> 的参与者，<strong>同时判断该 XA 事务里其他参与者的事务状态</strong>以及<strong>数据节点里 XA 事务状态</strong>，比如参与者为 <code>MySQL</code>时，可以使用 <code>XA RECOVER</code> 查询处于 <code>PREPARE</code> 所有的 XA 事务。</p>
<p>2、回滚 <code>PREPARE</code> 是异步进行的，在未进行完成时已经设置文件里回滚成功。如果异步过程中失败，会导致 XA 事务状态不一致。</p>
<p>建议：回调成功后，更新该 XA 事务状态。</p>
<h2>4.4 单节点事务未记录协调日志</h2>
<p>该情况较为极端。发起 <code>XA PREPARE</code>完后，MyCAT 挂了。重启后，该 XA 事务在 MyCAT 里就“消失“了，参与者的该 XA 事务一直处于 <code>PREPARE</code> 状态。从理论上来说，需要回滚该 XA 事务。</p>
<p>建议：记录协调日志。</p>
<h2>4.5 XA COMMIT 部分节点挂了重新恢复后，未进一步处理</h2>
<p>当一部分节点 <code>XA COMMIT</code> 完成，另外一部分此时挂了。在管理员重启挂掉的节点，其对应的 XA 事务未进一步处理，导致数据不一致。</p>
<p>建议：😈木有建议。也很好奇，如果是这样的情况，如何处理较为合适。如有大大知道，烦请告知下。</p>
<h1>5. 彩蛋</h1>
<p>例行“彩蛋”？</p>
<ul>
<li><a href="http://blog.csdn.net/d6619309/article/details/52330334" rel="external nofollow noopener noreferrer" target="_blank">《Mycat源码篇 : MyCat事务管理机制分析》</a> 来自 MyCAT Committer 的文章</li>
<li><a href="http://mysql.taobao.org/monthly/2015/04/05/" rel="external nofollow noopener noreferrer" target="_blank">《MySQL · 捉虫动态 · 连接断开导致XA事务丢失》</a></li>
<li><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" rel="external nofollow noopener noreferrer" target="_blank">《分布式系统事务一致性解决方案》</a></li>
<li><a href="http://blog.csdn.net/fly2749/article/details/44998203" rel="external nofollow noopener noreferrer" target="_blank">《MySQL数据库分布式事务XA优缺点与改进方案》</a></li>
<li><a href="http://www.hollischuang.com/archives/1580" rel="external nofollow noopener noreferrer" target="_blank">《深入理解分布式系统的2PC和3PC》</a></li>
<li><a href="https://github.com/YunaiV/yunaiv.github.io/blob/master/source/_drafts/MyCAT/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.xmind" rel="external nofollow noopener noreferrer" target="_blank">【分布式事务.xmind】</a> 笔者拙作</li>
<li><a href="http://www.yunai.me/RocketMQ/message-transaction/?self">《RocketMQ 源码分析 —— 事务消息》</a> 笔者拙作</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注**微信公众号：【芋艿的后端小屋】**有福利：&lt;/p&gt;
&lt;ol
    
    </summary>
    
      <category term="MyCAT" scheme="http://www.yunai.me/categories/MyCAT/"/>
    
    
  </entry>
  
</feed>
