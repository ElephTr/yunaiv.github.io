<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yunai.me/"/>
  <updated>2017-08-29T04:52:39.000Z</updated>
  <id>http://www.yunai.me/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>闲聊如何阅读源码（音频）</title>
    <link href="http://www.yunai.me/Architecture/how-to-read-source-code/"/>
    <id>http://www.yunai.me/Architecture/how-to-read-source-code/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2017-08-29T04:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-从零开始"><a href="#0-从零开始" class="headerlink" title="0. 从零开始"></a>0. 从零开始</h1><p>视频：</p>
<iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=p0543tzm648&tiny=0&auto=0" allowfullscreen></iframe>

<p>请关注笔者的公众号：芋道源码</p>
<ul>
<li>专注源码解析三十年！</li>
<li>专注源码解析三十年！</li>
<li>专注源码解析三十年！</li>
<li><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></li>
</ul>
<h1 id="1-调试"><a href="#1-调试" class="headerlink" title="1. 调试"></a>1. 调试</h1><p>通过 IDE 工具<strong>调试</strong>的方式阅读源码。</p>
<h2 id="1-1-Elastic-Job"><a href="#1-1-Elastic-Job" class="headerlink" title="1.1 Elastic-Job"></a>1.1 Elastic-Job</h2><ul>
<li>GitHub地址：<a href="https://github.com/dangdangdotcom/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dangdangdotcom/elastic-job</a><ul>
<li>开源不易，请点 Star 支持。</li>
<li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/elastic-job</a></li>
</ul>
</li>
<li>为什么阅读 Elastic-Job 源码？：<a href="http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/">http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/</a></li>
<li>调试方式：<code>com.dangdang.ddframe.job.example.JavaMain</code> 直接 DEBUG 即可。</li>
</ul>
<h2 id="1-2-Sharding-JDBC"><a href="#1-2-Sharding-JDBC" class="headerlink" title="1.2 Sharding-JDBC"></a>1.2 Sharding-JDBC</h2><ul>
<li>GitHub地址：<a href="https://github.com/dangdangdotcom/sharding-jdbc" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dangdangdotcom/sharding-jdbc</a><ul>
<li>开源不易，请点 Star 支持。</li>
<li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/sharding-jdbc" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/sharding-jdbc</a><ul>
<li>基于 Sharding-JDBC V1.5.1 版本，建议阅读最新版本代码，我的可以作为注释补充。 </li>
</ul>
</li>
</ul>
</li>
<li>为什么阅读 Sharding-JDBC 源码？：<a href="http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/">http://www.yunai.me/Sharding-JDBC/why-read-Sharding-JDBC-source-code/</a></li>
<li>调试方式：<code>com.dangdang.ddframe.rdb.sharding.example.jdbc.Main</code> 配置数据源后可以 DEBUG。</li>
<li>拆解图：<img src="http://www.yunai.me/images/Architecture/2017_12_02/01.png" alt=""></li>
</ul>
<h2 id="1-3-MyCAT"><a href="#1-3-MyCAT" class="headerlink" title="1.3 MyCAT"></a>1.3 MyCAT</h2><ul>
<li>GitHub地址：<a href="https://github.com/MyCATApache/Mycat-Server" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/MyCATApache/Mycat-Server</a><ul>
<li>开源不易，请点 Star 支持。</li>
<li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/Mycat-Server" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/Mycat-Server</a></li>
</ul>
</li>
<li>为什么阅读 MyCAT 源码？：<a href="http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/">http://www.yunai.me/MyCAT/why-read-MyCAT-source-code/</a></li>
<li>调试方式：<a href="http://www.yunai.me/MyCAT/build-debugging-environment/">http://www.yunai.me/MyCAT/build-debugging-environment/</a></li>
</ul>
<h2 id="1-4-RocketMQ"><a href="#1-4-RocketMQ" class="headerlink" title="1.4 RocketMQ"></a>1.4 RocketMQ</h2><ul>
<li>GitHub地址：<a href="https://github.com/apache/incubator-rocketmq" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-rocketmq</a><ul>
<li>开源不易，请点 Star 支持。</li>
<li>个人 Fork，增加部分中文注释 GitHub地址：<a href="https://github.com/YunaiV/incubator-rocketmq" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/incubator-rocketmq</a></li>
</ul>
</li>
<li>为什么阅读 RocketMQ 源码？：<a href="http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/">http://www.yunai.me/RocketMQ/why-read-RocketMQ-source-code/</a></li>
<li>调试方式：有点想不起来了。以后补充哈。</li>
</ul>
<h2 id="1-5-补充"><a href="#1-5-补充" class="headerlink" title="1.5 补充"></a>1.5 补充</h2><p>如果源码比较多，你不太清楚按照什么样的功能顺序调试下去，可以参考我写的博客。这个不是广告。确实有朋友是对照着博客顺序调试的。</p>
<h1 id="2-UML图"><a href="#2-UML图" class="headerlink" title="2. UML图"></a>2. UML图</h1><p>推荐使用 Astah 社区版。对的，不要考虑破解不破解的。社区版，够！</p>
<p>另外，请不要纠结用什么 UML 工具牛逼！重点先迈出调试源码那一步，其他的，慢慢优化。</p>
<p>推荐画两种图：</p>
<ul>
<li><p>类图：对整体、或者某个模块，有系统性的认识。</p>
<p>  <img src="http://www.yunai.me/images/Architecture/2017_12_02/02.png" alt=""></p>
</li>
<li><p>顺序图：对流程的调用顺序有整体的认识，避免调试，越调试越晕。</p>
<p>  <img src="http://www.yunai.me/images/Architecture/2017_12_02/03.png" alt=""></p>
</li>
</ul>
<p>如果你不会画 UML 图，直接直接 Google，不要去找什么 UML 的书，先干起来！</p>
<p>恩，笔者不排除看 UML 书，因为，我也看过几本，收获不小，哈哈哈哈。</p>
<h1 id="3-输出"><a href="#3-输出" class="headerlink" title="3. 输出"></a>3. 输出</h1><p>阅读源码，不尝试输出，就是在耍流氓。</p>
<p>推荐三种输出方式：</p>
<ol>
<li>写博客。</li>
<li>团队分享。</li>
<li>造小轮。</li>
</ol>
<p>刚开始推荐写博客。对的，不太建议只写自己看得懂的笔记。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-从零开始&quot;&gt;&lt;a href=&quot;#0-从零开始&quot; class=&quot;headerlink&quot; title=&quot;0. 从零开始&quot;&gt;&lt;/a&gt;0. 从零开始&lt;/h1&gt;&lt;p&gt;视频：&lt;/p&gt;
&lt;iframe frameborder=&quot;0&quot; width=&quot;640&quot; height=&quot;
    
    </summary>
    
      <category term="技术杂文" scheme="http://www.yunai.me/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业监控服务</title>
    <link href="http://www.yunai.me/Elastic-Job/job-monitor/"/>
    <id>http://www.yunai.me/Elastic-Job/job-monitor/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2017-08-28T11:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. MonitorService</a></li>
<li><a href="#">3. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业监控服务</strong>。内容对应<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/02-guide/dump/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— DUMP作业运行信息》</a>。</p>
<blockquote>
<p>使用Elastic-Job-Lite过程中可能会碰到一些分布式问题，导致作业运行不稳定。<br>由于无法在生产环境调试，通过dump命令可以把作业内部相关信息dump出来，方便开发者debug分析； 另外为了不泄露隐私，已将相关信息中的ip地址以ip1, ip2…的形式过滤，可以在互联网上公开传输环境信息，便于进一步完善Elastic-Job。</p>
</blockquote>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_12_01/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_12_01/01.png" alt=""></p>
<ul>
<li>在 Elastic-Job-lite 里，作业监控服务( MonitorService ) 实现了<strong>DUMP作业运行信息</strong>功能。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-MonitorService"><a href="#2-MonitorService" class="headerlink" title="2. MonitorService"></a>2. MonitorService</h1><p>MonitorService，作业监控服务。</p>
<p><strong>初始化 MonitorService 方法实现如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MonitorService.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> port = configService.load(<span class="keyword">true</span>).getMonitorPort();</div><div class="line">   <span class="keyword">if</span> (port &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       log.info(<span class="string">"Elastic job: Monitor service is running, the port is '&#123;&#125;'"</span>, port);</div><div class="line">       openSocketForMonitor(port);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">       log.error(<span class="string">"Elastic job: Monitor service listen failure, error is: "</span>, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openSocketForMonitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   serverSocket = <span class="keyword">new</span> ServerSocket(port);</div><div class="line">   <span class="keyword">new</span> Thread() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">while</span> (!closed) &#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   process(serverSocket.accept());</div><div class="line">               &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">                   log.error(<span class="string">"Elastic job: Monitor service open socket for monitor failure, error is: "</span>, ex);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在作业配置的监控服务端口属性( <code>LiteJobConfiguration.monitorPort</code> )启动 <strong>ServerSocket</strong>。一个作业对应一个作业监控端口，所以配置时，请不要重复端口噢。</li>
</ul>
<p><strong>处理 dump命令 方法如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MonitorService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">           BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line">           BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream()));</div><div class="line">           Socket autoCloseSocket = socket) &#123;</div><div class="line">       <span class="comment">// 读取命令</span></div><div class="line">       String cmdLine = reader.readLine();</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != cmdLine &amp;&amp; DUMP_COMMAND.equalsIgnoreCase(cmdLine)) &#123; <span class="comment">// DUMP</span></div><div class="line">           List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">           dumpDirectly(<span class="string">"/"</span> + jobName, result);</div><div class="line">           outputMessage(writer, Joiner.on(<span class="string">"\n"</span>).join(SensitiveInfoUtils.filterSensitiveIps(result)) + <span class="string">"\n"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#process()</code> 方法，目前只支持 <code>DUMP</code> 命令。如果你有自定义命令的需要，可以拓展该方法。</li>
<li><p>调用 <code>#dumpDirectly()</code> 方法，输出当前作业名对应的相关调试信息。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpDirectly</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> List&lt;String&gt; result)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : regCenter.getChildrenKeys(path)) &#123;</div><div class="line">       String zkPath = path + <span class="string">"/"</span> + each;</div><div class="line">       String zkValue = regCenter.get(zkPath);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == zkValue) &#123;</div><div class="line">           zkValue = <span class="string">""</span>;</div><div class="line">       &#125;</div><div class="line">       TreeCache treeCache = (TreeCache) regCenter.getRawCache(<span class="string">"/"</span> + jobName);</div><div class="line">       ChildData treeCacheData = treeCache.getCurrentData(zkPath);</div><div class="line">       String treeCachePath =  <span class="keyword">null</span> == treeCacheData ? <span class="string">""</span> : treeCacheData.getPath();</div><div class="line">       String treeCacheValue = <span class="keyword">null</span> == treeCacheData ? <span class="string">""</span> : <span class="keyword">new</span> String(treeCacheData.getData());</div><div class="line">       <span class="comment">// 判断 TreeCache缓存 和 注册中心 数据一致</span></div><div class="line">       <span class="keyword">if</span> (zkValue.equals(treeCacheValue) &amp;&amp; zkPath.equals(treeCachePath)) &#123;</div><div class="line">           result.add(Joiner.on(<span class="string">" | "</span>).join(zkPath, zkValue));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.add(Joiner.on(<span class="string">" | "</span>).join(zkPath, zkValue, treeCachePath, treeCacheValue));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 递归</span></div><div class="line">       dumpDirectly(zkPath, result);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当作业本地 <strong>TreeCache缓存</strong> 和注册中心数据不一致时，DUMP 出 [zkPath, zkValue, treeCachePath, treeCacheValue]。当相同时，只需 DUMP 出 [zkPath, zkValue]，<strong>方便看出本地和注册中心是否存在数据差异。</strong></li>
</ul>
</li>
<li><p>DUMP 信息例子如下：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">Yunai-MacdeMacBook-Pro-2:elastic-job yunai$ <span class="built_in">echo</span> <span class="string">"dump"</span> | nc 127.0.0.1 10024</div><div class="line">/javaSimpleJob/sharding | </div><div class="line">/javaSimpleJob/sharding/2 | </div><div class="line">/javaSimpleJob/sharding/2/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/sharding/1 | </div><div class="line">/javaSimpleJob/sharding/1/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/sharding/0 | </div><div class="line">/javaSimpleJob/sharding/0/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/servers | </div><div class="line">/javaSimpleJob/servers/ip2 | </div><div class="line">/javaSimpleJob/servers/ip198 | </div><div class="line">/javaSimpleJob/leader | </div><div class="line">/javaSimpleJob/leader/sharding | </div><div class="line">/javaSimpleJob/leader/failover | </div><div class="line">/javaSimpleJob/leader/failover/latch | </div><div class="line">/javaSimpleJob/leader/failover/items | </div><div class="line">/javaSimpleJob/leader/election | </div><div class="line">/javaSimpleJob/leader/election/latch | </div><div class="line">/javaSimpleJob/leader/election/instance | ip198@-@5100</div><div class="line">/javaSimpleJob/instances | </div><div class="line">/javaSimpleJob/instances/ip198@-@5100 | </div><div class="line">/javaSimpleJob/config | &#123;<span class="string">"jobName"</span>:<span class="string">"javaSimpleJob"</span>,<span class="string">"jobClass"</span>:<span class="string">"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob"</span>,<span class="string">"jobType"</span>:<span class="string">"SIMPLE"</span>,<span class="string">"cron"</span>:<span class="string">"0 0/2 * * * ?"</span>,<span class="string">"shardingTotalCount"</span>:3,<span class="string">"shardingItemParameters"</span>:<span class="string">"0\u003dBeijing,1\u003dShanghai,2\u003dGuangzhou"</span>,<span class="string">"jobParameter"</span>:<span class="string">""</span>,<span class="string">"failover"</span>:<span class="literal">true</span>,<span class="string">"misfire"</span>:<span class="literal">true</span>,<span class="string">"description"</span>:<span class="string">""</span>,<span class="string">"jobProperties"</span>:&#123;<span class="string">"job_exception_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler"</span>,<span class="string">"executor_service_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"</span>&#125;,<span class="string">"monitorExecution"</span>:<span class="literal">false</span>,<span class="string">"maxTimeDiffSeconds"</span>:-1,<span class="string">"monitorPort"</span>:10024,<span class="string">"jobShardingStrategyClass"</span>:<span class="string">"com.dangdang.ddframe.job.lite.api.strategy.impl.OdevitySortByNameJobShardingStrategy"</span>,<span class="string">"reconcileIntervalMinutes"</span>:10,<span class="string">"disabled"</span>:<span class="literal">false</span>,<span class="string">"overwrite"</span>:<span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：是是是，对对的，我水更啦！😆</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_12_01/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. MonitorService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 自诊断修复</title>
    <link href="http://www.yunai.me/Elastic-Job/reconcile/"/>
    <id>http://www.yunai.me/Elastic-Job/reconcile/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2017-08-28T09:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ReconcileService</a></li>
<li><a href="#">3. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 自诊断修复</strong>。</p>
<blockquote>
<p>在分布式的场景下由于网络、时钟等原因，可能导致 Zookeeper 的数据与真实运行的作业产生不一致，这种不一致通过正向的校验无法完全避免。需要另外启动一个线程定时校验注册中心数据与真实作业状态的一致性，即维持 Elastic-Job 的<strong>最终一致性</strong>。</p>
</blockquote>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_28/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_28/01.png" alt=""></p>
<ul>
<li>在 Elastic-Job-lite 里，调解分布式作业不一致状态服务( ReconcileService ) 实现了<strong>自诊断修复</strong>功能。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-ReconcileService"><a href="#2-ReconcileService" class="headerlink" title="2. ReconcileService"></a>2. ReconcileService</h1><p>ReconcileService，调解分布式作业不一致状态服务。</p>
<p>ReconcileService 继承 Google Guava AbstractScheduledService 抽象类，实现 <code>#scheduler()</code>、<code>#runOneIteration()</code> 方法，达到<strong>周期性</strong>校验注册中心数据与真实作业状态的一致性。</p>
<p><strong><code>#scheduler()</code> 方法实现如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReconcileService.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(<span class="number">0</span>, <span class="number">1</span>, TimeUnit.MINUTES);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每 1 分钟会调用一次 <code>#runOneIteration()</code> 方法进行校验。</li>
<li>Google Guava AbstractScheduledService 相关的知识，有兴趣的同学可以自己 Google 学习哟。</li>
</ul>
<p><strong><code>#runOneIteration()</code> 方法实现如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReconcileService.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   LiteJobConfiguration config = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">int</span> reconcileIntervalMinutes = <span class="keyword">null</span> == config ? -<span class="number">1</span> : config.getReconcileIntervalMinutes();</div><div class="line">   <span class="keyword">if</span> (reconcileIntervalMinutes &gt; <span class="number">0</span> &amp;&amp; (System.currentTimeMillis() - lastReconcileTime &gt;= reconcileIntervalMinutes * <span class="number">60</span> * <span class="number">1000</span>)) &#123; <span class="comment">// 校验是否达到校验周期</span></div><div class="line">       <span class="comment">// 设置最后校验时间</span></div><div class="line">       lastReconcileTime = System.currentTimeMillis();</div><div class="line">       <span class="keyword">if</span> (leaderService.isLeaderUntilBlock() <span class="comment">// 主作业节点才可以执行</span></div><div class="line">               &amp;&amp; !shardingService.isNeedSharding() <span class="comment">// 当前作业不需要重新分片</span></div><div class="line">               &amp;&amp; shardingService.hasShardingInfoInOfflineServers()) &#123; <span class="comment">// 查询是包含有分片节点的不在线服务器</span></div><div class="line">           log.warn(<span class="string">"Elastic Job: job status node has inconsistent value,start reconciling..."</span>);</div><div class="line">           <span class="comment">// 设置需要重新分片的标记</span></div><div class="line">           shardingService.setReshardingFlag();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过作业配置，设置<strong>修复作业服务器不一致状态服务调度间隔时间</strong>属性( <code>LiteJobConfiguration.reconcileIntervalMinutes</code> )。</li>
<li>调用 <code>ShardingService#setReshardingFlag()</code> 方法，设置需要重新分片的标记。这个也是 ReconcileService 最本质的行为，有了这个标记后，作业会重新进行分片，<strong>达到作业节点本地分片数据与 Zookeeper 数据一致</strong>。作业分片逻辑，在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>有详细解析。</li>
<li><p>调解分布式作业不一致状态服务一共有三个条件：</p>
<ul>
<li>调用 <code>LeaderService#isLeaderUntilBlock()</code> 方法，判断当前作业节点是否为主节点。在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》</a>有详细解析。</li>
<li>调用 <code>ShardingService#isNeedSharding()</code> 方法，判断当前作业是否需要重分片。如果需要重新分片，就不要重复设置当前作业需要重新分片的标记。</li>
<li><p>调用 <code>ShardingService#hasShardingInfoInOfflineServers()</code> 方法，查询是否包含有分片节点的不在线服务器。<strong>永久</strong>数据节点 <code>/${JOB_NAME}/sharding/${ITEM_INDEX}/instance</code> 存储分配的作业节点主键( <code>${JOB_INSTANCE_ID}</code> )， <strong>不会</strong>随着作业节点因为各种原因断开后会话超时移除，而<strong>临时</strong>数据节点<code>/${JOB_NAME}/instances/${JOB_INSTANCE_ID}</code> <strong>会</strong>随着作业节点因为各种原因断开后超时会话超时移除。当查询到包含有分片节点的不在线的作业节点，设置需要重新分片的标记后进行重新分片，将其持有的作业分片分配给其它在线的作业节点。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"> <span class="comment">/**</span></div><div class="line"> * 查询是包含有分片节点的不在线服务器.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 是包含有分片节点的不在线服务器</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasShardingInfoInOfflineServers</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;String&gt; onlineInstances = jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT); <span class="comment">// `/$&#123;JOB_NAME&#125;/instances/$&#123;JOB_INSTANCE_ID&#125;`</span></div><div class="line">    <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!onlineInstances.contains(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123; <span class="comment">// `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_INDEX&#125;/instance`</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>芋道君：【动作：一脚踢开旁白君】，这是对前面解析的主节点选举和作业分片的复习！不是水更！<br>旁白君：你承认水…【动作：芋道君又来一记千年杀】</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_28/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ReconcileService&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业监听器</title>
    <link href="http://www.yunai.me/Elastic-Job/job-listener/"/>
    <id>http://www.yunai.me/Elastic-Job/job-listener/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2017-08-28T05:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ElasticJobListener</a></li>
<li><a href="#">3. AbstractDistributeOnceElasticJobListener</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业监听器</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_21/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_21/01.png" alt=""></p>
<ul>
<li>绿色<strong>监听器</strong>接口 ElasticJobListener，每台作业节点均执行。</li>
<li>粉色<strong>监听器</strong>接口 AbstractDistributeOnceElasticJobListener，分布式场景中仅单一节点执行。</li>
<li>蓝色类在 <code>com.dangdang.ddframe.job.lite.internal.guarantee</code> 里，保证分布式任务全部开始和结束状态。 AbstractDistributeOnceElasticJobListener 通过 <code>guarantee</code> 功能，实现分布式场景中仅单一节点执行。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-ElasticJobListener"><a href="#2-ElasticJobListener" class="headerlink" title="2. ElasticJobListener"></a>2. ElasticJobListener</h1><p>ElasticJobListener，作业监听器接口，<strong>每台作业节点均执行</strong>。</p>
<blockquote>
<p>若作业处理作业服务器的文件，处理完成后删除文件，可考虑使用每个节点均执行清理任务。此类型任务实现简单，且无需考虑全局分布式任务是否完成，请尽量使用此类型监听器。</p>
</blockquote>
<p>接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ElasticJobListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行前的执行的方法.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行后的执行的方法.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用执行如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// ...省略无关代码</span></div><div class="line">   </div><div class="line">   <span class="comment">// 执行 作业执行前的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ...省略无关代码（执行 普通触发的作业）</span></div><div class="line">   <span class="comment">// ...省略无关代码（执行 被跳过触发的作业）</span></div><div class="line">   <span class="comment">// ...省略无关代码（执行 作业失效转移）</span></div><div class="line">   </div><div class="line">   <span class="comment">// ...执行 作业执行后的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.afterJobExecuted(shardingContexts);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>JobFacade 对作业监听器简单封装进行调用。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>下文提到的 AbstractDistributeOnceElasticJobListener，也是这么调用。</p>
</li>
</ul>
<h1 id="3-AbstractDistributeOnceElasticJobListener"><a href="#3-AbstractDistributeOnceElasticJobListener" class="headerlink" title="3. AbstractDistributeOnceElasticJobListener"></a>3. AbstractDistributeOnceElasticJobListener</h1><p>AbstractDistributeOnceElasticJobListener，在分布式作业中只执行一次的监听器。</p>
<blockquote>
<p>若作业处理数据库数据，处理完成后只需一个节点完成数据清理任务即可。此类型任务处理复杂，需同步分布式环境下作业的状态同步，提供了超时设置来避免作业不同步导致的死锁，请谨慎使用。</p>
</blockquote>
<p><strong>创建</strong> AbstractDistributeOnceElasticJobListener 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDistributeOnceElasticJobListener</span> <span class="keyword">implements</span> <span class="title">ElasticJobListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始超时时间</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startedTimeoutMilliseconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始等待对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startedWait = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 完成超时时间</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> completedTimeoutMilliseconds;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 完成等待对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object completedWait = <span class="keyword">new</span> Object();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 保证分布式任务全部开始和结束状态的服务</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> GuaranteeService guaranteeService;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> TimeService timeService = <span class="keyword">new</span> TimeService();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDistributeOnceElasticJobListener</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startedTimeoutMilliseconds, <span class="keyword">final</span> <span class="keyword">long</span> completedTimeoutMilliseconds)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (startedTimeoutMilliseconds &lt;= <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.startedTimeoutMilliseconds = Long.MAX_VALUE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.startedTimeoutMilliseconds = startedTimeoutMilliseconds;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (completedTimeoutMilliseconds &lt;= <span class="number">0L</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.completedTimeoutMilliseconds = Long.MAX_VALUE; </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.completedTimeoutMilliseconds = completedTimeoutMilliseconds;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>超时参数 <code>startedTimeoutMilliseconds</code>、<code>completedTimeoutMilliseconds</code> 务必传递，避免作业不同步导致的死锁。</li>
</ul>
<p>👇下面，我们来看本文的<strong>重点</strong>：AbstractDistributeOnceElasticJobListener，在分布式作业中只执行一次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="comment">// 注册作业分片项开始运行</span></div><div class="line">   guaranteeService.registerStart(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   <span class="comment">// 判断是否所有的分片项开始运行</span></div><div class="line">   <span class="keyword">if</span> (guaranteeService.isAllStarted()) &#123;</div><div class="line">       <span class="comment">// 执行</span></div><div class="line">       doBeforeJobExecutedAtLastStarted(shardingContexts);</div><div class="line">       <span class="comment">// 清理启动信息</span></div><div class="line">       guaranteeService.clearAllStartedInfo();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待</span></div><div class="line">   <span class="keyword">long</span> before = timeService.getCurrentMillis();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">synchronized</span> (startedWait) &#123;</div><div class="line">           startedWait.wait(startedTimeoutMilliseconds);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.interrupted();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待超时</span></div><div class="line">   <span class="keyword">if</span> (timeService.getCurrentMillis() - before &gt;= startedTimeoutMilliseconds) &#123;</div><div class="line">       <span class="comment">// 清理启动信息</span></div><div class="line">       guaranteeService.clearAllStartedInfo();</div><div class="line">       handleTimeout(startedTimeoutMilliseconds);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>GuaranteeService#registerStart(...)</code> 方法，注册作业分片项开始运行。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GuaranteeService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStart</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(GuaranteeNode.getStartedNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GuaranteeNode.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GuaranteeNode</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"guarantee"</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String STARTED_ROOT = ROOT + <span class="string">"/started"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getStartedNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Joiner.on(<span class="string">"/"</span>).join(STARTED_ROOT, shardingItem);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Zookeeper 数据节点 <code>/${JOB_NAME}/guarantee/started/${ITEM_INDEX}</code> 为<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )。为什么是<strong>永久</strong>节点呢？在 <code>GuaranteeService#isAllStarted()</code> 见分晓。</li>
</ul>
</li>
<li><p>调用 <code>GuaranteeService#isAllStarted()</code> 方法，判断是否所有的分片项开始运行。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 判断是否所有的任务均启动完毕.</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 是否所有的任务均启动完毕</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(GuaranteeNode.STARTED_ROOT)</div><div class="line">           &amp;&amp; configService.load(<span class="keyword">false</span>).getTypeConfig().getCoreConfig().getShardingTotalCount() == jobNodeStorage.getJobNodeChildrenKeys(GuaranteeNode.STARTED_ROOT).size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当 <code>/${JOB_NAME}/guarantee/started/</code> 目录下，所有作业分片项都开始运行，即运行总数等于作业分片总数( <code>JobCoreConfiguration.ShardingTotalCount</code> )，<strong>代表所有的任务均启动完毕</strong>。</li>
<li>等待所有任务启动过程中，不排除有作业节点会挂掉，如果 <code>/${JOB_NAME}/guarantee/started/${ITEM_INDEX}</code> 存储<strong>临时</strong>节点，会导致不能满足所有的分片项开始运行的条件。</li>
<li>等待过程中，如果调整作业分片总数( <code>JobCoreConfiguration.ShardingTotalCount</code> )，会导致异常。</li>
</ul>
</li>
<li><p>当不满足所有的分片项开始运行时，作业节点调用 <code>Object#wait(...)</code>  方法进行等待。该等待怎么结束等待？当满足所有的分片项开始运行的作业节点调用 <code>GuaranteeService#clearAllStartedInfo()</code> 时，StartedNodeRemovedJobListener 会监听到 <code>/${JOB_NAME}/guarantee/started/</code> 被删除，调用 <code>Object#notifyAll(...)</code> 方法进行唤醒全部。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// GuaranteeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 清理所有任务启动信息.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearAllStartedInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.removeJobNodeIfExisted(GuaranteeNode.STARTED_ROOT);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// StartedNodeRemovedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartedNodeRemovedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (Type.NODE_REMOVED == eventType &amp;&amp; guaranteeNode.isStartedRootNode(path)) &#123;</div><div class="line">           <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">               <span class="keyword">if</span> (each <span class="keyword">instanceof</span> AbstractDistributeOnceElasticJobListener) &#123;</div><div class="line">                   ((AbstractDistributeOnceElasticJobListener) each).notifyWaitingTaskStart();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>#doBeforeJobExecutedAtLastStarted(...)</code> 方法，执行最后一个作业执行前的执行的方法，实现该抽象方法，完成自定义逻辑。<code>#doAfterJobExecutedAtLastCompleted(...)</code> 实现的方式一样，就不重复解析了。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractDistributeOnceElasticJobListener.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 分布式环境中最后一个作业执行前的执行的方法.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBeforeJobExecutedAtLastStarted</span><span class="params">(ShardingContexts shardingContexts)</span></span>;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 分布式环境中最后一个作业执行后的执行的方法.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAfterJobExecutedAtLastCompleted</span><span class="params">(ShardingContexts shardingContexts)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>整体流程如下图：<img src="http://www.yunai.me/images/Elastic-Job/2017_11_21/02.png" alt="">    </p>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：哎哟喂，AbstractDistributeOnceElasticJobListener 还不错哟。<br>芋道君：那必须必的。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_21/03.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ElasticJobListener&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业事件追踪</title>
    <link href="http://www.yunai.me/Elastic-Job/job-event-trace/"/>
    <id>http://www.yunai.me/Elastic-Job/job-event-trace/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-08-28T05:02:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业事件总线</a></li>
<li><a href="#">3. 作业事件</a><ul>
<li><a href="#">3.1 作业状态追踪事件</a></li>
<li><a href="#">3.2 作业执行追踪事件</a></li>
<li><a href="#">3.3 作业事件数据库存储</a></li>
<li><a href="#">3.4 作业事件数据库查询</a></li>
</ul>
</li>
<li><a href="#">4. 作业监听器</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业事件追踪</strong>。</p>
<p>Elastic-Job 提供了事件追踪功能，可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job 目前订阅两种事件，基于<strong>关系型数据库</strong>记录事件。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_14/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_14/01.png" alt=""></p>
<ul>
<li>以上类在 <code>com.dangdang.ddframe.job.event</code> 包，不仅为 Elastic-Job-Lite，而且为 Elastic-Job-Cloud 实现了事件追踪功能。</li>
<li>作业<strong>事件</strong>：粉色的类。</li>
<li>作业<strong>事件总线</strong>：黄色的类。</li>
<li>作业<strong>事件监听器</strong>：蓝色的类。 </li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-作业事件总线"><a href="#2-作业事件总线" class="headerlink" title="2. 作业事件总线"></a>2. 作业事件总线</h1><p>JobEventBus，作业事件总线，提供了注册监听器、发布事件两个方法。</p>
<p><strong>创建</strong> JobEventBus 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventBus</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业事件配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventConfiguration jobEventConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程池执行服务对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorServiceObject executorServiceObject;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件总线</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否注册作业监听器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRegistered;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobEventConfig = <span class="keyword">null</span>;</div><div class="line">        executorServiceObject = <span class="keyword">null</span>;</div><div class="line">        eventBus = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventBus</span><span class="params">(<span class="keyword">final</span> JobEventConfiguration jobEventConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobEventConfig = jobEventConfig;</div><div class="line">        executorServiceObject = <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"job-event"</span>, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</div><div class="line">        <span class="comment">// 创建 异步事件总线</span></div><div class="line">        eventBus = <span class="keyword">new</span> AsyncEventBus(executorServiceObject.createExecutorService());</div><div class="line">        <span class="comment">// 注册 事件监听器</span></div><div class="line">        register();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JobEventBus 基于 <a href="https://github.com/google/guava/wiki/EventBusExplained" rel="external nofollow noopener noreferrer" target="_blank">Google Guava EventBus</a>，在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute">《Sharding-JDBC 源码分析 —— SQL 执行》「4.1 EventBus」</a>有详细分享。这里要注意的是 AsyncEventBus( <strong>异步事件总线</strong> )，注册在其上面的监听器是<strong>异步</strong>监听执行，事件发布无需阻塞等待监听器执行完逻辑，所以对性能不存在影响。</li>
<li><p>使用 JobEventConfiguration( 作业事件配置 ) 创建事件监听器，调用 <code>#register()</code> 方法进行注册监听。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       eventBus.register(jobEventConfig.createJobEventListener());</div><div class="line">       isRegistered = <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobEventListenerConfigurationException ex) &#123;</div><div class="line">       log.error(<span class="string">"Elastic job: create JobEventListener failure, error is: "</span>, ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>该方法是私有( <code>private</code> )方法，只能使用 JobEventConfiguration 创建事件监听器注册。当不传递该配置时，意味着不开启<strong>事件追踪</strong>功能。</li>
</ul>
</li>
</ul>
<p><strong>发布作业事件</strong></p>
<p>发布作业事件( JobEvent ) 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventBus.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">final</span> JobEvent event)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isRegistered &amp;&amp; !executorServiceObject.isShutdown()) &#123;</div><div class="line">       eventBus.post(event);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 Elaistc-Job-Lite 里，LiteJobFacade 对 <code>JobEventBus#post(...)</code> 进行封装，提供给作业执行器( AbstractElasticJobExecutor )调用( Elastic-Job-Cloud 实际也进行了封装 )：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postJobExecutionEvent</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent jobExecutionEvent)</span> </span>&#123;</div><div class="line">   jobEventBus.post(jobExecutionEvent);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postJobStatusTraceEvent</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> State state, <span class="keyword">final</span> String message)</span> </span>&#123;</div><div class="line">   TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">   jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(taskContext.getMetaInfo().getJobName(), taskContext.getId(),</div><div class="line">           taskContext.getSlaveId(), Source.LITE_EXECUTOR, taskContext.getType(), taskContext.getMetaInfo().getShardingItems().toString(), state, message));</div><div class="line">   <span class="keyword">if</span> (!Strings.isNullOrEmpty(message)) &#123;</div><div class="line">       log.trace(message);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>TaskContext 通过 <code>#from(...)</code> 方法，对作业任务ID( <code>taskId</code> ) 解析，获取任务上下文。TaskContext 代码注释很完整，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/8926e94aa7c48dc635a36518da2c4b10194420a5/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/context/TaskContext.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</li>
</ul>
<h1 id="3-作业事件"><a href="#3-作业事件" class="headerlink" title="3. 作业事件"></a>3. 作业事件</h1><p>目前有两种作业事件( JobEvent )：</p>
<ul>
<li>JobStatusTraceEvent，作业状态追踪事件。</li>
<li>JobExecutionEvent，作业执行追踪事件。</li>
</ul>
<p>本小节分享两方面：</p>
<ul>
<li>作业事件<strong>发布时机</strong>。</li>
<li>Elastic-Job 基于<strong>关系型数据库</strong>记录事件的<strong>表结构</strong>。</li>
</ul>
<h2 id="3-1-作业状态追踪事件"><a href="#3-1-作业状态追踪事件" class="headerlink" title="3.1 作业状态追踪事件"></a>3.1 作业状态追踪事件</h2><p>JobStatusTraceEvent，作业状态追踪事件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobStatusTraceEvent</span> <span class="keyword">implements</span> <span class="title">JobEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主键</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String id = UUID.randomUUID().toString();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 原作业任务ID</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> String originalTaskId = <span class="string">""</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业任务ID</div><div class="line">     * 来自 &#123;<span class="doctag">@link</span> com.dangdang.ddframe.job.executor.ShardingContexts#taskId&#125;</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行作业服务器的名字</div><div class="line">     * Elastic-Job-Lite，作业节点的 IP 地址</div><div class="line">     * Elastic-Job-Cloud，Mesos 执行机主键</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String slaveId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 任务来源</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Source source;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 任务执行类型</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType executionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片项</div><div class="line">     * 多个分片项以逗号分隔</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingItems;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 任务执行状态</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 相关信息</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 记录创建时间</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Date creationTime = <span class="keyword">new</span> Date();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>ExecutionType，执行类型。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionType &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 准备执行的任务.</div><div class="line">     */</div><div class="line">    READY,</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 失效转移的任务.</div><div class="line">     */</div><div class="line">    FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Source，任务来源。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Source &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Elastic-Job-Cloud 调度器</div><div class="line">    */</div><div class="line">   CLOUD_SCHEDULER,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Elastic-Job-Cloud 执行器</div><div class="line">    */</div><div class="line">   CLOUD_EXECUTOR,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * Elastic-Job-Lite 执行器</div><div class="line">    */</div><div class="line">   LITE_EXECUTOR</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>State，任务执行状态。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 开始中</div><div class="line">    */</div><div class="line">   TASK_STAGING,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 运行中</div><div class="line">    */</div><div class="line">   TASK_RUNNING,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 完成（正常）</div><div class="line">    */</div><div class="line">   TASK_FINISHED,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 完成（异常）</div><div class="line">    */</div><div class="line">   TASK_ERROR,</div><div class="line">       </div><div class="line">   TASK_KILLED, TASK_LOST, TASK_FAILED,  TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, TASK_UNREACHABLE, TASK_UNKNOWN</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Elastic-Job-Lite 只有 TASK_STAGING、TASK_RUNNING、TASK_FINISHED、TASK_ERROR 四种执行状态。</li>
<li>Elastic-Job-Cloud 有所有的执行状态。</li>
</ul>
</li>
</ul>
<p>关系数据库表 <code>JOB_STATUS_TRACE_LOG</code> 结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_STATUS_TRACE_LOG`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`original_task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`slave_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`source`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`execution_type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`sharding_item`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`state`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`message`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`creation_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`TASK_ID_STATE_INDEX`</span> (<span class="string">`task_id`</span>,<span class="string">`state`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure>
<ul>
<li><p>Elastic-Job-Lite 一次作业执行记录如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_14/02.png">打开大图</a> )：</p>
<p>  <img src="http://www.yunai.me/images/Elastic-Job/2017_11_14/02.png" alt=""></p>
</li>
</ul>
<p>JobStatusTraceEvent 在 Elastic-Job-Lite 发布时机：</p>
<ul>
<li><p>State.TASK_STAGING：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">    <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>State.TASK_RUNNING：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>State.TASK_FINISHED、State.TASK_ERROR【第一种】：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    <span class="comment">// 跳过 存在运行中的被错过作业</span></div><div class="line">    <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">      <span class="comment">// 发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">      <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">          jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div class="line">                  <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </div><div class="line">                  shardingContexts.getShardingItemParameters().keySet()));</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>State.TASK_FINISHED、State.TASK_ERROR【第二种】：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">  <span class="comment">// ... 省略无关代码</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      process(shardingContexts, executionSource);</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// ... 省略无关代码</span></div><div class="line">      <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">      <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">          <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">              jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">              jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-2-作业执行追踪事件"><a href="#3-2-作业执行追踪事件" class="headerlink" title="3.2 作业执行追踪事件"></a>3.2 作业执行追踪事件</h2><p>JobExecutionEvent，作业执行追踪事件。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutionEvent</span> <span class="keyword">implements</span> <span class="title">JobEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主键</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String id = UUID.randomUUID().toString();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主机名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String hostname = IpUtils.getHostName();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * IP</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String ip = IpUtils.getIp();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业任务ID</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行来源</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionSource source;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片项</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingItem;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开始时间</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Date startTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 结束时间</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> Date completeTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 是否执行成功</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行失败原因</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobExecutionEventThrowable failureCause;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>ExecutionSource，执行来源</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 普通触发执行</div><div class="line">    */</div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 被错过执行</div><div class="line">    */</div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 失效转移执行</div><div class="line">    */</div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>关系数据库表 <code>JOB_EXECUTION_LOG</code> 结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_EXECUTION_LOG`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`hostname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`sharding_item`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`execution_source`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`failure_cause`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`is_success`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`start_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`complete_time`</span> <span class="keyword">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_bin</div></pre></td></tr></table></figure>
<ul>
<li><p>Elastic-Job-Lite 一次作业<strong>多作业分片项</strong>执行记录如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_14/03.png">打开大图</a> )：</p>
<p>  <img src="http://www.yunai.me/images/Elastic-Job/2017_11_14/03.png" alt=""></p>
</li>
</ul>
<p>JobExecutionEvent 在 Elastic-Job-Lite 发布时机：</p>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// ... 省略无关代码</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="3-3-作业事件数据库存储"><a href="#3-3-作业事件数据库存储" class="headerlink" title="3.3 作业事件数据库存储"></a>3.3 作业事件数据库存储</h2><p>JobEventRdbStorage，作业事件数据库存储。</p>
<p><strong>创建</strong> JobEventRdbStorage 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobEventRdbStorage(<span class="keyword">final</span> DataSource dataSource) <span class="keyword">throws</span> SQLException &#123;</div><div class="line">   <span class="keyword">this</span>.dataSource = dataSource;</div><div class="line">   initTablesAndIndexes();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTablesAndIndexes</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">try</span> (Connection conn = dataSource.getConnection()) &#123;</div><div class="line">       createJobExecutionTableAndIndexIfNeeded(conn);</div><div class="line">       createJobStatusTraceTableAndIndexIfNeeded(conn);</div><div class="line">       databaseType = DatabaseType.valueFrom(conn.getMetaData().getDatabaseProductName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#createJobExecutionTableAndIndexIfNeeded(...)</code> 创建 <code>JOB_EXECUTION_LOG</code> 表和索引。</li>
<li>调用 <code>#createJobStatusTraceTableAndIndexIfNeeded(...)</code> 创建 <code>JOB_STATUS_TRACE_LOG</code> 表和索引。</li>
</ul>
<p><strong>存储</strong> JobStatusTraceEvent 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventRdbStorage.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addJobStatusTraceEvent</span><span class="params">(<span class="keyword">final</span> JobStatusTraceEvent jobStatusTraceEvent)</span> </span>&#123;</div><div class="line">   String originalTaskId = jobStatusTraceEvent.getOriginalTaskId();</div><div class="line">   <span class="keyword">if</span> (State.TASK_STAGING != jobStatusTraceEvent.getState()) &#123;</div><div class="line">       originalTaskId = getOriginalTaskId(jobStatusTraceEvent.getTaskId());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">   String sql = <span class="string">"INSERT INTO `"</span> + TABLE_JOB_STATUS_TRACE_LOG + <span class="string">"` (`id`, `job_name`, `original_task_id`, `task_id`, `slave_id`, `source`, `execution_type`, `sharding_item`,  "</span> </div><div class="line">           + <span class="string">"`state`, `message`, `creation_time`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);"</span>;</div><div class="line">   <span class="comment">// ... 省略你懂的代码</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getOriginalTaskId</span><span class="params">(<span class="keyword">final</span> String taskId)</span> </span>&#123;</div><div class="line">   String sql = String.format(<span class="string">"SELECT original_task_id FROM %s WHERE task_id = '%s' and state='%s'"</span>, TABLE_JOB_STATUS_TRACE_LOG, taskId, State.TASK_STAGING);</div><div class="line">   <span class="comment">// ... 省略你懂的代码</span></div><div class="line">   <span class="keyword">return</span> original_task_id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>originalTaskId</code>，原任务作业ID。<ul>
<li>Elastic-Job-Lite 暂未使用到该字段，存储空串( <code>&quot;&quot;</code> )。</li>
<li>Elastic-Job-Cloud 使用到，笔者暂未研究到。嘿嘿。</li>
</ul>
</li>
</ul>
<p><strong>存储</strong> JobExecutionEvent 代码如下：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventRdbStorage.java</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addJobExecutionEvent</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent jobExecutionEvent)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobExecutionEvent.getCompleteTime()) &#123; <span class="comment">// 作业分片项执行开始</span></div><div class="line">       <span class="keyword">return</span> insertJobExecutionEvent(jobExecutionEvent);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">if</span> (jobExecutionEvent.isSuccess()) &#123; <span class="comment">// 作业分片项执行完成（正常）</span></div><div class="line">           <span class="keyword">return</span> updateJobExecutionEventWhenSuccess(jobExecutionEvent);</div><div class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 作业分片项执行完成（异常）</span></div><div class="line">           <span class="keyword">return</span> updateJobExecutionEventFailure(jobExecutionEvent);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>作业分片项执行完成进行的是<strong>更新</strong>操作。</li>
</ul>
<h2 id="3-4-作业事件数据库查询"><a href="#3-4-作业事件数据库查询" class="headerlink" title="3.4 作业事件数据库查询"></a>3.4 作业事件数据库查询</h2><p>JobEventRdbSearch，作业事件数据库查询，提供给运维平台调用查询数据。感兴趣的同学点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/8283acf01548222f39f7bfc202a8f89d27728e6c/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/event/rdb/JobEventRdbSearch.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p>
<h1 id="4-作业监听器"><a href="#4-作业监听器" class="headerlink" title="4. 作业监听器"></a>4. 作业监听器</h1><p>在上文我们看到，作业监听器通过传递作业事件配置( JobEventConfiguration )给作业事件总线( JobEventBus ) <strong>进行创建监听器，并注册监听器到事件总线</strong>。</p>
<p>我们来看下 Elastic-Job 提供的基于<strong>关系数据库</strong>的事件配置实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventConfiguration.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobEventConfiguration</span> <span class="keyword">extends</span> <span class="title">JobEventIdentity</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建作业事件监听器.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 作业事件监听器.</div><div class="line">     * <span class="doctag">@throws</span> JobEventListenerConfigurationException 作业事件监听器配置异常</div><div class="line">     */</div><div class="line">    <span class="function">JobEventListener <span class="title">createJobEventListener</span><span class="params">()</span> <span class="keyword">throws</span> JobEventListenerConfigurationException</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobEventRdbConfiguration.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventRdbConfiguration</span> <span class="keyword">extends</span> <span class="title">JobEventRdbIdentity</span> <span class="keyword">implements</span> <span class="title">JobEventConfiguration</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> DataSource dataSource;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> JobEventListener <span class="title">createJobEventListener</span><span class="params">()</span> <span class="keyword">throws</span> JobEventListenerConfigurationException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JobEventRdbListener(dataSource);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobEventListenerConfigurationException(ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JobEventRdbConfiguration，作业数据库事件配置。调用 <code>#createJobEventListener()</code> 创建作业事件数据库监听器( JobEventRdbListener )。</li>
</ul>
<p>JobEventRdbListener，作业事件数据库监听器。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobEventListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobEventListener</span> <span class="keyword">extends</span> <span class="title">JobEventIdentity</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行事件监听执行.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> jobExecutionEvent 作业执行事件</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(JobExecutionEvent jobExecutionEvent)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业状态痕迹事件监听执行.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> jobStatusTraceEvent 作业状态痕迹事件</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">(JobStatusTraceEvent jobStatusTraceEvent)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobEventRdbListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobEventRdbListener</span> <span class="keyword">extends</span> <span class="title">JobEventRdbIdentity</span> <span class="keyword">implements</span> <span class="title">JobEventListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventRdbStorage repository;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobEventRdbListener</span><span class="params">(<span class="keyword">final</span> DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        repository = <span class="keyword">new</span> JobEventRdbStorage(dataSource);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> JobExecutionEvent executionEvent)</span> </span>&#123;</div><div class="line">        repository.addJobExecutionEvent(executionEvent);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> JobStatusTraceEvent jobStatusTraceEvent)</span> </span>&#123;</div><div class="line">        repository.addJobStatusTraceEvent(jobStatusTraceEvent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过 JobEventRdbStorage 存储作业事件到关系型数据库。</li>
</ul>
<p><strong>如何自定义作业监听器？</strong></p>
<p>有些同学可能希望使用 ES 或者其他数据库存储作业事件，这个时候可以通过实现 JobEventConfiguration、JobEventListener 进行拓展。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：瞎比比了这么长，能不能简单粗暴一点。<br>芋道君：是是是。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_14/04.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业事件总线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业失效转移</title>
    <link href="http://www.yunai.me/Elastic-Job/job-failover/"/>
    <id>http://www.yunai.me/Elastic-Job/job-failover/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-08-28T18:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业节点崩溃监听</a></li>
<li><a href="#">3. 作业失效转移</a></li>
<li><a href="#">4. 获取作业分片上下文集合</a></li>
<li><a href="#">5. 监听作业失效转移功能关闭</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业失效转移</strong>。</p>
<p>当作业节点执行作业异常崩溃时，其所分配的作业分片项在下次重新分片之前不会被重新执行。开启失效转移功能后，这部分作业分片项将被其他作业节点抓取后“执行”。为什么此处的执行打引号呢？😈下文我们会分享到噢，卖个关子。</p>
<p>笔者对<strong>失效转移</strong>理解了蛮久时间，因此引用官方对它的解释，让你能更好的理解：</p>
<blockquote>
<p>来源地址：<a href="https://my.oschina.net/u/719192/blog/506062" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/u/719192/blog/506062</a><br>失效转移： 运行中的作业服务器崩溃不会导致重新分片，只会在下次作业启动时分片。启用失效转移功能可以在本次作业执行过程中，监测其他作业服务器空闲，抓取未完成的孤儿分片项执行。<br>– 分隔符 –<br>来源地址：<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/03-design/lite-design/" rel="external nofollow noopener noreferrer" target="_blank">http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/03-design/lite-design/</a><br>实现失效转移功能，在某台服务器执行完毕后主动抓取未分配的分片，并且在某台服务器下线后主动寻找可用的服务器执行任务。</p>
</blockquote>
<p>这样看概念可能还是比较难理解，代码搞起来！</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_07/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_07/01.png" alt=""></p>
<ul>
<li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.failover</code> 包下，实现了 Elastic-Job-Lite 作业失效转移。</li>
<li>FailoverService，作业失效转移服务。</li>
<li>FailoverNode，作业失效转移数据存储路径。</li>
<li>FailoverListenerManager，作业失效转移监听管理器。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-作业节点崩溃监听"><a href="#2-作业节点崩溃监听" class="headerlink" title="2. 作业节点崩溃监听"></a>2. 作业节点崩溃监听</h1><p>当作业节点崩溃时，监听器 JobCrashedJobListener 会监听到该情况，进行作业失效转移处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobCrashedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobCrashedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isFailoverEnabled() &amp;&amp; Type.NODE_REMOVED == eventType</div><div class="line">               &amp;&amp; instanceNode.isInstancePath(path)) &#123; <span class="comment">// /$&#123;JOB_NAME&#125;/instances/$&#123;INSTANCE_ID&#125;</span></div><div class="line">           String jobInstanceId = path.substring(instanceNode.getInstanceFullPath().length() + <span class="number">1</span>);</div><div class="line">           <span class="keyword">if</span> (jobInstanceId.equals(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId())) &#123;</div><div class="line">               <span class="keyword">return</span>;</div><div class="line">           &#125;</div><div class="line">           List&lt;Integer&gt; failoverItems = failoverService.getFailoverItems(jobInstanceId); <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover</span></div><div class="line">           <span class="keyword">if</span> (!failoverItems.isEmpty()) &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> each : failoverItems) &#123;</div><div class="line">                   failoverService.setCrashedFailoverFlag(each);</div><div class="line">                   failoverService.failoverIfNecessary();</div><div class="line">               &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingService.getShardingItems(jobInstanceId)) &#123; <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance</span></div><div class="line">                   failoverService.setCrashedFailoverFlag(each);</div><div class="line">                   failoverService.failoverIfNecessary();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过判断 <code>/${JOB_NAME}/instances/${INSTANCE_ID}</code> 被移除，执行作业失效转移逻辑。❓说好的作业节点<strong>崩溃</strong>呢？经过确认，目前这块存在 BUG，未判断作业节点是否为奔溃。<strong>所以在当前版本，作业失效转移面向的是所有作业节点关闭逻辑，不仅限于作业崩溃关闭。</strong></li>
<li><p>优先调用 <code>FailoverService#getFailoverItems(...)</code> 方法，获得关闭作业节点( <code>${JOB_INSTANCE_ID}</code> )对应的 <code>${JOB_NAME}/sharding/${ITEM_ID}/failover</code> 作业分片项。</p>
<p>若该作业分片项为空，再调用 <code>ShardingService#getShardingItems(...)</code> 方法，获得关闭作业节点( <code>${JOB_INSTANCE_ID}</code> )对应的 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 作业分片项。</p>
<p>为什么是这样的顺序呢？放在 <code>FailoverService#failoverIfNecessary()</code> 一起讲。这里先看下 <code>FailoverService#getFailoverItems(...)</code> 方法的实现：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getFailoverItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</div><div class="line">   List&lt;String&gt; items = jobNodeStorage.getJobNodeChildrenKeys(ShardingNode.ROOT);</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(items.size());</div><div class="line">   <span class="keyword">for</span> (String each : items) &#123;</div><div class="line">       <span class="keyword">int</span> item = Integer.parseInt(each);</div><div class="line">       String node = FailoverNode.getExecutionFailoverNode(item); <span class="comment">// `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover`</span></div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(node) &amp;&amp; jobInstanceId.equals(jobNodeStorage.getJobNodeDataDirectly(node))) &#123;</div><div class="line">           result.add(item);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Collections.sort(result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>FailoverService#setCrashedFailoverFlag(...)</code> 方法，设置失效的分片项标记 <code>/${JOB_NAME}/leader/failover/items/${ITEM_ID}</code>。该数据节点为<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCrashedFailoverFlag</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isFailoverAssigned(item)) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(FailoverNode.getItemsNode(item)); <span class="comment">// /$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFailoverAssigned</span><span class="params">(<span class="keyword">final</span> Integer item)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.getExecutionFailoverNode(item));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>FailoverService#failoverIfNecessary()</code> 方法，如果需要失效转移, 则执行作业失效转移。</p>
</li>
</ul>
<h1 id="3-作业失效转移"><a href="#3-作业失效转移" class="headerlink" title="3. 作业失效转移"></a>3. 作业失效转移</h1><p>调用 <code>FailoverService#failoverIfNecessary()</code> 方法，如果需要失效转移, 则执行作业失效转移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (needFailover()) &#123;</div><div class="line">       jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#needFailover()</code> 方法，判断是否满足失效转移条件。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needFailover</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 有失效转移的作业分片项</span></div><div class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.ITEMS_ROOT) &amp;&amp; !jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).isEmpty()</div><div class="line">            <span class="comment">// 当前作业不在运行中</span></div><div class="line">            &amp;&amp; !JobRegistry.getInstance().isJobRunning(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>条件一：<code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 有失效转移的作业分片项。</li>
<li><p>条件二：当前作业不在运行中。此条件即是上文提交的作业节点<strong>空闲</strong>的定义。</p>
<blockquote>
<p>失效转移： 运行中的作业服务器崩溃不会导致重新分片，只会在下次作业启动时分片。启用失效转移功能可以在本次作业执行过程中，监测其他作业服务器【空闲】，抓取未完成的孤儿分片项执行</p>
</blockquote>
</li>
</ul>
</li>
<li><p>调用 <code>JobNodeStorage#executeInLeader(...)</code> 方法，使用 <code>FailoverNode.LATCH</code>( <code>/${JOB_NAME}/leader/failover/latch</code> ) 路径构成的<strong>分布式锁</strong>，保证 FailoverLeaderExecutionCallback 的回调方法同一时间，即使多个作业节点调用，有且仅有一个作业节点进行执行。另外，虽然 <code>JobNodeStorage#executeInLeader(...)</code> 方法上带有 <code>Leader</code> 关键字，实际非必须在主节点的操作，任何一个拿到<strong>分布式锁</strong>的作业节点都可以调用。目前和<strong>分布式锁</strong>相关的逻辑，在 Elastic-Job-Lite 里，都会调用 <code>JobNodeStorage#executeInLeader(...)</code> 方法，数据都存储在 <code>/leader/</code> 节点目录下。关于<strong>分布式锁</strong>相关的，在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》「3.1 在主节点执行操作」</a>有详细分享。</p>
</li>
</ul>
<hr>
<p>FailoverLeaderExecutionCallback 回调逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverLeaderExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 判断需要失效转移</span></div><div class="line">       <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !needFailover()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得一个 `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 作业分片项</span></div><div class="line">       <span class="keyword">int</span> crashedItem = Integer.parseInt(jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).get(<span class="number">0</span>));</div><div class="line">       log.debug(<span class="string">"Failover job '&#123;&#125;' begin, crashed item '&#123;&#125;'"</span>, jobName, crashedItem);</div><div class="line">       <span class="comment">// 设置这个 `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover` 作业分片项 为 当前作业节点</span></div><div class="line">       jobNodeStorage.fillEphemeralJobNode(FailoverNode.getExecutionFailoverNode(crashedItem), JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">       <span class="comment">// 移除这个 `$&#123;JOB_NAME&#125;/leader/failover/items/$&#123;ITEM_ID&#125;` 作业分片项</span></div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(FailoverNode.getItemsNode(crashedItem));</div><div class="line">       <span class="comment">// TODO 不应使用triggerJob, 而是使用executor统一调度 疑问：为什么要用executor统一，后面研究下</span></div><div class="line">       <span class="comment">// 触发作业执行</span></div><div class="line">       JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != jobScheduleController) &#123;</div><div class="line">           jobScheduleController.triggerJob();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>再次调用 <code>#needFailover()</code> 方法，确保经过分布式锁获取等待过程中，仍然需要失效转移。因为可能多个作业节点调用了该回调，第一个作业节点执行了失效转移，可能第二个作业节点就不需要执行失效转移了。</li>
<li><p>调用 <code>JobNodeStorage#getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT)#get(0)</code> 方法，获得<strong>一个</strong> <code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 作业分片项。  </p>
<p>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法，设置这个<strong>临时</strong>数据节点 <code>${JOB_NAME}/sharding/${ITEM_ID}failover</code> 作业分片项为当前作业节点( <code>${JOB_INSTANCE_ID}</code> )。  </p>
<p>调用 <code>JobNodeStorage#removeJobNodeIfExisted(...)</code> 方法，移除这个<code>${JOB_NAME}/leader/failover/items/${ITEM_ID}</code> 作业分片项。</p>
</li>
<li><p>调用 <code>JobScheduleController#triggerJob()</code> 方法，立即启动作业。调用该方法，实际作业不会立即执行，而仅仅是进行触发。如果有多个失效转移的作业分片项，多次调用 <code>JobScheduleController#triggerJob()</code> 方法会不会导致作业是<strong>并行执行</strong>的？答案是不会，因为一个作业的 Quartz 线程数设置为 1。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// Quartz 线程数：1</span></div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>如果说作业分片项实现转移时，每个作业节点都不处于非空闲状态，岂不是 FailoverLeaderExecutionCallback 一直无法被回调？答案当然不是的。作业在执行完分配给自己的作业分片项，会调用 <code>LiteJobFacade#failoverIfNecessary()</code> 方法，进行失效转移的作业分片项抓取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// ...  省略无关代码</span></div><div class="line">   </div><div class="line">   <span class="comment">// 执行 普通触发的作业</span></div><div class="line">   execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// 执行 作业失效转移</span></div><div class="line">   jobFacade.failoverIfNecessary();</div><div class="line">   </div><div class="line">   <span class="comment">// ...  省略无关代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (needFailover()) &#123;</div><div class="line">       jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们在翻回 JobCrashedJobListener 处代码，为什么获取失效转移的作业分片项是这样的优先顺序？一个作业节点拥有 <code>${JOB_NAME}/sharding/${ITEM_ID}/failover</code> 数据分片项，意味着分配给它的作业分片项已经执行完成，否则怎么回调 FailoverLeaderExecutionCallback 方法，抓取失效转移的作业分片项呢？！</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_07/02.png" alt=""></p>
<p>旁白君：双击666，关注笔者公众号一波。</p>
<h1 id="4-获取作业分片上下文集合"><a href="#4-获取作业分片上下文集合" class="headerlink" title="4. 获取作业分片上下文集合"></a>4. 获取作业分片上下文集合</h1><p>在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》「4.2 获取当前作业服务器的分片上下文」</a>中，我们可以看到作业执行器( AbstractElasticJobExecutor ) 执行作业时，会获取当前作业服务器的分片上下文进行执行。获取过程总体如下顺序图( <a href="http://www.yunai.me/images/Elastic-Job/2017_11_07/03.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_07/03.png" alt=""></p>
<ul>
<li>红色叉叉在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>有详细分享。</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得 失效转移的作业分片项</span></div><div class="line">   <span class="keyword">boolean</span> isFailover = configService.load(<span class="keyword">true</span>).isFailover();</div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</div><div class="line">       <span class="keyword">if</span> (!failoverShardingItems.isEmpty()) &#123;</div><div class="line">           <span class="comment">// 【忽略，作业分片详解】获取当前作业服务器分片上下文</span></div><div class="line">           <span class="keyword">return</span> executionContextService.getJobShardingContext(failoverShardingItems);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】作业分片，如果需要分片且当前节点为主节点</span></div><div class="line">   shardingService.shardingIfNecessary();</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】获得 分配在本机的作业分片项</span></div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   <span class="comment">// 移除 分配在本机的失效转移的作业分片项目</span></div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       shardingItems.removeAll(failoverService.getLocalTakeOffItems());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 被禁用的作业分片项</span></div><div class="line">   shardingItems.removeAll(executionService.getDisabledItems(shardingItems));</div><div class="line">   <span class="comment">// 【忽略，作业分片详解】获取当前作业服务器分片上下文</span></div><div class="line">   <span class="keyword">return</span> executionContextService.getJobShardingContext(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>FailoverService#getLocalFailoverItems()</code> 方法，获取运行在本作业节点的失效转移分片项集合。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalFailoverItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getFailoverItems(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId()); <span class="comment">// `$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/failover`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>ExecutionContextService#getJobShardingContext()</code> 方法，获取当前作业服务器分片上下文。在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》「4. 获取作业分片上下文集合」</a>有详细解析。</p>
</li>
<li><p>当本作业节点不存在抓取的失效转移分片项，则获得分配给本作业分解的作业分片项。此时你会看到略奇怪的方法调用，<code>shardingItems.removeAll(failoverService.getLocalTakeOffItems())</code>。为什么呢？举个例子，作业节点A持有作业分片项[0, 1]，此时异常断网，导致[0, 1]被作业节点B失效转移抓取，此时若作业节点A恢复，作业分片项[0, 1]依然属于作业节点A，但是可能已经在作业节点B执行，因此需要进行移除，避免多节点运行相同的作业分片项。<code>FailoverService#getLocalTakeOffItems()</code> 方法实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取运行在本作业服务器的被失效转移的序列号.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 运行在本作业服务器的被失效转移的序列号</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalTakeOffItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingItems.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(FailoverNode.getExecutionFailoverNode(each))) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="5-监听作业失效转移功能关闭"><a href="#5-监听作业失效转移功能关闭" class="headerlink" title="5. 监听作业失效转移功能关闭"></a>5. 监听作业失效转移功能关闭</h1><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverSettingsChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (configNode.isConfigPath(path) &amp;&amp; Type.NODE_UPDATED == eventType</div><div class="line">               &amp;&amp; !LiteJobConfigurationGsonFactory.fromJson(data).isFailover()) &#123; <span class="comment">// 关闭失效转移功能</span></div><div class="line">           failoverService.removeFailoverInfo();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：啊啊啊，有点绕。<br>芋道君：耐心，耐心，耐心。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_11_07/04.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;有福
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片</title>
    <link href="http://www.yunai.me/Elastic-Job/job-sharding/"/>
    <id>http://www.yunai.me/Elastic-Job/job-sharding/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2017-08-28T09:49:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业分片条件</a></li>
<li><a href="#">3. 分配作业分片项</a></li>
<li><a href="#">4. 获取作业分片上下文集合</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业分片</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_31/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_31/01.png" alt=""></p>
<ul>
<li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.sharding</code> 包下，实现了 Elastic-Job-Lite 作业分片。</li>
<li>ShardingService，作业分片服务。</li>
<li>ShardingNode，作业分片数据存储路径。</li>
<li>ShardingListenerManager，作业分片监听管理器。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-作业分片条件"><a href="#2-作业分片条件" class="headerlink" title="2. 作业分片条件"></a>2. 作业分片条件</h1><p>当作业满足分片条件时，不会<strong>立即</strong>进行作业分片分配，而是设置需要重新进行分片的<strong>标记</strong>，等到作业分片获取时，判断有该标记后<strong>执行</strong>作业分配。</p>
<p>设置需要重新进行分片的<strong>标记</strong>的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置需要重新分片的标记.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReshardingFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.createJobNodeIfNeeded(ShardingNode.NECESSARY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 如果存在则创建作业节点.</div><div class="line">* 如果作业根节点不存在表示作业已经停止, 不再继续创建节点.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 作业节点名称</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createJobNodeIfNeeded</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isJobRootNodeExisted() &amp;&amp; !isJobNodeExisted(node)) &#123;</div><div class="line">       regCenter.persist(jobNodePath.getFullPath(node), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#setReshardingFlag()</code> 方法设置<strong>需要重新分片的标记</strong> <code>/${JOB_NAME}/leader/sharding/necessary</code>。该 Zookeeper 数据节点是<strong>永久</strong>节点，存储空串( <code>&quot;&quot;</code> )，使用 zkClient 查看如下：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line">[necessary]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-example-lite-java/javaSimpleJob/leader/sharding/necessary</div></pre></td></tr></table></figure>
</li>
<li><p>设置标记之后，通过调用 <code>#isNeedSharding()</code> 方法即可判断是否需要重新分片。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断是否需要重分片.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 是否需要重分片</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNeedSharding</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(ShardingNode.NECESSARY);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断作业节点是否存在.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 作业节点名称</div><div class="line">* <span class="doctag">@return</span> 作业节点是否存在</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isJobNodeExisted</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> regCenter.isExisted(jobNodePath.getFullPath(node));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>设置需要重新进行分片有 4 种情况</strong></p>
<p><strong>第一种</strong>，注册作业启动信息时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">   <span class="comment">// 设置 需要重新分片的标记</span></div><div class="line">   shardingService.setReshardingFlag();</div><div class="line">  <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>第二种</strong>，作业分片总数( <code>JobCoreConfiguration.shardingTotalCount</code> )变化时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingTotalCountChangedJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (configNode.isConfigPath(path)</div><div class="line">               &amp;&amp; <span class="number">0</span> != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">           <span class="keyword">int</span> newShardingTotalCount = LiteJobConfigurationGsonFactory.fromJson(data).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">           <span class="keyword">if</span> (newShardingTotalCount != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123; <span class="comment">// 作业分片总数变化</span></div><div class="line">               <span class="comment">// 设置需要重新分片的标记</span></div><div class="line">               shardingService.setReshardingFlag();</div><div class="line">               <span class="comment">// 设置当前分片总数</span></div><div class="line">               JobRegistry.getInstance().setCurrentShardingTotalCount(jobName, newShardingTotalCount);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>第三种</strong>，服务器变化时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingListenerManager.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; (isInstanceChange(eventType, path)</div><div class="line">                   || isServerChange(path))) &#123;</div><div class="line">           shardingService.setReshardingFlag();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> serverNode.isServerPath(path);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>服务器变化有<strong>两种</strong>情况。</li>
<li>第一种，<code>#isServerChange(...)</code> 服务器被开启或禁用。</li>
<li>第二种，<code>#isInstanceChange(...)</code> 作业节点新增或者移除。</li>
</ul>
<p><strong>第四种</strong>，在<a href="http://www.yunai.me/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码解析 —— 自诊断修复》</a>详细分享。</p>
<h1 id="3-分配作业分片项"><a href="#3-分配作业分片项" class="headerlink" title="3. 分配作业分片项"></a>3. 分配作业分片项</h1><p>调用 <code>ShardingService#shardingIfNecessary()</code> 方法，如果需要分片且当前节点为主节点, 则作业分片。</p>
<p>总体流程如下<strong>顺序图</strong>：( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_31/02.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_31/02.png" alt=""></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 如果需要分片且当前节点为主节点, 则作业分片.</div><div class="line">* </div><div class="line">* 如果当前无可用节点则不分片.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</div><div class="line">   <span class="keyword">if</span> (!isNeedSharding() <span class="comment">// 判断是否需要重新分片</span></div><div class="line">           || availableJobInstances.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【非主节点】等待 作业分片项分配完成</span></div><div class="line">   <span class="keyword">if</span> (!leaderService.isLeaderUntilBlock()) &#123; <span class="comment">// 判断是否为【主节点】</span></div><div class="line">       blockUntilShardingCompleted();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 【主节点】作业分片项分配</span></div><div class="line">   <span class="comment">// 等待 作业未在运行中状态</span></div><div class="line">   waitingOtherJobCompleted();</div><div class="line">   <span class="comment">//</span></div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</div><div class="line">   <span class="keyword">int</span> shardingTotalCount = liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">   <span class="comment">// 设置 作业正在重分片的标记</span></div><div class="line">   log.debug(<span class="string">"Job '&#123;&#125;' sharding begin."</span>, jobName);</div><div class="line">   jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, <span class="string">""</span>);</div><div class="line">   <span class="comment">// 重置 作业分片项信息</span></div><div class="line">   resetShardingInfo(shardingTotalCount);</div><div class="line">   <span class="comment">// 【事务中】设置 作业分片项信息</span></div><div class="line">   JobShardingStrategy jobShardingStrategy = JobShardingStrategyFactory.getStrategy(liteJobConfig.getJobShardingStrategyClass());</div><div class="line">   jobNodeStorage.executeInTransaction(<span class="keyword">new</span> PersistShardingInfoTransactionExecutionCallback(jobShardingStrategy.sharding(availableJobInstances, jobName, shardingTotalCount)));</div><div class="line">   log.debug(<span class="string">"Job '&#123;&#125;' sharding complete."</span>, jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#isNeedSharding()</code> 方法判断是否需要重新分片。</li>
<li>调用 <code>LeaderService#isLeaderUntilBlock()</code> 方法判断是否为<strong>主节点</strong>。作业分片项的分配过程：<ul>
<li>【主节点】<strong>执行</strong>作业分片项分配。</li>
<li>【非主节点】<strong>等待</strong>作业分片项分配完成。</li>
<li><code>LeaderService#isLeaderUntilBlock()</code> 方法在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 主节点选举》「3. 选举主节点」</a>有详细分享。</li>
</ul>
</li>
<li><p>调用 <code>#blockUntilShardingCompleted()</code> 方法【非主节点】<strong>等待</strong>作业分片项分配完成。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShardingCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (!leaderService.isLeaderUntilBlock() <span class="comment">// 当前作业节点不为【主节点】</span></div><div class="line">           &amp;&amp; (jobNodeStorage.isJobNodeExisted(ShardingNode.NECESSARY) <span class="comment">// 存在作业需要重分片的标记</span></div><div class="line">               || jobNodeStorage.isJobNodeExisted(ShardingNode.PROCESSING))) &#123; <span class="comment">// 存在作业正在重分片的标记</span></div><div class="line">       log.debug(<span class="string">"Job '&#123;&#125;' sleep short time until sharding completed."</span>, jobName);</div><div class="line">       BlockUtils.waitingShortTime();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#LeaderService#isLeaderUntilBlock()</code> 方法判断是否为<strong>主节点</strong>。为什么上面判断了一次，这里又判断一次？主节点作业分片项分配过程中，不排除自己挂掉了，此时【非主节点】若选举成主节点，无需继续等待，当然也不能等待，因为已经没节点在执行作业分片项分配，所有节点都会卡在这里。</li>
<li>当 <strong>作业需要重分片的标记</strong>、<strong>作业正在重分片的标记</strong> 都不存在时，意味着作业分片项分配已经完成，下文 PersistShardingInfoTransactionExecutionCallback 类里我们会看到。</li>
</ul>
</li>
<li><p>调用 <code>#waitingOtherJobCompleted()</code> 方法等待作业未在运行中状态。作业是否在运行中需要 <code>LiteJobConfiguration.monitorExecution = true</code>，<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》「4.6 执行普通触发的作业」</a>有详细分享。</p>
</li>
<li>调用 <code>ConfigurationService#load(...)</code> 方法从注册中心获取作业配置( <strong>非缓存</strong> )，避免主节点本地作业配置可能非最新的，主要目的是获得作业分片总数( <code>shardingTotalCount</code> )。</li>
<li>调用 <code>jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, &quot;&quot;)</code> 设置<strong>作业正在重分片的标记</strong> <code>/${JOB_NAME}/leader/sharding/processing</code>。该 Zookeeper 数据节点是<strong>临时</strong>节点，存储空串( <code>&quot;&quot;</code> )，仅用于标记作业正在重分片，无特别业务逻辑。</li>
<li><p>调用 <code>#resetShardingInfo(...)</code> 方法<strong>重置</strong>作业分片信息。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetShardingInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount)</span> </span>&#123;</div><div class="line">  <span class="comment">// 重置 有效的作业分片项</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">      jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getInstanceNode(i)); <span class="comment">// 移除 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance`</span></div><div class="line">      jobNodeStorage.createJobNodeIfNeeded(ShardingNode.ROOT + <span class="string">"/"</span> + i); <span class="comment">// 创建 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;`</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 移除 多余的作业分片项</span></div><div class="line">  <span class="keyword">int</span> actualShardingTotalCount = jobNodeStorage.getJobNodeChildrenKeys(ShardingNode.ROOT).size();</div><div class="line">  <span class="keyword">if</span> (actualShardingTotalCount &gt; shardingTotalCount) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = shardingTotalCount; i &lt; actualShardingTotalCount; i++) &#123;</div><div class="line">          jobNodeStorage.removeJobNodeIfExisted(ShardingNode.ROOT + <span class="string">"/"</span> + i); <span class="comment">// 移除 `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;`</span></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>JobShardingStrategy#sharding(...)</code> 方法<strong>计算</strong>每个节点分配的作业分片项。<a href="http://www.yunai.me/Elastic-Job/job-sharding-strategy/?self">《Elastic-Job-Lite 源码分析 —— 作业分片策略》</a>有详细分享。</p>
</li>
<li><p>调用 <code>JobNodeStorage#executeInTransaction(...)</code> + <code>PersistShardingInfoTransactionExecutionCallback#execute()</code> 方法实现在<strong>事务</strong>中<strong>设置</strong>每个节点分配的作业分片项。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PersistShardingInfoTransactionExecutionCallback.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistShardingInfoTransactionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">TransactionExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 作业分片项分配结果</div><div class="line">    * key：作业节点</div><div class="line">    * value：作业分片项</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CuratorTransactionFinal curatorTransactionFinal)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">       <span class="comment">// 设置 每个节点分配的作业分片项</span></div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> shardingItem : entry.getValue()) &#123;</div><div class="line">               curatorTransactionFinal.create().forPath(jobNodePath.getFullPath(ShardingNode.getInstanceNode(shardingItem))</div><div class="line">                       , entry.getKey().getJobInstanceId().getBytes()).and();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 移除 作业需要重分片的标记、作业正在重分片的标记</span></div><div class="line">       curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.NECESSARY)).and();</div><div class="line">       curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.PROCESSING)).and();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 在事务中执行操作.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> callback 执行操作的回调</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInTransaction</span><span class="params">(<span class="keyword">final</span> TransactionExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       CuratorTransactionFinal curatorTransactionFinal = getClient().inTransaction().check().forPath(<span class="string">"/"</span>).and();</div><div class="line">       callback.execute(curatorTransactionFinal);</div><div class="line">       curatorTransactionFinal.commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>设置<strong>临时</strong>数据节点 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 为分配的作业节点的作业实例主键( <code>jobInstanceId</code> )。使用 zkClient 查看如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 0] get /elastic-job-example-lite-java/javaSimpleJob/sharding/0/instance</div><div class="line">192.168.3.2@-@31492</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>作业分片项分配整体流程有点长，耐着心看，毕竟是核心代码哟。如果中间有任何疑问，欢迎给我公众号：<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg">芋道源码</a> 留言。</strong></p>
<h1 id="4-获取作业分片上下文集合"><a href="#4-获取作业分片上下文集合" class="headerlink" title="4. 获取作业分片上下文集合"></a>4. 获取作业分片上下文集合</h1><p>在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行的》「4.2 获取当前作业服务器的分片上下文」</a>中，我们可以看到作业执行器( AbstractElasticJobExecutor ) 执行作业时，会获取当前作业服务器的分片上下文进行执行。获取过程总体如下顺序图( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_31/03.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_31/03.png" alt=""></p>
<ul>
<li>橘色叉叉在<a href="http://www.yunai.me/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>有详细分享。</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 【忽略，作业失效转移详解】获得 失效转移的作业分片项</span></div><div class="line">   <span class="keyword">boolean</span> isFailover = configService.load(<span class="keyword">true</span>).isFailover();</div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</div><div class="line">       <span class="keyword">if</span> (!failoverShardingItems.isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span> executionContextService.getJobShardingContext(failoverShardingItems);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 作业分片，如果需要分片且当前节点为主节点</span></div><div class="line">   shardingService.shardingIfNecessary();</div><div class="line">   <span class="comment">// 获得 分配在本机的作业分片项</span></div><div class="line">   List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div class="line">   <span class="comment">// 【忽略，作业失效转移详解】移除 分配在本机的失效转移的作业分片项目</span></div><div class="line">   <span class="keyword">if</span> (isFailover) &#123;</div><div class="line">       shardingItems.removeAll(failoverService.getLocalTakeOffItems());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 被禁用的作业分片项</span></div><div class="line">   shardingItems.removeAll(executionService.getDisabledItems(shardingItems));</div><div class="line">   <span class="comment">// 获取当前作业服务器分片上下文</span></div><div class="line">   <span class="keyword">return</span> executionContextService.getJobShardingContext(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>ShardingService#shardingIfNecessary()</code> 方法，如果需要分片且当前节点为主节点，作业分片项<strong>分配</strong>。<strong>不是每次都需要作业分片，必须满足「2. 作业分片条件」才执行作业分片</strong>。</li>
<li><p>调用 <code>ShardingService#getLocalShardingItems()</code>方法，获得分配在<strong>本机</strong>的作业分片项，即 <code>/${JOB_NAME}/sharding/${ITEM_ID}/instance</code> 为本机的作业分片项。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取运行在本作业实例的分片项集合.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 运行在本作业实例的分片项集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getLocalShardingItems</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getShardingItems(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取作业运行实例的分片项集合.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobInstanceId 作业运行实例主键</div><div class="line">* <span class="doctag">@return</span> 作业运行实例的分片项集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getShardingItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</div><div class="line">   JobInstance jobInstance = <span class="keyword">new</span> JobInstance(jobInstanceId);</div><div class="line">   <span class="keyword">if</span> (!serverService.isAvailableServer(jobInstance.getIp())) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">       <span class="comment">// `/$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/instance`</span></div><div class="line">       <span class="keyword">if</span> (jobInstance.getJobInstanceId().equals(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123;</div><div class="line">           result.add(i);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>shardingItems.removeAll(executionService.getDisabledItems(shardingItems))</code>，移除<strong>被禁用</strong>的作业分片项，即 <code>/${JOB_NAME}/sharding/${ITEM_ID}/disabled</code> <strong>存在</strong>的作业分片项。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取禁用的任务分片项.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> items 需要获取禁用的任务分片项</div><div class="line">* <span class="doctag">@return</span> 禁用的任务分片项</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getDisabledItems</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/disabled</span></div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getDisabledNode(each))) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>ExecutionContextService#getJobShardingContext(...)</code> 方法，获取<strong>当前</strong>作业服务器分片上下文。</p>
</li>
</ul>
<p><strong>获取当前作业服务器分片上下文</strong></p>
<p>调用 <code>ExecutionContextService#getJobShardingContext(...)</code> 方法，获取<strong>当前</strong>作业服务器分片上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutionContextService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> ShardingContexts <span class="title">getJobShardingContext</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</div><div class="line">   <span class="comment">// 移除 正在运行中的作业分片项</span></div><div class="line">   removeRunningIfMonitorExecution(liteJobConfig.isMonitorExecution(), shardingItems);</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (shardingItems.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), </div><div class="line">               liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), Collections.&lt;Integer, String&gt;emptyMap());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析分片参数</span></div><div class="line">   Map&lt;Integer, String&gt; shardingItemParameterMap = <span class="keyword">new</span> ShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</div><div class="line">   <span class="comment">// 创建 分片上下文集合</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(buildTaskId(liteJobConfig, shardingItems), <span class="comment">//</span></div><div class="line">           liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div class="line">           liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(),</div><div class="line">           getAssignedShardingItemParameterMap(shardingItems, shardingItemParameterMap)); <span class="comment">// 获得当前作业节点的分片参数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#removeRunningIfMonitorExecution()</code> 方法，移除正在运行中的作业分片项。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeRunningIfMonitorExecution</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> monitorExecution, <span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!monitorExecution) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   List&lt;Integer&gt; runningShardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingItems.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">       <span class="keyword">if</span> (isRunning(each)) &#123;</div><div class="line">           runningShardingItems.add(each); <span class="comment">// /$&#123;JOB_NAME&#125;/sharding/$&#123;ITEM_ID&#125;/running</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   shardingItems.removeAll(runningShardingItems);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> shardingItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(shardingItem));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用 ShardingItemParameters 解析作业分片参数。例如作业分片参数( <code>JobCoreConfiguration.shardingItemParameters=&quot;0=Beijing,1=Shanghai,2=Guangzhou&quot;</code> ) 解析结果：<br>  <img src="http://www.yunai.me/images/Elastic-Job/2017_10_31/04.png" alt=""></p>
<ul>
<li>ShardingItemParameters 代码清晰易懂，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/fd45d3799565f69c6b604db83f78629d8c9a70cd/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/util/config/ShardingItemParameters.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</li>
</ul>
</li>
<li><p>调用 <code>#buildTaskId(...)</code> 方法，创建作业任务ID( <code>ShardingContexts.taskId</code> )：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildTaskId</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> List&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   JobInstance jobInstance = JobRegistry.getInstance().getJobInstance(jobName);</div><div class="line">   <span class="keyword">return</span> Joiner.on(<span class="string">"@-@"</span>).join(liteJobConfig.getJobName(), Joiner.on(<span class="string">","</span>).join(shardingItems), <span class="string">"READY"</span>, </div><div class="line">           <span class="keyword">null</span> == jobInstance.getJobInstanceId() ? <span class="string">"127.0.0.1@-@1"</span> : jobInstance.getJobInstanceId()); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>taskId</code> = <code>${JOB_NAME}</code> + <code>@-@</code> + <code>${SHARDING_ITEMS}</code> + <code>@-@</code> + <code>READY</code> + <code>@-@</code> + <code>${IP}</code> + <code>@-@</code> + <code>${PID}</code>。例如：<code>javaSimpleJob@-@0,1,2@-@READY@-@192.168.3.2@-@38330</code>。</li>
</ul>
</li>
<li><p>调用 <code>#getAssignedShardingItemParameterMap(...)</code> 方法，获得当前作业节点的分片参数。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer, String&gt; <span class="title">getAssignedShardingItemParameterMap</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; shardingItems, <span class="keyword">final</span> Map&lt;Integer, String&gt; shardingItemParameterMap)</span> </span>&#123;</div><div class="line">       Map&lt;Integer, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(shardingItemParameterMap.size(), <span class="number">1</span>);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingItems) &#123;</div><div class="line">           result.put(each, shardingItemParameterMap.get(each));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    ```    </div><div class="line"></div><div class="line">* ShardingContexts，分片上下文集合。</div><div class="line">    ```Java</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContexts</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4585977349142082152L</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业任务ID.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业名称.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 分片总数.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业自定义参数.</div><div class="line">         * 可以配置多个相同的作业, 但是用不同的参数作为不同的调度实例.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 分配于本作业实例的分片项和参数的Map.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; shardingItemParameters;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业事件采样统计数.</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> jobEventSamplingCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 当前作业事件采样统计数.</div><div class="line">         */</div><div class="line">        <span class="meta">@Setter</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentJobEventSamplingCount;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 是否允许可以发送作业事件.</div><div class="line">         */</div><div class="line">        <span class="meta">@Setter</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> allowSendJobEvent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>jobEventSamplingCount</code>，<code>currentJobEventSamplingCount</code> 在 Elastic-Job-Lite 暂未还使用，在 Elastic-Job-Cloud 使用。</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：小伙伴，更新了干货嘛，双击 666。<br>芋道君：那必须的嘛，而且这么勤快更新！是不是应该分享一波朋友圈。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_31/05.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业分片条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业分片策略</title>
    <link href="http://www.yunai.me/Elastic-Job/job-sharding-strategy/"/>
    <id>http://www.yunai.me/Elastic-Job/job-sharding-strategy/</id>
    <published>2017-10-25T16:00:00.000Z</published>
    <updated>2017-08-28T09:43:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 自带作业分片策略</a><ul>
<li><a href="#">2.1 AverageAllocationJobShardingStrategy</a></li>
<li><a href="#">2.2 OdevitySortByNameJobShardingStrategy</a></li>
<li><a href="#">2.3 RotateServerByNameJobShardingStrategy</a></li>
</ul>
</li>
<li><a href="#">3. 自定义作业分片策略</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业分片策略</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_26/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_26/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-自带作业分片策略"><a href="#2-自带作业分片策略" class="headerlink" title="2. 自带作业分片策略"></a>2. 自带作业分片策略</h1><p>JobShardingStrategy，作业分片策略<strong>接口</strong>。分片策略通过实现接口的 <code>#sharding(...)</code> 方法提供作业分片的<strong>计算</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobInstances 所有参与分片的单元列表</div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> shardingTotalCount 分片总数</div><div class="line">     * <span class="doctag">@return</span> 分片结果</div><div class="line">     */</div><div class="line">    Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(List&lt;JobInstance&gt; jobInstances, String jobName, <span class="keyword">int</span> shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Elastic-Job-Lite 提供三种自带的作业分片策略：</p>
<ul>
<li>AverageAllocationJobShardingStrategy：基于平均分配算法的分片策略。</li>
<li>OdevitySortByNameJobShardingStrategy：根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</li>
<li>RotateServerByNameJobShardingStrategy：根据作业名的哈希值对作业节点列表进行轮转的分片策略。</li>
</ul>
<h2 id="2-1-AverageAllocationJobShardingStrategy"><a href="#2-1-AverageAllocationJobShardingStrategy" class="headerlink" title="2.1 AverageAllocationJobShardingStrategy"></a>2.1 AverageAllocationJobShardingStrategy</h2><p>AverageAllocationJobShardingStrategy，基于平均分配算法的分片策略。<strong>Elastic-Job-Lite 默认的作业分片策略</strong>。</p>
<blockquote>
<p>如果分片不能整除，则不能整除的多余分片将依次追加到序号小的作业节点。如：<br>如果有3台作业节点，分成9片，则每台作业节点分到的分片是：1=[0,1,2], 2=[3,4,5], 3=[6,7,8]<br>如果有3台作业节点，分成8片，则每台作业节点分到的分片是：1=[0,1,6], 2=[2,3,7], 3=[4,5]<br>如果有3台作业节点，分成10片，则每台作业节点分到的分片是：1=[0,1,2,9], 2=[3,4,5], 3=[6,7,8]  </p>
</blockquote>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AverageAllocationJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 不存在 作业运行实例</span></div><div class="line">        <span class="keyword">if</span> (jobInstances.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span> Collections.emptyMap();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 分配能被整除的部分</span></div><div class="line">        Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = shardingAliquot(jobInstances, shardingTotalCount);</div><div class="line">        <span class="comment">// 分配不能被整除的部分</span></div><div class="line">        addAliquant(jobInstances, shardingTotalCount, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#shardingAliquot(...)</code> 方法分配能<strong>被整除</strong>的部分。能整除的咱就不举例子。如果有 3 台作业节点，分成 8 片，被整除的部分是前 6 片 [0, 1, 2, 3, 4, 5]，调用该方法结果：1=[0,1], 2=[2,3], 3=[4,5]。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingAliquot(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   Map&lt;JobInstance, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(shardingTotalCount, <span class="number">1</span>);</div><div class="line">   <span class="keyword">int</span> itemCountPerSharding = shardingTotalCount / shardingUnits.size(); <span class="comment">// 每个作业运行实例分配的平均分片数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (JobInstance each : shardingUnits) &#123;</div><div class="line">       List&lt;Integer&gt; shardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(itemCountPerSharding + <span class="number">1</span>);</div><div class="line">       <span class="comment">// 顺序向下分配</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = count * itemCountPerSharding; i &lt; (count + <span class="number">1</span>) * itemCountPerSharding; i++) &#123;</div><div class="line">           shardingItems.add(i);</div><div class="line">       &#125;</div><div class="line">       result.put(each, shardingItems);</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>#addAliquant(...)</code> 方法分配能<strong>不被整除</strong>的部分。继续上面的例子。不能被整除的部分是后 2 片 [6, 7]，调用该方法结果：1=[0,1] + <strong>[6]</strong>, 2=[2,3] + <strong>[7]</strong>, 3=[4,5]。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAliquant</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount, <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> aliquant = shardingTotalCount % shardingUnits.size(); <span class="comment">// 余数</span></div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</div><div class="line">       <span class="keyword">if</span> (count &lt; aliquant) &#123;</div><div class="line">           entry.getValue().add(shardingTotalCount / shardingUnits.size() * shardingUnits.size() + count);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>如何实现主备</strong></p>
<p>通过作业配置设置总分片数为 1 ( <code>JobCoreConfiguration.shardingTotalCount = 1</code> )，只有一个作业分片能够分配到作业分片项，从而达到<strong>一主N备</strong>。</p>
<h2 id="2-2-OdevitySortByNameJobShardingStrategy"><a href="#2-2-OdevitySortByNameJobShardingStrategy" class="headerlink" title="2.2 OdevitySortByNameJobShardingStrategy"></a>2.2 OdevitySortByNameJobShardingStrategy</h2><p>OdevitySortByNameJobShardingStrategy，根据作业名的哈希值奇偶数决定IP升降序算法的分片策略。</p>
<blockquote>
<p>作业名的哈希值为奇数则IP <strong>降序</strong>.<br>作业名的哈希值为偶数则IP <strong>升序</strong>.<br>用于不同的作业平均分配负载至不同的作业节点.<br>如:   </p>
<ol>
<li>如果有3台作业节点, 分成2片, 作业名称的哈希值为奇数, 则每台作业节点分到的分片是: 1=[ ], 2=[1], 3=[0].  </li>
<li>如果有3台作业节点, 分成2片, 作业名称的哈希值为偶数, 则每台作业节点分到的分片是: 1=[0], 2=[1], 3=[ ].</li>
</ol>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">   <span class="keyword">long</span> jobNameHash = jobName.hashCode();</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == jobNameHash % <span class="number">2</span>) &#123;</div><div class="line">       Collections.reverse(jobInstances);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(jobInstances, jobName, shardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>从实现代码上，仿佛和 IP 升降序没什么关系？答案在传递进来的参数 <code>jobInstances</code>。<code>jobInstances</code> 已经是按照 IP 进行<strong>降序</strong>的数组。所以当判断到作业名的哈希值为偶数时，进行数组反转( <code>Collections#reverse(...)</code> )实现按照 IP <strong>升序</strong>。下面看下为什么说<code>jobInstances</code> 已经按照 IP 进行<strong>降序</strong>：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZookeeperRegistryCenter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildrenKeys</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;String&gt; result = client.getChildren().forPath(key);</div><div class="line">       Collections.sort(result, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> String o1, <span class="keyword">final</span> String o2)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</p>
</li>
</ul>
<h2 id="2-3-RotateServerByNameJobShardingStrategy"><a href="#2-3-RotateServerByNameJobShardingStrategy" class="headerlink" title="2.3 RotateServerByNameJobShardingStrategy"></a>2.3 RotateServerByNameJobShardingStrategy</h2><p>RotateServerByNameJobShardingStrategy，根据作业名的哈希值对作业节点列表进行<strong>轮转</strong>的分片策略。这里的<strong>轮转</strong>怎么定义呢？如果有 3 台作业节点，顺序为 [0, 1, 2]，如果作业名的哈希值根据作业分片总数取模为 1, 作业节点顺序变为 [1, 2, 0]。</p>
<p><strong>分片的目的</strong>，是将作业的负载合理的分配到不同的作业节点上，要避免分片策略总是让固定的作业节点负载特别大，其它工作节点负载特别小。这个也是为什么<strong>官方</strong>对比 RotateServerByNameJobShardingStrategy、AverageAllocationJobShardingStrategy 如下：</p>
<blockquote>
<p>AverageAllocationJobShardingStrategy的缺点是，一旦分片数小于作业作业节点数，作业将永远分配至IP地址靠前的作业节点，导致IP地址靠后的作业节点空闲。如：<br>OdevitySortByNameJobShardingStrategy则可以根据作业名称重新分配作业节点负载。<br>如果有3台作业节点，分成2片，作业名称的哈希值为奇数，则每台作业节点分到的分片是：1=[0], 2=[1], 3=[]<br>如果有3台作业节点，分成2片，作业名称的哈希值为偶数，则每台作业节点分到的分片是：3=[0], 2=[1], 1=[]  </p>
</blockquote>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateServerByNameJobShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> AverageAllocationJobShardingStrategy averageAllocationJobShardingStrategy = <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="keyword">return</span> averageAllocationJobShardingStrategy.sharding(rotateServerList(jobInstances, jobName), jobName, shardingTotalCount);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;JobInstance&gt; <span class="title">rotateServerList</span><span class="params">(<span class="keyword">final</span> List&lt;JobInstance&gt; shardingUnits, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> shardingUnitsSize = shardingUnits.size();</div><div class="line">        <span class="keyword">int</span> offset = Math.abs(jobName.hashCode()) % shardingUnitsSize; <span class="comment">// 轮转开始位置</span></div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == offset) &#123;</div><div class="line">            <span class="keyword">return</span> shardingUnits;</div><div class="line">        &#125;</div><div class="line">        List&lt;JobInstance&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingUnitsSize);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingUnitsSize; i++) &#123;</div><div class="line">            <span class="keyword">int</span> index = (i + offset) % shardingUnitsSize;</div><div class="line">            result.add(shardingUnits.get(index));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#rotateServerList(...)</code> 实现作业节点数组<strong>轮转</strong>。</li>
<li>调用 <code>AverageAllocationJobShardingStrategy#sharding(...)</code> 方法完成最终作业分片计算。</li>
</ul>
<h1 id="3-自定义作业分片策略"><a href="#3-自定义作业分片策略" class="headerlink" title="3. 自定义作业分片策略"></a>3. 自定义作业分片策略</h1><p>可能在你的业务场景下，需要实现自定义的作业分片策略。通过定义类实现 JobShardingStrategy 接口即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OOXXShardingStrategy</span> <span class="keyword">implements</span> <span class="title">JobShardingStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; sharding(<span class="keyword">final</span> List&lt;JobInstance&gt; jobInstances, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount) &#123;</div><div class="line">        <span class="comment">// 实现逻辑</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现后，配置实现类的<strong>全路径</strong>到 Lite作业配置( LiteJobConfiguration )的 <code>jobShardingStrategyClass</code> 属性。</p>
<p>作业进行分片计算时，作业分片策略工厂( JobShardingStrategyFactory ) 会创建作业分片策略实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShardingStrategyFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业分片策略实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobShardingStrategyClassName 作业分片策略类名</div><div class="line">     * <span class="doctag">@return</span> 作业分片策略实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobShardingStrategy <span class="title">getStrategy</span><span class="params">(<span class="keyword">final</span> String jobShardingStrategyClassName)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(jobShardingStrategyClassName)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AverageAllocationJobShardingStrategy();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; jobShardingStrategyClass = Class.forName(jobShardingStrategyClassName);</div><div class="line">            <span class="keyword">if</span> (!JobShardingStrategy.class.isAssignableFrom(jobShardingStrategyClass)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Class '%s' is not job strategy class"</span>, jobShardingStrategyClassName);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (JobShardingStrategy) jobShardingStrategyClass.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Sharding strategy class '%s' config error, message details are '%s'"</span>, jobShardingStrategyClassName, ex.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：雾草，刚夸奖你，就又开始水更。<br>芋道君：咳咳咳，作业分片策略炒鸡重要的好不好！嘿嘿嘿，为<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>做个铺垫嘛。</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_26/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 自带作业分片策略&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 主节点选举</title>
    <link href="http://www.yunai.me/Elastic-Job/election/"/>
    <id>http://www.yunai.me/Elastic-Job/election/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-08-28T12:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="">1. 概述</a></li>
<li><a href="">2. 为什么需要选举主节点</a></li>
<li><a href="">3. 选举主节点</a></li>
<li><a href="">4. 删除主节点</a></li>
<li><a href="">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 主节点选举</strong>。</p>
<p>建议前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码分析 —— 作业数据存储》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/?self">《Elastic-Job-Lite 源码分析 —— 注册中心监听器》</a></li>
</ul>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_21/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/01.png" alt=""></p>
<ul>
<li>粉色的类在 <code>com.dangdang.ddframe.job.lite.internal.election</code> 包下，实现了 Elastic-Job-Lite 主节点选举。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-为什么需要选举主节点"><a href="#2-为什么需要选举主节点" class="headerlink" title="2. 为什么需要选举主节点"></a>2. 为什么需要选举主节点</h1><p>首先我们来看一段<strong>官方</strong>对 Elastic-Job-Lite 的介绍：</p>
<blockquote>
<p>Elastic-Job-Lite 定位为轻量级无中心化解决方案，使用 jar 包的形式提供分布式任务的协调服务。</p>
</blockquote>
<p><strong>无中心化</strong>，意味着 Elastic-Job-Lite 不存在<strong>一个中心</strong>执行一些操作，例如：分配作业分片项。Elastic-Job-Lite 选举主节点，通过主节点进行作业分片项分配。目前，必须在主节点执行的操作有：分配作业分片项，调解分布式作业不一致状态。</p>
<p>另外，主节点的选举是以<strong>作业为维度</strong>。例如：有一个 Elastic-Job-Lite 集群有三个作业节点 <code>A</code>、<code>B</code>、<code>C</code>，存在两个作业 <code>a</code>、<code>b</code>，可能 <code>a</code> 作业的主节点是 <code>C</code>，<code>b</code> 作业的主节点是 <code>A</code>。</p>
<h1 id="3-选举主节点"><a href="#3-选举主节点" class="headerlink" title="3. 选举主节点"></a>3. 选举主节点</h1><p>调用 <code>LeaderService#electLeader()</code> 选举主节点。</p>
<p>大体流程如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_21/02.png">打开大图</a> )：<br><img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/02.png" alt=""></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 选举主节点.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">electLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elect a new leader now."</span>);</div><div class="line">   jobNodeStorage.executeInLeader(LeaderNode.LATCH, <span class="keyword">new</span> LeaderElectionExecutionCallback());</div><div class="line">   log.debug(<span class="string">"Leader election completed."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(<span class="keyword">final</span> String latchNode, <span class="keyword">final</span> LeaderExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) &#123;</div><div class="line">       latch.start();</div><div class="line">       latch.await();</div><div class="line">       callback.execute();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LeaderElectionExecutionCallback.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!hasLeader()) &#123; <span class="comment">// 当前无主节点</span></div><div class="line">           jobNodeStorage.fillEphemeralJobNode(LeaderNode.INSTANCE, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>使用 Curator LeaderLatch 分布式锁，<strong>保证同一时间有且仅有一个工作节点</strong>能够调用 <code>LeaderElectionExecutionCallback#execute()</code> 方法执行主节点设置。Curator LeaderLatch 在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》「3.1 在主节点执行操作」</a>有详细解析。</li>
<li><p>在 <code>LeaderElectionExecutionCallback#execute()</code> 为什么要调用 <code>#hasLeader()</code> 呢？LeaderLatch <strong>只保证同一时间有且仅有一个工作节点</strong>，在获得分布式锁的工作节点结束逻辑后，第二个工作节点会开始逻辑，如果不判断当前是否有主节点，原来的主节点会被覆盖。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断是否已经有主节点.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@return</span> 是否已经有主节点</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>选举成功后，Zookeeper 存储<strong>作业</strong>的主节点：<code>/${JOB_NAME}/leader/electron/instance</code> 为当前节点。该节点为<strong>临时</strong>节点。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 7] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@82496</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>选举主节点时机</strong></p>
<p><strong>第一种</strong>，注册作业启动信息时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">   <span class="comment">// 选举 主节点</span></div><div class="line">   leaderService.electLeader();</div><div class="line">   <span class="comment">// .... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>新的作业启动时，即能保证选举出主节点。<ul>
<li>当该作业<strong>不存在</strong>主节点时，当前作业节点<strong>成为</strong>主节点。</li>
<li>当该作业<strong>存在</strong>主节点，当前作业节主节点<strong>不变</strong>。</li>
</ul>
</li>
</ul>
<p><strong>第二种</strong>，节点数据发生变化时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderElectionJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isActiveElection(path, data) || isPassiveElection(path, eventType))) &#123;</div><div class="line">           leaderService.electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>符合重新选举主节点分成两种情况。</li>
<li><p><strong>主动</strong>选举 <code>#isActiveElection(...)</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isActiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> !leaderService.hasLeader() <span class="comment">// 不存在主节点</span></div><div class="line">          &amp;&amp; isLocalServerEnabled(path, data); <span class="comment">// 开启作业</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerEnabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> serverNode.isLocalServerPath(path) </div><div class="line">       &amp;&amp; !ServerStatus.DISABLED.name().equals(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当作业被禁用( <code>LiteJobConfiguration.disabled = true</code> )时，作业是不存在主节点的。那有同学就有疑问了？<code>LeaderService#electLeader()</code> 没做这个限制呀，作业<strong>注册作业启动信息时</strong>也进行了选举。在「4. 删除主节点」小结，我们会解开这个答案。这里大家先记住这个结论。</li>
<li>根据上面我们说的结论，这里就很好理解了，<code>#isActiveElection()</code> 方法判断了两个条件：( 1 ) 不存在主节点；( 2 ) 开启作业，不再禁用，因此需要进行主节点选举落。</li>
<li>这里判断开启作业的方法 <code>#isLocalServerEnabled(...)</code> 有点特殊，它不是通过作业节点是否处于开启状态，而是该数据不是将作业节点更新成关闭状态。举个例子：作业节点处于<strong>禁用</strong>状态，使用<strong>运维平台</strong>设置作业节点开启，会进行主节点选举；作业节点处于<strong>开启</strong>状态，使用<strong>运维平台</strong>设置作业节点禁用，不会进行主节点选举。</li>
</ul>
</li>
<li><p><strong>被动</strong>选举 <code>#isPassiveElection(...)</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPassiveElection</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> isLeaderCrashed(path, eventType) <span class="comment">// 主节点 Crashed</span></div><div class="line">          &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()); <span class="comment">// 当前节点正在运行中（未挂掉）</span></div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaderCrashed</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> leaderNode.isLeaderInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当主节点因为各种情况( 「4. 删除主节点」会列举 )被删除，需要重新进行选举。对的，<strong>必须主节点被删除后才可以重新进行选举</strong>。</li>
<li><code>#isPassiveElection(...)</code> 方法判断了两个条件：( 1 ) 原主节点被删除；( 2 ) 当前节点正在运行中（未挂掉），可以参加主节点选举。</li>
<li><code>#isLeaderCrashed(...)</code> 方法虽然命名带有 <code>Crashed</code> 英文，实际主作业节点<strong>正常</strong>退出也符合<strong>被动</strong>选举条件。</li>
</ul>
</li>
</ul>
<p><strong>等待主节点选举完成</strong></p>
<p>必须在主节点执行的操作，执行之前，需要判断当前节点是否为主节点。如果主节点已经选举好，可以直接进行判断。但是，不排除主节点还没选举到，因而需要阻塞等待到主节点选举完成后才能进行判断。</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断当前节点是否是主节点.</div><div class="line">* </div><div class="line">* 如果主节点正在选举中而导致取不到主节点, 则阻塞至主节点选举完成再返回.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前节点是否是主节点</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeaderUntilBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在主节点 &amp;&amp; 有可用的服务器节点</span></div><div class="line">   <span class="keyword">while</span> (!hasLeader() &amp;&amp; serverService.hasAvailableServers()) &#123;</div><div class="line">       log.info(<span class="string">"Leader is electing, waiting for &#123;&#125; ms"</span>, <span class="number">100</span>);</div><div class="line">       BlockUtils.waitingShortTime();</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) &#123; <span class="comment">// 当前服务器节点可用</span></div><div class="line">           electLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回当前节点是否是主节点</span></div><div class="line">   <span class="keyword">return</span> isLeader();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>BlockUtils#waitingShortTime()</code> 方法，选举不到主节点进行等待，避免不间断、无间隔的进行主节点选举。</li>
</ul>
<h1 id="4-删除主节点"><a href="#4-删除主节点" class="headerlink" title="4. 删除主节点"></a>4. 删除主节点</h1><p>有主节点的选举，必然有主节点的删除，否则怎么进行<strong>重新选举</strong>。</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LeaderService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 删除主节点供重新选举.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLeader</span><span class="params">()</span> </span>&#123;</div><div class="line">   jobNodeStorage.removeJobNodeIfExisted(LeaderNode.INSTANCE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>删除主节点时机</strong></p>
<p><strong>第一种</strong>，主节点进程<strong>正常</strong>关闭时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobShutdownHookPlugin</span> <span class="keyword">extends</span> <span class="title">ShutdownHookPlugin</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        CoordinatorRegistryCenter regCenter = JobRegistry.getInstance().getRegCenter(jobName);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == regCenter) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        LeaderService leaderService = <span class="keyword">new</span> LeaderService(regCenter, jobName);</div><div class="line">        <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">            leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">new</span> InstanceService(regCenter, jobName).removeInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这个比较好理解，退出进程，若该进程为主节点，需要将自己移除。</li>
</ul>
<p><strong>第二种</strong>，主节点进程 CRASHED 时。</p>
<p><code>${JOB_NAME}/leader/electron/instance</code> 是<strong>临时</strong>节点，主节点进程 CRASHED 后，超过最大会话时间，Zookeeper 自动进行删除，触发重新选举逻辑。</p>
<p><strong>第三种</strong>，作业被<strong>禁用</strong>时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeaderAbdicationJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (leaderService.isLeader() &amp;&amp; isLocalServerDisabled(path, data)) &#123;</div><div class="line">           leaderService.removeLeader();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocalServerDisabled</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> serverNode.isLocalServerPath(path) &amp;&amp; ServerStatus.DISABLED.name().equals(data);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这里就解答上面我们遗留的疑问。被禁用的作业<strong>注册作业启动信息时</strong>即使进行了主节点选举，也会被该监听器处理，移除该选举的主节点。</li>
</ul>
<p><strong>第四种</strong>，主节点进程<strong>远程</strong>关闭。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceShutdownStatusJobListener.java</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceShutdownStatusJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)</div><div class="line">               &amp;&amp; !JobRegistry.getInstance().getJobScheduleController(jobName).isPaused() <span class="comment">// 作业未暂停调度</span></div><div class="line">               &amp;&amp; isRemoveInstance(path, eventType) <span class="comment">// 移除【运行实例】事件</span></div><div class="line">               &amp;&amp; !isReconnectedRegistryCenter()) &#123; <span class="comment">// 运行实例被移除</span></div><div class="line">           schedulerFacade.shutdownInstance();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRemoveInstance</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceNode.isLocalInstancePath(path) &amp;&amp; Type.NODE_REMOVED == eventType;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isReconnectedRegistryCenter</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> instanceService.isLocalJobInstanceExisted();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 终止作业调度.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (leaderService.isLeader()) &#123;</div><div class="line">       leaderService.removeLeader(); <span class="comment">// 移除主节点</span></div><div class="line">   &#125;</div><div class="line">   monitorService.close();</div><div class="line">   <span class="keyword">if</span> (reconcileService.isRunning()) &#123;</div><div class="line">       reconcileService.stopAsync();</div><div class="line">   &#125;</div><div class="line">   JobRegistry.getInstance().shutdown(jobName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>远程</strong>关闭作业节点有两种方式：<ul>
<li>zkClient 发起命令：<code>rmr /${NAMESPACE}/${JOB_NAME}/instances/${JOB_INSTANCE_ID}</code>。</li>
<li>运维平台发起 <code>Shutdown</code> 操作。<code>Shutdown</code> 操作实质上就是第一种。<br>  <img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/04.png" alt=""></li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：哎哟，这次竟然分享了点干货 😈<br>芋道君：嘿呀嘿呀，必须的啊，虽然有点焦头烂额啦。  </p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_21/03.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;2. 为什么需要选举主节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 注册中心监听器</title>
    <link href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/"/>
    <id>http://www.yunai.me/Elastic-Job/reg-center-zookeeper-listener/</id>
    <published>2017-10-13T16:00:00.000Z</published>
    <updated>2017-08-28T09:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. ListenerManager</a></li>
<li><a href="#">3. AbstractListenerManager</a></li>
<li><a href="#">4. AbstractJobListener</a></li>
<li><a href="#">5. RegistryCenterConnectionStateListener</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 注册中心监听器</strong>。</p>
<p>建议前置阅读：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》</a></li>
</ul>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_14/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_14/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-ListenerManager"><a href="#2-ListenerManager" class="headerlink" title="2. ListenerManager"></a>2. ListenerManager</h1><p>ListenerManager，作业注册中心的监听器管理者。管理者<strong>两类</strong>组件：</p>
<ul>
<li>监听管理器</li>
<li>注册中心连接状态监听器</li>
</ul>
<p>其中<strong>监听管理器</strong>管理着自己的作业注册中心监听器。</p>
<p>一起从代码层面看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElectionListenerManager electionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingListenerManager shardingListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverListenerManager failoverListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorExecutionListenerManager monitorExecutionListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShutdownListenerManager shutdownListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TriggerListenerManager triggerListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RescheduleListenerManager rescheduleListenerManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GuaranteeListenerManager guaranteeListenerManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryCenterConnectionStateListener regCenterConnectionStateListener;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>第一类：<code>electionListenerManager</code> / <code>shardingListenerManager</code> / <code>failoverListenerManager</code> / <code>MonitorExecutionListenerManager</code> / <code>shutdownListenerManager</code> / <code>triggerListenerManager</code> / <code>rescheduleListenerManager</code> / <code>guaranteeListenerManager</code> 是不同服务的<strong>监听管理器</strong>，都继承<strong>作业注册中心的监听器管理者的抽象类</strong>( AbstractListenerManager )。我们以下一篇文章会涉及到的<strong>分片监听管理器</strong>( ShardingListenerManager ) 来瞅瞅内部整体实现：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ShardingListenerManager 内部管理了 ShardingTotalCountChangedJobListener / ListenServersChangedJobListener 两个作业注册中心监听器。具体作业注册中心监听器是什么，有什么用途，下文会详细解析。</li>
</ul>
</li>
<li>第二类：<code>regCenterConnectionStateListener</code> 是注册中心连接状态监听器。下文也会详细解析。</li>
</ul>
<p>在<a href="http://www.yunai.me/Elastic-Job/job-init?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「3.2.4」注册作业启动信息</a>，我们看到作业初始化时，会开启所有注册中心监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 所有监听器</span></div><div class="line">   listenerManager.startAllListeners();</div><div class="line">   <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ListenerManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 开启所有监听器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAllListeners</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 不同服务监听管理器</span></div><div class="line">   electionListenerManager.start();</div><div class="line">   shardingListenerManager.start();</div><div class="line">   failoverListenerManager.start();</div><div class="line">   monitorExecutionListenerManager.start();</div><div class="line">   shutdownListenerManager.start();</div><div class="line">   triggerListenerManager.start();</div><div class="line">   rescheduleListenerManager.start();</div><div class="line">   guaranteeListenerManager.start();</div><div class="line">   <span class="comment">// 开启 注册中心连接状态监听器</span></div><div class="line">   jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-AbstractListenerManager"><a href="#3-AbstractListenerManager" class="headerlink" title="3. AbstractListenerManager"></a>3. AbstractListenerManager</h1><p>AbstractListenerManager，作业注册中心的监听器管理者的<strong>抽象类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractListenerManager</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开启监听器.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加注册中心监听器</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> listener 注册中心监听器</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addDataListener</span><span class="params">(<span class="keyword">final</span> TreeCacheListener listener)</span> </span>&#123;</div><div class="line">        jobNodeStorage.addDataListener(listener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#addDataListener()</code>，将作业注册中心的监听器添加到注册中心 TreeCache 的监听者里。<code>JobNodeStorage#addDataListener(...)</code> 在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》「2.2」缓存</a>已经详细解析。</li>
<li><p>子类实现 <code>#start()</code> 方法实现监听器初始化。目前所有子类的实现都是将自己管理的注册中心监听器调用 <code>#addDataListener(...)</code>，还是以 ShardingListenerManager 举例子：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        addDataListener(<span class="keyword">new</span> ShardingTotalCountChangedJobListener());</div><div class="line">        addDataListener(<span class="keyword">new</span> ListenServersChangedJobListener());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="4-AbstractJobListener"><a href="#4-AbstractJobListener" class="headerlink" title="4. AbstractJobListener"></a>4. AbstractJobListener</h1><p>AbstractJobListener，作业注册中心的监听器<strong>抽象类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJobListener</span> <span class="keyword">implements</span> <span class="title">TreeCacheListener</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ChildData childData = event.getData();</div><div class="line">        <span class="comment">// 忽略掉非数据变化的事件，例如 event.type 为 CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == childData) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        String path = childData.getPath();</div><div class="line">        <span class="keyword">if</span> (path.isEmpty()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        dataChanged(path, event.getType(), <span class="keyword">null</span> == childData.getData() ? <span class="string">""</span> : <span class="keyword">new</span> String(childData.getData(), Charsets.UTF_8));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 节点数据变化</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> path 节点路径</div><div class="line">     * <span class="doctag">@param</span> eventType 事件类型</div><div class="line">     * <span class="doctag">@param</span> data 数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>作业注册中心的监听器<strong>实现类</strong>实现 <code>#dataChanged(...)</code>，对节点数据变化进行处理。</li>
<li><code>#childEvent(...)</code> 屏蔽掉非节点数据变化事件，例如：CONNECTION_SUSPENDED、CONNECTION_RECONNECTED、CONNECTION_LOST、INITIALIZED 事件，只处理 NODE_ADDED、NODE_UPDATED、NODE_REMOVED 事件。</li>
</ul>
<p>我们再拿 ShardingListenerManager 举例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingListenerManager</span> <span class="keyword">extends</span> <span class="title">AbstractListenerManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ShardingTotalCountChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (configNode.isConfigPath(path) &amp;&amp; <span class="number">0</span> != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                <span class="keyword">int</span> newShardingTotalCount = LiteJobConfigurationGsonFactory.fromJson(data).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">                <span class="keyword">if</span> (newShardingTotalCount != JobRegistry.getInstance().getCurrentShardingTotalCount(jobName)) &#123;</div><div class="line">                    shardingService.setReshardingFlag();</div><div class="line">                    JobRegistry.getInstance().setCurrentShardingTotalCount(jobName, newShardingTotalCount);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isInstanceChange(eventType, path) || isServerChange(path))) &#123;</div><div class="line">                shardingService.setReshardingFlag();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> serverNode.isServerPath(path);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 任务分片》</a>详细解析。</li>
</ul>
<h1 id="5-RegistryCenterConnectionStateListener"><a href="#5-RegistryCenterConnectionStateListener" class="headerlink" title="5. RegistryCenterConnectionStateListener"></a>5. RegistryCenterConnectionStateListener</h1><p>RegistryCenterConnectionStateListener，实现 Curator ConnectionStateListener 接口，注册中心连接状态监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryCenterConnectionStateListener</span> <span class="keyword">implements</span> <span class="title">ConnectionStateListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">final</span> CuratorFramework client, <span class="keyword">final</span> ConnectionState newState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</div><div class="line">        <span class="keyword">if</span> (ConnectionState.SUSPENDED == newState || ConnectionState.LOST == newState) &#123; <span class="comment">// Zookeeper 连接终端 或 连接丢失</span></div><div class="line">            <span class="comment">// 暂停作业调度</span></div><div class="line">            jobScheduleController.pauseJob();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConnectionState.RECONNECTED == newState) &#123; <span class="comment">// Zookeeper 重新连上</span></div><div class="line">            <span class="comment">// 持久化作业服务器上线信息</span></div><div class="line">            serverService.persistOnline(serverService.isEnableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp()));</div><div class="line">            <span class="comment">// 持久化作业运行实例上线相关信息</span></div><div class="line">            instanceService.persistOnline();</div><div class="line">            <span class="comment">// 清除本地分配的作业分片项运行中的标记</span></div><div class="line">            executionService.clearRunningInfo(shardingService.getLocalShardingItems());</div><div class="line">            <span class="comment">// 恢复作业调度</span></div><div class="line">            jobScheduleController.resumeJob();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>当注册中心连接 SUSPENDED 或 LOST 时，暂停<strong>本地</strong>作业调度：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduleController.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pauseJob</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">           scheduler.pauseAll();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当注册中心重新连接成功( RECONNECTED )，恢复<strong>本地</strong>作业调度：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 恢复作业.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resumeJob</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!scheduler.isShutdown()) &#123;</div><div class="line">          scheduler.resumeAll();</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：芋道君，你又水更了！<br>芋道君：是是是，是是是！</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_14/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. ListenerManager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业数据存储</title>
    <link href="http://www.yunai.me/Elastic-Job/job-storage/"/>
    <id>http://www.yunai.me/Elastic-Job/job-storage/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2017-08-28T09:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-jobnodepath">2. JobNodePath</a></li>
<li><a href="#3-jobnodestorage">3. JobNodeStorage</a></li>
<li><a href="#4-configurationnode">4. ConfigurationNode</a></li>
<li><a href="#5-servernode">5. ServerNode</a></li>
<li><a href="#6-instancenode">6. InstanceNode</a></li>
<li><a href="#7-shardingnode">7. ShardingNode</a></li>
<li><a href="#8-leadernode">8. LeaderNode</a></li>
<li><a href="#9-failovernode">9. FailoverNode</a></li>
<li><a href="#10-guaranteenode">10. GuaranteeNode</a></li>
<li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业数据存储</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_10_07/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_07/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-JobNodePath"><a href="#2-JobNodePath" class="headerlink" title="2. JobNodePath"></a>2. JobNodePath</h1><p>JobNodePath，作业节点路径类。<strong>作业节点是在普通的节点前加上作业名称的前缀</strong>。</p>
<p>在 Zookeeper 看一个作业的数据存储：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 65] ls /elastic-job-example-lite-java/javaSimpleJob</div><div class="line">[leader, servers, config, instances, sharding]</div></pre></td></tr></table></figure>
<ul>
<li><code>elastic-job-example-lite-java</code>：作业节点集群名，使用 <code>ZookeeperConfiguration.namespace</code> 属性配置。</li>
<li><code>javaSimpleJob</code>：作业名字，使用 <code>JobCoreConfiguration.jobName</code> 属性配置。</li>
<li><code>config</code> / <code>servers</code> / <code>instances</code> / <code>sharding</code> / <code>leader</code>：不同服务的数据存储节点路径。</li>
</ul>
<p>JobNodePath，注释很易懂，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。这里我们梳理下 JobNodePath 和<strong>其它节点路径类</strong>的关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Zookeeper 路径</th>
<th style="text-align:left">JobNodePath 静态属性</th>
<th style="text-align:left">JobNodePath 方法</th>
<th style="text-align:left">节点路径类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>config</code></td>
<td style="text-align:left">CONFIG_NODE</td>
<td style="text-align:left"><code>#getConfigNodePath()</code></td>
<td style="text-align:left">ConfigurationNode</td>
</tr>
<tr>
<td style="text-align:left"><code>servers</code></td>
<td style="text-align:left">SERVERS_NODE</td>
<td style="text-align:left"><code>#getServerNodePath()</code></td>
<td style="text-align:left">ServerNode</td>
</tr>
<tr>
<td style="text-align:left"><code>instances</code></td>
<td style="text-align:left">INSTANCES_NODE</td>
<td style="text-align:left"><code>#getInstancesNodePath()</code></td>
<td style="text-align:left">InstanceNode</td>
</tr>
<tr>
<td style="text-align:left"><code>sharding</code></td>
<td style="text-align:left">SHARDING_NODE</td>
<td style="text-align:left"><code>#getShardingNodePath()</code></td>
<td style="text-align:left">ShardingNode</td>
</tr>
<tr>
<td style="text-align:left"><code>leader</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">LeaderNode</td>
</tr>
<tr>
<td style="text-align:left"><code>leader/failover</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">FailoverNode</td>
</tr>
<tr>
<td style="text-align:left"><code>guarantee</code></td>
<td style="text-align:left">/</td>
<td style="text-align:left"><code>#getFullPath(node)</code></td>
<td style="text-align:left">GuaranteeNode</td>
</tr>
</tbody>
</table>
<h1 id="3-JobNodeStorage"><a href="#3-JobNodeStorage" class="headerlink" title="3. JobNodeStorage"></a>3. JobNodeStorage</h1><p>JobNodeStorage，作业节点数据访问类。</p>
<p>Elastic-Job-Lite 使用<strong>注册中心</strong>存储作业节点数据，JobNodeStorage 对注册中心提供的方法做下简单的封装提供调用。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> JobNodePath jobNodePath;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 判断作业节点是否存在.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 作业节点名称</div><div class="line">* <span class="doctag">@return</span> 作业节点是否存在</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isJobNodeExisted</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> regCenter.isExisted(jobNodePath.getFullPath(node));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobNodePath.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取节点全路径.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> node 节点名称</div><div class="line">* <span class="doctag">@return</span> 节点全路径</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFullPath</span><span class="params">(<span class="keyword">final</span> String node)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> String.format(<span class="string">"/%s/%s"</span>, jobName, node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>传递的参数 <code>node</code> 只是简单的<strong>作业节点名称</strong>，通过调用 <code>JobNodePath#getFullPath(...)</code> 方法获取节点全路径。</li>
<li>其它方法类似，有兴趣的同学点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/storage/JobNodePath.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</li>
</ul>
<h1 id="4-ConfigurationNode"><a href="#4-ConfigurationNode" class="headerlink" title="4. ConfigurationNode"></a>4. ConfigurationNode</h1><p>ConfigurationNode，配置节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>配置</strong>节点数据存储：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 67] get /elastic-job-example-lite-java/javaSimpleJob/config</div><div class="line">&#123;<span class="string">"jobName"</span>:<span class="string">"javaSimpleJob"</span>,<span class="string">"jobClass"</span>:<span class="string">"com.dangdang.ddframe.job.example.job.simple.JavaSimpleJob"</span>,<span class="string">"jobType"</span>:<span class="string">"SIMPLE"</span>,<span class="string">"cron"</span>:<span class="string">"0/5 * * * * ?"</span>,<span class="string">"shardingTotalCount"</span>:3,<span class="string">"shardingItemParameters"</span>:<span class="string">"0\u003dBeijing,1\u003dShanghai,2\u003dGuangzhou"</span>,<span class="string">"jobParameter"</span>:<span class="string">""</span>,<span class="string">"failover"</span>:<span class="literal">true</span>,<span class="string">"misfire"</span>:<span class="literal">true</span>,<span class="string">"description"</span>:<span class="string">""</span>,<span class="string">"jobProperties"</span>:&#123;<span class="string">"job_exception_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler"</span>,<span class="string">"executor_service_handler"</span>:<span class="string">"com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler"</span>&#125;,<span class="string">"monitorExecution"</span>:<span class="literal">true</span>,<span class="string">"maxTimeDiffSeconds"</span>:-1,<span class="string">"monitorPort"</span>:-1,<span class="string">"jobShardingStrategyClass"</span>:<span class="string">""</span>,<span class="string">"reconcileIntervalMinutes"</span>:10,<span class="string">"disabled"</span>:<span class="literal">false</span>,<span class="string">"overwrite"</span>:<span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>/config</code> 是<strong>持久</strong>节点，存储Lite作业配置( LiteJobConfiguration ) JSON化字符串。</li>
</ul>
<p>ConfigurationNode 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"config"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConfigurationNode 如何读取、存储，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.」作业配置服务</a>已经详细解析。</p>
<h1 id="5-ServerNode"><a href="#5-ServerNode" class="headerlink" title="5. ServerNode"></a>5. ServerNode</h1><p>ServerNode，服务器节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>服务器</strong>节点数据存储： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 72] ls /elastic-job-example-lite-java/javaSimpleJob/servers</div><div class="line">[192.168.16.164, 169.254.93.156, 192.168.252.57, 192.168.16.137, 192.168.3.2, 192.168.43.31]</div><div class="line">[zk: localhost:2181(CONNECTED) 73] get /elastic-job-example-lite-java/javaSimpleJob/servers/192.168.16.164</div></pre></td></tr></table></figure>
<ul>
<li><code>/servers/</code> 目录下以 <code>IP</code> 为数据节点路径存储每个服务器节点。如果<strong>相同IP</strong>服务器有多个服务器节点，只存储一个 <code>IP</code> 数据节点。</li>
<li><code>/servers/${IP}</code> 是<strong>持久</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</li>
</ul>
<p>ServerNode 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 服务器信息根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"servers"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVERS = ROOT + <span class="string">"/%s"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ServerNode 如何存储，在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p>
<h1 id="6-InstanceNode"><a href="#6-InstanceNode" class="headerlink" title="6. InstanceNode"></a>6. InstanceNode</h1><p>InstanceNode，运行实例节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>运行实例</strong>节点数据存储： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 81] ls /elastic-job-example-lite-java/javaSimpleJob/instances</div><div class="line">[192.168.16.137@-@56010]</div><div class="line">[zk: localhost:2181(CONNECTED) 82] get /elastic-job-example-lite-java/javaSimpleJob/instances</div></pre></td></tr></table></figure>
<ul>
<li><code>/instances</code> 目录下以作业实例主键( <code>JOB_INSTANCE_ID</code> ) 为数据节点路径存储每个运行实例节点。</li>
<li><code>/instances/${JOB_INSTANCE_ID}</code> 是<strong>临时</strong>节点，不存储任何信息，只是空串( <code>&quot;&quot;</code>);</li>
<li><p><code>JOB_INSTANCE_ID</code> 生成方式：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobInstance.java</span></div><div class="line"></div><div class="line">jobInstanceId = IpUtils.getIp()</div><div class="line">                + DELIMITER</div><div class="line">                + ManagementFactory.getRuntimeMXBean().getName().split(<span class="string">"@"</span>)[<span class="number">0</span>]; <span class="comment">// PID</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>InstanceNode 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 运行实例信息根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"instances"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCES = ROOT + <span class="string">"/%s"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取当前运行实例节点路径</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 当前运行实例节点路径</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">getLocalInstanceNode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(INSTANCES, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InstanceNode 如何存储，在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.4」注册作业启动信息</a>已经详细解析。</p>
<h1 id="7-ShardingNode"><a href="#7-ShardingNode" class="headerlink" title="7. ShardingNode"></a>7. ShardingNode</h1><p>ShardingNode，分片节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>分片</strong>节点数据存储： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/sharding</div><div class="line">[0, 1, 2]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /elastic-job-example-lite-java/javaSimpleJob/sharding/0</div><div class="line">[running, instance, misfire]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-example-lite-java/javaSimpleJob/sharding/0/instance</div><div class="line">192.168.16.137@-@56010</div></pre></td></tr></table></figure>
<ul>
<li><code>/sharding/${ITEM_ID}</code> 目录下以作业分片项序号( <code>ITEM_ID</code> ) 为数据节点路径存储作业分片项的 <code>instance</code> / <code>running</code> / <code>misfire</code> / <code>disable</code> <strong>数据节点</strong>信息。</li>
<li><code>/sharding/${ITEM_ID}/instance</code> 是<strong>临时</strong>节点，存储该作业分片项<strong>分配到的作业实例主键</strong>( <code>JOB_INSTANCE_ID</code> )。在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li>
<li><code>/sharding/${ITEM_ID}/running</code> 是<strong>临时</strong>节点，当该作业分片项<strong>正在运行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>不在运行</strong>，移除该数据节点。<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.6」执行普通触发的作业</a>已经详细解析。</li>
<li><code>/sharding/${ITEM_ID}/misfire</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被错过执行</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项重新执行，移除该数据节点。<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》的「4.7」执行被错过触发的作业</a>已经详细解析。</li>
<li><code>/sharding/${ITEM_ID}/disable</code> 是<strong>永久节点</strong>，当该作业分片项<strong>被禁用</strong>，存储空串( <code>&quot;&quot;</code> )；当该作业分片项<strong>被开启</strong>，移除数据节点。</li>
</ul>
<p>ShardingNode，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行状态根节点.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"sharding"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE_APPENDIX = <span class="string">"instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ROOT + <span class="string">"/%s/"</span> + INSTANCE_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_APPENDIX = <span class="string">"running"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING = ROOT + <span class="string">"/%s/"</span> + RUNNING_APPENDIX;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MISFIRE = ROOT + <span class="string">"/%s/misfire"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DISABLED = ROOT + <span class="string">"/%s/disabled"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + ROOT;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String NECESSARY = LEADER_ROOT + <span class="string">"/necessary"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PROCESSING = LEADER_ROOT + <span class="string">"/processing"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>LEADER_ROOT / NECESSARY / PROCESSING 放在「4.7」<strong>LeaderNode</strong> 解析。</li>
</ul>
<h1 id="8-LeaderNode"><a href="#8-LeaderNode" class="headerlink" title="8. LeaderNode"></a>8. LeaderNode</h1><p>LeaderNode，主节点路径。</p>
<p>在 <code>leader</code> 目录下一共有三个存储子节点：</p>
<ul>
<li><code>election</code>：主节点选举。</li>
<li><code>sharding</code>：作业分片项分配。</li>
<li><code>failover</code>：作业失效转移。</li>
</ul>
<p><strong>主节点选举</strong></p>
<p>在 Zookeeper 看一个作业的 <strong><code>leader/election</code></strong> 节点数据存储： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/election</div><div class="line">[latch, instance]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] get /elastic-job-example-lite-java/javaSimpleJob/leader/election/instance</div><div class="line">192.168.16.137@-@1910</div></pre></td></tr></table></figure>
<ul>
<li><code>/leader/election/instance</code> 是<strong>临时</strong>节点，当作业集群完成选举后，存储主作业实例主键( <code>JOB_INSTANCE_ID</code> )。</li>
<li><code>/leader/election/latch</code> 主节点选举分布式锁，是 Apache Curator 针对 Zookeeper 实现的<strong>分布式锁</strong>的一种，笔者暂未了解存储形式，无法解释。在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码分析 —— 注册中心》的「3.1」在主节点执行操作</a>进行了简单解析。</li>
</ul>
<p><strong>作业分片项分配</strong></p>
<p>在 Zookeeper 看一个作业的 <strong><code>leader/sharding</code></strong> 节点数据存储： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line">[necessary, processing]</div><div class="line">[zk: localhost:2181(CONNECTED) 2] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/sharding</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] 个get /elastic-job-example-lite-java/javaSimpleJob/leader/processing</div></pre></td></tr></table></figure>
<ul>
<li><code>/leader/sharding/necessary</code> 是<strong>永久节点</strong>，当<strong>相同作业</strong>有新的作业节点加入或者移除时，存储空串( <code>&quot;&quot;</code> )，标记需要进行作业分片项重新分配；当重新分配完成后，移除该数据节点。</li>
<li><code>/leader/sharding/processing</code> 是<strong>临时节点</strong>，当开始重新分配作业分片项时，存储空串( <code>&quot;&quot;</code> )，标记正在进行重新分配；当重新分配完成后，移除该数据节点。</li>
<li>当且仅当作业节点为主节点时，才可以执行作业分片项分配，<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码分析 —— 作业分片》</a>详细解析。</li>
</ul>
<p><strong>作业失效转移</strong></p>
<p>作业失效转移数据节点在 FailoverNode，放在「9」<strong>FailoverNode</strong> 解析。</p>
<p>这里大家可能会和我一样比较疑惑，为什么 <code>/leader/failover</code> 放在 <code>/leader</code> 目录下，而不独立成为一个根目录？经过确认，<strong>作业失效转移</strong> 设计到分布式锁，统一存储在 <code>/leader</code> 目录下。</p>
<hr>
<p>LeaderNode，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主节点根路径.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = <span class="string">"leader"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ELECTION_ROOT = ROOT + <span class="string">"/election"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String INSTANCE = ELECTION_ROOT + <span class="string">"/instance"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String  LATCH = ELECTION_ROOT + <span class="string">"/latch"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="9-FailoverNode"><a href="#9-FailoverNode" class="headerlink" title="9. FailoverNode"></a>9. FailoverNode</h1><p>FailoverNode，失效转移节点路径。</p>
<p>在 Zookeeper 看一个作业的<strong>失效转移</strong>节点数据存储： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover</div><div class="line">[latch, items]</div><div class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>] ls /elastic-job-example-lite-java/javaSimpleJob/leader/failover/items</div><div class="line">[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<ul>
<li><code>/leader/failover/latch</code> 作业失效转移分布式锁，和 <code>/leader/failover/latch</code> 是一致的。</li>
<li><code>/leader/items/${ITEM_ID}</code> 是<strong>永久节点</strong>，当某台作业节点 CRASH 时，其分配的作业分片项标记需要进行失效转移，存储其分配的作业分片项的 <code>/leader/items/${ITEM_ID}</code> 为空串( <code>&quot;&quot;</code> )；当失效转移标记，移除 <code>/leader/items/${ITEM_ID}</code>，存储 <code>/sharding/${ITEM_ID}/failover</code> 为空串( <code>&quot;&quot;</code> )，<strong>临时</strong>节点，需要进行失效转移执行。<a href="http://www.yunai.me/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码分析 —— 作业失效转移》</a>详细解析。</li>
</ul>
<p>FailoverNode 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER = <span class="string">"failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEADER_ROOT = LeaderNode.ROOT + <span class="string">"/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS_ROOT = LEADER_ROOT + <span class="string">"/items"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ITEMS = ITEMS_ROOT + <span class="string">"/%s"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LATCH = LEADER_ROOT + <span class="string">"/latch"</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTION_FAILOVER = ShardingNode.ROOT + <span class="string">"/%s/"</span> + FAILOVER;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getItemsNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(ITEMS, item);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getExecutionFailoverNode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.format(EXECUTION_FAILOVER, item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="10-GuaranteeNode"><a href="#10-GuaranteeNode" class="headerlink" title="10. GuaranteeNode"></a>10. GuaranteeNode</h1><p>GuaranteeNode，保证分布式任务全部开始和结束状态节点路径。在<a href="http://www.yunai.me/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码分析 —— 作业监听器》</a>详细解析。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：芋道君，你又水更了！<br>芋道君：屁屁屁，劳资怼死你！如下是作业数据存储整理，哼哼哈兮！</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_10_07/02.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-jobnodepath&quot;&gt;2.
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 注册中心</title>
    <link href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/"/>
    <id>http://www.yunai.me/Elastic-Job/reg-center-zookeeper/</id>
    <published>2017-09-29T16:00:00.000Z</published>
    <updated>2017-08-25T07:44:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 基于 Zookeeper 注册中心</a><ul>
<li><a href="#">2.1 初始化</a></li>
<li><a href="#">2.2 缓存</a></li>
<li><a href="#">2.3 关闭</a></li>
<li><a href="#">2.4 获得数据</a></li>
<li><a href="#">2.5 获得注册子节点</a></li>
<li><a href="#">2.6 存储注册数据</a></li>
<li><a href="#">2.7 存储顺序注册数据</a></li>
<li><a href="#">2.8 移除注册数据</a></li>
<li><a href="#">2.9 获取注册中心当前时间</a></li>
<li><a href="#">2.10 注册中心异常处理器</a></li>
</ul>
</li>
<li><a href="#">3. 作业节点数据访问类</a><ul>
<li><a href="#">3.1 在主节点执行操作</a></li>
<li><a href="#">3.2 在事务中执行操作</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 注册中心</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_30/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_30/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>注册中心类。</li>
<li>作业节点数据访问类( JobNodeStorage )的<strong>在主节点执行操作</strong>、<strong>在事务中执行操作</strong>两个方法和注册中心<strong>协调分布式服务</strong>有关系，从<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>摘出来，放本文解析。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-基于-Zookeeper-注册中心"><a href="#2-基于-Zookeeper-注册中心" class="headerlink" title="2. 基于 Zookeeper 注册中心"></a>2. 基于 Zookeeper 注册中心</h1><p>ZookeeperRegistryCenter，基于 Zookeeper 注册中心。从上面的类图可以看到，ZookeeperRegistryCenter 实现 CoordinatorRegistryCenter 接口，CoordinatorRegistryCenter 继承 RegistryCenter 接口。</p>
<ul>
<li>RegistryCenter，注册中心，定义了简单的增删改查注册数据和查询时间的接口方法。</li>
<li>CoordinatorRegistryCenter，用于协调分布式服务的注册中心，定义了持久节点、临时节点、持久顺序节点、临时顺序节点等<strong>目录服务</strong>接口方法，隐性的要求提供<strong>事务</strong>、<strong>分布式锁</strong>、<strong>数据订阅</strong>等特性。</li>
</ul>
<p>ZookeeperRegistryCenter 使用 <a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 进行 Zookeeper 注册中心。</p>
<h2 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h2><p>ZookeeperConfiguration，基于 Zookeeper 的注册中心配置，注释完整，点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/reg/zookeeper/ZookeeperConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   log.debug(<span class="string">"Elastic job: zookeeper registry center init, server lists is: &#123;&#125;."</span>, zkConfig.getServerLists());</div><div class="line">   CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</div><div class="line">           .connectString(zkConfig.getServerLists())</div><div class="line">           .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(zkConfig.getBaseSleepTimeMilliseconds(), zkConfig.getMaxRetries(), zkConfig.getMaxSleepTimeMilliseconds()))</div><div class="line">           .namespace(zkConfig.getNamespace()); <span class="comment">// 命名空间</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> != zkConfig.getSessionTimeoutMilliseconds()) &#123;</div><div class="line">       builder.sessionTimeoutMs(zkConfig.getSessionTimeoutMilliseconds()); <span class="comment">// 会话超时时间，默认 60 * 1000 毫秒</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> != zkConfig.getConnectionTimeoutMilliseconds()) &#123;</div><div class="line">       builder.connectionTimeoutMs(zkConfig.getConnectionTimeoutMilliseconds()); <span class="comment">// 连接超时时间，默认 15 * 1000 毫秒</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 认证</span></div><div class="line">   <span class="keyword">if</span> (!Strings.isNullOrEmpty(zkConfig.getDigest())) &#123;</div><div class="line">       builder.authorization(<span class="string">"digest"</span>, zkConfig.getDigest().getBytes(Charsets.UTF_8))</div><div class="line">               .aclProvider(<span class="keyword">new</span> ACLProvider() &#123;</div><div class="line">               </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> List&lt;ACL&gt; <span class="title">getDefaultAcl</span><span class="params">()</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> ZooDefs.Ids.CREATOR_ALL_ACL;</div><div class="line">                   &#125;</div><div class="line">               </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> List&lt;ACL&gt; <span class="title">getAclForPath</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> ZooDefs.Ids.CREATOR_ALL_ACL;</div><div class="line">                   &#125;</div><div class="line">               &#125;);</div><div class="line">   &#125;</div><div class="line">   client = builder.build();</div><div class="line">   client.start();</div><div class="line">   <span class="comment">// 连接 Zookeeper</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!client.blockUntilConnected(zkConfig.getMaxSleepTimeMilliseconds() * zkConfig.getMaxRetries(), TimeUnit.MILLISECONDS)) &#123;</div><div class="line">           client.close();</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> KeeperException.OperationTimeoutException();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ExponentialBackoffRetry，当 Zookeeper 失去链接后重新连接的<strong>一种</strong>策略：动态计算每次计算重连的间隔，时间间隔 = <code>baseSleepTimeMs * Math.max(1, random.nextInt(1 &lt;&lt; (retryCount + 1)))</code>。如果对其它重连策略感兴趣，可以看 <a href="https://github.com/apache/curator/blob/abaabb5f65c2161f77527165a15d2420f6c88219/curator-client/src/main/java/org/apache/curator/RetryPolicy.java" rel="external nofollow noopener noreferrer" target="_blank">RetryPolicy</a> 的实现类，本文就不展开了。</li>
<li><strong>相同</strong>的作业集群使用<strong>相同</strong>的 Zookeeper 命名空间( <code>ZookeeperConfiguration.namespace</code> )。</li>
</ul>
<h2 id="2-2-缓存"><a href="#2-2-缓存" class="headerlink" title="2.2 缓存"></a>2.2 缓存</h2><p>通过 Curator TreeCache 实现监控整个树( Zookeeper目录 )的数据订阅和缓存，包括节点的状态，子节点的状态。</p>
<p><strong>初始化作业缓存</strong></p>
<p>作业初始化注册时，初始化缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJob</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobScheduleController jobScheduleController, <span class="keyword">final</span> CoordinatorRegistryCenter regCenter)</span> </span>&#123;</div><div class="line">   schedulerMap.put(jobName, jobScheduleController);</div><div class="line">   regCenterMap.put(jobName, regCenter);</div><div class="line">   <span class="comment">// 添加注册中心缓存</span></div><div class="line">   regCenter.addCacheData(<span class="string">"/"</span> + jobName);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// ZookeeperRegistryCenter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 缓存</div><div class="line">* key：/作业名/</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, TreeCache&gt; caches = <span class="keyword">new</span> HashMap&lt;&gt;();</div></pre></td></tr></table></figure>
<p><strong>作业服务订阅数据</strong></p>
<p>每个不同的服务，都会订阅数据实现功能逻辑。在后续不同服务的文章，我们会详细解析。🙂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDataListener</span><span class="params">(<span class="keyword">final</span> TreeCacheListener listener)</span> </span>&#123;</div><div class="line">   TreeCache cache = (TreeCache) regCenter.getRawCache(<span class="string">"/"</span> + jobName);</div><div class="line">   cache.getListenable().addListener(listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>关闭作业缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evictCacheData</span><span class="params">(<span class="keyword">final</span> String cachePath)</span> </span>&#123;</div><div class="line">   TreeCache cache = caches.remove(cachePath + <span class="string">"/"</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != cache) &#123;</div><div class="line">       cache.close();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对 Curator TreeCache 感兴趣的同学，可以点击<a href="http://colobu.com/2014/12/15/zookeeper-recipes-by-example-5/" rel="external nofollow noopener noreferrer" target="_blank">链接</a>继续了解。</p>
<h2 id="2-3-关闭"><a href="#2-3-关闭" class="headerlink" title="2.3 关闭"></a>2.3 关闭</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, TreeCache&gt; each : caches.entrySet()) &#123;</div><div class="line">       each.getValue().close();</div><div class="line">   &#125;</div><div class="line">   waitForCacheClose();</div><div class="line">   CloseableUtils.closeQuietly(client);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/* TODO 等待500ms, cache先关闭再关闭client, 否则会抛异常</span></div><div class="line">* 因为异步处理, 可能会导致client先关闭而cache还未关闭结束.</div><div class="line">* 等待Curator新版本解决这个bug.</div><div class="line">* BUG地址：https://issues.apache.org/jira/browse/CURATOR-157</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForCacheClose</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Thread.sleep(<span class="number">500L</span>);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-4-获得数据"><a href="#2-4-获得数据" class="headerlink" title="2.4 获得数据"></a>2.4 获得数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   TreeCache cache = findTreeCache(key); <span class="comment">// 获取缓存</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == cache) &#123;</div><div class="line">       <span class="keyword">return</span> getDirectly(key);</div><div class="line">   &#125;</div><div class="line">   ChildData resultInCache = cache.getCurrentData(key); <span class="comment">// 缓存中获取 value</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != resultInCache) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> == resultInCache.getData() ? <span class="keyword">null</span> : <span class="keyword">new</span> String(resultInCache.getData(), Charsets.UTF_8);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> getDirectly(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDirectly</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(client.getData().forPath(key), Charsets.UTF_8);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#get(...)</code> 先从 <strong>TreeCache缓存</strong> 获取，后从 Zookeeper 获取。</li>
<li><code>#getDirectly(...)</code> <strong>直接</strong>从 Zookeeper 获取。</li>
<li><p><code>#findTreeCache(...)</code> 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TreeCache <span class="title">findTreeCache</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, TreeCache&gt; entry : caches.entrySet()) &#123;</div><div class="line">       <span class="keyword">if</span> (key.startsWith(entry.getKey())) &#123;</div><div class="line">           <span class="keyword">return</span> entry.getValue();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-5-获得注册子节点"><a href="#2-5-获得注册子节点" class="headerlink" title="2.5 获得注册子节点"></a>2.5 获得注册子节点</h2><p><strong>获取子节点名称集合(降序)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildrenKeys</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;String&gt; result = client.getChildren().forPath(key);</div><div class="line">       Collections.sort(result, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> String o1, <span class="keyword">final</span> String o2)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> o2.compareTo(o1);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>获取子节点数量</strong>    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumChildren</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Stat stat = client.checkExists().forPath(key);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != stat) &#123;</div><div class="line">           <span class="keyword">return</span> stat.getNumChildren();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-6-存储注册数据"><a href="#2-6-存储注册数据" class="headerlink" title="2.6 存储注册数据"></a>2.6 存储注册数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!isExisted(key)) &#123;</div><div class="line">           client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(key, value.getBytes(Charsets.UTF_8));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           update(key, value);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistEphemeral</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (isExisted(key)) &#123;</div><div class="line">           client.delete().deletingChildrenIfNeeded().forPath(key);</div><div class="line">       &#125;</div><div class="line">       client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(key, value.getBytes(Charsets.UTF_8));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#persist(...)</code> 存储<strong>持久</strong>节点数据。逻辑等价于 insertOrUpdate 操作。</li>
<li><code>persistEphemeral(...)</code> 存储<strong>临时</strong>节点数据。节点类型无法变更，因此如果数据已存在，需要先进行删除。</li>
<li><p><code>#isExisted(...)</code>、<code>#update(...)</code> 代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExisted</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span> != client.checkExists().forPath(key);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       client.inTransaction().check().forPath(key).and().setData().forPath(key, value.getBytes(Charsets.UTF_8)).and().commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#update(...)</code> 使用<strong>事务</strong>校验键( key )存在才进行更新。</li>
</ul>
</li>
</ul>
<h2 id="2-7-存储顺序注册数据"><a href="#2-7-存储顺序注册数据" class="headerlink" title="2.7 存储顺序注册数据"></a>2.7 存储顺序注册数据</h2><p>实现逻辑和<strong>存储注册数据</strong>类似。Elastic-Job 未使用该方法，跳过。</p>
<h2 id="2-8-移除注册数据"><a href="#2-8-移除注册数据" class="headerlink" title="2.8 移除注册数据"></a>2.8 移除注册数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       client.delete().deletingChildrenIfNeeded().forPath(key);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-9-获取注册中心当前时间"><a href="#2-9-获取注册中心当前时间" class="headerlink" title="2.9 获取注册中心当前时间"></a>2.9 获取注册中心当前时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getRegistryCenterTime</span><span class="params">(<span class="keyword">final</span> String key)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> result = <span class="number">0L</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       persist(key, <span class="string">""</span>);</div><div class="line">       result = client.checkExists().forPath(key).getMtime();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(<span class="number">0L</span> != result, <span class="string">"Cannot get registry center time."</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过更新节点，获得该节点的最后更新时间( <code>mtime</code> )获得 Zookeeper 的时间。six six six。</li>
</ul>
<h2 id="2-10-注册中心异常处理器"><a href="#2-10-注册中心异常处理器" class="headerlink" title="2.10 注册中心异常处理器"></a>2.10 注册中心异常处理器</h2><p>RegExceptionHandler，注册中心异常处理器。在上面的操作 Zookeeper 发生异常时，都会调用 <code>RegExceptionHandler.handleException(...)</code> 处理异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> Exception cause)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == cause) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isIgnoredException(cause) || <span class="keyword">null</span> != cause.getCause() &amp;&amp; isIgnoredException(cause.getCause())) &#123;</div><div class="line">       log.debug(<span class="string">"Elastic job: ignored exception for: &#123;&#125;"</span>, cause.getMessage());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> InterruptedException) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RegException(cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIgnoredException</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> cause <span class="keyword">instanceof</span> ConnectionLossException || cause <span class="keyword">instanceof</span> NoNodeException || cause <span class="keyword">instanceof</span> NodeExistsException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>部分异常会被无视，仅打印异常。例如调用 <code>#getDirectly(...)</code> 获得注册数据时，可能节点不存在，抛出 NodeExistsException，这种异常可以无视。</li>
</ul>
<h1 id="3-作业节点数据访问类"><a href="#3-作业节点数据访问类" class="headerlink" title="3. 作业节点数据访问类"></a>3. 作业节点数据访问类</h1><p>JobNodeStorage，作业节点数据访问类。</p>
<h2 id="3-1-在主节点执行操作"><a href="#3-1-在主节点执行操作" class="headerlink" title="3.1 在主节点执行操作"></a>3.1 在主节点执行操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 在主节点执行操作.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> latchNode 分布式锁使用的节点，例如：leader/election/latch</div><div class="line">* <span class="doctag">@param</span> callback 执行操作的回调</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(<span class="keyword">final</span> String latchNode, <span class="keyword">final</span> LeaderExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) &#123;</div><div class="line">       latch.start();</div><div class="line">       latch.await();</div><div class="line">       callback.execute();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Apache Curator</a> 使用 Zookeeper 实现了两种分布式锁，LeaderLatch 是其中的一种。使用<strong>一个</strong> Zookeeper 节点路径创建<strong>一个</strong> LeaderLatch，<code>#start()</code> 后，调用 <code>#await()</code> 等待拿到这把<strong>锁</strong>。如果有多个线程执行了<strong>相同节点路径</strong>的 LeaderLatch 的 <code>#await()</code> 后，同一时刻有且仅有一个线程可以继续执行，其他线程需要等待。当该线程释放( <code>LeaderLatch#close()</code> )后，下一个线程可以拿到该<strong>锁</strong>继续执行。用 Java 并发包 Lock 举例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInLeader</span><span class="params">(Lock lock)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="comment">// doSomething();</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/Netflix/curator/wiki/Leader-Latch" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— LeaderLatch》</a>，有兴趣的同学可以看看。在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码解析 —— 主节点选举》</a>中，我们会看到 <code>#executeInLeader(...)</code> 的使用。</p>
<p>另一种分布式锁实现，<a href="https://github.com/Netflix/curator/wiki/Leader-Election" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— LeaderElection》</a>，有兴趣也可以看看。在 Elastic-Job-Cloud 中使用到了，后续进行解析。</p>
<h2 id="3-2-在事务中执行操作"><a href="#3-2-在事务中执行操作" class="headerlink" title="3.2 在事务中执行操作"></a>3.2 在事务中执行操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobNodeStorage.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeInTransaction</span><span class="params">(<span class="keyword">final</span> TransactionExecutionCallback callback)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       CuratorTransactionFinal curatorTransactionFinal = getClient().inTransaction().check().forPath(<span class="string">"/"</span>).and();</div><div class="line">       callback.execute(curatorTransactionFinal);</div><div class="line">       curatorTransactionFinal.commit();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       RegExceptionHandler.handleException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>开启事务，执行 TransactionExecutionCallback 回调逻辑，提交事务。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：煞笔芋道君，又在水更<br>芋道君：人艰不拆，好不好。</p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 基
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业执行</title>
    <link href="http://www.yunai.me/Elastic-Job/job-execute/"/>
    <id>http://www.yunai.me/Elastic-Job/job-execute/</id>
    <published>2017-09-22T16:00:00.000Z</published>
    <updated>2017-08-28T11:05:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-lite%E8%B0%83%E5%BA%A6%E4%BD%9C%E4%B8%9A">2. Lite调度作业</a></li>
<li><a href="#3-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%9B%E5%BB%BA">3. 执行器创建</a><ul>
<li><a href="#31-%E5%8A%A0%E8%BD%BD%E4%BD%9C%E4%B8%9A%E9%85%8D%E7%BD%AE">3.1 加载作业配置</a></li>
<li><a href="#32-%E8%8E%B7%E5%8F%96%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0">3.2 获取作业执行线程池</a></li>
<li><a href="#33-%E8%8E%B7%E5%8F%96%E4%BD%9C%E4%B8%9A%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C%E5%99%A8">3.3 获取作业异常执行器</a></li>
</ul>
</li>
<li><a href="#4-%E6%89%A7%E8%A1%8C%E5%99%A8%E6%89%A7%E8%A1%8C">4. 执行器执行</a><ul>
<li><a href="#41-%E6%A3%80%E6%9F%A5%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">4.1 检查作业执行环境</a></li>
<li><a href="#42-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%9C%E4%B8%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8A%E4%B8%8B%E6%96%87">4.2 获取当前作业服务器的分片上下文</a></li>
<li><a href="#43-%E5%8F%91%E5%B8%83%E4%BD%9C%E4%B8%9A%E7%8A%B6%E6%80%81%E8%BF%BD%E8%B8%AA%E4%BA%8B%E4%BB%B6">4.3 发布作业状态追踪事件</a></li>
<li><a href="#44-%E8%B7%B3%E8%BF%87%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E8%A2%AB%E9%94%99%E8%BF%87%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BD%9C%E4%B8%9A">4.4 跳过正在运行中的被错过执行的作业</a></li>
<li><a href="#45-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%89%8D%E7%9A%84%E6%96%B9%E6%B3%95">4.5 执行作业执行前的方法</a></li>
<li><a href="#46-%E6%89%A7%E8%A1%8C%E6%99%AE%E9%80%9A%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BD%9C%E4%B8%9A">4.6 执行普通触发的作业</a><ul>
<li><a href="#461-%E7%AE%80%E5%8D%95%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.1 简单作业执行器</a></li>
<li><a href="#462-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.2 数据流作业执行器</a></li>
<li><a href="#463-%E8%84%9A%E6%9C%AC%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%99%A8">4.6.3 脚本作业执行器</a></li>
</ul>
</li>
<li><a href="#47-%E6%89%A7%E8%A1%8C%E8%A2%AB%E9%94%99%E8%BF%87%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BD%9C%E4%B8%9A">4.7 执行被错过触发的作业</a></li>
<li><a href="#48-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB">4.8 执行作业失效转移</a></li>
<li><a href="#49-%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A%E6%89%A7%E8%A1%8C%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95">4.9 执行作业执行后的方法</a></li>
</ul>
</li>
<li><a href="#666-%E5%BD%A9%E8%9B%8B">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业执行</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_23/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业执行类。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-Lite调度作业"><a href="#2-Lite调度作业" class="headerlink" title="2. Lite调度作业"></a>2. Lite调度作业</h1><p>Lite调度作业( LiteJob )，作业被调度后，调用 <code>#execute()</code> 执行作业。</p>
<p><strong>为什么是 LiteJob 作为入口呢？</strong></p>
<p>在<a href="http://www.yunai.me/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.3」创建作业调度控制器</a>里，我们可以看到 Quartz 的 JobDetail 创建代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div></pre></td></tr></table></figure>
<p><code>#newJob()</code> 里的参数是 LiteJob，因此，每次 Quartz 到达调度时间时，会创建该对象进行作业执行。</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>LiteJob 通过 JobExecutorFactory 获得到作业执行器( AbstractElasticJobExecutor )，并进行执行：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutorFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业执行器.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> elasticJob 分布式弹性作业</div><div class="line">     * <span class="doctag">@param</span> jobFacade 作业内部服务门面服务</div><div class="line">     * <span class="doctag">@return</span> 作业执行器</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractElasticJobExecutor <span class="title">getJobExecutor</span><span class="params">(<span class="keyword">final</span> ElasticJob elasticJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="comment">// ScriptJob</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == elasticJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SimpleJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> SimpleJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// DataflowJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> DataflowJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot support job type '%s'"</span>, elasticJob.getClass().getCanonicalName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JobExecutorFactory，作业执行器工厂，根据不同的作业类型，返回对应的<strong>作业执行器</strong>。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">作业</th>
<th style="text-align:left">作业接口</th>
<th style="text-align:left">执行器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单作业</td>
<td style="text-align:left">SimpleJob</td>
<td style="text-align:left">SimpleJobExecutor</td>
</tr>
<tr>
<td style="text-align:left">数据流作业</td>
<td style="text-align:left">DataflowJob</td>
<td style="text-align:left">DataflowJobExecutor</td>
</tr>
<tr>
<td style="text-align:left">脚本作业</td>
<td style="text-align:left">ScriptJob</td>
<td style="text-align:left">ScriptJobExecutor</td>
</tr>
</tbody>
</table>
<h1 id="3-执行器创建"><a href="#3-执行器创建" class="headerlink" title="3. 执行器创建"></a>3. 执行器创建</h1><p>AbstractElasticJobExecutor，作业执行器抽象类。不同作业执行器都继承该类，创建的过程是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业门面对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobRootConfiguration jobRootConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业执行线程池</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业异常处理器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobExceptionHandler jobExceptionHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片错误信息集合</div><div class="line">     * key：分片序号</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; itemErrorMessages;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractElasticJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobFacade = jobFacade;</div><div class="line">        <span class="comment">// 加载 作业配置</span></div><div class="line">        jobRootConfig = jobFacade.loadJobRootConfiguration(<span class="keyword">true</span>);</div><div class="line">        jobName = jobRootConfig.getTypeConfig().getCoreConfig().getJobName();</div><div class="line">        <span class="comment">// 获取 作业执行线程池</span></div><div class="line">        executorService = ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));</div><div class="line">        <span class="comment">// 获取 作业异常处理器</span></div><div class="line">        jobExceptionHandler = (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);</div><div class="line">        <span class="comment">// 设置 分片错误信息集合</span></div><div class="line">        itemErrorMessages = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SimpleJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataflowJobExecutor</span><span class="params">(<span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.dataflowJob = dataflowJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ScriptJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScriptJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-1-加载作业配置"><a href="#3-1-加载作业配置" class="headerlink" title="3.1 加载作业配置"></a>3.1 加载作业配置</h2><p>从<strong>缓存</strong>中读取作业配置。在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.1」读取作业配置</a> 已经解析。</p>
<h2 id="3-2-获取作业执行线程池"><a href="#3-2-获取作业执行线程池" class="headerlink" title="3.2 获取作业执行线程池"></a>3.2 获取作业执行线程池</h2><p>作业每次执行时，可能分配到<strong>多个分片项</strong>，需要使用线程池实现<strong>并行</strong>执行。考虑到不同作业之间的隔离性，通过<strong>一个作业一个线程池</strong>实现。线程池服务处理器注册表( ExecutorServiceHandlerRegistry ) 获取作业线程池( <code>#getExecutorServiceHandler(....)</code> )代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceHandlerRegistry</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 线程池集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ExecutorService&gt; REGISTRY = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线程池服务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> executorServiceHandler 线程池服务处理器</div><div class="line">     * <span class="doctag">@return</span> 线程池服务</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">getExecutorServiceHandler</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> ExecutorServiceHandler executorServiceHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!REGISTRY.containsKey(jobName)) &#123;</div><div class="line">            REGISTRY.put(jobName, executorServiceHandler.createExecutorService(jobName));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> REGISTRY.get(jobName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ExecutorServiceHandlerRegistry 使用 ExecutorServiceHandler 创建线程池。ExecutorServiceHandler 本身是个<strong>接口</strong>，默认使用 DefaultExecutorServiceHandler 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function">ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorServiceHandler</span> <span class="keyword">implements</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"inner-job-"</span> + jobName, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>).createExecutorService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 ExecutorServiceObject 的 <code>#createExecutorService(....)</code> 方法创建线程池：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceObject</span><span class="params">(<span class="keyword">final</span> String namingPattern, <span class="keyword">final</span> <span class="keyword">int</span> threadSize)</span> </span>&#123;</div><div class="line">        workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">        threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(threadSize, threadSize, <span class="number">5L</span>, TimeUnit.MINUTES, workQueue, </div><div class="line">                <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(Joiner.on(<span class="string">"-"</span>).join(namingPattern, <span class="string">"%s"</span>)).build());</div><div class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建线程池服务对象.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> 线程池服务对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MoreExecutors.listeningDecorator(MoreExecutors.getExitingExecutorService(threadPoolExecutor));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>MoreExecutors#listeningDecorator(...)</code> 在<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a> 已经解析。</li>
<li><p><code>MoreExecutors#getExitingExecutorService(...)</code> 方法逻辑：将 ThreadPoolExecutor 转换成 ExecutorService，并增加 JVM 关闭钩子，实现 <strong>120s</strong> 等待任务完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">service.shutdown();</div><div class="line">service.awaitTermination(terminationTimeout, timeUnit);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>如何实现自定义 ExecutorServiceHandler ?</strong></p>
<p>先看下 AbstractElasticJobExecutor 是如何获得<strong>每个作业</strong>的 ExecutorServiceHandler ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【自定义】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum)</span> </span>&#123;</div><div class="line">   String handlerClassName = jobRootConfig.getTypeConfig().getCoreConfig().getJobProperties().get(jobPropertiesEnum);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class&lt;?&gt; handlerClass = Class.forName(handlerClassName);</div><div class="line">       <span class="keyword">if</span> (jobPropertiesEnum.getClassType().isAssignableFrom(handlerClass)) &#123; <span class="comment">// 必须是接口实现，才使用【自定义】</span></div><div class="line">           <span class="keyword">return</span> handlerClass.newInstance();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得【默认】处理器</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</div><div class="line">* <span class="doctag">@param</span> handlerClassName 处理器类名</div><div class="line">* <span class="doctag">@return</span> 处理器</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDefaultHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum, <span class="keyword">final</span> String handlerClassName)</span> </span>&#123;</div><div class="line">   log.warn(<span class="string">"Cannot instantiation class '&#123;&#125;', use default '&#123;&#125;' class."</span>, handlerClassName, jobPropertiesEnum.getKey());</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> Class.forName(jobPropertiesEnum.getDefaultValue()).newInstance();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个处理器都会对应一个 JobPropertiesEnum，使用枚举获得处理器。优先从 <code>JobProperties.map</code> 获取<strong>自定义</strong>的处理器实现类，如果不符合条件( 未实现正确接口 或者 创建处理器失败 )，使用<strong>默认</strong>的处理器实现。</li>
<li>每个作业可以配置<strong>不同</strong>的处理器，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「2.2.2」作业核心配置</a> 已经解析。</li>
</ul>
<h2 id="3-3-获取作业异常执行器"><a href="#3-3-获取作业异常执行器" class="headerlink" title="3.3 获取作业异常执行器"></a>3.3 获取作业异常执行器</h2><p>获取作业异常执行器( JobExceptionHandler )和 ExecutorServiceHandler( ExecutorServiceHandler )<strong>相同</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理作业异常.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> jobName 作业名称</div><div class="line">     * <span class="doctag">@param</span> cause 异常原因</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(String jobName, Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultJobExceptionHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>默认实现 DefaultJobExceptionHandler <strong>打印异常日志，不会抛出异常</strong>。</li>
</ul>
<h1 id="4-执行器执行"><a href="#4-执行器执行" class="headerlink" title="4. 执行器执行"></a>4. 执行器执行</h1><p>执行逻辑主流程如下图( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_23/02.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_23/02.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 检查 作业执行环境</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.checkJobExecutionEnvironment();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobExecutionEnvironmentException cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 当前作业服务器的分片上下文</span></div><div class="line">   ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 跳过 存在运行中的被错过作业</span></div><div class="line">   <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       <span class="comment">// 发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div class="line">                   <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </div><div class="line">                   shardingContexts.getShardingItemParameters().keySet()));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业执行前的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.beforeJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 普通触发的作业</span></div><div class="line">   execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业失效转移</span></div><div class="line">   jobFacade.failoverIfNecessary();</div><div class="line">   <span class="comment">// 执行 作业执行后的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.afterJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码步骤比较多，我们一步一步往下看。</p>
<h2 id="4-1-检查作业执行环境"><a href="#4-1-检查作业执行环境" class="headerlink" title="4.1 检查作业执行环境"></a>4.1 检查作业执行环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkJobExecutionEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   configService.checkMaxTimeDiffSecondsTolerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>ConfigService#checkMaxTimeDiffSecondsTolerable()</code> 方法校验本机时间是否合法，在<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.3」校验本机时间是否合法</a> 已经解析。</li>
<li>当校验本机时间不合法时，抛出异常。若使用 DefaultJobExceptionHandler 作为异常处理，<strong>只打印日志，不会终止作业执行</strong>。如果你的作业对时间精准度有比较高的要求，期望作业<strong>终止</strong>执行，可以自定义 JobExceptionHandler 实现对异常的处理。</li>
</ul>
<h2 id="4-2-获取当前作业服务器的分片上下文"><a href="#4-2-获取当前作业服务器的分片上下文" class="headerlink" title="4.2 获取当前作业服务器的分片上下文"></a>4.2 获取当前作业服务器的分片上下文</h2><p>调用 <code>LiteJobFacade#getShardingContexts()</code> 方法获取当前作业服务器的分片上下文。通过这个方法，作业获得<strong>其所分配执行的分片项</strong>，在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</p>
<h2 id="4-3-发布作业状态追踪事件"><a href="#4-3-发布作业状态追踪事件" class="headerlink" title="4.3 发布作业状态追踪事件"></a>4.3 发布作业状态追踪事件</h2><p>调用 <code>LiteJobFacade#postJobStatusTraceEvent()</code> 方法发布作业状态追踪事件，在<a href="http://www.yunai.me/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码解析 —— 作业事件追踪》</a>详细分享。</p>
<h2 id="4-4-跳过正在运行中的被错过执行的作业"><a href="#4-4-跳过正在运行中的被错过执行的作业" class="headerlink" title="4.4 跳过正在运行中的被错过执行的作业"></a>4.4 跳过正在运行中的被错过执行的作业</h2><p>该逻辑和<strong>「4.7」执行被错过执行的作业</strong>，一起解析，可以整体性的理解 Elastic-Job-Lite 对被错过执行( misfired )的作业处理。</p>
<h2 id="4-5-执行作业执行前的方法"><a href="#4-5-执行作业执行前的方法" class="headerlink" title="4.5 执行作业执行前的方法"></a>4.5 执行作业执行前的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用作业监听器执行作业<strong>执行前</strong>的方法，在<a href="http://www.yunai.me/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li>
</ul>
<h2 id="4-6-执行普通触发的作业"><a href="#4-6-执行普通触发的作业" class="headerlink" title="4.6 执行普通触发的作业"></a>4.6 执行普通触发的作业</h2><p>这个小节的标题不太准确，其他<strong>作业来源</strong>( ExecutionSource )也是执行这样的逻辑。本小节执行作业会经历 4 个方法，方法<strong>顺序</strong>往下调用，我们逐个来看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行多个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> executionSource 执行来源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</div><div class="line">* <span class="doctag">@param</span> item 分片序号</div><div class="line">* <span class="doctag">@param</span> startEvent 执行事件(开始)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 执行单个作业的分片【子类实现】</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文集合</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure>
<p>ps：<strong>作业事件</strong>相关逻辑，先统一跳过，在<a href="http://www.yunai.me/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码解析 —— 作业事件追踪》</a>详细分享。</p>
<hr>
<p><strong>private void execute(shardingContexts, executionSource)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无可执行的分片，发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.getShardingItemParameters().isEmpty()) &#123;</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(<span class="string">"Sharding item for job '%s' is empty."</span>, jobName));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册作业启动信息</span></div><div class="line">   jobFacade.registerJobBegin(shardingContexts);</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   String taskId = shardingContexts.getTaskId();</div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       process(shardingContexts, executionSource);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路</span></div><div class="line">       <span class="comment">// 注册作业完成信息</span></div><div class="line">       jobFacade.registerJobCompleted(shardingContexts);</div><div class="line">       <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">       <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>方法参数 <code>executionSource</code> 代表执行来源( ExecutionSource )，一共有三种：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 普通触发执行</div><div class="line">    */</div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 被错过执行</div><div class="line">    */</div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 失效转移执行</div><div class="line">    */</div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>LiteJobFacade#registerJobBegin(...)</code> 方法注册作业<strong>启动</strong>信息：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobBegin(shardingContexts);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.fillEphemeralJobNode(ShardingNode.getRunningNode(each), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时，记录作业运行状态。</li>
<li>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法记录<strong>分配的作业分片项</strong>正在运行中。如何记录的，在<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>详细分享。</li>
</ul>
</li>
<li><p>调用 <code>LiteJobFacade#registerJobCompleted(...)</code> 方法注册作业<strong>完成</strong>信息：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobCompleted(shardingContexts);</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.updateFailoverComplete(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业完成信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> shardingContexts 分片上下文</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">false</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getRunningNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )，移除作业运行状态。</li>
<li>调用 <code>JobNodeStorage#removeJobNodeIfExisted(...)</code> 方法<strong>移除分配的作业分片项</strong>正在运行中的标记，表示作业分片项不在运行中状态。</li>
<li>调用 <code>FailoverService#updateFailoverComplete(...)</code> 方法更新执行完毕失效转移的分片项状态，在<a href="http://www.yunai.me/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>private void process(shardingContexts, executionSource)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   Collection&lt;Integer&gt; items = shardingContexts.getShardingItemParameters().keySet();</div><div class="line">   <span class="comment">// 单分片，直接执行</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == items.size()) &#123;</div><div class="line">       <span class="keyword">int</span> item = shardingContexts.getShardingItemParameters().keySet().iterator().next();</div><div class="line">       JobExecutionEvent jobExecutionEvent =  <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);</div><div class="line">       <span class="comment">// 执行一个作业</span></div><div class="line">       process(shardingContexts, item, jobExecutionEvent);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多分片，并行执行</span></div><div class="line">   <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">final</span> JobExecutionEvent jobExecutionEvent = <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);</div><div class="line">       <span class="keyword">if</span> (executorService.isShutdown()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       executorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 执行一个作业</span></div><div class="line">                   process(shardingContexts, each, jobExecutionEvent);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   latch.countDown();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待多分片全部完成</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       latch.await();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>分配<strong>单</strong>分片项时，直接执行，无需使用线程池，性能更优。</li>
<li>分配<strong>多</strong>分片项时，使用线程池<strong>并发</strong>执行，通过 CountDownLatch 实现等待分片项全部执行完成。</li>
</ul>
<hr>
<p><strong>private void process(shardingContexts, item, startEvent)</strong><br><strong>protected abstract void process(shardingContext)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"Job '&#123;&#125;' executing, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       log.trace(<span class="string">"Job '&#123;&#125;' executed, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// 设置该分片执行异常信息</span></div><div class="line">       itemErrorMessages.put(item, ExceptionUtil.transform(cause));</div><div class="line">       <span class="comment">//</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
<li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li>
</ul>
<h3 id="4-6-1-简单作业执行器"><a href="#4-6-1-简单作业执行器" class="headerlink" title="4.6.1 简单作业执行器"></a>4.6.1 简单作业执行器</h3><p>SimpleJobExecutor，简单作业执行器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 简单作业实现</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        simpleJob.execute(shardingContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>SimpleJob#execute()</code> 方法对单个分片项作业进行处理。</li>
</ul>
<h3 id="4-6-2-数据流作业执行器"><a href="#4-6-2-数据流作业执行器" class="headerlink" title="4.6.2 数据流作业执行器"></a>4.6.2 数据流作业执行器</h3><p>DataflowJobExecutor，数据流作业执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据流作业对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        DataflowJobConfiguration dataflowConfig = (DataflowJobConfiguration) getJobRootConfig().getTypeConfig();</div><div class="line">        <span class="keyword">if</span> (dataflowConfig.isStreamingProcess()) &#123; <span class="comment">// 流式处理数据</span></div><div class="line">            streamingExecute(shardingContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            oneOffExecute(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 流式处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">streamingExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">            <span class="keyword">if</span> (!getJobFacade().isEligibleForJobRunning()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            data = fetchData(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 一次处理</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneOffExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>当作业配置设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = true</code> ) 时，调用 <code>#streamingExecute()</code> <strong>不断</strong>加载数据，<strong>不断</strong>处理数据，直到<strong>数据为空</strong> 或者 <strong>作业不适合继续运行</strong>：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligibleForJobRunning</span><span class="params">()</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (liteJobConfig.getTypeConfig() <span class="keyword">instanceof</span> DataflowJobConfiguration) &#123;</div><div class="line">       <span class="keyword">return</span> !shardingService.isNeedSharding() <span class="comment">// 作业不需要重新分片</span></div><div class="line">               &amp;&amp; ((DataflowJobConfiguration) liteJobConfig.getTypeConfig()).isStreamingProcess();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> !shardingService.isNeedSharding(); <span class="comment">// 作业不需要重新分片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>作业需要重新分片，所以不适合继续流式数据处理。</p>
<blockquote>
<p>如果采用流式作业处理方式，建议processData处理数据后更新其状态，避免fetchData再次抓取到，从而使得作业永不停止。 流式数据处理参照TbSchedule设计，适用于不间歇的数据处理。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当作业配置<strong>不</strong>设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = false</code> ) 时，调用 <code>#oneOffExecute()</code> <strong>一次</strong>加载数据，<strong>一次</strong>处理数据。</p>
</li>
<li><p>调用 <code>#fetchData()</code> 方法加载数据；调用 <code>#processData(...)</code> 方法处理数据：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 加载数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@return</span> 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dataflowJob.fetchData(shardingContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理数据</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">* <span class="doctag">@param</span> data 数据</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> List&lt;Object&gt; data)</span> </span>&#123;</div><div class="line">   dataflowJob.processData(shardingContext, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-6-3-脚本作业执行器"><a href="#4-6-3-脚本作业执行器" class="headerlink" title="4.6.3 脚本作业执行器"></a>4.6.3 脚本作业执行器</h3><p>ScriptJobExecutor，脚本作业执行器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> String scriptCommandLine = ((ScriptJobConfiguration) getJobRootConfig().getTypeConfig()).getScriptCommandLine();</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(scriptCommandLine)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot find script command line for job '%s', job is not executed."</span>, shardingContext.getJobName());</div><div class="line">        &#125;</div><div class="line">        executeScript(shardingContext, scriptCommandLine);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行脚本</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> shardingContext 分片上下文</div><div class="line">     * <span class="doctag">@param</span> scriptCommandLine 执行脚本路径</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeScript</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> String scriptCommandLine)</span> </span>&#123;</div><div class="line">        CommandLine commandLine = CommandLine.parse(scriptCommandLine);</div><div class="line">        <span class="comment">// JSON 格式传递参数</span></div><div class="line">        commandLine.addArgument(GsonFactory.getGson().toJson(shardingContext), <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> DefaultExecutor().execute(commandLine);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Execute script failure."</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>scriptCommandLine</code> 传递的是<strong>脚本路径</strong>。使用 <a href="https://commons.apache.org/proper/commons-exec/" rel="external nofollow noopener noreferrer" target="_blank">Apache Commons Exec</a> 工具包实现脚本调用：</p>
<blockquote>
<p>Script类型作业意为脚本类型作业，支持shell，python，perl等所有类型脚本。只需通过控制台或代码配置scriptCommandLine即可，无需编码。执行脚本路径可包含参数，参数传递完毕后，作业框架会自动追加最后一个参数为作业运行时信息。</p>
</blockquote>
</li>
<li><p>脚本参数传递使用 JSON 格式。</p>
</li>
</ul>
<h2 id="4-7-执行被错过触发的作业"><a href="#4-7-执行被错过触发的作业" class="headerlink" title="4.7 执行被错过触发的作业"></a>4.7 执行被错过触发的作业</h2><p>当作业执行过久，导致到达下次执行时间未进行下一次作业执行，Elastic-Job-Lite 会设置该作业分片项为被错过执行( misfired )。下一次作业执行时，会<strong>补充</strong>执行被错过执行的作业分片项。</p>
<p><strong>标记作业被错过执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>org.quartz.jobStore.misfireThreshold</code> 设置超过 1 毫秒，作业分片项即被视为错过执行。</li>
<li><code>#withMisfireHandlingInstructionDoNothing()</code> 设置 Quartz 系统不会立刻再执行任务，而是等到距离目前时间最近的预计时间执行。<strong>重新执行被错过执行的作业交给 Elastic-Job-Lite 处理</strong>。</li>
<li><p>使用 TriggerListener 监听被错过执行的作业分片项：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTriggerListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTriggerListener</span> <span class="keyword">extends</span> <span class="title">TriggerListenerSupport</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerMisfired</span><span class="params">(<span class="keyword">final</span> Trigger trigger)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trigger.getPreviousFireTime()) &#123;</div><div class="line">            executionService.setMisfire(shardingService.getLocalShardingItems());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getMisfireNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#setMisfire(...)</code> 设置作业分片项被错过执行。</li>
</ul>
</li>
</ul>
<p><strong>跳过正在运行中的被错过执行的作业</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfRunning</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executionService.misfireIfHasRunningItems(shardingItems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfHasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!hasRunningItems(items)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   setMisfire(items);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration jobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobConfig || !jobConfig.isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(each))) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当分配的作业分片项里存在<strong>任意一个分片正在运行</strong>中，设置分片项<strong>都</strong>被错过执行( <code>misfired</code> )，并不执行这些作业分片。如果不进行跳过，则可能导致<strong>同时</strong>运行某个作业分片。</li>
<li>该功能依赖作业配置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时生效。</li>
</ul>
<p><strong>执行被错过执行的作业分片项</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuteMisfired</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isEligibleForJobRunning() <span class="comment">// 合适继续运行</span></div><div class="line">           &amp;&amp; configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().isMisfire() <span class="comment">// 作业配置开启作业被错过触发</span></div><div class="line">           &amp;&amp; !executionService.getMisfiredJobItems(shardingItems).isEmpty(); <span class="comment">// 所执行的作业分片存在被错过( misfired )</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   executionService.clearMisfire(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>清除分配的作业分片项被错过执行的标识，并执行作业分片项。</li>
<li>为什么此处使用 <strong>while(…)</strong>？<strong>防御性编程</strong>，<code>#isExecuteMisfired(...)</code> 判断使用<strong>内存缓存</strong>的数据，而该数据的更新依赖 Zookeeper 通知进行<strong>异步</strong>更新，可能因为各种情况，例如网络，数据可能未及时更新导致<strong>数据不一致</strong>。使用 <strong>while(…)</strong> 进行防御编程，保证<strong>内存缓存</strong>的数据已经更新。</li>
</ul>
<h2 id="4-8-执行作业失效转移"><a href="#4-8-执行作业失效转移" class="headerlink" title="4.8 执行作业失效转移"></a>4.8 执行作业失效转移</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用作业失效转移服务( FailoverService )执行作业失效转移( <code>#failoverIfNecessary()</code> )，在<a href="http://www.yunai.me/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li>
</ul>
<h2 id="4-9-执行作业执行后的方法"><a href="#4-9-执行作业执行后的方法" class="headerlink" title="4.9 执行作业执行后的方法"></a>4.9 执行作业执行后的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用作业监听器执行作业<strong>执行后</strong>的方法，在<a href="http://www.yunai.me/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼！略长略长略长！</p>
<p>下面会更新如下两篇文章，为后续的主节点选举、失效转移、作业分片策略等文章做铺垫：</p>
<ul>
<li><a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码解析 —— 注册中心》</a></li>
<li><a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a></li>
</ul>
<p>道友，赶紧上车，分享一波朋友圈！</p>
<p>啊啊啊，我好想马上拜读 Elastic-Job-Cloud。为了你们，我忍住了心碎。</p>
<p>旁白君：煞笔笔者已经偷偷在读了。<br>芋道君：旁白君，你大爷！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-%E6%A6%82%E8%BF%B0&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-lite%E8%B0%83%E
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业初始化</title>
    <link href="http://www.yunai.me/Elastic-Job/job-init/"/>
    <id>http://www.yunai.me/Elastic-Job/job-init/</id>
    <published>2017-09-15T16:00:00.000Z</published>
    <updated>2017-08-28T11:05:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业注册表</a></li>
<li><a href="#">3. 作业调度器</a><ul>
<li><a href="#">3.1 创建</a></li>
<li><a href="#">3.2 初始化</a><ul>
<li><a href="#">3.2.1 更新作业配置</a></li>
<li><a href="#">3.2.2 设置当前作业分片总数</a></li>
<li><a href="#">3.2.3 创建作业调度控制器</a></li>
<li><a href="#">3.2.4 注册作业启动信息</a></li>
<li><a href="#">3.2.5 调度作业</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业初始化</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_09/16.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_16/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-作业注册表"><a href="#2-作业注册表" class="headerlink" title="2. 作业注册表"></a>2. 作业注册表</h1><p>作业注册表( JobRegistry )，维护了单个 Elastic-Job-Lite <strong>进程内</strong>作业相关信息，可以理解成其专属的 Spring IOC 容器。因此，其本身是一个<strong>单例</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 单例</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JobRegistry instance;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业调度控制器集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, JobScheduleController&gt; schedulerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册中心集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, CoordinatorRegistryCenter&gt; regCenterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行实例集合</div><div class="line">     * key：作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 运行中作业集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Boolean&gt; jobRunningMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业总分片数量集合</div><div class="line">     * key：作业名字</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; currentShardingTotalCountMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取作业注册表实例.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 作业注册表实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobRegistry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (JobRegistry.class) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> JobRegistry();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>instance</code> 是一个单例，通过 <code>#getInstance()</code> 方法获取该单例。该单例的创建方式为<strong><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/#%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81" rel="external nofollow noopener noreferrer" target="_blank">双重检验锁模式</a></strong>。</li>
<li>Map集合属性<strong>全部</strong>以<strong>作业名称</strong>作为 KEY，通过作业名称，可以获得作业相关信息。</li>
<li>省略的方法，下文在实际调用时，进行解析。</li>
</ul>
<h1 id="3-作业调度器"><a href="#3-作业调度器" class="headerlink" title="3. 作业调度器"></a>3. 作业调度器</h1><p>作业调度器( JobScheduler )，创建并初始化后，进行作业调度。</p>
<p><strong>Elastic-Job-Lite 使用 Quartz 作为调度内核。</strong></p>
<h2 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobScheduler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Lite作业配置</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LiteJobConfiguration liteJobConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册中心</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CoordinatorRegistryCenter regCenter;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调度器门面对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SchedulerFacade schedulerFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业门面对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> ElasticJobListener... elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(regCenter, liteJobConfig, <span class="keyword">new</span> JobEventBus(), elasticJobListeners);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> JobEventConfiguration jobEventConfig, </span></span></div><div class="line">                        <span class="keyword">final</span> ElasticJobListener... elasticJobListeners) &#123;</div><div class="line">        <span class="keyword">this</span>(regCenter, liteJobConfig, <span class="keyword">new</span> JobEventBus(jobEventConfig), elasticJobListeners);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JobScheduler</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> LiteJobConfiguration liteJobConfig, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> ElasticJobListener... elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 作业运行实例</span></div><div class="line">        JobRegistry.getInstance().addJobInstance(liteJobConfig.getJobName(), <span class="keyword">new</span> JobInstance());</div><div class="line">        <span class="comment">// 设置 Lite作业配置</span></div><div class="line">        <span class="keyword">this</span>.liteJobConfig = liteJobConfig;</div><div class="line">        <span class="keyword">this</span>.regCenter = regCenter;</div><div class="line">        <span class="comment">// 设置 作业监听器</span></div><div class="line">        List&lt;ElasticJobListener&gt; elasticJobListenerList = Arrays.asList(elasticJobListeners);</div><div class="line">        setGuaranteeServiceForElasticJobListeners(regCenter, elasticJobListenerList);</div><div class="line">        <span class="comment">// 设置 调度器门面对象</span></div><div class="line">        schedulerFacade = <span class="keyword">new</span> SchedulerFacade(regCenter, liteJobConfig.getJobName(), elasticJobListenerList);</div><div class="line">        <span class="comment">// 设置 作业门面对象</span></div><div class="line">        jobFacade = <span class="keyword">new</span> LiteJobFacade(regCenter, liteJobConfig.getJobName(), Arrays.asList(elasticJobListeners), jobEventBus);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#JobRegistry#addJobInstance()</code> 方法添<strong>加作业运行实例( JobInstance )</strong>。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 作业运行实例集合</div><div class="line">* key：作业名称</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 添加作业实例.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobName 作业名称</div><div class="line">* <span class="doctag">@param</span> jobInstance 作业实例</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJobInstance</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobInstance jobInstance)</span> </span>&#123;</div><div class="line">   jobInstanceMap.put(jobName, jobInstance);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobInstance.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobInstance</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELIMITER = <span class="string">"@-@"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业实例主键.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobInstanceId;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobInstanceId = IpUtils.getIp()</div><div class="line">                + DELIMITER</div><div class="line">                + ManagementFactory.getRuntimeMXBean().getName().split(<span class="string">"@"</span>)[<span class="number">0</span>]; <span class="comment">// PID</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>jobInstanceId</code> 格式：<code>${IP}@-@${PID}</code>。其中 <code>PID</code> 为进程编号。同一个 Elastic-Job-Lite 实例，<strong>不同</strong>的作业使用<strong>相同</strong>的作业实例主键。</li>
</ul>
</li>
<li><p>设置作业监听器，在<a href="http://www.yunai.me/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</p>
</li>
<li><p>SchedulerFacade，为<strong>调度器</strong>提供内部服务的门面类。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerFacade</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationService configService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingService shardingService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主节点服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LeaderService leaderService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业服务器服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerService serverService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行实例服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceService instanceService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行作业服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionService executionService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业监控服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorService monitorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 调解作业不一致状态服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReconcileService reconcileService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业注册中心的监听器管理者</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> ListenerManager listenerManager;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SchedulerFacade</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobName = jobName;</div><div class="line">        <span class="comment">// .... 省略 new XXXXX() 对象</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>LiteJobFacade，为<strong>作业</strong>提供内部服务的门面类。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJobFacade</span> <span class="keyword">implements</span> <span class="title">JobFacade</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业配置服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConfigurationService configService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业分片服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingService shardingService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行作业服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionService executionService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业运行时上下文服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionContextService executionContextService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业失效转移服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverService failoverService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业监听器数组</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业事件总线</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobEventBus jobEventBus;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiteJobFacade</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners, <span class="keyword">final</span> JobEventBus jobEventBus)</span> </span>&#123;</div><div class="line">        <span class="comment">// .... 省略 new XXXXX() 对象</span></div><div class="line">        failoverService = <span class="keyword">new</span> FailoverService(regCenter, jobName);</div><div class="line">        <span class="keyword">this</span>.elasticJobListeners = elasticJobListeners;</div><div class="line">        <span class="keyword">this</span>.jobEventBus = jobEventBus;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>SchedulerFacade 和 LiteJobFacade，看起来很相近，实际差别很大。它们分别为调度器、作业提供需要的方法。下文也会体现这一特点。</p>
<h2 id="3-2-初始化"><a href="#3-2-初始化" class="headerlink" title="3.2 初始化"></a>3.2 初始化</h2><p>作业调度器创建后，调用 <code>#init()</code> 方法初始化，作业方<strong>开始</strong>调度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 初始化作业.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 更新 作业配置</span></div><div class="line">   LiteJobConfiguration liteJobConfigFromRegCenter = schedulerFacade.updateJobConfiguration(liteJobConfig);</div><div class="line">   <span class="comment">// 设置 当前作业分片总数</span></div><div class="line">   JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());</div><div class="line">   <span class="comment">// 创建 作业调度控制器</span></div><div class="line">   JobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</div><div class="line">           createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</div><div class="line">   <span class="comment">// 添加 作业调度控制器</span></div><div class="line">   JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);</div><div class="line">   <span class="comment">// 注册 作业启动信息</span></div><div class="line">   schedulerFacade.registerStartUpInfo(!liteJobConfigFromRegCenter.isDisabled());</div><div class="line">   <span class="comment">// 调度作业</span></div><div class="line">   jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-1-更新作业配置"><a href="#3-2-1-更新作业配置" class="headerlink" title="3.2.1 更新作业配置"></a>3.2.1 更新作业配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerFacade.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 更新作业配置.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> liteJobConfig 作业配置</div><div class="line">* <span class="doctag">@return</span> 更新后的作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> LiteJobConfiguration <span class="title">updateJobConfiguration</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   <span class="comment">// 更新 作业配置</span></div><div class="line">   configService.persist(liteJobConfig);</div><div class="line">   <span class="comment">// 读取 作业配置</span></div><div class="line">   <span class="keyword">return</span> configService.load(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从<a href="http://www.yunai.me/Elastic-Job/job-config/?self">《Elastic-Job 源码分析 —— 作业配置》</a>的「3.2 持久化作业配置」，调用 <code>ConfigService#persist(...)</code> 方法也不一定会更新作业配置，因此调用 <code>ConfigService#load(...)</code> 方法返回的可能是本地的作业配置，也可能是<strong>注册中心</strong>存储的作业配置。</li>
</ul>
<h3 id="3-2-2-设置当前作业分片总数"><a href="#3-2-2-设置当前作业分片总数" class="headerlink" title="3.2.2 设置当前作业分片总数"></a>3.2.2 设置当前作业分片总数</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobRegistry.java</span></div><div class="line"><span class="keyword">private</span> Map&lt;String, Integer&gt; currentShardingTotalCountMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 设置当前分片总数.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> jobName 作业名称</div><div class="line">* <span class="doctag">@param</span> currentShardingTotalCount 当前分片总数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentShardingTotalCount</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> <span class="keyword">int</span> currentShardingTotalCount)</span> </span>&#123;</div><div class="line">   currentShardingTotalCountMap.put(jobName, currentShardingTotalCount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-3-创建作业调度控制器"><a href="#3-2-3-创建作业调度控制器" class="headerlink" title="3.2.3 创建作业调度控制器"></a>3.2.3 创建作业调度控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略</span></div><div class="line">   <span class="comment">// 创建 作业调度控制器</span></div><div class="line">   JobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</div><div class="line">           createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</div><div class="line">   <span class="comment">// .... 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>JobScheduleController，作业调度控制器，提供对 Quartz 方法的封装：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobScheduleController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Quartz 调度器</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业信息</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobDetail jobDetail;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 触发器编号</div><div class="line">     * 目前使用工作名字( jobName )</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String triggerIdentity;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 调度作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rescheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 重新调度作业</span></div><div class="line">    <span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;&#125; <span class="comment">// 创建触发器</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isPaused</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 判断作业是否暂停</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pauseJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 暂停作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">resumeJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 恢复作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">triggerJob</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 立刻启动作业</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 关闭调度器</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>#createScheduler()</code> 方法创建 Quartz 调度器：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">       factory.initialize(getBaseQuartzProperties());</div><div class="line">       result = factory.getScheduler();</div><div class="line">       result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, org.quartz.simpl.SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// Quartz 线程数：1</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, liteJobConfig.getJobName());</div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, JobShutdownHookPlugin.class.getName()); <span class="comment">// 作业关闭钩子</span></div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString()); <span class="comment">// 关闭时，清理所有资源</span></div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>org.quartz.threadPool.threadCount = 1</code>，即 Quartz 执行作业线程数量为 1。原因：一个<strong>作业( ElasticJob )</strong>的调度，需要配置<strong>独有</strong>的一个<strong>作业调度器( JobScheduler )</strong>，两者是 <code>1 : 1</code> 的关系。</li>
<li><code>org.quartz.plugin.shutdownhook.class</code> 设置作业<strong>优雅关闭</strong>钩子：<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/internal/schedule/JobShutdownHookPlugin.java" rel="external nofollow noopener noreferrer" target="_blank">JobShutdownHookPlugin</a>。</li>
<li>触发器监听器( TriggerListener )，在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</li>
</ul>
</li>
<li><p>调用 <code>#createJobDetail()</code> 方法创建 Quartz 作业：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> JobDetail <span class="title">createJobDetail</span><span class="params">(<span class="keyword">final</span> String jobClass)</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 Quartz 作业</span></div><div class="line">   JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div><div class="line">   <span class="comment">//</span></div><div class="line">   result.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);</div><div class="line">   <span class="comment">// 创建 Elastic-Job 对象</span></div><div class="line">   Optional&lt;ElasticJob&gt; elasticJobInstance = createElasticJobInstance();</div><div class="line">   <span class="keyword">if</span> (elasticJobInstance.isPresent()) &#123;</div><div class="line">       result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJobInstance.get());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!jobClass.equals(ScriptJob.class.getCanonicalName())) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           result.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, Class.forName(jobClass).newInstance());</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Elastic-Job: Job class '%s' can not initialize."</span>, jobClass);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> Optional&lt;ElasticJob&gt; <span class="title">createElasticJobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// SpringJobScheduler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Optional&lt;ElasticJob&gt; <span class="title">createElasticJobInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> Optional.fromNullable(elasticJob);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>创建 Quartz 作业设置了 LiteJob 类，这样 Quartz 触发作业执行时，LiteJob 会去调用 Elastic-Job 作业对象。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</li>
<li>在 Spring 里，Elastic-Job 如果已经创建好<strong>注入</strong>到 SpringJobScheduler，无需进行创建。</li>
<li><code>Jodetail.jobDataMap</code> 属性里添加了作业门面对象( LiteJobFacade )、Elastic-Job 对象，Quartz  触发作业时，会设置到 LiteJob 对象里。</li>
</ul>
</li>
</ul>
<h3 id="3-2-4-注册作业启动信息"><a href="#3-2-4-注册作业启动信息" class="headerlink" title="3.2.4 注册作业启动信息"></a>3.2.4 注册作业启动信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 注册作业启动信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStartUpInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">   <span class="comment">// 开启 所有监听器</span></div><div class="line">   listenerManager.startAllListeners();</div><div class="line">   <span class="comment">// 选举 主节点</span></div><div class="line">   leaderService.electLeader();</div><div class="line">   <span class="comment">// 持久化 作业服务器上线信息</span></div><div class="line">   serverService.persistOnline(enabled);</div><div class="line">   <span class="comment">// 持久化 作业运行实例上线相关信息</span></div><div class="line">   instanceService.persistOnline();</div><div class="line">   <span class="comment">// 设置 需要重新分片的标记</span></div><div class="line">   shardingService.setReshardingFlag();</div><div class="line">   <span class="comment">// 初始化 作业监听服务</span></div><div class="line">   monitorService.listen();</div><div class="line">   <span class="comment">// 初始化 调解作业不一致状态服务</span></div><div class="line">   <span class="keyword">if</span> (!reconcileService.isRunning()) &#123;</div><div class="line">       reconcileService.startAsync();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>开启所有监听器。每个功能模块都有其相应的监听器，在<a href="http://www.yunai.me/images/common/wechat_mp_2017_07_31_bak.jpg">模块对应「文章」</a>详细分享。</li>
<li>选举主节点，在<a href="http://www.yunai.me/Elastic-Job/election/?self">《Elastic-Job-Lite 源码解析 —— 主节点选举》</a>详细分享。</li>
<li><p>调用 <code>ServerService#persistOnline()</code> 方法，持久化作业服务器上线信息。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerService</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持久化作业服务器上线信息.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> enabled 作业是否启用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistOnline</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName)) &#123;</div><div class="line">            jobNodeStorage.fillJobNode(serverNode.getServerNode(JobRegistry.getInstance().getJobInstance(jobName).getIp()), enabled ? <span class="string">""</span> : ServerStatus.DISABLED.name());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当作业配置设置作业<strong>禁用</strong>时( <code>LiteJobConfiguration.disabled = true</code> )，作业调度但<strong>调度作业分片为空</strong>。不太好理解？<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</li>
</ul>
</li>
<li><p>调用 <code>InstanceService#persistOnline()</code> 方法，持久化作业运行实例上线相关信息：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceService</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持久化作业运行实例上线相关信息.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistOnline</span><span class="params">()</span> </span>&#123;</div><div class="line">        jobNodeStorage.fillEphemeralJobNode(instanceNode.getLocalInstanceNode(), <span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>设置需要重新分片的标记，在<a href="http://www.yunai.me/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</p>
</li>
<li>初始化作业监听服务，在<a href="http://www.yunai.me/Elastic-Job/job-monitor/?self">《Elastic-Job-Lite 源码解析 —— 作业监控服务》</a>详细分享。</li>
<li>初始化调解作业不一致状态服务，在<a href="http://www.yunai.me/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码解析 —— 自诊断修复》</a>详细分享。</li>
</ul>
<h3 id="3-2-5-调度作业"><a href="#3-2-5-调度作业" class="headerlink" title="3.2.5 调度作业"></a>3.2.5 调度作业</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 调度作业</span></div><div class="line">   jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 调度作业.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> cron CRON表达式</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobDetail.getKey())) &#123;</div><div class="line">           scheduler.scheduleJob(jobDetail, createTrigger(cron));</div><div class="line">       &#125;</div><div class="line">       scheduler.start();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#scheduleJob()</code> 方法后，该 Elastic-Job 作业<strong>开始</strong>被调度。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>作业初始化，如果你对 Quartz 不是特别了解，可以再看 Quartz 再重新理解。</p>
<p>下一篇，<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a> 起航！</p>
<p>道友，分享一波<strong>微信朋友圈</strong>支持支持支持，可好？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业注册表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;3
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job-Lite 源码分析 —— 作业配置</title>
    <link href="http://www.yunai.me/Elastic-Job/job-config/"/>
    <id>http://www.yunai.me/Elastic-Job/job-config/</id>
    <published>2017-09-08T16:00:00.000Z</published>
    <updated>2017-08-28T11:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 作业配置</a><ul>
<li><a href="#">2.1 注册中心配置</a></li>
<li><a href="#">2.2 Lite作业配置</a><ul>
<li><a href="#">2.2.1 作业类型配置</a></li>
<li><a href="#">2.2.2 作业核心配置</a></li>
</ul>
</li>
<li><a href="#">2.3 作业事件配置</a></li>
<li><a href="#">2.4 作业监听器</a></li>
</ul>
</li>
<li><a href="#">3. 作业配置服务</a><ul>
<li><a href="#">3.1 读取作业配置</a></li>
<li><a href="#">3.2 持久化作业配置</a></li>
<li><a href="#">3.3 校验本机时间是否合法</a></li>
</ul>
</li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业配置</strong>。</p>
<p>涉及到主要类的类图如下( <a href="http://www.yunai.me/images/Elastic-Job/2017_09_09/01.png">打开大图</a> )：</p>
<p><img src="http://www.yunai.me/images/Elastic-Job/2017_09_09/01.png" alt=""></p>
<ul>
<li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业配置类。</li>
</ul>
<p>另外建议你已经( 非必须 )：</p>
<ul>
<li>阅读过<a href="http://dangdangdotcom.github.io/elastic-job/elastic-job-lite/02-guide/config-manual/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 配置手册》</a></li>
<li>运行过 <a href="https://github.com/dangdangdotcom/elastic-job/blob/8926e94aa7c48dc635a36518da2c4b10194420a5/elastic-job-example/elastic-job-example-lite-java/src/main/java/com/dangdang/ddframe/job/example/JavaMain.java" rel="external nofollow noopener noreferrer" target="_blank">JavaMain.java</a></li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<h1 id="2-作业配置"><a href="#2-作业配置" class="headerlink" title="2. 作业配置"></a>2. 作业配置</h1><p>一个<strong>作业( ElasticJob )</strong>的调度，需要配置<strong>独有</strong>的一个<strong>作业调度器( JobScheduler )</strong>，两者是 <code>1 : 1</code> 的关系。<strong>这点大家要注意下，当然下文看代码也会看到。</strong></p>
<p>作业调度器的创建可以配置四个参数：</p>
<ol>
<li>注册中心( CoordinatorRegistryCenter )：用于协调分布式服务。<strong>必填</strong>。</li>
<li>Lite作业配置( LiteJobConfiguration )：<strong>必填</strong>。</li>
<li>作业事件总线( JobEventBus )：对作业事件<strong>异步</strong>监听。<strong>选填</strong>。</li>
<li>作业监听器( ElasticJobListener )：对作业执行前，执行后进行<strong>同步</strong>监听。<strong>选填</strong>。</li>
</ol>
<h2 id="2-1-注册中心配置"><a href="#2-1-注册中心配置" class="headerlink" title="2.1 注册中心配置"></a>2.1 注册中心配置</h2><p>Elastic-Job 抽象了<strong>注册中心接口( RegistryCenter )</strong>，并提供了默认<strong>基于 Zookeeper 的注册中心实现( ZookeeperRegistryCenter )</strong>。</p>
<p>ZookeeperRegistryCenter 对应配置类为 ZookeeperConfiguration。该类注释很完整，可以点击<a href="https://github.com/dangdangdotcom/elastic-job/blob/7dc099541a16de49f024fc59e46377a726be7f6b/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/reg/zookeeper/ZookeeperConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>直接查看源码，这里我们重点说下 <code>namespace</code> 属性。如果你有多个<strong>不同</strong> Elastic-Job集群 时，使用相同 Zookeeper，可以配置不同的 <code>namespace</code> 进行隔离。</p>
<p>注册中心的<strong>初始化</strong>，我们会在<a href="http://www.yunai.me/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码解析 —— 注册中心》</a>详细分享。</p>
<h2 id="2-2-Lite作业配置"><a href="#2-2-Lite作业配置" class="headerlink" title="2.2 Lite作业配置"></a>2.2 Lite作业配置</h2><p><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-lite/elastic-job-lite-core/src/main/java/com/dangdang/ddframe/job/lite/config/LiteJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">LiteJobConfiguration</a> 继承自接口 <a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/JobRootConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">JobRootConfiguration</a>，作为 Elastic-Job-Lite 里的作业( LiteJob )配置。<em>Elastic-Job-Cloud 的作业( CloudJob )对应另外的配置类，也实现了该接口。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJobConfiguration</span> <span class="keyword">implements</span> <span class="title">JobRootConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobTypeConfiguration typeConfig;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> monitorExecution;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimeDiffSeconds;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> monitorPort;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobShardingStrategyClass;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconcileIntervalMinutes;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> disabled;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> overwrite;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略部分get方法</span></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// .... 省略部分属性</span></div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LiteJobConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LiteJobConfiguration(jobConfig, monitorExecution, maxTimeDiffSeconds, monitorPort, jobShardingStrategyClass, reconcileIntervalMinutes, disabled, overwrite);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>typeConfig</code>：作业类型配置。<strong>必填</strong>。</li>
<li><p><code>monitorExecution</code>：监控作业运行时状态。默认为 <code>false</code>。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行》</a>详细分享。</p>
<blockquote>
<p>每次作业执行时间和间隔时间均<strong>非常短</strong>的情况，建议不监控作业运行时状态以提升效率。因为是瞬时状态，所以无必要监控。请用户自行增加数据堆积监控。并且不能保证数据重复选取，应在作业中实现幂等性。<br>  每次作业执行时间和间隔时间均<strong>较长的</strong>情况，建议监控作业运行时状态，可保证数据不会重复选取。</p>
</blockquote>
</li>
<li><p><code>monitorPort</code>：作业监控端口。默认为 <code>-1</code>，不开启作业监控端口。选填。在<a href="http://www.yunai.me/Elastic-Job/job-monitor/?self">《Elastic-Job-Lite 源码解析 —— 作业监控服务》</a>详细分享。</p>
<blockquote>
<p>建议配置作业监控端口, 方便开发者dump作业信息。<br>  使用方法: echo “dump” | nc 127.0.0.1 9888</p>
</blockquote>
</li>
<li><p><code>maxTimeDiffSeconds</code>：设置最大容忍的本机与注册中心的时间误差秒数。默认为 <code>-1</code>，不检查时间误差。选填。</p>
</li>
<li><code>jobShardingStrategyClass</code>：作业分片策略实现类全路径。默认为使用分配侧路。选填。在<a href="http://www.yunai.me/Elastic-Job/job-sharding-strategy/?self">《Elastic-Job-Lite 源码解析 —— 作业分片策略》</a>详细分享。</li>
<li><p><code>reconcileIntervalMinutes</code>：修复作业服务器不一致状态服务调度间隔时间，配置为小于1的任意值表示不执行修复。默认为 <code>10</code>。在<a href="http://www.yunai.me/Elastic-Job/reconcile/?self">《Elastic-Job-Lite 源码解析 —— 自诊断修复 》</a>详细分享。</p>
</li>
<li><p><code>disabled</code>：作业是否禁用执行。默认为 <code>false</code>。选填。</p>
</li>
<li><code>overwrite</code>：设置使用本地作业配置覆盖注册中心的作业配置。默认为 <code>false</code>。选填。建议使用<strong>运维平台( console )</strong>配置作业配置，统一管理。</li>
<li>Builder 类：使用该类配置 LiteJobConfiguration 属性，调用 <code>#build()</code> 方法最终生成作业配置。参见：<a href="http://blog.csdn.net/top_code/article/details/8469297" rel="external nofollow noopener noreferrer" target="_blank">《JAVA设计模式 — 生成器模式(Builder)》</a>。</li>
</ul>
<h3 id="2-2-1-作业类型配置"><a href="#2-2-1-作业类型配置" class="headerlink" title="2.2.1 作业类型配置"></a>2.2.1 作业类型配置</h3><p>作业类型配置<strong>接口</strong>( <a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/JobTypeConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">JobTypeConfiguration</a> ) 有三种配置实现，针对三种作业类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">配置实现</th>
<th style="text-align:left">作业</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/simple/SimpleJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">SimpleJobConfiguration</a></td>
<td style="text-align:left">SimpleJob</td>
<td style="text-align:left">简单作业。例如：订单过期作业</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/dataflow/DataflowJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">DataflowJobConfiguration</a></td>
<td style="text-align:left">DataflowJob</td>
<td style="text-align:left">数据流作业。TODO：笔者暂时未了解流式处理数据，不误人子弟</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/dangdangdotcom/elastic-job/blob/6617853bf059df373e2cb6ce959038c583ae5064/elastic-job-common/elastic-job-common-core/src/main/java/com/dangdang/ddframe/job/config/script/ScriptJobConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">ScriptJobConfiguration</a></td>
<td style="text-align:left">ScriptJob</td>
<td style="text-align:left">脚本作业。例如：调用 shell 脚本备份数据库作业</td>
</tr>
</tbody>
</table>
<p>三种<strong>配置类</strong>属性对比如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">SimpleJob</th>
<th style="text-align:left">DataflowJob</th>
<th style="text-align:left">ScriptJob</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>coreConfig</code></td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">作业核心配置</td>
</tr>
<tr>
<td style="text-align:left"><code>jobType</code></td>
<td style="text-align:left">JobType.SIMPLE</td>
<td style="text-align:left">JobType.DATAFLOW</td>
<td style="text-align:left">JobType.SCRIPT</td>
<td style="text-align:left">作业类型</td>
</tr>
<tr>
<td style="text-align:left"><code>jobClass</code></td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√ (默认：ScriptJob.class)</td>
<td style="text-align:left">作业实现类全路径</td>
</tr>
<tr>
<td style="text-align:left"><code>streamingProcess</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">√</td>
<td style="text-align:left"></td>
<td style="text-align:left">是否流式处理数据</td>
</tr>
<tr>
<td style="text-align:left"><code>scriptCommandLine</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">√</td>
<td style="text-align:left">脚本型作业执行命令行</td>
</tr>
</tbody>
</table>
<p><strong>作业类型配置不仅仅适用于 Elastic-Job-Lite，也适用于 Elastic-Job-Cloud。</strong></p>
<h3 id="2-2-2-作业核心配置"><a href="#2-2-2-作业核心配置" class="headerlink" title="2.2.2 作业核心配置"></a>2.2.2 作业核心配置</h3><p>作业核心配置( JobCoreConfiguration )，我们可以看到在每种作业类型配置都有该属性( <code>coreConfig</code> )。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobCoreConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cron;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingItemParameters;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failover;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> misfire;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobProperties jobProperties;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="comment">// .... 省略部分属性</span></div><div class="line">    </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> JobCoreConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            Preconditions.checkArgument(!Strings.isNullOrEmpty(jobName), <span class="string">"jobName can not be empty."</span>);</div><div class="line">            Preconditions.checkArgument(!Strings.isNullOrEmpty(cron), <span class="string">"cron can not be empty."</span>);</div><div class="line">            Preconditions.checkArgument(shardingTotalCount &gt; <span class="number">0</span>, <span class="string">"shardingTotalCount should larger than zero."</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JobCoreConfiguration(jobName, cron, shardingTotalCount, shardingItemParameters, jobParameter, failover, misfire, description, jobProperties);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>jobName</code>：作业名称。<strong>必填。</strong></li>
<li><code>cron</code>：cron表达式，用于控制作业触发时间。<strong>必填。</strong></li>
<li><code>shardingTotalCount</code>：作业分片总数。如果一个作业启动超过作业分片总数的节点，只有 <code>shardingTotalCount</code> 会执行作业。<strong>必填。</strong>在<a href="http://www.yunai.me/Elastic-Job/job-sharding-strategy/?self">《Elastic-Job-Lite 源码解析 —— 作业分片策略 》</a>详细分享。</li>
<li><p><code>shardingItemParameters</code>：分片序列号和参数。选填。</p>
<blockquote>
<p>分片序列号和参数用等号分隔，多个键值对用逗号分隔<br>  分片序列号从0开始，<strong>不可大于或等于</strong>作业分片总数<br>  如：<br>  0=a,1=b,2=c  </p>
</blockquote>
</li>
<li><p><code>jobParameter</code>：作业自定义参数。选填。</p>
<blockquote>
<p>作业自定义参数，可通过传递该参数为作业调度的业务方法传参，用于实现带参数的作业<br>  例：每次获取的数据量、作业实例从数据库读取的主键等</p>
</blockquote>
</li>
<li><p><code>failover</code>：是否开启作业执行失效转移。<strong>开启表示如果作业在一次作业执行中途宕机，允许将该次未完成的作业在另一作业节点上补偿执行</strong>。默认为 <code>false</code>。选填。在<a href="http://www.yunai.me/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移 》</a>详细分享。</p>
</li>
<li><code>misfire</code>：是否开启错过作业重新执行。默认为 <code>true</code>。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行 》</a>详细分享。</li>
<li><code>description</code>：作业描述。选填。</li>
<li><p><code>jobProperties</code>：作业属性配置。选填。在<a href="http://www.yunai.me/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码解析 —— 作业执行 》</a>详细分享。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobProperties</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> EnumMap&lt;JobPropertiesEnum, String&gt; map = <span class="keyword">new</span> EnumMap&lt;&gt;(JobPropertiesEnum.class);</div><div class="line">    </div><div class="line">   <span class="keyword">public</span> <span class="keyword">enum</span> JobPropertiesEnum &#123;</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 作业异常处理器.</div><div class="line">         */</div><div class="line">        JOB_EXCEPTION_HANDLER(<span class="string">"job_exception_handler"</span>, JobExceptionHandler.class, DefaultJobExceptionHandler.class.getCanonicalName()),</div><div class="line">        </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 线程池服务处理器.</div><div class="line">         */</div><div class="line">        EXECUTOR_SERVICE_HANDLER(<span class="string">"executor_service_handler"</span>, ExecutorServiceHandler.class, DefaultExecutorServiceHandler.class.getCanonicalName());</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String key;</div><div class="line">    </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; classType;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String defaultValue;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>JOB_EXCEPTION_HANDLER</code>：用于扩展<strong>异常处理</strong>类。</li>
<li><code>EXECUTOR_SERVICE_HANDLER</code>：用于扩展<strong>作业处理线程池</strong>类。</li>
<li>通过这个属性，我们可以自定义<strong>每个作业</strong>的异常处理和线程池服务。    </li>
</ul>
</li>
</ul>
<h2 id="2-3-作业事件配置"><a href="#2-3-作业事件配置" class="headerlink" title="2.3 作业事件配置"></a>2.3 作业事件配置</h2><p>通过作业事件配置( JobEventConfiguration )，实现对作业事件的<strong>异步</strong>监听、处理。在<a href="http://www.yunai.me/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码解析 —— 作业事件追踪》</a>详细分享。</p>
<h2 id="2-4-作业监听器"><a href="#2-4-作业监听器" class="headerlink" title="2.4 作业监听器"></a>2.4 作业监听器</h2><p>通过配置作业监听器( ElasticJobListener )，实现对作业执行的<strong>同步</strong>监听、处理。在<a href="http://www.yunai.me/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</p>
<h1 id="3-作业配置服务"><a href="#3-作业配置服务" class="headerlink" title="3. 作业配置服务"></a>3. 作业配置服务</h1><p>多个 Elastic-Job-Lite 使用相同<strong>注册中心</strong>和相同 <strong><code>namespace</code></strong> 组成集群，实现高可用。集群中，使用作业配置服务( ConfigurationService ) 共享作业配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 时间服务</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeService timeService;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业节点数据访问类</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigurationService</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</div><div class="line">        timeService = <span class="keyword">new</span> TimeService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>JobNodeStorage，封装注册中心，提供存储服务。在<a href="http://www.yunai.me/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>详细分享。</li>
<li><p>TimeService，时间服务，提供当前时间查询。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取当前时间的毫秒数.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@return</span> 当前时间的毫秒数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCurrentMillis</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-1-读取作业配置"><a href="#3-1-读取作业配置" class="headerlink" title="3.1 读取作业配置"></a>3.1 读取作业配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 读取作业配置.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> fromCache 是否从缓存中读取</div><div class="line">* <span class="doctag">@return</span> 作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> LiteJobConfiguration <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromCache)</span> </span>&#123;</div><div class="line">   String result;</div><div class="line">   <span class="keyword">if</span> (fromCache) &#123; <span class="comment">// 缓存</span></div><div class="line">       result = jobNodeStorage.getJobNodeData(ConfigurationNode.ROOT);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result) &#123;</div><div class="line">           result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result = jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> LiteJobConfigurationGsonFactory.fromJson(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-持久化作业配置"><a href="#3-2-持久化作业配置" class="headerlink" title="3.2 持久化作业配置"></a>3.2 持久化作业配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 持久化分布式作业配置信息.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> liteJobConfig 作业配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persist</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   checkConflictJob(liteJobConfig);</div><div class="line">   <span class="keyword">if</span> (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT) || liteJobConfig.isOverwrite()) &#123;</div><div class="line">       jobNodeStorage.replaceJobNode(ConfigurationNode.ROOT, LiteJobConfigurationGsonFactory.toJson(liteJobConfig));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#checkConflictJob(...)</code> 方法<strong>校验</strong>注册中心存储的作业配置的作业实现类全路径( <code>jobClass</code> )和当前的是否相同，如果不同，则认为是<strong>冲突</strong>，不允许存储：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConflictJob</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</div><div class="line">   Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</div><div class="line">   <span class="keyword">if</span> (liteJobConfigFromZk.isPresent()</div><div class="line">           &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123; <span class="comment">// jobClass 是否相同</span></div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job conflict with register center. The job '%s' in register center's class is '%s', your job class is '%s'"</span>, </div><div class="line">               liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>当注册中心<strong>未存储</strong>该作业配置 或者 当前作业配置允许替换注册中心作业配置( <code>overwrite = true</code> )时，持久化作业配置。</li>
</ul>
<h2 id="3-3-校验本机时间是否合法"><a href="#3-3-校验本机时间是否合法" class="headerlink" title="3.3 校验本机时间是否合法"></a>3.3 校验本机时间是否合法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 检查本机与注册中心的时间误差秒数是否在允许范围.</div><div class="line">* </div><div class="line">* <span class="doctag">@throws</span> JobExecutionEnvironmentException 本机与注册中心的时间误差秒数不在允许范围所抛出的异常</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkMaxTimeDiffSecondsTolerable</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   <span class="keyword">int</span> maxTimeDiffSeconds =  load(<span class="keyword">true</span>).getMaxTimeDiffSeconds();</div><div class="line">   <span class="keyword">if</span> (-<span class="number">1</span>  == maxTimeDiffSeconds) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">long</span> timeDiff = Math.abs(timeService.getCurrentMillis() - jobNodeStorage.getRegistryCenterTime());</div><div class="line">   <span class="keyword">if</span> (timeDiff &gt; maxTimeDiffSeconds * <span class="number">1000L</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobExecutionEnvironmentException(</div><div class="line">               <span class="string">"Time different between job server and register center exceed '%s' seconds, max time different is '%s' seconds."</span>, timeDiff / <span class="number">1000</span>, maxTimeDiffSeconds);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Elastic-Job-Lite 作业触发是<strong>依赖本机时间</strong>，相同集群使用注册中心时间为基准，校验本机与注册中心的时间误差是否在允许范围内( <code>LiteJobConfiguration.maxTimeDiffSeconds</code> )。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>Elastic-Job-Lite 源码解析系列第一篇文章，希望大家多多支持，预计全部更新完会有 15+ 篇。Elastic-Job-Cloud 源码系列后续也会更新。</p>
<p>道友，分享一波<strong>微信朋友圈</strong>支持支持支持，可好？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文基于 Elastic-Job V2.1.5 版本分享&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;1. 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2. 作业配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#&quot;&gt;2.1
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title>Elastic-Job 源码分析 —— 为什么阅读 Elastic-Job 源码？</title>
    <link href="http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/"/>
    <id>http://www.yunai.me/Elastic-Job/why-read-Elastic-Job-source-code/</id>
    <published>2017-08-31T16:00:00.000Z</published>
    <updated>2017-08-26T13:35:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h2 id="为什么阅读-Elastic-Job-源码？"><a href="#为什么阅读-Elastic-Job-源码？" class="headerlink" title="为什么阅读 Elastic-Job 源码？"></a>为什么阅读 Elastic-Job 源码？</h2><ol>
<li>之前断断续续读过 Quartz 源码，团队里也对 Quartz 做过一些封装管理，很多 Quartz 二次封装开源项目，想了解 Elastic-Job 做了哪些功能，是怎么实现的</li>
<li>Quartz 多节点通过数据库锁实现任务抢占，Elastic-Job 基于什么策略实现任务调度与分配</li>
<li>任务分片如何实现</li>
<li>Elastic-Job-Cloud 如何实现任务动态扩容和缩容</li>
<li>任务超时如何处理？任务假死怎么判断？</li>
</ol>
<h2 id="使用公司"><a href="#使用公司" class="headerlink" title="使用公司"></a>使用公司</h2><h2 id="步骤-功能"><a href="#步骤-功能" class="headerlink" title="步骤/功能"></a>步骤/功能</h2><ul>
<li>[ ] 分布式调度协调</li>
<li>[ ] 弹性扩容缩容</li>
<li>[ ] 失效转移</li>
<li>[x] 错过执行作业重触发</li>
<li>[x] 作业分片策略</li>
<li>[x] 作业唯一节点执行</li>
<li>[ ] 自诊断并修复分布式不稳定造成的问题</li>
<li>[x] 支持并行调度</li>
<li>[ ] 支持作业生命周期操作</li>
<li>[x] 丰富的作业类型</li>
<li>[ ] Spring整合以及命名空间提供</li>
<li>[ ] 运维平台</li>
<li>[ ] 事件追踪</li>
<li>[ ] DUMP 作业运行信息</li>
<li>[ ] 作业监听器</li>
<li>[ ] 基于 Docker 的进程隔离（TBD）</li>
<li>[x] 高可用</li>
</ul>
<h2 id="XXL-JOB"><a href="#XXL-JOB" class="headerlink" title="XXL-JOB"></a>XXL-JOB</h2><p>基于 V1.8，会逐渐和 Elastic-Job 功能做对比</p>
<ul>
<li>[ ] 1、简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；</li>
<li>[ ] 2、动态：支持动态修改任务状态、暂停/恢复任务，以及终止运行中任务，即时生效；</li>
<li>[ ] 3、调度中心HA（中心式）：调度采用中心式设计，“调度中心”基于集群Quartz实现，可保证调度中心HA；</li>
<li>[ ] 4、执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA；</li>
<li>[ ] 5、任务Failover：执行器集群部署时，任务路由策略选择”故障转移”情况下调度失败时将会平滑切换执行器进行Failover；</li>
<li>[ ] 6、一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</li>
<li>[ ] 7、自定义任务参数：支持在线配置调度任务入参，即时生效；</li>
<li>[ ] 8、调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；</li>
<li>[ ] 9、弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；</li>
<li>[ ] 10、邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；</li>
<li>[ ] 11、状态监控：支持实时监控任务进度；</li>
<li>[ ] 12、Rolling执行日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；</li>
<li>[ ] 13、GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。</li>
<li>[ ] 14、数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；</li>
<li>[ ] 15、任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；</li>
<li>[ ] 16、推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;</li>
<li>[ ] 17、任务注册: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；</li>
<li>[ ] 18、路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li>
<li>[ ] 19、运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；</li>
<li>[ ] 20、脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python等类型脚本;</li>
<li>[ ] 21、阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；</li>
<li>[ ] 22、失败处理策略；调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；</li>
<li>[ ] 23、分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；</li>
<li>[ ] 24、动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;有福
    
    </summary>
    
      <category term="Elastic-Job" scheme="http://www.yunai.me/categories/Elastic-Job/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.yunai.me/Elastic-Job/x/"/>
    <id>http://www.yunai.me/Elastic-Job/x/</id>
    <published>2017-08-28T21:32:19.000Z</published>
    <updated>2017-08-28T21:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>elastic-job-common-restful</p>
<ol>
<li>RestfulServer 内嵌服务</li>
<li>GSONProvider</li>
<li>RestfulExceptionMapper 异常</li>
<li>WwwAuthFilter </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;elastic-job-common-restful&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RestfulServer 内嵌服务&lt;/li&gt;
&lt;li&gt;GSONProvider&lt;/li&gt;
&lt;li&gt;RestfulExceptionMapper 异常&lt;/li&gt;
&lt;li&gt;WwwAuthFilte
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-tcc/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p>占坑文。关注公众号，第一时间获得更新通知。<br>ps：tcc 暂时未实现，目前在 RoadMap 中</p>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;有
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— 分布式事务（一）之最大努力型</title>
    <link href="http://www.yunai.me/Sharding-JDBC/transaction-bed/"/>
    <id>http://www.yunai.me/Sharding-JDBC/transaction-bed/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-08-28T09:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. 最大努力送达型</a></li>
<li><a href="#">3. 柔性事务管理器</a><ul>
<li><a href="#">3.1 概念</a></li>
<li><a href="#">3.2 柔性事务配置</a></li>
<li><a href="#">3.3 柔性事务</a><ul>
<li><a href="#">3.3.1 创建柔性事务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#">4. 事务日志存储器</a><ul>
<li><a href="#">4.1 #add()</a></li>
<li><a href="#">4.2 #remove()</a></li>
<li><a href="#">4.3 #findEligibleTransactionLogs()</a></li>
<li><a href="#">4.4 #increaseAsyncDeliveryTryTimes()</a></li>
<li><a href="#">4.5 #processData()</a></li>
</ul>
</li>
<li><a href="#">5. 最大努力送达型事务监听器</a></li>
<li><a href="#">6. 最大努力送达型异步作业</a><ul>
<li><a href="#">6.1 BestEffortsDeliveryJob</a></li>
<li><a href="#">6.2 AsyncSoftTransactionJobConfiguration</a></li>
<li><a href="#">6.3 Elastic-Job 是否必须？</a></li>
</ul>
</li>
<li><a href="#">7. 适用场景</a></li>
<li><a href="#">8. 开发指南 &amp; 开发示例</a></li>
<li><a href="#">666. 彩蛋</a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>数据库表<strong>分库</strong>后，业务场景下的<strong>单库本地事务</strong>可能变成<strong>跨库分布式事务</strong>。虽然我们可以通过合适的<strong>分库规则</strong>让操作的数据在同库下，继续保证<strong>单库本地事务</strong>，这也是非常推崇的，但不是所有场景下都能适用。如果这些场景对事务的一致性有要求，我们就不得不解决分布式事务的“麻烦”。</p>
<p><strong>分布式事务</strong>是个很大的话题，我们来看看 Sharding-JDBC 对她的权衡：</p>
<blockquote>
<p>Sharding-JDBC由于性能方面的考量，决定不支持强一致性分布式事务。我们已明确规划线路图，未来会支持最终一致性的柔性事务。</p>
</blockquote>
<p>Sharding-JDBC 提供了两种 <strong>柔性事务</strong>：</p>
<ul>
<li>最大努力送达型 BED ：已经实现</li>
<li>事务补偿型 TCC ：计划中</li>
</ul>
<p><strong>本文分享 最大努力送达型 的实现</strong>。建议前置阅读：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a>。</p>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-最大努力送达型"><a href="#2-最大努力送达型" class="headerlink" title="2. 最大努力送达型"></a>2. 最大努力送达型</h1><p><strong>概念</strong></p>
<blockquote>
<p>在分布式数据库的场景下，相信对于该数据库的操作最终一定可以成功，所以通过最大努力反复尝试送达操作。</p>
</blockquote>
<p>从概念看，可能不是很直白的理解是什么意思，本文会<strong>最大努力</strong>让你干净理解。</p>
<p><strong>架构图</strong></p>
<blockquote>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_20/01.jpeg" alt=""></p>
</blockquote>
<p>执行过程有 <strong>四种</strong> 情况：</p>
<ol>
<li>【红线】执行成功</li>
<li>【棕线】执行失败，同步重试成功</li>
<li>【粉线】执行失败，同步重试失败，异步重试成功</li>
<li>【绿线】执行失败，同步重试失败，异步重试失败，事务日志保留</li>
</ol>
<p>整体成漏斗倒三角，上一个阶段失败，交给下一个阶段重试：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_20/02.png" alt=""></p>
<p>整个过程通过如下 <strong>组件</strong> 完成：</p>
<ul>
<li>柔性事务管理器</li>
<li>最大努力送达型柔性事务</li>
<li>最大努力送达型事务监听器</li>
<li>事务日志存储器</li>
<li>最大努力送达型异步作业</li>
</ul>
<p>下面，我们逐节分享每个组件。</p>
<h1 id="3-柔性事务管理器"><a href="#3-柔性事务管理器" class="headerlink" title="3. 柔性事务管理器"></a>3. 柔性事务管理器</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>柔性事务管理器，SoftTransactionManager 实现，负责对柔性事务配置( SoftTransactionConfiguration ) 、柔性事务( AbstractSoftTransaction )的管理。</p>
<h2 id="3-2-柔性事务配置"><a href="#3-2-柔性事务配置" class="headerlink" title="3.2 柔性事务配置"></a>3.2 柔性事务配置</h2><p>调用 <code>#init()</code> 初始化柔性管理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 柔性事务配置对象</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SoftTransactionConfiguration transactionConfig;  </div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 初始化事务管理器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// 初始化 最大努力送达型事务监听器</span></div><div class="line">   EventBusInstance.getInstance().register(<span class="keyword">new</span> BestEffortsDeliveryListener());</div><div class="line">   <span class="comment">// 初始化 事务日志数据库存储表</span></div><div class="line">   <span class="keyword">if</span> (TransactionLogDataSourceType.RDB == transactionConfig.getStorageType()) &#123;</div><div class="line">       Preconditions.checkNotNull(transactionConfig.getTransactionLogDataSource());</div><div class="line">       createTable();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 初始化 内嵌的最大努力送达型异步作业</span></div><div class="line">   <span class="keyword">if</span> (transactionConfig.getBestEffortsDeliveryJobConfiguration().isPresent()) &#123;</div><div class="line">       <span class="keyword">new</span> NestedBestEffortsDeliveryJobFactory(transactionConfig).init();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>将最大努力送达型事务监听器( BestEffortsDeliveryListener )注册到事务总线 ( EventBus )。在『最大努力送达型事务监听器』小节会详细分享</li>
<li>当使用<strong>数据库</strong>存储事务日志( TransactionLog ) 时，若<strong>事务日志表( <code>transaction_log</code> )</strong>不存在则进行创建。在『事务日志存储器』小节会详细分享</li>
<li>当配置使用<strong>内嵌的</strong>最大努力送达型异步作业( NestedBestEffortsDeliveryJob ) 时，进行初始化。在『最大努力送达型异步作业』小节会详细分享</li>
</ul>
<p><strong>SoftTransactionConfiguration</strong></p>
<p>SoftTransactionConfiguration，柔性事务配置对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftTransactionConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务管理器管理的数据源.</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.NONE)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource targetDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步的事务送达的最大尝试次数.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> syncMaxDeliveryTryTimes = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务日志存储类型.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> TransactionLogDataSourceType storageType = RDB;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存储事务日志的数据源.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> DataSource transactionLogDataSource;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 内嵌的最大努力送达型异步作业配置对象.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Optional&lt;NestedBestEffortsDeliveryJobConfiguration&gt; bestEffortsDeliveryJobConfiguration = Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-3-柔性事务"><a href="#3-3-柔性事务" class="headerlink" title="3.3 柔性事务"></a>3.3 柔性事务</h2><p>在 Sharding-JDBC 里，目前柔性事务分成两种：</p>
<ul>
<li>BEDSoftTransaction ：最大努力送达型柔性事务</li>
<li>TCCSoftTransaction ：TCC型柔性事务</li>
</ul>
<p><strong>继承 AbstractSoftTransaction</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接原自动提交状态</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> previousAutoCommit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分片连接</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> ShardingConnection connection;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务类型</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> SoftTransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务编号</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> String transactionId;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AbstractSoftTransaction 实现了开启柔性事务、关闭柔性事务两个方法提供给子类调用：</p>
<ul>
<li><p><code>#beginInternal()</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 开启柔性</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> conn 分片连接</div><div class="line">* <span class="doctag">@param</span> type 事务类型</div><div class="line">* <span class="doctag">@throws</span> SQLException</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginInternal</span><span class="params">(<span class="keyword">final</span> Connection conn, <span class="keyword">final</span> SoftTransactionType type)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// TODO 判断如果在传统事务中，则抛异常</span></div><div class="line">   Preconditions.checkArgument(conn <span class="keyword">instanceof</span> ShardingConnection, <span class="string">"Only ShardingConnection can support eventual consistency transaction."</span>);</div><div class="line">   <span class="comment">// 设置执行错误，不抛出异常</span></div><div class="line">   ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">false</span>);</div><div class="line">   connection = (ShardingConnection) conn;</div><div class="line">   transactionType = type;</div><div class="line">   <span class="comment">// 设置自动提交状态</span></div><div class="line">   previousAutoCommit = connection.getAutoCommit();</div><div class="line">   connection.setAutoCommit(<span class="keyword">true</span>);</div><div class="line">   <span class="comment">// 生成事务编号</span></div><div class="line">   <span class="comment">// TODO 替换UUID为更有效率的id生成器</span></div><div class="line">   transactionId = UUID.randomUUID().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>ExecutorExceptionHandler.setExceptionThrown(false)</code> 设置执行 SQL 错误时，也不抛出异常。</p>
<ul>
<li>对异常处理的代码：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorExceptionHandler.java#L59" rel="external nofollow noopener noreferrer" target="_blank">ExecutorExceptionHandler#setExceptionThrown()</a> </li>
<li>对于其他 SQL，不会因为 SQL 错误不执行，会继续执行</li>
<li>对于上层业务，不会因为 SQL 错误终止逻辑，会继续执行。这里有一点要注意下，上层业务不能对该 SQL 执行结果有强依赖，因为 SQL 错误需要重试达到数据最终一致性</li>
<li>对于<strong>最大努力型事务</strong>( TCC暂未实现 )，会对执行错误的 SQL 进行重试</li>
</ul>
</li>
<li><p>调用 <code>connection.setAutoCommit(true);</code>，设置执行自动提交。<strong>使用最大努力型事务时，上层业务执行 SQL 会马上提交，即使调用  <code>Connection#rollback()</code> 也是无法回滚的，这点一定要注意。</strong></p>
</li>
</ul>
</li>
<li><p><code>#end()</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 结束柔性事务.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">      ExecutorExceptionHandler.setExceptionThrown(<span class="keyword">true</span>);</div><div class="line">      connection.setAutoCommit(previousAutoCommit);</div><div class="line">      SoftTransactionManager.closeCurrentTransactionManager();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 关闭当前的柔性事务管理器.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeCurrentTransactionManager</span><span class="params">()</span> </span>&#123;</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION, <span class="keyword">null</span>);</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>事务结束后，一定要记得调用 <code>#end()</code> 清理线程变量。否则，下次请求使用到该线程，会继续在这个柔性事务内。</li>
</ul>
</li>
</ul>
<p><strong>BEDSoftTransaction</strong>    </p>
<p>BEDSoftTransaction，最大努力送达型柔性事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BEDSoftTransaction</span> <span class="keyword">extends</span> <span class="title">AbstractSoftTransaction</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 开启柔性事务.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connection 数据库连接对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">final</span> Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        beginInternal(connection, SoftTransactionType.BestEffortsDelivery);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>TCCSoftTransaction</strong></p>
<p>TCCSoftTransaction，TCC 型柔性事务，暂未实现。实现后，会更新到 <a href="http://www.yunai.me/Sharding-JDBC/transaction-tcc/?self">《Sharding-JDBC 源码分析 —— 分布式事务（二）之事务补偿型》</a>。</p>
<hr>
<h3 id="3-3-1-创建柔性事务"><a href="#3-3-1-创建柔性事务" class="headerlink" title="3.3.1 创建柔性事务"></a>3.3.1 创建柔性事务</h3><p>通过调用 <code>SoftTransactionManager#getTransaction()</code> 创建柔性事务对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务对象 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION = <span class="string">"transaction"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* &#123;<span class="doctag">@link</span> ExecutorDataMap#dataMap&#125; 柔性事务配置 key</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_CONFIG = <span class="string">"transactionConfig"</span>;</div><div class="line"></div><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> type 柔性事务类型</div><div class="line">* <span class="doctag">@return</span> 柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> AbstractSoftTransaction <span class="title">getTransaction</span><span class="params">(<span class="keyword">final</span> SoftTransactionType type)</span> </span>&#123;</div><div class="line">   AbstractSoftTransaction result;</div><div class="line">   <span class="keyword">switch</span> (type) &#123;</div><div class="line">       <span class="keyword">case</span> BestEffortsDelivery: </div><div class="line">           result = <span class="keyword">new</span> BEDSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TryConfirmCancel:</div><div class="line">           result = <span class="keyword">new</span> TCCSoftTransaction();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>: </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(type.toString());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TODO 目前使用不支持嵌套事务，以后这里需要可配置</span></div><div class="line">   <span class="keyword">if</span> (getCurrentTransaction().isPresent()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support nested transaction."</span>);</div><div class="line">   &#125;</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION, result);</div><div class="line">   ExecutorDataMap.getDataMap().put(TRANSACTION_CONFIG, transactionConfig);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>后续可以从 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/executor/threadlocal/ExecutorDataMap.java" rel="external nofollow noopener noreferrer" target="_blank">ExecutorDataMap</a> 中获取当前线程的柔性事务和柔性事务配置：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SoftTransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前线程的柔性事务配置.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前线程的柔性事务配置</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;SoftTransactionConfiguration&gt; <span class="title">getCurrentTransactionConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transactionConfig = ExecutorDataMap.getDataMap().get(TRANSACTION_CONFIG);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transactionConfig)</div><div class="line">           ? Optional.&lt;SoftTransactionConfiguration&gt;absent()</div><div class="line">           : Optional.of((SoftTransactionConfiguration) transactionConfig);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取当前的柔性事务.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 当前的柔性事务</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;AbstractSoftTransaction&gt; <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   Object transaction = ExecutorDataMap.getDataMap().get(TRANSACTION);</div><div class="line">   <span class="keyword">return</span> (<span class="keyword">null</span> == transaction)</div><div class="line">           ? Optional.&lt;AbstractSoftTransaction&gt;absent()</div><div class="line">           : Optional.of((AbstractSoftTransaction) transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="4-事务日志存储器"><a href="#4-事务日志存储器" class="headerlink" title="4. 事务日志存储器"></a>4. 事务日志存储器</h1><p>柔性事务执行过程中，会通过事务日志( TransactionLog ) 记录每条 SQL 执行状态：</p>
<ul>
<li>SQL 执行前，记录一条事务日志</li>
<li>SQL 执行成功，移除对应的事务日志 </li>
</ul>
<p>通过实现事务日志存储器接口( TransactionLogStorage )，提供存储功能。目前有两种实现：</p>
<ul>
<li>MemoryTransactionLogStorage ：基于<strong>内存</strong>的事务日志存储器。主要用于开发测试，<strong>生产环境下不要使用</strong>。</li>
<li>RdbTransactionLogStorage ：基于<strong>数据库</strong>的事务日志存储器。</li>
</ul>
<p>本节只分析 RdbTransactionLogStorage。对 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/884b38f4c2402e31464d15b444f4b405e07fe211/sharding-jdbc-transaction-parent/sharding-jdbc-transaction-storage/src/main/java/com/dangdang/ddframe/rdb/transaction/soft/storage/impl/RdbTransactionLogStorage.java" rel="external nofollow noopener noreferrer" target="_blank">MemoryTransactionLogStorage</a> 感兴趣的同学可以点击链接传送到达。</p>
<p><strong>TransactionLogStorage 有五个接口方法，下文每个小标题都是一个方法。</strong></p>
<h2 id="4-1-add"><a href="#4-1-add" class="headerlink" title="4.1 #add()"></a>4.1 #add()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 存储事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(TransactionLog transactionLog)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TransactionLog transactionLog)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"INSERT INTO `transaction_log` (`id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`) VALUES (?, ?, ?, ?, ?, ?);"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">    <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：如果插入事务日志<strong>失败</strong>，SQL 会继续执行，如果此时 SQL 执行失败，则该 SQL 会不见了。建议：<code>#add()</code> 和下文的 <code>#remove()</code> 异常时，都打印下异常日志都文件系统</li>
</ul>
<p>TransactionLog (transaction_log) 数据库表结构如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>名字</th>
<th>数据库类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>事件编号</td>
<td>VARCHAR(40)</td>
<td>EventBus 事件编号，<strong>非事务编号</strong></td>
</tr>
<tr>
<td>transaction_type</td>
<td>柔性事务类型</td>
<td>VARCHAR(30)</td>
</tr>
<tr>
<td>data_source</td>
<td>真实数据源名</td>
<td>VARCHAR(255)</td>
<td></td>
</tr>
<tr>
<td>sql</td>
<td>执行 SQL</td>
<td>TEXT</td>
<td>已经改写过的 SQL</td>
</tr>
<tr>
<td>parameters</td>
<td>占位符参数</td>
<td>TEXT</td>
<td>JSON 字符串存储</td>
</tr>
<tr>
<td>creation_time</td>
<td>记录时间</td>
<td>LONG</td>
</tr>
<tr>
<td>async_delivery_try_times</td>
<td>已异步重试次数</td>
<td>INT</td>
</tr>
</tbody>
</table>
<h2 id="4-2-remove"><a href="#4-2-remove" class="headerlink" title="4.2 #remove()"></a>4.2 #remove()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 根据主键删除事务日志.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务日志主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String id)</span></span>;</div><div class="line">    </div><div class="line"><span class="comment">// RdbTransactionLogStorage.java    </span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"DELETE FROM `transaction_log` WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">          <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3-findEligibleTransactionLogs"><a href="#4-3-findEligibleTransactionLogs" class="headerlink" title="4.3 #findEligibleTransactionLogs()"></a>4.3 #findEligibleTransactionLogs()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 读取需要处理的事务日志.</div><div class="line">* </div><div class="line">* &lt;p&gt;需要处理的事务日志为: &lt;/p&gt;</div><div class="line">* &lt;p&gt;1. 异步处理次数小于最大处理次数.&lt;/p&gt;</div><div class="line">* &lt;p&gt;2. 异步处理的事务日志早于异步处理的间隔时间.&lt;/p&gt;</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> size 获取日志的数量</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryDelayMillis 执行送达事务的延迟毫秒数.</div><div class="line">*/</div><div class="line"><span class="function">List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;TransactionLog&gt; <span class="title">findEligibleTransactionLogs</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes, <span class="keyword">final</span> <span class="keyword">long</span> maxDeliveryTryDelayMillis)</span> </span>&#123;</div><div class="line">   List&lt;TransactionLog&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</div><div class="line">   String sql = <span class="string">"SELECT `id`, `transaction_type`, `data_source`, `sql`, `parameters`, `creation_time`, `async_delivery_try_times` "</span></div><div class="line">       + <span class="string">"FROM `transaction_log` WHERE `async_delivery_try_times`&lt;? AND `transaction_type`=? AND `creation_time`&lt;? LIMIT ?;"</span>;</div><div class="line">   <span class="keyword">try</span> (Connection conn = dataSource.getConnection()) &#123;</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-4-increaseAsyncDeliveryTryTimes"><a href="#4-4-increaseAsyncDeliveryTryTimes" class="headerlink" title="4.4 #increaseAsyncDeliveryTryTimes()"></a>4.4 #increaseAsyncDeliveryTryTimes()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 增加事务日志异步重试次数.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> id 事务主键</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(String id)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseAsyncDeliveryTryTimes</span><span class="params">(<span class="keyword">final</span> String id)</span> </span>&#123;</div><div class="line">   String sql = <span class="string">"UPDATE `transaction_log` SET `async_delivery_try_times`=`async_delivery_try_times`+1 WHERE `id`=?;"</span>;</div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       <span class="comment">// ... 省略你熟悉的代码</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionLogStorageException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-5-processData"><a href="#4-5-processData" class="headerlink" title="4.5 #processData()"></a>4.5 #processData()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionLogStorage.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 处理事务数据.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> connection 业务数据库连接</div><div class="line">* <span class="doctag">@param</span> transactionLog 事务日志</div><div class="line">* <span class="doctag">@param</span> maxDeliveryTryTimes 事务送达的最大尝试次数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(Connection connection, TransactionLog transactionLog, <span class="keyword">int</span> maxDeliveryTryTimes)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// RdbTransactionLogStorage.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> Connection connection, <span class="keyword">final</span> TransactionLog transactionLog, <span class="keyword">final</span> <span class="keyword">int</span> maxDeliveryTryTimes)</span> </span>&#123;</div><div class="line">   <span class="comment">// 重试执行失败 SQL</span></div><div class="line">   <span class="keyword">try</span> (</div><div class="line">       Connection conn = connection;</div><div class="line">       PreparedStatement preparedStatement = conn.prepareStatement(transactionLog.getSql())) &#123;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; transactionLog.getParameters().size(); parameterIndex++) &#123;</div><div class="line">           preparedStatement.setObject(parameterIndex + <span class="number">1</span>, transactionLog.getParameters().get(parameterIndex));</div><div class="line">       &#125;</div><div class="line">       preparedStatement.executeUpdate();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="comment">// 重试失败，更新事务日志，增加已异步重试次数</span></div><div class="line">       increaseAsyncDeliveryTryTimes(transactionLog.getId());</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> TransactionCompensationException(ex);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除重试执行成功 SQL 对应的事务日志</span></div><div class="line">   remove(transactionLog.getId());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不同于前四个<strong>增删改查</strong>接口方法的实现，<code>#processData()</code> 是带有一些逻辑的。根据事务日志( TransactionLog )重试执行失败的 SQL，若成功，移除事务日志；若失败，更新事务日志，增加已异步重试次数</li>
<li>该方法会被<strong>最大努力送达型异步作业</strong>调用到</li>
</ul>
<h1 id="5-最大努力送达型事务监听器"><a href="#5-最大努力送达型事务监听器" class="headerlink" title="5. 最大努力送达型事务监听器"></a>5. 最大努力送达型事务监听器</h1><p>最大努力送达型事务监听器，BestEffortsDeliveryListener，负责记录事务日志、同步重试执行失败 SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BestEffortsDeliveryListener.java</span></div><div class="line"><span class="meta">@Subscribe</span></div><div class="line"><span class="meta">@AllowConcurrentEvents</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">   TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">   BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">   <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">       <span class="keyword">case</span> BEFORE_EXECUTE: <span class="comment">// 执行前，插入事务日志</span></div><div class="line">           <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">           transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                   event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">case</span> EXECUTE_SUCCESS: <span class="comment">// 执行成功，移除事务日志</span></div><div class="line">           transactionLogStorage.remove(event.getId());</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">case</span> EXECUTE_FAILURE: <span class="comment">// 执行失败，同步重试</span></div><div class="line">           <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123; <span class="comment">// 同步【多次】重试</span></div><div class="line">               <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">               Connection conn = <span class="keyword">null</span>;</div><div class="line">               PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 获得数据库连接</span></div><div class="line">                   conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.DML);</div><div class="line">                   <span class="keyword">if</span> (!isValidConnection(conn)) &#123; <span class="comment">// 因为可能执行失败是数据库连接异常，所以判断一次，如果无效，重新获取数据库连接</span></div><div class="line">                       bedSoftTransaction.getConnection().release(conn);</div><div class="line">                       conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.DML);</div><div class="line">                       isNewConnection = <span class="keyword">true</span>;</div><div class="line">                   &#125;</div><div class="line">                   preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                   <span class="comment">// 同步重试</span></div><div class="line">                   <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                       preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                   &#125;</div><div class="line">                   preparedStatement.executeUpdate();</div><div class="line">                   deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                   <span class="comment">// 同步重试成功，移除事务日志</span></div><div class="line">                   transactionLogStorage.remove(event.getId());</div><div class="line">               &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                   log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   close(isNewConnection, conn, preparedStatement);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       <span class="keyword">default</span>: </div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BestEffortsDeliveryListener 通过 EventBus 实现监听 SQL 的执行。Sharding-JDBC 如何实现 EventBus 的，请看<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a></li>
<li>调用 <code>#isProcessContinuously()</code> 方法判断是否处于<strong>最大努力送达型事务</strong>中，当且仅当处于该状态才进行监听事件处理</li>
<li>SQL 执行<strong>前</strong>，插入事务日志</li>
<li>SQL 执行<strong>成功</strong>，移除事务日志</li>
<li><p>SQL 执行<strong>失败</strong>，根据柔性事务配置( SoftTransactionConfiguration )同步的事务送达的最大尝试次数( <code>syncMaxDeliveryTryTimes</code> )进行多次重试<strong>直到成功</strong>。总体逻辑和 <code>RdbTransactionLogStorage#processData()</code> 方法逻辑类似，区别在于<strong>获取分片数据库连接</strong>的特殊处理：此处调用失败，数据库连接可能是异常无效的，因此调用了 <code>#isValidConnection()</code> 判断连接的<strong>有效性</strong>。若无效，则重新获取分片数据库连接。另外，若是重新获取分片数据库连接，需要进行关闭释放 (<code>Connection#close()</code>)：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BestEffortsDeliveryListener.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 通过 SELECT 1 校验数据库连接是否有效</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> conn 数据库连接</div><div class="line">* <span class="doctag">@return</span> 是否有效</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(<span class="keyword">final</span> Connection conn)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> (PreparedStatement preparedStatement = conn.prepareStatement(<span class="string">"SELECT 1"</span>)) &#123;</div><div class="line">       <span class="keyword">try</span> (ResultSet rs = preparedStatement.executeQuery()) &#123;</div><div class="line">           <span class="keyword">return</span> rs.next() &amp;&amp; <span class="number">1</span> == rs.getInt(<span class="string">"1"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 关闭释放预编译SQL对象和数据库连接</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> isNewConnection 是否新创建的数据库连接，是的情况下才释放</div><div class="line">* <span class="doctag">@param</span> conn 数据库连接</div><div class="line">* <span class="doctag">@param</span> preparedStatement 预编译SQL</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isNewConnection, <span class="keyword">final</span> Connection conn, <span class="keyword">final</span> PreparedStatement preparedStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != preparedStatement) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           preparedStatement.close();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           log.error(<span class="string">"PreparedStatement closed error:"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isNewConnection &amp;&amp; <span class="keyword">null</span> != conn) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           conn.close();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           log.error(<span class="string">"Connection closed error:"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="6-最大努力送达型异步作业"><a href="#6-最大努力送达型异步作业" class="headerlink" title="6. 最大努力送达型异步作业"></a>6. 最大努力送达型异步作业</h1><p>当最大努力送达型事务监听器( BestEffortsDeliveryListener )<strong>多次同步</strong>重试失败后，交给<strong>最大努力送达型异步作业</strong>进行<strong>多次异步</strong>重试，并且多次执行有<strong>固定间隔</strong>。</p>
<p>Sharding-JDBC 提供了两个最大努力送达型异步作业实现：</p>
<ul>
<li>NestedBestEffortsDeliveryJob ：内嵌的最大努力送达型异步作业</li>
<li>BestEffortsDeliveryJob ：最大努力送达型异步作业</li>
</ul>
<p>两者实现代码逻辑<strong>基本一致</strong>。前者相比后者，用于开发测试，去除对 Zookeeper 依赖，无法实现<strong>高可用</strong>，因此<strong>生产环境下不适合使用</strong>。</p>
<h2 id="6-1-BestEffortsDeliveryJob"><a href="#6-1-BestEffortsDeliveryJob" class="headerlink" title="6.1 BestEffortsDeliveryJob"></a>6.1 BestEffortsDeliveryJob</h2><p>BestEffortsDeliveryJob 所在 Maven 项目为 <code>sharding-jdbc-transaction-async-job</code>，基于当当开源的 <a href="https://github.com/dangdangdotcom/elastic-job" rel="external nofollow noopener noreferrer" target="_blank">Elastic-Job</a> 实现。如下是官方对该 Maven 项目的简要说明：</p>
<blockquote>
<p>由于柔性事务采用异步尝试，需要部署独立的作业和Zookeeper。sharding-jdbc-transaction采用elastic-job实现的sharding-jdbc-transaction-async-job，通过简单配置即可启动高可用作业异步送达柔性事务，启动脚本为start.sh。</p>
</blockquote>
<p><strong>BestEffortsDeliveryJob</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryJob</span> <span class="keyword">extends</span> <span class="title">AbstractIndividualThroughputDataFlowElasticJob</span>&lt;<span class="title">TransactionLog</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 最大努力送达型异步作业配置对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> BestEffortsDeliveryConfiguration bedConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务日志存储器对象</div><div class="line">     */</div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> TransactionLogStorage transactionLogStorage;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;TransactionLog&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> JobExecutionMultipleShardingContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> transactionLogStorage.findEligibleTransactionLogs(context.getFetchDataCount(),</div><div class="line">            bedConfig.getJobConfig().getMaxDeliveryTryTimes(), bedConfig.getJobConfig().getMaxDeliveryTryDelayMillis());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> JobExecutionMultipleShardingContext context, <span class="keyword">final</span> TransactionLog data)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> (</div><div class="line">            Connection conn = bedConfig.getTargetDataSource(data.getDataSource()).getConnection()) &#123;</div><div class="line">            transactionLogStorage.processData(conn, data, bedConfig.getJobConfig().getMaxDeliveryTryTimes());</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException | TransactionCompensationException ex) &#123;</div><div class="line">            log.error(String.format(<span class="string">"Async delivery times %s error, max try times is %s, exception is %s"</span>, data.getAsyncDeliveryTryTimes() + <span class="number">1</span>, </div><div class="line">                bedConfig.getJobConfig().getMaxDeliveryTryTimes(), ex.getMessage()));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStreamingProcess</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#fetchData()</code> 方法获取需要处理的事务日志 (TransactionLog)，内部调用了 <code>TransactionLogStorage#findEligibleTransactionLogs()</code> 方法</li>
<li>调用 <code>#processData()</code> 方法处理事务日志，重试执行失败的 SQL，内部调用了 <code>TransactionLogStorage#processData()</code></li>
<li><code>#fetchData()</code> 和 <code>#processData()</code> 调用是 Elastic-Job 控制的。每一轮定时调度，<strong>每条</strong>事务日志只执行<strong>一次</strong>。当<strong>超过</strong>最大异步调用次数后，该条事务日志不再处理，所以<strong>生产使用时，最好增加下相应监控超过最大异步重试次数的事务日志</strong>。</li>
</ul>
<h2 id="6-2-AsyncSoftTransactionJobConfiguration"><a href="#6-2-AsyncSoftTransactionJobConfiguration" class="headerlink" title="6.2 AsyncSoftTransactionJobConfiguration"></a>6.2 AsyncSoftTransactionJobConfiguration</h2><p>AsyncSoftTransactionJobConfiguration，异步柔性事务作业配置对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSoftTransactionJobConfiguration</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 作业名称.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String name = <span class="string">"bestEffortsDeliveryJob"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 触发作业的cron表达式.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String cron = <span class="string">"0/5 * * * * ?"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 每次作业获取的事务日志最大数量.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> transactionLogFetchDataCount = <span class="number">100</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事务送达的最大尝试次数.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxDeliveryTryTimes = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行事务的延迟毫秒数.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;早于此间隔时间的入库事务才会被作业执行.&lt;/p&gt;</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxDeliveryTryDelayMillis = <span class="number">60</span>  * <span class="number">1000L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-3-Elastic-Job-是否必须？"><a href="#6-3-Elastic-Job-是否必须？" class="headerlink" title="6.3 Elastic-Job 是否必须？"></a>6.3 Elastic-Job 是否必须？</h2><p>Sharding-JDBC 提供的最大努力送达型异步作业实现( BestEffortsDeliveryJob )，通过与 Elastic-Job 集成，可以很便捷并且有质量保证的<strong>高可用</strong>、<strong>高性能</strong>使用。一部分团队，可能已经引入或自研了类似 Elastic-Job 的分布式作业中间件解决方案，每多一个中间件，就是多一个学习与运维成本。那么是否可以使用自己的分布式作业解决方案？答案是，可以的。参考 BestEffortsDeliveryJob 的实现，通过调用 TransactionLogStorage 来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 伪代码(不考虑性能、异常)</span></div><div class="line">List&lt;TransactionLog&gt; transactionLogs = transactionLogStorage.findEligibleTransactionLogs(....);</div><div class="line"><span class="keyword">for</span> (TransactionLog transactionLog : transactionLogs) &#123;</div><div class="line">       transactionLogStorage.processData(conn, log, maxDeliveryTryTimes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，个人还是很推荐 Elastic-Job。  </p>
<p>😈 <strong>笔者要开始写<a href="http://www.yunai.me/categories/Elastic-Job//?self">《Elastic-Job 源码分析》</a></strong>。</p>
<hr>
<p>另外，如果有支持<strong>事务消息</strong>的分布式队列系统，可以通过 TransactionLogStorage 实现存储事务消息存储成消息。为什么要支持<strong>事务消息</strong>？如果 SQL 执行是成功的，需要回滚（删除）事务消息。</p>
<h1 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a>7. 适用场景</h1><p>见<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/transaction/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 - 事务支持》</a>。</p>
<h1 id="8-开发指南-amp-开发示例"><a href="#8-开发指南-amp-开发示例" class="headerlink" title="8. 开发指南 &amp; 开发示例"></a>8. 开发指南 &amp; 开发示例</h1><p>见<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/transaction/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 - 事务支持》</a>。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈</p>
<p>算是坚持把这个系列写完了，给自己 32 個赞。</p>
<p>满足！</p>
<p><a href="http://www.yunai.me/categories/Elastic-Job//?self">《Elastic-Job 源码分析》</a> 走起！不 High 不结束！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;有
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
  <entry>
    <title>Sharding-JDBC 源码分析 —— JDBC实现与读写分离</title>
    <link href="http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/"/>
    <id>http://www.yunai.me/Sharding-JDBC/jdbc-implement-and-read-write-splitting/</id>
    <published>2017-08-17T16:00:00.000Z</published>
    <updated>2017-08-14T18:34:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong>  </p>
<ul>
<li><a href="#">1. 概述</a></li>
<li><a href="#">2. unspported 包</a></li>
<li><a href="#">3. adapter 包</a><ul>
<li><a href="#">3.1 WrapperAdapter</a></li>
<li><a href="#">3.2 AbstractDataSourceAdapter</a></li>
<li><a href="#">3.3 AbstractConnectionAdapter</a></li>
<li><a href="#">3.4 AbstractStatementAdapter</a></li>
<li><a href="#">3.5 AbstractPreparedStatementAdapter</a></li>
<li><a href="#">3.6 AbstractResultSetAdapter</a></li>
</ul>
</li>
<li><a href="#">4. 插入流程</a></li>
<li><a href="#">5. 查询流程</a></li>
<li><a href="#">6. 读写分离</a></li>
<li><a href="#">666. <del>彩蛋</del></a></li>
</ul>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>JDBC</strong> 与 <strong>读写分离</strong> 的实现。为什么会把这两个东西放在一起讲呢？客户端直连数据库的读写分离主要通过获取读库和写库的不同连接来实现，和 JDBC Connection 刚好放在一块。</p>
<p>OK，我们先来看一段 Sharding-JDBC 官方对自己的定义和定位</p>
<blockquote>
<p>Sharding-JDBC定位为轻量级java框架，使用客户端直连数据库，以jar包形式提供服务，未使用中间层，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式，可理解为<strong>增强版的JDBC驱动</strong>，旧代码迁移成本几乎为零。</p>
</blockquote>
<p>可以看出，Sharding-JDBC 通过实现 <strong>JDBC规范</strong>，对上层提供透明化数据库分库分表的访问。😈 黑科技？实际我们使用的<strong>数据库连接池</strong>也是通过这种方式实现对上层无感知的提供连接池。甚至还可以通过这种方式实现对 Lucene、<a href="http://www.yunai.me/MyCAT/connect-mongodb/?self">MongoDB</a> 等等的访问。</p>
<p>扯远了，下面来看看 Sharding-JDBC <code>jdbc</code> 包的结构：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/01.png" alt=""></p>
<ul>
<li><code>unsupported</code>：声明<strong>不支持</strong>的数据操作方法</li>
<li><code>adapter</code>：适配类，实现和分库分表<strong>无关</strong>的方法</li>
<li><code>core</code>：核心类，实现和分库分表<strong>相关</strong>的方法</li>
</ul>
<p>根据 <code>core</code> 包，可以看出分到四种我们<strong>超级熟悉</strong>的对象  </p>
<ul>
<li><p>Datasource</p>
<p>  <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/02.png" alt="-w640"></p>
</li>
<li><p>Connection</p>
<p> <img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/03.png" alt="-w640"></p>
</li>
<li><p>Statement</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/04.png" alt="-w640"></p>
</li>
<li><p>ResultSet</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/05.png" alt="-w640"></p>
</li>
</ul>
<p><strong>实现</strong>层级如下：<strong>JDBC 接口</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>unsupported</code>抽象类</strong> &lt;=(继承)== <strong><code>core</code>类</strong>。</p>
<hr>
<p><strong>本文内容顺序</strong></p>
<ol>
<li><code>unspported</code> 包</li>
<li><code>adapter</code> 包</li>
<li>插入流程，分析的类：<ul>
<li>ShardingDataSource</li>
<li>ShardingConnection</li>
<li>ShardingPreparedStatement（ShardingStatement 类似，不重复分析）</li>
<li>GeneratedKeysResultSet、GeneratedKeysResultSetMetaData</li>
</ul>
</li>
<li>查询流程，分析的类：<ul>
<li>ShardingPreparedStatement</li>
<li>ShardingResultSet</li>
</ul>
</li>
<li>读写分离，分析的类：<ul>
<li>MasterSlaveDataSource</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p>
</blockquote>
<h1 id="2-unspported-包"><a href="#2-unspported-包" class="headerlink" title="2. unspported 包"></a>2. unspported 包</h1><p><code>unspported</code> 包内的<strong>抽象</strong>类，声明不支持操作的数据对象，所有方法都是 <code>throw new SQLFeatureNotSupportedException()</code> 方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedGeneratedKeysResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"getBoolean"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractUnsupportedOperationConnection</span> <span class="keyword">extends</span> <span class="title">WrapperAdapter</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> CallableStatement <span class="title">prepareCall</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLFeatureNotSupportedException(<span class="string">"prepareCall"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   <span class="comment">// .... 省略其它类似方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="3-adapter-包"><a href="#3-adapter-包" class="headerlink" title="3. adapter 包"></a>3. adapter 包</h1><p><code>adapter</code> 包内的<strong>抽象</strong>类，实现和分库分表<strong>无关</strong>的方法。</p>
<p><strong>考虑到第4、5两小节更容易理解，本小节贴的代码会相对多</strong></p>
<h2 id="3-1-WrapperAdapter"><a href="#3-1-WrapperAdapter" class="headerlink" title="3.1 WrapperAdapter"></a>3.1 WrapperAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/WrapperAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">WrapperAdapter</a>，JDBC Wrapper 适配类。</p>
<p><strong>对 Wrapper 接口实现如下两个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isWrapperFor(iface)) &#123;</div><div class="line">       <span class="keyword">return</span> (T) <span class="keyword">this</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(String.format(<span class="string">"[%s] cannot be unwrapped as [%s]"</span>, getClass().getName(), iface.getName()));</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> iface.isInstance(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>提供子类 <code>#recordMethodInvocation()</code> 记录方法调用，<code>#replayMethodsInvocation()</code> 回放记录的方法调用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;JdbcMethodInvocation&gt; jdbcMethodInvocations = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> targetClass 目标类</div><div class="line">* <span class="doctag">@param</span> methodName 方法名称</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">recordMethodInvocation</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; targetClass, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;[] argumentTypes, <span class="keyword">final</span> Object[] arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jdbcMethodInvocations.add(<span class="keyword">new</span> JdbcMethodInvocation(targetClass.getMethod(methodName, argumentTypes), arguments));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的方法调用.</div><div class="line">* </div><div class="line">* <span class="doctag">@param</span> target 目标对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">replayMethodsInvocation</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (JdbcMethodInvocation each : jdbcMethodInvocations) &#123;</div><div class="line">       each.invoke(target);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>这两个方法有什么用途呢？例如下文会提到的 AbstractConnectionAdapter 的 <code>#setAutoCommit()</code>，当它无数据库连接时，先记录；等获得到数据连接后，再回放：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractConnectionAdapter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>JdbcMethodInvocation，反射调用JDBC相关方法的工具类：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 方法参数</div><div class="line">    */</div><div class="line">   <span class="meta">@Getter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object[] arguments;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line">    *  调用方法.</div><div class="line">    * </div><div class="line">    * <span class="doctag">@param</span> target 目标对象</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           method.invoke(target, arguments); <span class="comment">// 反射调用</span></div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IllegalAccessException | InvocationTargetException ex) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Invoke jdbc method exception"</span>, ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>提供子类 <code>#throwSQLExceptionIfNecessary()</code> 抛出异常链</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">throwSQLExceptionIfNecessary</span><span class="params">(<span class="keyword">final</span> Collection&lt;SQLException&gt; exceptions)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">if</span> (exceptions.isEmpty()) &#123; <span class="comment">// 为空不抛出异常</span></div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLException ex = <span class="keyword">new</span> SQLException();</div><div class="line">   <span class="keyword">for</span> (SQLException each : exceptions) &#123;</div><div class="line">       ex.setNextException(each); <span class="comment">// 异常链</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> ex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-AbstractDataSourceAdapter"><a href="#3-2-AbstractDataSourceAdapter" class="headerlink" title="3.2 AbstractDataSourceAdapter"></a>3.2 AbstractDataSourceAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractDataSourceAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractDataSourceAdapter</a>，数据源适配类。</p>
<p>直接点击链接查看源码。</p>
<h2 id="3-3-AbstractConnectionAdapter"><a href="#3-3-AbstractConnectionAdapter" class="headerlink" title="3.3 AbstractConnectionAdapter"></a>3.3 AbstractConnectionAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractConnectionAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractConnectionAdapter</a>，数据库连接适配类。</p>
<p>我们来瞅瞅大家最关心的<strong>事务</strong>相关方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 是否自动提交</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> autoCommit = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获得链接</div><div class="line">*</div><div class="line">* <span class="doctag">@return</span> 链接</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;Connection&gt; <span class="title">getConnections</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAutoCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">return</span> autoCommit;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.autoCommit = autoCommit;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123; <span class="comment">// 无数据连接时，记录方法调用</span></div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setAutoCommit"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;autoCommit&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setAutoCommit(autoCommit);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#setAutoCommit()</code> 调用时，实际会设置其所持有的 Connection 的 <code>autoCommit</code> 属性</li>
<li><code>#getConnections()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.commit();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;SQLException&gt; exceptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           each.rollback();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           exceptions.add(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   throwSQLExceptionIfNecessary(exceptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>#commit()</code>、<code>#rollback()</code> 调用时，实际调用其所持有的 Connection 的方法</li>
<li><p>异常情况下，<code>#commit()</code> 和 <code>#rollback()</code> 处理方式不同，笔者暂时不知道答案，求证后会进行更新 </p>
<ul>
<li><p><code>#commit()</code> 处理方式需要改成和 <code>#rollback()</code> 一样。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;SQLException&gt; exceptions = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           each.commit();</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           exceptions.add(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   throwSQLExceptionIfNecessary(exceptions);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>事务级别和是否只读相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 只读</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readOnly = <span class="keyword">true</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 事务级别</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> transactionIsolation = TRANSACTION_READ_UNCOMMITTED;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">this</span>.readOnly = readOnly;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setReadOnly"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">boolean</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;readOnly&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setReadOnly(readOnly);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   transactionIsolation = level;</div><div class="line">   <span class="keyword">if</span> (getConnections().isEmpty()) &#123;</div><div class="line">       recordMethodInvocation(Connection.class, <span class="string">"setTransactionIsolation"</span>, <span class="keyword">new</span> Class[] &#123;<span class="keyword">int</span>.class&#125;, <span class="keyword">new</span> Object[] &#123;level&#125;);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (Connection each : getConnections()) &#123;</div><div class="line">       each.setTransactionIsolation(level);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-AbstractStatementAdapter"><a href="#3-4-AbstractStatementAdapter" class="headerlink" title="3.4 AbstractStatementAdapter"></a>3.4 AbstractStatementAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractStatementAdapter</a>，静态语句对象适配类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">boolean</span> hasResult = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">for</span> (Statement each : getRoutedStatements()) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getUpdateCount() &gt; -<span class="number">1</span>) &#123;</div><div class="line">           hasResult = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       result += each.getUpdateCount();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (result &gt; Integer.MAX_VALUE) &#123;</div><div class="line">       result = Integer.MAX_VALUE;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> hasResult ? Long.valueOf(result).intValue() : -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取路由的静态语句对象集合.</div><div class="line">* </div><div class="line">* <span class="doctag">@return</span> 路由的静态语句对象集合</div><div class="line">*/</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;? extends Statement&gt; getRoutedStatements();</div></pre></td></tr></table></figure>
<ul>
<li><code>#getUpdateCount()</code> 调用持有的 Statement 计算更新数量</li>
<li><code>#getRoutedStatements()</code> 和分库分表相关，因而仅抽象该方法，留给子类实现</li>
</ul>
<h2 id="3-5-AbstractPreparedStatementAdapter"><a href="#3-5-AbstractPreparedStatementAdapter" class="headerlink" title="3.5 AbstractPreparedStatementAdapter"></a>3.5 AbstractPreparedStatementAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractPreparedStatementAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractPreparedStatementAdapter</a>，预编译语句对象的适配类。</p>
<p><strong><code>#recordSetParameter()</code>实现对占位符参数的设置</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 记录的设置参数方法数组</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;SetParameterMethodInvocation&gt; setParameterMethodInvocations = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="comment">/**</span></div><div class="line">* 参数</div><div class="line">*/</div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> <span class="keyword">int</span> x)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   setParameter(parameterIndex, x);</div><div class="line">   recordSetParameter(<span class="string">"setInt"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;, parameterIndex, x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录占位符参数</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> parameterIndex 占位符参数位置</div><div class="line">* <span class="doctag">@param</span> value 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> parameterIndex, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (parameters.size() == parameterIndex - <span class="number">1</span>) &#123;</div><div class="line">       parameters.add(value);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = parameters.size(); i &lt;= parameterIndex - <span class="number">1</span>; i++) &#123; <span class="comment">// 用 null 填充前面未设置的位置</span></div><div class="line">       parameters.add(<span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line">   parameters.set(parameterIndex - <span class="number">1</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 记录设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> methodName 方法名，例如 setInt、setLong 等</div><div class="line">* <span class="doctag">@param</span> argumentTypes 参数类型</div><div class="line">* <span class="doctag">@param</span> arguments 参数</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordSetParameter</span><span class="params">(<span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class[] argumentTypes, <span class="keyword">final</span> Object... arguments)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       setParameterMethodInvocations.add(<span class="keyword">new</span> SetParameterMethodInvocation(PreparedStatement.class.getMethod(methodName, argumentTypes), arguments, arguments[<span class="number">1</span>]));</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NoSuchMethodException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 回放记录的设置参数方法调用</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> preparedStatement 预编译语句对象</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">replaySetParameter</span><span class="params">(<span class="keyword">final</span> PreparedStatement preparedStatement)</span> </span>&#123;</div><div class="line">   addParameters();</div><div class="line">   <span class="keyword">for</span> (SetParameterMethodInvocation each : setParameterMethodInvocations) &#123;</div><div class="line">       updateParameterValues(each, parameters.get(each.getIndex() - <span class="number">1</span>)); <span class="comment">// 同一个位置多次设置，值可能不一样，需要更新下</span></div><div class="line">       each.invoke(preparedStatement);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当使用分布式主键时，生成后会添加到 parameters，此时 parameters 数量多于 setParameterMethodInvocations，需要生成该分布式主键的 SetParameterMethodInvocation</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addParameters</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = setParameterMethodInvocations.size(); i &lt; parameters.size(); i++) &#123;</div><div class="line">       recordSetParameter(<span class="string">"setObject"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, Object.class&#125;, i + <span class="number">1</span>, parameters.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParameterValues</span><span class="params">(<span class="keyword">final</span> SetParameterMethodInvocation setParameterMethodInvocation, <span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!Objects.equals(setParameterMethodInvocation.getValue(), value)) &#123;</div><div class="line">       setParameterMethodInvocation.changeValueArgument(value); <span class="comment">// 修改占位符参数</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>逻辑类似 <code>WrapperAdapter</code> 的 <code>#recordMethodInvocation()</code>，<code>#replayMethodsInvocation()</code>，请<strong>认真</strong>阅读代码注释</p>
</li>
<li><p>SetParameterMethodInvocation，继承 JdbcMethodInvocation，反射调用参数设置方法的工具类：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SetParameterMethodInvocation</span> <span class="keyword">extends</span> <span class="title">JdbcMethodInvocation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 位置</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 参数值</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 设置参数值.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> value 参数值</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeValueArgument</span><span class="params">(<span class="keyword">final</span> Object value)</span> </span>&#123;</div><div class="line">        getArguments()[<span class="number">1</span>] = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-6-AbstractResultSetAdapter"><a href="#3-6-AbstractResultSetAdapter" class="headerlink" title="3.6 AbstractResultSetAdapter"></a>3.6 AbstractResultSetAdapter</h2><p><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/jdbc/adapter/AbstractResultSetAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractResultSetAdapter</a>，代理结果集适配器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResultSetAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractUnsupportedOperationResultSet</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 结果集集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResultSet&gt; resultSets;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="comment">// TODO should return sharding statement in future</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Statement <span class="title">getStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getStatement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).getMetaData();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findColumn</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">return</span> getResultSets().get(<span class="number">0</span>).findColumn(columnLabel);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 省略其它方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-插入流程"><a href="#4-插入流程" class="headerlink" title="4. 插入流程"></a>4. 插入流程</h1><p>插入使用<strong>分布式主键</strong>例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 代码仅仅是例子，生产环境下请注意异常处理和资源关闭</span></div><div class="line">String sql = <span class="string">"INSERT INTO t_order(uid, nickname, pid) VALUES (1, '2', ?)"</span>;</div><div class="line">DataSource dataSource = <span class="keyword">new</span> ShardingDataSource(shardingRule);</div><div class="line">Connection conn = dataSource.getConnection();</div><div class="line">PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); <span class="comment">// 返回主键需要  Statement.RETURN_GENERATED_KEYS</span></div><div class="line">ps.setLong(<span class="number">1</span>, <span class="number">100</span>);</div><div class="line">ps.executeUpdate();</div><div class="line">ResultSet rs = ps.getGeneratedKeys();</div><div class="line"><span class="keyword">if</span> (rs.next()) &#123;</div><div class="line">    System.out.println(<span class="string">"id:"</span> + rs.getLong(<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>调用 <code>#executeUpdate()</code> 方法，内部过程如下</strong>：</p>
<p><img src="http://www.yunai.me/images/Sharding-JDBC/2017_08_18/06.png" alt=""></p>
<p>是不是对上层<strong>完全透明</strong>？！我们来看看内部是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeUpdate();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>#route()</code> 分库分表路由，获得预编译语句对象执行单元( PreparedStatementUnit )集合。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementUnit</span> <span class="keyword">implements</span> <span class="title">BaseStatementUnit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * SQL 执行单元</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 预编译语句对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>#executeUpdate()</code> 调用<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">执行引擎</a><strong>并行</strong>执行<strong>多个</strong>预编译语句对象。执行时，最终调用预编译语句对象( PreparedStatement )。我们来看一个例子：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatementExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executePreparedStatement(sqlType, preparedStatementUnits, parameters, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="comment">// 调用 PreparedStatement#executeUpdate()</span></div><div class="line">               <span class="keyword">return</span> ((PreparedStatement) baseStatementUnit.getStatement()).executeUpdate();</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;PreparedStatementUnit&gt; <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Collection&lt;PreparedStatementUnit&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   setRouteResult(routingEngine.route(getParameters()));</div><div class="line">   <span class="comment">// 遍历 SQL 执行单元</span></div><div class="line">   <span class="keyword">for</span> (SQLExecutionUnit each : getRouteResult().getExecutionUnits()) &#123;</div><div class="line">       SQLType sqlType = getRouteResult().getSqlStatement().getType();</div><div class="line">       Collection&lt;PreparedStatement&gt; preparedStatements;</div><div class="line">       <span class="comment">// 创建实际的 PreparedStatement</span></div><div class="line">       <span class="keyword">if</span> (SQLType.DDL == sqlType) &#123;</div><div class="line">           preparedStatements = generatePreparedStatementForDDL(each);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           preparedStatements = Collections.singletonList(generatePreparedStatement(each));</div><div class="line">       &#125;</div><div class="line">       getRoutedStatements().addAll(preparedStatements);</div><div class="line">       <span class="comment">// 回放设置占位符参数到 PreparedStatement</span></div><div class="line">       <span class="keyword">for</span> (PreparedStatement preparedStatement : preparedStatements) &#123;</div><div class="line">           replaySetParameter(preparedStatement);</div><div class="line">           result.add(<span class="keyword">new</span> PreparedStatementUnit(each, preparedStatement));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 创建 PreparedStatement</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlExecutionUnit SQL 执行单元</div><div class="line">* <span class="doctag">@return</span> PreparedStatement</div><div class="line">* <span class="doctag">@throws</span> SQLException 当 JDBC 操作发生异常时</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> PreparedStatement <span class="title">generatePreparedStatement</span><span class="params">(<span class="keyword">final</span> SQLExecutionUnit sqlExecutionUnit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">   <span class="comment">// 获得连接</span></div><div class="line">   Connection connection = getShardingConnection().getConnection(sqlExecutionUnit.getDataSource(), getRouteResult().getSqlStatement().getType());</div><div class="line">   <span class="comment">// 声明返回主键</span></div><div class="line">   <span class="keyword">if</span> (isReturnGeneratedKeys() || isReturnGeneratedKeys() &amp;&amp; generatedKey.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> connection.prepareStatement(sqlExecutionUnit.getSql(), getResultSetType(), getResultSetConcurrency(), getResultSetHoldability());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#generatePreparedStatement()</code> 创建 PreparedStatement，后调用 <code>#replaySetParameter()</code> 回放设置占位符参数到 PreparedStatement</li>
<li><p>当 <strong>声明返回主键</strong> 时，即 <code>#isReturnGeneratedKeys()</code> 返回 <code>true</code> 时，调用 <code>connection.prepareStatement(sqlExecutionUnit.getSql(), RETURN_GENERATED_KEYS)</code>。为什么该方法会返回 <code>true</code>？上文例子 <code>conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> String[] columnNames)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql, Statement.RETURN_GENERATED_KEYS);</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// ShardingPreparedStatement.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingPreparedStatement</span><span class="params">(<span class="keyword">final</span> ShardingConnection shardingConnection, <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> autoGeneratedKeys)</span> </span>&#123;</div><div class="line"> <span class="keyword">this</span>(shardingConnection, sql);</div><div class="line"> <span class="keyword">if</span> (RETURN_GENERATED_KEYS == autoGeneratedKeys) &#123;</div><div class="line">     markReturnGeneratedKeys();</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">markReturnGeneratedKeys</span><span class="params">()</span> </span>&#123;</div><div class="line"> returnGeneratedKeys = <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <strong>声明返回主键</strong>后，插入执行完成，我们调用 <code>#getGeneratedKeys()</code> 可以获得主键 ：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStatement.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">getGeneratedKeys</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Optional&lt;GeneratedKey&gt; generatedKey = getGeneratedKey();</div><div class="line">    <span class="comment">// 分布式主键</span></div><div class="line">    <span class="keyword">if</span> (generatedKey.isPresent() &amp;&amp; returnGeneratedKeys) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet(routeResult.getGeneratedKeys().iterator(), generatedKey.get().getColumn(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 数据库自增</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> == getRoutedStatements().size()) &#123;</div><div class="line">        <span class="keyword">return</span> getRoutedStatements().iterator().next().getGeneratedKeys();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GeneratedKeysResultSet();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>ShardingConnection#getConnection()</code> 方法获得该 PreparedStatement 对应的<strong>真实</strong>数据库连接( Connection )：  </p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据数据源名称获取相应的数据库连接.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> dataSourceName 数据源名称</div><div class="line"> * <span class="doctag">@param</span> sqlType SQL语句类型</div><div class="line"> * <span class="doctag">@return</span> 数据库连接</div><div class="line"> * <span class="doctag">@throws</span> SQLException SQL异常</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    <span class="comment">// 从连接缓存中获取连接</span></div><div class="line">    Optional&lt;Connection&gt; connection = getCachedConnection(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">if</span> (connection.isPresent()) &#123;</div><div class="line">        <span class="keyword">return</span> connection.get();</div><div class="line">    &#125;</div><div class="line">    Context metricsContext = MetricsContext.start(Joiner.on(<span class="string">"-"</span>).join(<span class="string">"ShardingConnection-getConnection"</span>, dataSourceName));</div><div class="line">    <span class="comment">//</span></div><div class="line">    DataSource dataSource = shardingContext.getShardingRule().getDataSourceRule().getDataSource(dataSourceName);</div><div class="line">    Preconditions.checkState(<span class="keyword">null</span> != dataSource, <span class="string">"Missing the rule of %s in DataSourceRule"</span>, dataSourceName);</div><div class="line">    String realDataSourceName;</div><div class="line">    <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123;</div><div class="line">        dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">        realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        realDataSourceName = dataSourceName;</div><div class="line">    &#125;</div><div class="line">    Connection result = dataSource.getConnection();</div><div class="line">    MetricsContext.stop(metricsContext);</div><div class="line">    <span class="comment">// 添加到连接缓存</span></div><div class="line">    connectionMap.put(realDataSourceName, result);</div><div class="line">    <span class="comment">// 回放 Connection 方法</span></div><div class="line">    replayMethodsInvocation(result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;Connection&gt; <span class="title">getCachedConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">    String key = connectionMap.containsKey(dataSourceName) ? dataSourceName : MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">    <span class="keyword">return</span> Optional.fromNullable(connectionMap.get(key));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#getCachedConnection()</code> 尝试获得<strong>已缓存</strong>的数据库连接；如果缓存中不存在，获取到连接后会进行<strong>缓存</strong></li>
<li>从 ShardingRule 配置的 DataSourceRule 获取<strong>真实</strong>的数据源( DataSource )</li>
<li>MasterSlaveDataSource 实现<strong>主从</strong>数据源封装，我们在<em>下小节</em>分享</li>
<li>调用 <code>#replayMethodsInvocation()</code> 回放记录的 Connection 方法</li>
</ul>
</li>
</ul>
<p><em>插入实现的代码基本分享完了，因为是不断代码下钻的方式分析，可以反向向上在理理，会更加清晰</em>。</p>
<h1 id="5-查询流程"><a href="#5-查询流程" class="headerlink" title="5. 查询流程"></a>5. 查询流程</h1><p>单纯从 <code>core</code> 包里的 JDBC 实现，查询流程 <code>#executeQuery()</code> 和 <code>#execute()</code> 基本一致，差别在于<strong>执行</strong>和<strong>多结果集归并</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   ResultSet result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 路由</span></div><div class="line">       Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits = route();</div><div class="line">       <span class="comment">// 执行</span></div><div class="line">       List&lt;ResultSet&gt; resultSets = <span class="keyword">new</span> PreparedStatementExecutor(</div><div class="line">               getShardingConnection().getShardingContext().getExecutorEngine(), getRouteResult().getSqlStatement().getType(), preparedStatementUnits, getParameters()).executeQuery();</div><div class="line">       <span class="comment">// 结果归并</span></div><div class="line">       result = <span class="keyword">new</span> ShardingResultSet(resultSets, <span class="keyword">new</span> MergeEngine(</div><div class="line">               getShardingConnection().getShardingContext().getDatabaseType(), resultSets, (SelectStatement) getRouteResult().getSqlStatement()).merge());</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       clearBatch();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 设置结果集</span></div><div class="line">   setCurrentResultSet(result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>SQL执行</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a></li>
<li><strong>结果归并</strong> 感兴趣的同学可以看：<a href="http://www.yunai.me/Sharding-JDBC/result-merger/?self">《Sharding-JDBC 源码分析 —— 结果归并》</a></li>
<li><p>结果归并 <code>#merge()</code> 完后，创建分片结果集( ShardingResultSet )</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingResultSet</span> <span class="keyword">extends</span> <span class="title">AbstractResultSetAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 归并结果集</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResultSetMerger mergeResultSet;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnIndex, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">final</span> String columnLabel)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        Object result = mergeResultSet.getValue(columnLabel, <span class="keyword">int</span>.class);</div><div class="line">        wasNull = <span class="keyword">null</span> == result;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ResultSetUtil.convertValue(result, <span class="keyword">int</span>.class);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// .... 隐藏其他类似 getXXXX() 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="6-读写分离"><a href="#6-读写分离" class="headerlink" title="6. 读写分离"></a>6. 读写分离</h1><p>建议前置阅读：<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/master-slave/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— 读写分离》</a></p>
<p>当你有读写分离的需求时，将 ShardingRule 配置<strong>对应的数据源</strong> 从 ShardingDataSource 替换成 MasterSlaveDataSource。我们来看看 MasterSlaveDataSource 的功能和实现。</p>
<p><strong>支持一主多从的读写分离配置，可配合分库分表使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MasterSlaveDataSourceFactory.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSourceFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建读写分离数据源.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> name 读写分离数据源名称</div><div class="line">     * <span class="doctag">@param</span> masterDataSource 主节点数据源</div><div class="line">     * <span class="doctag">@param</span> slaveDataSource 从节点数据源</div><div class="line">     * <span class="doctag">@param</span> otherSlaveDataSources 其他从节点数据源</div><div class="line">     * <span class="doctag">@return</span> 读写分离数据源</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">createDataSource</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> DataSource masterDataSource, <span class="keyword">final</span> DataSource slaveDataSource, <span class="keyword">final</span> DataSource... otherSlaveDataSources)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MasterSlaveDataSource(name, masterDataSource, Lists.asList(slaveDataSource, otherSlaveDataSources));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceAdapter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据源名</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 主数据源</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource masterDataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从数据源集合</div><div class="line">     */</div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;DataSource&gt; slaveDataSources;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingConnection.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(<span class="keyword">final</span> String dataSourceName, <span class="keyword">final</span> SQLType sqlType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   String realDataSourceName;</div><div class="line">   <span class="keyword">if</span> (dataSource <span class="keyword">instanceof</span> MasterSlaveDataSource) &#123; <span class="comment">// 读写分离</span></div><div class="line">       dataSource = ((MasterSlaveDataSource) dataSource).getDataSource(sqlType);</div><div class="line">       realDataSourceName = MasterSlaveDataSource.getDataSourceName(dataSourceName, sqlType);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       realDataSourceName = dataSourceName;</div><div class="line">   &#125;</div><div class="line">   Connection result = dataSource.getConnection();</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// MasterSlaveDataSource.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* 当前线程是否是 DML 操作标识</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; DML_FLAG = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;() &#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Boolean <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">/**</span></div><div class="line">* 从库负载均衡策略</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SlaveLoadBalanceStrategy slaveLoadBalanceStrategy = <span class="keyword">new</span> RoundRobinSlaveLoadBalanceStrategy();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 获取主或从节点的数据源.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> sqlType SQL类型</div><div class="line">* <span class="doctag">@return</span> 主或从节点的数据源</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isMasterRoute(sqlType)) &#123;</div><div class="line">       DML_FLAG.set(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span> masterDataSource;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> slaveLoadBalanceStrategy.getDataSource(name, slaveDataSources);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMasterRoute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.DQL != sqlType || DML_FLAG.get() || HintManagerHolder.isMasterRouteOnly();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ShardingConnection 获取到的数据源是 MasterSlaveDataSource 时，调用 <code>MasterSlaveDataSource#getConnection()</code> 方法获取<strong>真实</strong>的数据源</li>
<li>通过 <code>#isMasterRoute()</code> 判断是否读取<strong>主库</strong>，以下三种情况会访问主库：<ul>
<li>非查询语句 (DQL)</li>
<li><strong>该</strong>数据源在<strong>当前</strong>线程访问过主库：通过线程变量 <code>DML_FLAG</code> 实现</li>
<li>强制主库：程序里调用 <code>HintManager.getInstance().setMasterRouteOnly()</code> 实现</li>
</ul>
</li>
<li><p>访问从库时，会通过负载均衡策略( SlaveLoadBalanceStrategy ) 选择一个从库</p>
<pre><code class="Java"><span class="comment">// SlaveLoadBalanceStrategy.java</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SlaveLoadBalanceStrategy</span> </span>{

    <span class="comment">/**
     * 根据负载均衡策略获取从库数据源.
     * 
     * <span class="doctag">@param</span> name 读写分离数据源名称
     * <span class="doctag">@param</span> slaveDataSources 从库数据源列表
     * <span class="doctag">@return</span> 选中的从库数据源
     */</span>
    <span class="function">DataSource <span class="title">getDataSource</span><span class="params">(String name, List&lt;DataSource&gt; slaveDataSources)</span></span>;
}

<span class="comment">// RoundRobinSlaveLoadBalanceStrategy.java</span>
<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinSlaveLoadBalanceStrategy</span> <span class="keyword">implements</span> <span class="title">SlaveLoadBalanceStrategy</span> </span>{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, AtomicInteger&gt; COUNT_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> List&lt;DataSource&gt; slaveDataSources)</span> </span>{
        AtomicInteger count = COUNT_MAP.containsKey(name) ? COUNT_MAP.get(name) : <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);
        COUNT_MAP.putIfAbsent(name, count);
        count.compareAndSet(slaveDataSources.size(), <span class="number">0</span>);
        <span class="keyword">return</span> slaveDataSources.get(count.getAndIncrement() % slaveDataSources.size());
    }
}
</code></pre>
<ul>
<li>MasterSlaveDataSource 默认使用 RoundRobinSlaveLoadBalanceStrategy，暂时不支持配置</li>
<li>RoundRobinSlaveLoadBalanceStrategy，轮询负载均衡策略，<strong>每个从节点访问次数均衡，暂不支持数据源故障移除</strong></li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>没有彩蛋<br>没有彩<br>没有<br>没  </p>
<p>下一篇，<a href="http://www.yunai.me/Sharding-JDBC/transaction-bed/?self">《分布式事务（一）之最大努力型》</a>走起。老司机，赶紧上车。</p>
<p>道友，分享一个朋友圈可好？不然交个道姑那<del>敏感词</del>你。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.yunai.me/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;有
    
    </summary>
    
      <category term="Sharding-JDBC" scheme="http://www.yunai.me/categories/Sharding-JDBC/"/>
    
    
  </entry>
  
</feed>
